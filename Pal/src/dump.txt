
libpal.so:     file format elf64-x86-64-freebsd

Disassembly of section .plt:

0000000000003160 <DkObjectClose@plt-0x10>:
    3160:	ff 35 42 0a 22 00    	pushq  0x220a42(%rip)        # 223ba8 <_GLOBAL_OFFSET_TABLE_+0x8>
    3166:	ff 25 44 0a 22 00    	jmpq   *0x220a44(%rip)        # 223bb0 <_GLOBAL_OFFSET_TABLE_+0x10>
    316c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000003170 <DkObjectClose@plt>:
    3170:	ff 25 42 0a 22 00    	jmpq   *0x220a42(%rip)        # 223bb8 <_GLOBAL_OFFSET_TABLE_+0x18>
    3176:	68 00 00 00 00       	pushq  $0x0
    317b:	e9 e0 ff ff ff       	jmpq   3160 <GLIBC+0x3160>
Disassembly of section .text:

0000000000003180 <DkStreamAttributesSetbyHandle>:
/* PAL call DkStreamAttributesSetbyHandle: Set attribute of a stream by
   its handle, attr is memory given by user space. Return the pointer of attr
   if succeeded, or NULL if failed. Error code is notified */
PAL_BOL
DkStreamAttributesSetbyHandle (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    3180:	55                   	push   %rbp
    3181:	48 89 e5             	mov    %rsp,%rbp
    3184:	41 56                	push   %r14
    3186:	41 55                	push   %r13

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3188:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
    318f:	41 54                	push   %r12
    3191:	53                   	push   %rbx
    3192:	49 89 fc             	mov    %rdi,%r12
    3195:	49 89 f5             	mov    %rsi,%r13
    3198:	48 83 ec 70          	sub    $0x70,%rsp
    319c:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    frame->func = func;
    31a3:	48 8b 05 ae 07 22 00 	mov    0x2207ae(%rip),%rax        # 223958 <_DYNAMIC+0x170>
    frame->funcname = funcname;
    frame->context = NULL;
    31aa:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    31b1:	00 
    frame->retval = NULL;
    31b2:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    31b9:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    31ba:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    frame->funcname = funcname;
    31c1:	48 8d 05 38 54 01 00 	lea    0x15438(%rip),%rax        # 18600 <write_config+0x50>
    31c8:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    31cc:	48 89 e0             	mov    %rsp,%rax
    31cf:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    31d3:	48 89 e8             	mov    %rbp,%rax
    31d6:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    31da:	48 89 d8             	mov    %rbx,%rax
    31dd:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    31e1:	48 89 f0             	mov    %rsi,%rax
    31e4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    31e8:	48 89 f8             	mov    %rdi,%rax
    31eb:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    31ef:	4c 89 e0             	mov    %r12,%rax
    31f2:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    31f6:	4c 89 e8             	mov    %r13,%rax
    31f9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    31fd:	4c 89 f0             	mov    %r14,%rax
    3200:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    3204:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamAttributesSetbyHandle);

    if (!handle || !attr) {
    3207:	48 85 ff             	test   %rdi,%rdi
    320a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    320e:	0f 94 c3             	sete   %bl
    3211:	48 85 f6             	test   %rsi,%rsi
    3214:	0f 94 c0             	sete   %al
    3217:	08 c3                	or     %al,%bl
    3219:	75 48                	jne    3263 <DkStreamAttributesSetbyHandle+0xe3>
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    if (UNKNOWN_HANDLE(handle)) {
    321b:	48 63 17             	movslq (%rdi),%rdx
    321e:	8d 42 ff             	lea    -0x1(%rdx),%eax
    3221:	83 f8 10             	cmp    $0x10,%eax
    3224:	77 7a                	ja     32a0 <DkStreamAttributesSetbyHandle+0x120>
        notify_failure(PAL_ERROR_BADHANDLE);
        return PAL_FALSE;
    }

    const struct handle_ops * ops = HANDLE_OPS(handle);
    3226:	48 8b 05 d3 07 22 00 	mov    0x2207d3(%rip),%rax        # 223a00 <_DYNAMIC+0x218>
    322d:	4c 8b 34 d0          	mov    (%rax,%rdx,8),%r14

    assert(ops);
    3231:	4d 85 f6             	test   %r14,%r14
    3234:	0f 84 92 00 00 00    	je     32cc <DkStreamAttributesSetbyHandle+0x14c>

    if (!ops->attrsetbyhdl) {
    323a:	49 8b 46 78          	mov    0x78(%r14),%rax
    323e:	48 85 c0             	test   %rax,%rax
    3241:	74 7d                	je     32c0 <DkStreamAttributesSetbyHandle+0x140>
        notify_failure(PAL_ERROR_NOTSUPPORT);
        return PAL_FALSE;
    }

    int ret = ops->attrsetbyhdl(handle, attr);
    3243:	4c 89 ee             	mov    %r13,%rsi
    3246:	4c 89 e7             	mov    %r12,%rdi
    3249:	ff d0                	callq  *%rax

    if (ret < 0) {
    324b:	85 c0                	test   %eax,%eax
    324d:	78 31                	js     3280 <DkStreamAttributesSetbyHandle+0x100>
        notify_failure (-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    324f:	bb 01 00 00 00       	mov    $0x1,%ebx
}
    3254:	48 83 c4 70          	add    $0x70,%rsp
    3258:	89 d8                	mov    %ebx,%eax
    325a:	5b                   	pop    %rbx
    325b:	41 5c                	pop    %r12
    325d:	41 5d                	pop    %r13
    325f:	41 5e                	pop    %r14
    3261:	5d                   	pop    %rbp
    3262:	c3                   	retq   
DkStreamAttributesSetbyHandle (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    store_frame(StreamAttributesSetbyHandle);

    if (!handle || !attr) {
        notify_failure(PAL_ERROR_INVAL);
    3263:	bf 04 00 00 00       	mov    $0x4,%edi
        return PAL_FALSE;
    3268:	31 db                	xor    %ebx,%ebx
DkStreamAttributesSetbyHandle (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    store_frame(StreamAttributesSetbyHandle);

    if (!handle || !attr) {
        notify_failure(PAL_ERROR_INVAL);
    326a:	e8 e1 1b 01 00       	callq  14e50 <notify_failure>
        notify_failure (-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    326f:	48 83 c4 70          	add    $0x70,%rsp
    3273:	89 d8                	mov    %ebx,%eax
    3275:	5b                   	pop    %rbx
    3276:	41 5c                	pop    %r12
    3278:	41 5d                	pop    %r13
    327a:	41 5e                	pop    %r14
    327c:	5d                   	pop    %rbp
    327d:	c3                   	retq   
    327e:	66 90                	xchg   %ax,%ax
    }

    int ret = ops->attrsetbyhdl(handle, attr);

    if (ret < 0) {
        notify_failure (-ret);
    3280:	f7 d8                	neg    %eax
    3282:	48 63 f8             	movslq %eax,%rdi
    3285:	e8 c6 1b 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    328a:	48 83 c4 70          	add    $0x70,%rsp
    328e:	89 d8                	mov    %ebx,%eax
    3290:	5b                   	pop    %rbx
    3291:	41 5c                	pop    %r12
    3293:	41 5d                	pop    %r13
    3295:	41 5e                	pop    %r14
    3297:	5d                   	pop    %rbp
    3298:	c3                   	retq   
    3299:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    if (UNKNOWN_HANDLE(handle)) {
        notify_failure(PAL_ERROR_BADHANDLE);
    32a0:	bf 07 00 00 00       	mov    $0x7,%edi
    32a5:	e8 a6 1b 01 00       	callq  14e50 <notify_failure>
        notify_failure (-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    32aa:	48 83 c4 70          	add    $0x70,%rsp
    32ae:	89 d8                	mov    %ebx,%eax
    32b0:	5b                   	pop    %rbx
    32b1:	41 5c                	pop    %r12
    32b3:	41 5d                	pop    %r13
    32b5:	41 5e                	pop    %r14
    32b7:	5d                   	pop    %rbp
    32b8:	c3                   	retq   
    32b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    const struct handle_ops * ops = HANDLE_OPS(handle);

    assert(ops);

    if (!ops->attrsetbyhdl) {
        notify_failure(PAL_ERROR_NOTSUPPORT);
    32c0:	bf 03 00 00 00       	mov    $0x3,%edi
    32c5:	e8 86 1b 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    32ca:	eb 88                	jmp    3254 <DkStreamAttributesSetbyHandle+0xd4>
        return PAL_FALSE;
    }

    const struct handle_ops * ops = HANDLE_OPS(handle);

    assert(ops);
    32cc:	48 8d 15 4b 53 01 00 	lea    0x1534b(%rip),%rdx        # 1861e <write_config+0x6e>
    32d3:	48 8d 35 51 53 01 00 	lea    0x15351(%rip),%rsi        # 1862b <write_config+0x7b>
    32da:	48 8d 3d 57 54 01 00 	lea    0x15457(%rip),%rdi        # 18738 <write_config+0x188>
    32e1:	b9 d6 01 00 00       	mov    $0x1d6,%ecx
    32e6:	31 c0                	xor    %eax,%eax
    32e8:	e8 33 5b 00 00       	callq  8e20 <pal_printf>
    32ed:	e8 7e 37 00 00       	callq  6a70 <__assert>
    32f2:	bf 01 00 00 00       	mov    $0x1,%edi
    32f7:	e8 84 f2 00 00       	callq  12580 <_DkProcessExit>
    32fc:	e9 39 ff ff ff       	jmpq   323a <DkStreamAttributesSetbyHandle+0xba>
    3301:	66 66 66 66 66 66 2e 	nopw   %cs:0x0(%rax,%rax,1)
    3308:	0f 1f 84 00 00 00 00 
    330f:	00 

0000000000003310 <DkReceiveHandle>:
    Ans - Yes, Initialize and make it compatibile in the target process
   3. Should remalloc be done or the process shares the same references?
    Ans - Variables members have to allocated data again.
*/
PAL_HANDLE DkReceiveHandle (PAL_HANDLE handle)
{
    3310:	55                   	push   %rbp
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    frame->funcname = funcname;
    3311:	48 8d 05 17 53 01 00 	lea    0x15317(%rip),%rax        # 1862f <write_config+0x7f>
    3318:	48 89 e5             	mov    %rsp,%rbp
    331b:	53                   	push   %rbx

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    331c:	48 8d 55 80          	lea    -0x80(%rbp),%rdx
    3320:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    frame->func = func;
    frame->funcname = funcname;
    3327:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->context = NULL;
    332b:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    3332:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3333:	48 89 55 80          	mov    %rdx,-0x80(%rbp)
    frame->func = func;
    3337:	48 8b 15 12 07 22 00 	mov    0x220712(%rip),%rdx        # 223a50 <_DYNAMIC+0x268>
    frame->funcname = funcname;
    frame->context = NULL;
    frame->retval = NULL;
    333e:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    3345:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    3346:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
    frame->funcname = funcname;
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    334a:	48 89 e2             	mov    %rsp,%rdx
    334d:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
    3351:	48 89 ea             	mov    %rbp,%rdx
    3354:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
    3358:	48 89 da             	mov    %rbx,%rdx
    335b:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
    335f:	48 89 f2             	mov    %rsi,%rdx
    3362:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    3366:	48 89 fa             	mov    %rdi,%rdx
    3369:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    336d:	4c 89 e2             	mov    %r12,%rdx
    3370:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    3374:	4c 89 ea             	mov    %r13,%rdx
    3377:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    337b:	4c 89 f2             	mov    %r14,%rdx
    337e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
    3382:	4c 89 fa             	mov    %r15,%rdx
    store_frame(ReceiveHandle);

    // return error if any of the handle is NULL
    if(handle == NULL) {
    3385:	48 85 ff             	test   %rdi,%rdi
    3388:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)
    338c:	74 46                	je     33d4 <DkReceiveHandle+0xc4>

    // create a reference for the received PAL_HANDLE
    union pal_handle cargo;

    // call the internal function after validating input args
    int ret = _DkReceiveHandle(handle, &cargo);
    338e:	48 8d 9d 20 ff ff ff 	lea    -0xe0(%rbp),%rbx
    3395:	48 89 de             	mov    %rbx,%rsi
    3398:	e8 03 c9 00 00       	callq  fca0 <_DkReceiveHandle>

    // notify failure would have been called from other functions
    if(ret < 0) {
    339d:	85 c0                	test   %eax,%eax
    339f:	78 2f                	js     33d0 <DkReceiveHandle+0xc0>
                sizeof(handle->semaphore),
                sizeof(handle->event),
                sizeof(handle->gipc),
            };

    if (UNKNOWN_HANDLE(handle))
    33a1:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
        return 0;
    33a7:	31 f6                	xor    %esi,%esi
                sizeof(handle->semaphore),
                sizeof(handle->event),
                sizeof(handle->gipc),
            };

    if (UNKNOWN_HANDLE(handle))
    33a9:	8d 50 ff             	lea    -0x1(%rax),%edx
    33ac:	83 fa 10             	cmp    $0x10,%edx
    33af:	76 12                	jbe    33c3 <DkReceiveHandle+0xb3>
       return NULL;
    }

    return remalloc(&cargo, handle_size(&cargo));
    33b1:	48 89 df             	mov    %rbx,%rdi
    33b4:	e8 47 58 00 00       	callq  8c00 <remalloc>
}
    33b9:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    33c0:	5b                   	pop    %rbx
    33c1:	5d                   	pop    %rbp
    33c2:	c3                   	retq   
        return 0;
    else
        return handle_sizes[HANDLE_TYPE(handle)];
    33c3:	48 8d 15 b6 53 01 00 	lea    0x153b6(%rip),%rdx        # 18780 <handle_sizes.1924>
    33ca:	8b 34 82             	mov    (%rdx,%rax,4),%esi
    33cd:	eb e2                	jmp    33b1 <DkReceiveHandle+0xa1>
    33cf:	90                   	nop    
    // call the internal function after validating input args
    int ret = _DkReceiveHandle(handle, &cargo);

    // notify failure would have been called from other functions
    if(ret < 0) {
       return NULL;
    33d0:	31 c0                	xor    %eax,%eax
    33d2:	eb e5                	jmp    33b9 <DkReceiveHandle+0xa9>
{
    store_frame(ReceiveHandle);

    // return error if any of the handle is NULL
    if(handle == NULL) {
       notify_failure(PAL_ERROR_INVAL);
    33d4:	40 b7 04             	mov    $0x4,%dil
    33d7:	e8 74 1a 01 00       	callq  14e50 <notify_failure>
       return 0;
    33dc:	31 c0                	xor    %eax,%eax
    33de:	eb d9                	jmp    33b9 <DkReceiveHandle+0xa9>

00000000000033e0 <DkStreamGetName>:

/* PAL call DkStreamAttributesSetbyHandle: Set attribute of a stream by
   its handle, attr is memory given by user space. Return the pointer of attr
   if succeeded, or NULL if failed. Error code is notified */
PAL_NUM DkStreamGetName (PAL_HANDLE handle, PAL_BUF buffer, PAL_NUM size)
{
    33e0:	55                   	push   %rbp
    33e1:	48 89 e5             	mov    %rsp,%rbp
    33e4:	41 56                	push   %r14
    33e6:	41 55                	push   %r13

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    33e8:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
    33ef:	41 54                	push   %r12
    33f1:	53                   	push   %rbx
    33f2:	49 89 f4             	mov    %rsi,%r12
    33f5:	48 89 d3             	mov    %rdx,%rbx
    33f8:	48 83 ec 70          	sub    $0x70,%rsp
    33fc:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    frame->func = func;
    3403:	48 8b 05 be 05 22 00 	mov    0x2205be(%rip),%rax        # 2239c8 <_DYNAMIC+0x1e0>
    frame->funcname = funcname;
    frame->context = NULL;
    340a:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    3411:	00 
    frame->retval = NULL;
    3412:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    3419:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    341a:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    frame->funcname = funcname;
    3421:	48 8d 05 17 52 01 00 	lea    0x15217(%rip),%rax        # 1863f <write_config+0x8f>
    3428:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    342c:	48 89 e0             	mov    %rsp,%rax
    342f:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    3433:	48 89 e8             	mov    %rbp,%rax
    3436:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    343a:	48 89 d8             	mov    %rbx,%rax
    343d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    3441:	48 89 f0             	mov    %rsi,%rax
    3444:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    3448:	48 89 f8             	mov    %rdi,%rax
    344b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    344f:	4c 89 e0             	mov    %r12,%rax
    3452:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    3456:	4c 89 e8             	mov    %r13,%rax
    3459:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    345d:	4c 89 f0             	mov    %r14,%rax
    3460:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    3464:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamGetName);

    if (!handle || !buffer || !size) {
    3467:	48 85 f6             	test   %rsi,%rsi
    346a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    346e:	0f 94 c2             	sete   %dl
    3471:	48 85 db             	test   %rbx,%rbx
    3474:	0f 94 c0             	sete   %al
    3477:	08 c2                	or     %al,%dl
    3479:	75 55                	jne    34d0 <DkStreamGetName+0xf0>
    347b:	48 85 ff             	test   %rdi,%rdi
    347e:	49 89 fd             	mov    %rdi,%r13
    3481:	74 4d                	je     34d0 <DkStreamGetName+0xf0>
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    if (UNKNOWN_HANDLE(handle)) {
    3483:	48 63 07             	movslq (%rdi),%rax
    3486:	8d 50 ff             	lea    -0x1(%rax),%edx
    3489:	83 fa 10             	cmp    $0x10,%edx
    348c:	77 62                	ja     34f0 <DkStreamGetName+0x110>
        notify_failure(PAL_ERROR_BADHANDLE);
        return 0;
    }

    const struct handle_ops * ops = HANDLE_OPS(handle);
    348e:	48 8b 15 6b 05 22 00 	mov    0x22056b(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
    3495:	4c 8b 34 c2          	mov    (%rdx,%rax,8),%r14

    assert(ops);
    3499:	4d 85 f6             	test   %r14,%r14
    349c:	0f 84 8c 00 00 00    	je     352e <DkStreamGetName+0x14e>

    /* if ops->getname is not defined, the stream cannot be queried */
    if (!ops->getname) {
    34a2:	49 8b 46 08          	mov    0x8(%r14),%rax
    34a6:	48 85 c0             	test   %rax,%rax
    34a9:	74 65                	je     3510 <DkStreamGetName+0x130>
        notify_failure(PAL_ERROR_NOTSUPPORT);
        return 0;
    }

    int ret = ops->getname(handle, buffer, size - 1);
    34ab:	8d 53 ff             	lea    -0x1(%rbx),%edx
    34ae:	4c 89 e6             	mov    %r12,%rsi
    34b1:	4c 89 ef             	mov    %r13,%rdi
    34b4:	ff d0                	callq  *%rax

    if (ret < 0) {
    34b6:	85 c0                	test   %eax,%eax
    34b8:	78 66                	js     3520 <DkStreamGetName+0x140>
        notify_failure(-ret);
        return 0;
    }

    ((char *)buffer)[ret] = 0;
    34ba:	48 98                	cltq   
    34bc:	41 c6 04 04 00       	movb   $0x0,(%r12,%rax,1)
    return ret;
}
    34c1:	48 83 c4 70          	add    $0x70,%rsp
    34c5:	5b                   	pop    %rbx
    34c6:	41 5c                	pop    %r12
    34c8:	41 5d                	pop    %r13
    34ca:	41 5e                	pop    %r14
    34cc:	5d                   	pop    %rbp
    34cd:	c3                   	retq   
    34ce:	66 90                	xchg   %ax,%ax
PAL_NUM DkStreamGetName (PAL_HANDLE handle, PAL_BUF buffer, PAL_NUM size)
{
    store_frame(StreamGetName);

    if (!handle || !buffer || !size) {
        notify_failure(PAL_ERROR_INVAL);
    34d0:	bf 04 00 00 00       	mov    $0x4,%edi
    34d5:	e8 76 19 01 00       	callq  14e50 <notify_failure>
        return 0;
    34da:	31 c0                	xor    %eax,%eax
        return 0;
    }

    ((char *)buffer)[ret] = 0;
    return ret;
}
    34dc:	48 83 c4 70          	add    $0x70,%rsp
    34e0:	5b                   	pop    %rbx
    34e1:	41 5c                	pop    %r12
    34e3:	41 5d                	pop    %r13
    34e5:	41 5e                	pop    %r14
    34e7:	5d                   	pop    %rbp
    34e8:	c3                   	retq   
    34e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    if (UNKNOWN_HANDLE(handle)) {
        notify_failure(PAL_ERROR_BADHANDLE);
    34f0:	bf 07 00 00 00       	mov    $0x7,%edi
    34f5:	e8 56 19 01 00       	callq  14e50 <notify_failure>
        return 0;
    }

    ((char *)buffer)[ret] = 0;
    return ret;
}
    34fa:	48 83 c4 70          	add    $0x70,%rsp
        return 0;
    }

    if (UNKNOWN_HANDLE(handle)) {
        notify_failure(PAL_ERROR_BADHANDLE);
        return 0;
    34fe:	31 c0                	xor    %eax,%eax
        return 0;
    }

    ((char *)buffer)[ret] = 0;
    return ret;
}
    3500:	5b                   	pop    %rbx
    3501:	41 5c                	pop    %r12
    3503:	41 5d                	pop    %r13
    3505:	41 5e                	pop    %r14
    3507:	5d                   	pop    %rbp
    3508:	c3                   	retq   
    3509:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

    assert(ops);

    /* if ops->getname is not defined, the stream cannot be queried */
    if (!ops->getname) {
        notify_failure(PAL_ERROR_NOTSUPPORT);
    3510:	bf 03 00 00 00       	mov    $0x3,%edi
    3515:	e8 36 19 01 00       	callq  14e50 <notify_failure>
        return 0;
    351a:	31 c0                	xor    %eax,%eax
    351c:	eb be                	jmp    34dc <DkStreamGetName+0xfc>
    351e:	66 90                	xchg   %ax,%ax
    }

    int ret = ops->getname(handle, buffer, size - 1);

    if (ret < 0) {
        notify_failure(-ret);
    3520:	f7 d8                	neg    %eax
    3522:	48 63 f8             	movslq %eax,%rdi
    3525:	e8 26 19 01 00       	callq  14e50 <notify_failure>
        return 0;
    352a:	31 c0                	xor    %eax,%eax
    352c:	eb ae                	jmp    34dc <DkStreamGetName+0xfc>
        return 0;
    }

    const struct handle_ops * ops = HANDLE_OPS(handle);

    assert(ops);
    352e:	48 8d 15 e9 50 01 00 	lea    0x150e9(%rip),%rdx        # 1861e <write_config+0x6e>
    3535:	48 8d 35 ef 50 01 00 	lea    0x150ef(%rip),%rsi        # 1862b <write_config+0x7b>
    353c:	48 8d 3d f5 51 01 00 	lea    0x151f5(%rip),%rdi        # 18738 <write_config+0x188>
    3543:	b9 fa 01 00 00       	mov    $0x1fa,%ecx
    3548:	31 c0                	xor    %eax,%eax
    354a:	e8 d1 58 00 00       	callq  8e20 <pal_printf>
    354f:	e8 1c 35 00 00       	callq  6a70 <__assert>
    3554:	bf 01 00 00 00       	mov    $0x1,%edi
    3559:	e8 22 f0 00 00       	callq  12580 <_DkProcessExit>
    355e:	e9 3f ff ff ff       	jmpq   34a2 <DkStreamGetName+0xc2>
    3563:	66 66 66 66 2e 0f 1f 	nopw   %cs:0x0(%rax,%rax,1)
    356a:	84 00 00 00 00 00 

0000000000003570 <DkStreamUnmap>:

/* PAL call DkStreamUnmap: Unmap memory mapped at an address. The memory has
   to be a stream map, and it got unmapped as a whole memory area. No
   return value. Error code is notified */
void DkStreamUnmap (PAL_BUF addr, PAL_NUM size)
{
    3570:	55                   	push   %rbp
    3571:	48 89 e5             	mov    %rsp,%rbp
    3574:	41 54                	push   %r12
    3576:	53                   	push   %rbx

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3577:	48 8d 45 80          	lea    -0x80(%rbp),%rax
    357b:	48 83 ec 70          	sub    $0x70,%rsp
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    357f:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    3586:	00 
    frame->retval = NULL;
    3587:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    358e:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    358f:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->func = func;
    3593:	48 8b 05 46 04 22 00 	mov    0x220446(%rip),%rax        # 2239e0 <_DYNAMIC+0x1f8>
    359a:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    frame->funcname = funcname;
    359e:	48 8d 05 aa 50 01 00 	lea    0x150aa(%rip),%rax        # 1864f <write_config+0x9f>
    35a5:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    35a9:	48 89 e0             	mov    %rsp,%rax
    35ac:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    35b0:	48 89 e8             	mov    %rbp,%rax
    35b3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    35b7:	48 89 d8             	mov    %rbx,%rax
    35ba:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    35be:	48 89 f0             	mov    %rsi,%rax
    35c1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    35c5:	48 89 f8             	mov    %rdi,%rax
    35c8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    35cc:	4c 89 e0             	mov    %r12,%rax
    35cf:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    35d3:	4c 89 e8             	mov    %r13,%rax
    35d6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    35da:	4c 89 f0             	mov    %r14,%rax
    35dd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    35e1:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamUnmap);

    if (!addr) {
    35e4:	48 85 ff             	test   %rdi,%rdi
    35e7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    35eb:	74 43                	je     3630 <DkStreamUnmap+0xc0>
    35ed:	48 89 fb             	mov    %rdi,%rbx
    35f0:	49 89 f4             	mov    %rsi,%r12
        notify_failure (PAL_ERROR_INVAL);
        return;
    }

    if (check_memory_overlap(addr, size)) {
    35f3:	e8 98 11 00 00       	callq  4790 <check_memory_overlap>
    35f8:	84 c0                	test   %al,%al
        notify_failure(PAL_ERROR_DENIED);
    35fa:	bf 06 00 00 00       	mov    $0x6,%edi
    if (!addr) {
        notify_failure (PAL_ERROR_INVAL);
        return;
    }

    if (check_memory_overlap(addr, size)) {
    35ff:	75 22                	jne    3623 <DkStreamUnmap+0xb3>
        notify_failure(PAL_ERROR_DENIED);
        return;
    }

    int ret = _DkStreamUnmap(addr, size);
    3601:	4c 89 e6             	mov    %r12,%rsi
    3604:	48 89 df             	mov    %rbx,%rdi
    3607:	e8 f4 c1 00 00       	callq  f800 <_DkStreamUnmap>

    if (ret < 0)
    360c:	85 c0                	test   %eax,%eax
    360e:	78 10                	js     3620 <DkStreamUnmap+0xb0>
        notify_failure(ret);
}
    3610:	48 83 c4 70          	add    $0x70,%rsp
    3614:	5b                   	pop    %rbx
    3615:	41 5c                	pop    %r12
    3617:	5d                   	pop    %rbp
    3618:	c3                   	retq   
    3619:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    }

    int ret = _DkStreamUnmap(addr, size);

    if (ret < 0)
        notify_failure(ret);
    3620:	48 63 f8             	movslq %eax,%rdi
}
    3623:	48 83 c4 70          	add    $0x70,%rsp
    3627:	5b                   	pop    %rbx
    3628:	41 5c                	pop    %r12
    362a:	5d                   	pop    %rbp
    }

    int ret = _DkStreamUnmap(addr, size);

    if (ret < 0)
        notify_failure(ret);
    362b:	e9 20 18 01 00       	jmpq   14e50 <notify_failure>
}
    3630:	48 83 c4 70          	add    $0x70,%rsp
void DkStreamUnmap (PAL_BUF addr, PAL_NUM size)
{
    store_frame(StreamUnmap);

    if (!addr) {
        notify_failure (PAL_ERROR_INVAL);
    3634:	40 b7 04             	mov    $0x4,%dil

    int ret = _DkStreamUnmap(addr, size);

    if (ret < 0)
        notify_failure(ret);
}
    3637:	5b                   	pop    %rbx
    3638:	41 5c                	pop    %r12
    363a:	5d                   	pop    %rbp
    }

    int ret = _DkStreamUnmap(addr, size);

    if (ret < 0)
        notify_failure(ret);
    363b:	e9 10 18 01 00       	jmpq   14e50 <notify_failure>

0000000000003640 <DkSendHandle>:
}

/* PAL call DkSendHandle: Write to a process handle.
   Return 1 on success and 0 on failure */
PAL_BOL DkSendHandle(PAL_HANDLE handle, PAL_HANDLE cargo)
{
    3640:	55                   	push   %rbp
    3641:	48 89 e5             	mov    %rsp,%rbp
    3644:	53                   	push   %rbx

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3645:	48 8d 45 80          	lea    -0x80(%rbp),%rax
    3649:	48 83 ec 78          	sub    $0x78,%rsp
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    364d:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    3654:	00 
    frame->retval = NULL;
    3655:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    365c:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    365d:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->func = func;
    3661:	48 8b 05 18 03 22 00 	mov    0x220318(%rip),%rax        # 223980 <_DYNAMIC+0x198>
    3668:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    frame->funcname = funcname;
    366c:	48 8d 05 ea 4f 01 00 	lea    0x14fea(%rip),%rax        # 1865d <write_config+0xad>
    3673:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    3677:	48 89 e0             	mov    %rsp,%rax
    367a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    367e:	48 89 e8             	mov    %rbp,%rax
    3681:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    3685:	48 89 d8             	mov    %rbx,%rax
    3688:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    368c:	48 89 f0             	mov    %rsi,%rax
    368f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    3693:	48 89 f8             	mov    %rdi,%rax
    3696:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    369a:	4c 89 e0             	mov    %r12,%rax
    369d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    36a1:	4c 89 e8             	mov    %r13,%rax
    36a4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    36a8:	4c 89 f0             	mov    %r14,%rax
    36ab:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    36af:	4c 89 f8             	mov    %r15,%rax
    store_frame(SendHandle);

    // Return error if any of the handle is NULL
    if (!handle || !cargo) {
    36b2:	48 85 ff             	test   %rdi,%rdi
    36b5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    36b9:	0f 94 c3             	sete   %bl
    36bc:	48 85 f6             	test   %rsi,%rsi
    36bf:	0f 94 c0             	sete   %al
    36c2:	08 c3                	or     %al,%bl
    36c4:	75 1a                	jne    36e0 <DkSendHandle+0xa0>
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    // Call the internal function after validating input args
    int ret = _DkSendHandle(handle, cargo);
    36c6:	e8 75 c1 00 00       	callq  f840 <_DkSendHandle>

    if (ret < 0) {
    36cb:	85 c0                	test   %eax,%eax
    36cd:	78 26                	js     36f5 <DkSendHandle+0xb5>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    36cf:	bb 01 00 00 00       	mov    $0x1,%ebx
}
    36d4:	48 83 c4 78          	add    $0x78,%rsp
    36d8:	89 d8                	mov    %ebx,%eax
    36da:	5b                   	pop    %rbx
    36db:	5d                   	pop    %rbp
    36dc:	c3                   	retq   
    36dd:	0f 1f 00             	nopl   (%rax)
{
    store_frame(SendHandle);

    // Return error if any of the handle is NULL
    if (!handle || !cargo) {
        notify_failure(PAL_ERROR_INVAL);
    36e0:	bf 04 00 00 00       	mov    $0x4,%edi
        return PAL_FALSE;
    36e5:	31 db                	xor    %ebx,%ebx
{
    store_frame(SendHandle);

    // Return error if any of the handle is NULL
    if (!handle || !cargo) {
        notify_failure(PAL_ERROR_INVAL);
    36e7:	e8 64 17 01 00       	callq  14e50 <notify_failure>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    36ec:	48 83 c4 78          	add    $0x78,%rsp
    36f0:	89 d8                	mov    %ebx,%eax
    36f2:	5b                   	pop    %rbx
    36f3:	5d                   	pop    %rbp
    36f4:	c3                   	retq   

    // Call the internal function after validating input args
    int ret = _DkSendHandle(handle, cargo);

    if (ret < 0) {
        notify_failure(-ret);
    36f5:	f7 d8                	neg    %eax
    36f7:	48 63 f8             	movslq %eax,%rdi
    36fa:	e8 51 17 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    36ff:	48 83 c4 78          	add    $0x78,%rsp
    3703:	89 d8                	mov    %ebx,%eax
    3705:	5b                   	pop    %rbx
    3706:	5d                   	pop    %rbp
    3707:	c3                   	retq   
    3708:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    370f:	00 

0000000000003710 <parse_stream_uri>:

/* parse_stream_uri scan the uri, seperate prefix and search for
   stream handler which will open or access the stream */
int parse_stream_uri (const char ** uri, const char ** prefix,
                      struct handle_ops ** ops)
{
    3710:	55                   	push   %rbp
    3711:	48 89 e5             	mov    %rsp,%rbp
    3714:	41 57                	push   %r15
    3716:	41 56                	push   %r14
    3718:	41 55                	push   %r13
    371a:	41 54                	push   %r12
    371c:	53                   	push   %rbx
    371d:	48 83 ec 08          	sub    $0x8,%rsp
    const char * p, * u = (*uri);
    3721:	4c 8b 27             	mov    (%rdi),%r12

    for (p = u ; (*p) && (*p) != ':' ; p++);
    3724:	41 0f b6 0c 24       	movzbl (%r12),%ecx
    3729:	4c 89 e3             	mov    %r12,%rbx
    372c:	80 f9 3a             	cmp    $0x3a,%cl
    372f:	75 0e                	jne    373f <parse_stream_uri+0x2f>
    3731:	eb 10                	jmp    3743 <parse_stream_uri+0x33>
    3733:	48 83 c3 01          	add    $0x1,%rbx
    3737:	0f b6 0b             	movzbl (%rbx),%ecx
    373a:	80 f9 3a             	cmp    $0x3a,%cl
    373d:	74 04                	je     3743 <parse_stream_uri+0x33>
    373f:	84 c9                	test   %cl,%cl
    3741:	75 f0                	jne    3733 <parse_stream_uri+0x23>

    if ((*p) != ':')
    3743:	80 f9 3a             	cmp    $0x3a,%cl
        return -PAL_ERROR_INVAL;
    3746:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
{
    const char * p, * u = (*uri);

    for (p = u ; (*p) && (*p) != ':' ; p++);

    if ((*p) != ':')
    374b:	0f 85 97 00 00 00    	jne    37e8 <parse_stream_uri+0xd8>
        return -PAL_ERROR_INVAL;

    struct handle_ops * hops = NULL;

    switch (p - u) {
    3751:	48 89 d8             	mov    %rbx,%rax
    3754:	49 89 d5             	mov    %rdx,%r13
    3757:	49 89 f7             	mov    %rsi,%r15
    375a:	4c 29 e0             	sub    %r12,%rax
    375d:	49 89 fe             	mov    %rdi,%r14
    3760:	48 83 f8 04          	cmp    $0x4,%rax
    3764:	0f 84 ea 00 00 00    	je     3854 <parse_stream_uri+0x144>
    376a:	7e 35                	jle    37a1 <parse_stream_uri+0x91>
    376c:	48 83 f8 07          	cmp    $0x7,%rax
    3770:	0f 84 ba 00 00 00    	je     3830 <parse_stream_uri+0x120>
    3776:	48 83 f8 08          	cmp    $0x8,%rax
    377a:	0f 85 93 00 00 00    	jne    3813 <parse_stream_uri+0x103>
            else if (memcmp(u, "udp.srv", 7) == 0)
                hops = &udp_ops;
            break;

        case 8:
            if (memcmp(u, "pipe.srv", 8) == 0)
    3780:	48 8d 35 03 4f 01 00 	lea    0x14f03(%rip),%rsi        # 1868a <write_config+0xda>
    3787:	ba 08 00 00 00       	mov    $0x8,%edx
    378c:	4c 89 e7             	mov    %r12,%rdi
    378f:	e8 7c 2b 01 00       	callq  16310 <memcmp>
    3794:	85 c0                	test   %eax,%eax
    3796:	75 7b                	jne    3813 <parse_stream_uri+0x103>

        case 4:
            if (memcmp(u, "file", 4) == 0)
                hops = &file_ops;
            else if (memcmp(u, "pipe", 4) == 0)
                hops = &pipe_ops;
    3798:	48 8b 05 c1 02 22 00 	mov    0x2202c1(%rip),%rax        # 223a60 <_DYNAMIC+0x278>
    379f:	eb 29                	jmp    37ca <parse_stream_uri+0xba>
    if ((*p) != ':')
        return -PAL_ERROR_INVAL;

    struct handle_ops * hops = NULL;

    switch (p - u) {
    37a1:	48 83 f8 03          	cmp    $0x3,%rax
    37a5:	75 6c                	jne    3813 <parse_stream_uri+0x103>
        case 3:
            if (memcmp(u, "dir", 3) == 0)
    37a7:	48 8d 35 bc 4e 01 00 	lea    0x14ebc(%rip),%rsi        # 1866a <write_config+0xba>
    37ae:	ba 03 00 00 00       	mov    $0x3,%edx
    37b3:	4c 89 e7             	mov    %r12,%rdi
    37b6:	e8 55 2b 01 00       	callq  16310 <memcmp>
    37bb:	85 c0                	test   %eax,%eax
    37bd:	0f 85 bc 00 00 00    	jne    387f <parse_stream_uri+0x16f>
                hops = &dir_ops;
    37c3:	48 8b 05 66 02 22 00 	mov    0x220266(%rip),%rax        # 223a30 <_DYNAMIC+0x248>
    }

    if (!hops)
        return -PAL_ERROR_NOTSUPPORT;

    *uri = p + 1;
    37ca:	48 83 c3 01          	add    $0x1,%rbx

    if (prefix)
    37ce:	4d 85 ff             	test   %r15,%r15
    }

    if (!hops)
        return -PAL_ERROR_NOTSUPPORT;

    *uri = p + 1;
    37d1:	49 89 1e             	mov    %rbx,(%r14)

    if (prefix)
    37d4:	74 03                	je     37d9 <parse_stream_uri+0xc9>
        *prefix = u;
    37d6:	4d 89 27             	mov    %r12,(%r15)

    if (ops)
    37d9:	4d 85 ed             	test   %r13,%r13
    37dc:	0f 84 96 00 00 00    	je     3878 <parse_stream_uri+0x168>
        *ops = hops;
    37e2:	49 89 45 00          	mov    %rax,0x0(%r13)

    return 0;
    37e6:	31 c0                	xor    %eax,%eax
}
    37e8:	48 83 c4 08          	add    $0x8,%rsp
    37ec:	5b                   	pop    %rbx
    37ed:	41 5c                	pop    %r12
    37ef:	41 5d                	pop    %r13
    37f1:	41 5e                	pop    %r14
    37f3:	41 5f                	pop    %r15
    37f5:	5d                   	pop    %rbp
    37f6:	c3                   	retq   
            break;

        case 7:
            if (memcmp(u, "tcp.srv", 7) == 0)
                hops = &tcp_ops;
            else if (memcmp(u, "udp.srv", 7) == 0)
    37f7:	48 8d 35 84 4e 01 00 	lea    0x14e84(%rip),%rsi        # 18682 <write_config+0xd2>
    37fe:	ba 07 00 00 00       	mov    $0x7,%edx
    3803:	4c 89 e7             	mov    %r12,%rdi
    3806:	e8 05 2b 01 00       	callq  16310 <memcmp>
    380b:	85 c0                	test   %eax,%eax
    380d:	0f 84 11 01 00 00    	je     3924 <parse_stream_uri+0x214>

    if (ops)
        *ops = hops;

    return 0;
}
    3813:	48 83 c4 08          	add    $0x8,%rsp
        default:
            break;
    }

    if (!hops)
        return -PAL_ERROR_NOTSUPPORT;
    3817:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

    if (ops)
        *ops = hops;

    return 0;
}
    381c:	5b                   	pop    %rbx
    381d:	41 5c                	pop    %r12
    381f:	41 5d                	pop    %r13
    3821:	41 5e                	pop    %r14
    3823:	41 5f                	pop    %r15
    3825:	5d                   	pop    %rbp
    3826:	c3                   	retq   
    3827:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    382e:	00 00 
            else if (memcmp(u, "gipc", 4) == 0)
                hops = &gipc_ops;
            break;

        case 7:
            if (memcmp(u, "tcp.srv", 7) == 0)
    3830:	48 8d 35 43 4e 01 00 	lea    0x14e43(%rip),%rsi        # 1867a <write_config+0xca>
    3837:	ba 07 00 00 00       	mov    $0x7,%edx
    383c:	4c 89 e7             	mov    %r12,%rdi
    383f:	e8 cc 2a 01 00       	callq  16310 <memcmp>
    3844:	85 c0                	test   %eax,%eax
    3846:	75 af                	jne    37f7 <parse_stream_uri+0xe7>
    switch (p - u) {
        case 3:
            if (memcmp(u, "dir", 3) == 0)
                hops = &dir_ops;
            else if (memcmp(u, "tcp", 3) == 0)
                hops = &tcp_ops;
    3848:	48 8b 05 a1 02 22 00 	mov    0x2202a1(%rip),%rax        # 223af0 <_DYNAMIC+0x308>
    384f:	e9 76 ff ff ff       	jmpq   37ca <parse_stream_uri+0xba>
            else if (memcmp(u, "dev", 3) == 0)
                hops = &dev_ops;
            break;

        case 4:
            if (memcmp(u, "file", 4) == 0)
    3854:	48 8d 35 5a c0 01 00 	lea    0x1c05a(%rip),%rsi        # 1f8b5 <sys_nerr_internal+0x779>
    385b:	ba 04 00 00 00       	mov    $0x4,%edx
    3860:	4c 89 e7             	mov    %r12,%rdi
    3863:	e8 a8 2a 01 00       	callq  16310 <memcmp>
    3868:	85 c0                	test   %eax,%eax
    386a:	75 74                	jne    38e0 <parse_stream_uri+0x1d0>
                hops = &file_ops;
    386c:	48 8b 05 fd 01 22 00 	mov    0x2201fd(%rip),%rax        # 223a70 <_DYNAMIC+0x288>
    3873:	e9 52 ff ff ff       	jmpq   37ca <parse_stream_uri+0xba>
        *prefix = u;

    if (ops)
        *ops = hops;

    return 0;
    3878:	31 c0                	xor    %eax,%eax
    387a:	e9 69 ff ff ff       	jmpq   37e8 <parse_stream_uri+0xd8>

    switch (p - u) {
        case 3:
            if (memcmp(u, "dir", 3) == 0)
                hops = &dir_ops;
            else if (memcmp(u, "tcp", 3) == 0)
    387f:	48 8d 35 e8 4d 01 00 	lea    0x14de8(%rip),%rsi        # 1866e <write_config+0xbe>
    3886:	ba 03 00 00 00       	mov    $0x3,%edx
    388b:	4c 89 e7             	mov    %r12,%rdi
    388e:	e8 7d 2a 01 00       	callq  16310 <memcmp>
    3893:	85 c0                	test   %eax,%eax
    3895:	74 b1                	je     3848 <parse_stream_uri+0x138>
                hops = &tcp_ops;
            else if (memcmp(u, "udp", 3) == 0)
    3897:	48 8d 35 d4 4d 01 00 	lea    0x14dd4(%rip),%rsi        # 18672 <write_config+0xc2>
    389e:	ba 03 00 00 00       	mov    $0x3,%edx
    38a3:	4c 89 e7             	mov    %r12,%rdi
    38a6:	e8 65 2a 01 00       	callq  16310 <memcmp>
    38ab:	85 c0                	test   %eax,%eax
    38ad:	74 75                	je     3924 <parse_stream_uri+0x214>
                hops = &udp_ops;
            else if (memcmp(u, "dev", 3) == 0)
    38af:	48 8d 35 c0 4d 01 00 	lea    0x14dc0(%rip),%rsi        # 18676 <write_config+0xc6>
    38b6:	ba 03 00 00 00       	mov    $0x3,%edx
    38bb:	4c 89 e7             	mov    %r12,%rdi
    38be:	e8 4d 2a 01 00       	callq  16310 <memcmp>
    38c3:	85 c0                	test   %eax,%eax
    38c5:	0f 85 48 ff ff ff    	jne    3813 <parse_stream_uri+0x103>
                hops = &dev_ops;
    38cb:	48 8b 05 86 01 22 00 	mov    0x220186(%rip),%rax        # 223a58 <_DYNAMIC+0x270>
    38d2:	e9 f3 fe ff ff       	jmpq   37ca <parse_stream_uri+0xba>
    38d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    38de:	00 00 
            break;

        case 4:
            if (memcmp(u, "file", 4) == 0)
                hops = &file_ops;
            else if (memcmp(u, "pipe", 4) == 0)
    38e0:	48 8d 35 88 ba 01 00 	lea    0x1ba88(%rip),%rsi        # 1f36f <sys_nerr_internal+0x233>
    38e7:	ba 04 00 00 00       	mov    $0x4,%edx
    38ec:	4c 89 e7             	mov    %r12,%rdi
    38ef:	e8 1c 2a 01 00       	callq  16310 <memcmp>
    38f4:	85 c0                	test   %eax,%eax
    38f6:	0f 84 9c fe ff ff    	je     3798 <parse_stream_uri+0x88>
                hops = &pipe_ops;
            else if (memcmp(u, "gipc", 4) == 0)
    38fc:	48 8d 35 c0 b4 01 00 	lea    0x1b4c0(%rip),%rsi        # 1edc3 <slab_levels+0x5b23>
    3903:	ba 04 00 00 00       	mov    $0x4,%edx
    3908:	4c 89 e7             	mov    %r12,%rdi
    390b:	e8 00 2a 01 00       	callq  16310 <memcmp>
    3910:	85 c0                	test   %eax,%eax
    3912:	0f 85 fb fe ff ff    	jne    3813 <parse_stream_uri+0x103>
                hops = &gipc_ops;
    3918:	48 8b 05 c9 01 22 00 	mov    0x2201c9(%rip),%rax        # 223ae8 <_DYNAMIC+0x300>
    391f:	e9 a6 fe ff ff       	jmpq   37ca <parse_stream_uri+0xba>
            if (memcmp(u, "dir", 3) == 0)
                hops = &dir_ops;
            else if (memcmp(u, "tcp", 3) == 0)
                hops = &tcp_ops;
            else if (memcmp(u, "udp", 3) == 0)
                hops = &udp_ops;
    3924:	48 8b 05 3d 02 22 00 	mov    0x22023d(%rip),%rax        # 223b68 <_DYNAMIC+0x380>
    392b:	e9 9a fe ff ff       	jmpq   37ca <parse_stream_uri+0xba>

0000000000003930 <_DkStreamOpen>:
/* _DkStreamOpen for internal use. Open stream based on uri.
   access/share/create/options are the same flags defined for
   DkStreamOpen. */
int _DkStreamOpen (PAL_HANDLE * handle, const char * uri,
                   int access, int share, int create, int options)
{
    3930:	55                   	push   %rbp
    3931:	48 89 e5             	mov    %rsp,%rbp
    3934:	41 57                	push   %r15
    3936:	41 56                	push   %r14
    3938:	41 55                	push   %r13
    393a:	41 54                	push   %r12
    393c:	41 89 d5             	mov    %edx,%r13d
    393f:	53                   	push   %rbx
    3940:	49 89 fc             	mov    %rdi,%r12
    struct handle_ops * ops = NULL;
    const char * type = NULL;
    int ret = parse_stream_uri(&uri, &type, &ops);
    3943:	48 8d 55 c0          	lea    -0x40(%rbp),%rdx
    3947:	48 8d 7d b8          	lea    -0x48(%rbp),%rdi
/* _DkStreamOpen for internal use. Open stream based on uri.
   access/share/create/options are the same flags defined for
   DkStreamOpen. */
int _DkStreamOpen (PAL_HANDLE * handle, const char * uri,
                   int access, int share, int create, int options)
{
    394b:	41 89 ce             	mov    %ecx,%r14d
    394e:	44 89 c3             	mov    %r8d,%ebx
    3951:	48 83 ec 28          	sub    $0x28,%rsp
    3955:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
    struct handle_ops * ops = NULL;
    const char * type = NULL;
    int ret = parse_stream_uri(&uri, &type, &ops);
    3959:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
/* _DkStreamOpen for internal use. Open stream based on uri.
   access/share/create/options are the same flags defined for
   DkStreamOpen. */
int _DkStreamOpen (PAL_HANDLE * handle, const char * uri,
                   int access, int share, int create, int options)
{
    395d:	45 89 cf             	mov    %r9d,%r15d
    struct handle_ops * ops = NULL;
    3960:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    3967:	00 
    const char * type = NULL;
    3968:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    396f:	00 
    int ret = parse_stream_uri(&uri, &type, &ops);
    3970:	e8 9b fd ff ff       	callq  3710 <parse_stream_uri>

    if (ret < 0)
    3975:	85 c0                	test   %eax,%eax
    3977:	78 3a                	js     39b3 <_DkStreamOpen+0x83>
        return ret;

    assert(ops && ops->open);
    3979:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    397d:	48 85 c0             	test   %rax,%rax
    3980:	74 40                	je     39c2 <_DkStreamOpen+0x92>
    3982:	48 8b 40 10          	mov    0x10(%rax),%rax
    3986:	48 85 c0             	test   %rax,%rax
    3989:	74 37                	je     39c2 <_DkStreamOpen+0x92>

#ifndef __linux__
    if(create != 0)
	    create = PAL_CREAT_TRY;
    398b:	85 db                	test   %ebx,%ebx
    398d:	ba 00 02 00 00       	mov    $0x200,%edx
#endif	    
    return ops->open(handle, type, uri, access, share, create, options);
    3992:	44 89 e9             	mov    %r13d,%ecx

    assert(ops && ops->open);

#ifndef __linux__
    if(create != 0)
	    create = PAL_CREAT_TRY;
    3995:	0f 45 da             	cmovne %edx,%ebx
#endif	    
    return ops->open(handle, type, uri, access, share, create, options);
    3998:	48 83 ec 08          	sub    $0x8,%rsp
    399c:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    39a0:	41 57                	push   %r15
    39a2:	41 89 d9             	mov    %ebx,%r9d
    39a5:	45 89 f0             	mov    %r14d,%r8d
    39a8:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    39ac:	4c 89 e7             	mov    %r12,%rdi
    39af:	ff d0                	callq  *%rax
    39b1:	5a                   	pop    %rdx
    39b2:	59                   	pop    %rcx
}
    39b3:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    39b7:	5b                   	pop    %rbx
    39b8:	41 5c                	pop    %r12
    39ba:	41 5d                	pop    %r13
    39bc:	41 5e                	pop    %r14
    39be:	41 5f                	pop    %r15
    39c0:	5d                   	pop    %rbp
    39c1:	c3                   	retq   
    int ret = parse_stream_uri(&uri, &type, &ops);

    if (ret < 0)
        return ret;

    assert(ops && ops->open);
    39c2:	48 8d 15 55 4c 01 00 	lea    0x14c55(%rip),%rdx        # 1861e <write_config+0x6e>
    39c9:	48 8d 35 c3 4c 01 00 	lea    0x14cc3(%rip),%rsi        # 18693 <write_config+0xe3>
    39d0:	48 8d 3d 61 4d 01 00 	lea    0x14d61(%rip),%rdi        # 18738 <write_config+0x188>
    39d7:	b9 98 00 00 00       	mov    $0x98,%ecx
    39dc:	31 c0                	xor    %eax,%eax
    39de:	e8 3d 54 00 00       	callq  8e20 <pal_printf>
    39e3:	e8 88 30 00 00       	callq  6a70 <__assert>
    39e8:	bf 01 00 00 00       	mov    $0x1,%edi
    39ed:	e8 8e eb 00 00       	callq  12580 <_DkProcessExit>
    39f2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    39f6:	48 8b 40 10          	mov    0x10(%rax),%rax
    39fa:	eb 8f                	jmp    398b <_DkStreamOpen+0x5b>
    39fc:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000003a00 <DkStreamOpen>:
   create/options flags. DkStreamOpen return a PAL_HANDLE to access the
   stream, or return NULL. Error code is notified. */
PAL_HANDLE
DkStreamOpen (PAL_STR uri, PAL_FLG access, PAL_FLG share, PAL_FLG create,
              PAL_FLG options)
{
    3a00:	55                   	push   %rbp
    3a01:	48 89 f8             	mov    %rdi,%rax
    3a04:	48 89 e5             	mov    %rsp,%rbp
    3a07:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3a0b:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    3a0f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    3a16:	00 
    frame->retval = NULL;
    3a17:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    3a1e:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3a1f:	48 89 7d 90          	mov    %rdi,-0x70(%rbp)
    frame->func = func;
    3a23:	48 8b 3d ee ff 21 00 	mov    0x21ffee(%rip),%rdi        # 223a18 <_DYNAMIC+0x230>
    3a2a:	48 89 7d 98          	mov    %rdi,-0x68(%rbp)
    frame->funcname = funcname;
    3a2e:	48 8d 3d 6f 4c 01 00 	lea    0x14c6f(%rip),%rdi        # 186a4 <write_config+0xf4>
    3a35:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    3a39:	48 89 e7             	mov    %rsp,%rdi
    3a3c:	48 89 7d a8          	mov    %rdi,-0x58(%rbp)
    3a40:	48 89 ef             	mov    %rbp,%rdi
    3a43:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
    3a47:	48 89 df             	mov    %rbx,%rdi
    3a4a:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    3a4e:	48 89 f7             	mov    %rsi,%rdi
    3a51:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
    3a55:	48 89 ff             	mov    %rdi,%rdi
    3a58:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    3a5c:	4c 89 e7             	mov    %r12,%rdi
    3a5f:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
    3a63:	4c 89 ef             	mov    %r13,%rdi
    3a66:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    3a6a:	4c 89 f7             	mov    %r14,%rdi
    3a6d:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
    3a71:	4c 89 ff             	mov    %r15,%rdi
    3a74:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    store_frame(StreamOpen);

    PAL_HANDLE handle;
    int ret = _DkStreamOpen(&handle, uri, access, share, create, options);
    3a78:	48 8d 7d 88          	lea    -0x78(%rbp),%rdi
    3a7c:	45 89 c1             	mov    %r8d,%r9d
    3a7f:	41 89 c8             	mov    %ecx,%r8d
    3a82:	89 d1                	mov    %edx,%ecx
    3a84:	89 f2                	mov    %esi,%edx
    3a86:	48 89 c6             	mov    %rax,%rsi
    3a89:	e8 a2 fe ff ff       	callq  3930 <_DkStreamOpen>

    if (ret < 0) {
    3a8e:	85 c0                	test   %eax,%eax
    3a90:	78 0e                	js     3aa0 <DkStreamOpen+0xa0>
        notify_failure (-ret);
        return NULL;
    }

    return handle;
    3a92:	48 8b 45 88          	mov    -0x78(%rbp),%rax
}
    3a96:	c9                   	leaveq 
    3a97:	c3                   	retq   
    3a98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    3a9f:	00 

    PAL_HANDLE handle;
    int ret = _DkStreamOpen(&handle, uri, access, share, create, options);

    if (ret < 0) {
        notify_failure (-ret);
    3aa0:	f7 d8                	neg    %eax
    3aa2:	48 63 f8             	movslq %eax,%rdi
    3aa5:	e8 a6 13 01 00       	callq  14e50 <notify_failure>
        return NULL;
    3aaa:	31 c0                	xor    %eax,%eax
    }

    return handle;
}
    3aac:	c9                   	leaveq 
    3aad:	c3                   	retq   
    3aae:	66 90                	xchg   %ax,%ax

0000000000003ab0 <_DkStreamWaitForClient>:

int _DkStreamWaitForClient(PAL_HANDLE handle, PAL_HANDLE * client)
{
    3ab0:	48 63 07             	movslq (%rdi),%rax
    3ab3:	55                   	push   %rbp
    3ab4:	48 89 e5             	mov    %rsp,%rbp
    if (UNKNOWN_HANDLE(handle))
    3ab7:	8d 50 ff             	lea    -0x1(%rax),%edx
    3aba:	83 fa 10             	cmp    $0x10,%edx
    3abd:	77 21                	ja     3ae0 <_DkStreamWaitForClient+0x30>
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(handle);
    3abf:	48 8b 15 3a ff 21 00 	mov    0x21ff3a(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
    3ac6:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax

    /* No ops or ops->delete being defined, inferring the handle can never
       be deleted */
    if (!ops || !ops->waitforclient)
    3aca:	48 85 c0             	test   %rax,%rax
    3acd:	74 21                	je     3af0 <_DkStreamWaitForClient+0x40>
    3acf:	48 8b 40 60          	mov    0x60(%rax),%rax
    3ad3:	48 85 c0             	test   %rax,%rax
    3ad6:	74 18                	je     3af0 <_DkStreamWaitForClient+0x40>
        return -PAL_ERROR_NOTSERVER;

    return ops->waitforclient(handle, client);
}
    3ad8:	5d                   	pop    %rbp
    /* No ops or ops->delete being defined, inferring the handle can never
       be deleted */
    if (!ops || !ops->waitforclient)
        return -PAL_ERROR_NOTSERVER;

    return ops->waitforclient(handle, client);
    3ad9:	ff e0                	jmpq   *%rax
    3adb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
}

int _DkStreamWaitForClient(PAL_HANDLE handle, PAL_HANDLE * client)
{
    if (UNKNOWN_HANDLE(handle))
        return -PAL_ERROR_BADHANDLE;
    3ae0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
       be deleted */
    if (!ops || !ops->waitforclient)
        return -PAL_ERROR_NOTSERVER;

    return ops->waitforclient(handle, client);
}
    3ae5:	5d                   	pop    %rbp
    3ae6:	c3                   	retq   
    3ae7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3aee:	00 00 
    const struct handle_ops * ops = HANDLE_OPS(handle);

    /* No ops or ops->delete being defined, inferring the handle can never
       be deleted */
    if (!ops || !ops->waitforclient)
        return -PAL_ERROR_NOTSERVER;
    3af0:	b8 eb ff ff ff       	mov    $0xffffffeb,%eax

    return ops->waitforclient(handle, client);
}
    3af5:	5d                   	pop    %rbp
    3af6:	c3                   	retq   
    3af7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3afe:	00 00 

0000000000003b00 <DkStreamWaitForClient>:

PAL_HANDLE
DkStreamWaitForClient (PAL_HANDLE handle)
{
    3b00:	55                   	push   %rbp
    3b01:	48 89 e5             	mov    %rsp,%rbp
    3b04:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3b08:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    3b0c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    3b13:	00 
    frame->retval = NULL;
    3b14:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    3b1b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3b1c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    3b20:	48 8b 05 61 ff 21 00 	mov    0x21ff61(%rip),%rax        # 223a88 <_DYNAMIC+0x2a0>
    3b27:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    3b2b:	48 8d 05 7f 4b 01 00 	lea    0x14b7f(%rip),%rax        # 186b1 <write_config+0x101>
    3b32:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    3b36:	48 89 e0             	mov    %rsp,%rax
    3b39:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    3b3d:	48 89 e8             	mov    %rbp,%rax
    3b40:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    3b44:	48 89 d8             	mov    %rbx,%rax
    3b47:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    3b4b:	48 89 f0             	mov    %rsi,%rax
    3b4e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    3b52:	48 89 f8             	mov    %rdi,%rax
    3b55:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    3b59:	4c 89 e0             	mov    %r12,%rax
    3b5c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    3b60:	4c 89 e8             	mov    %r13,%rax
    3b63:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    3b67:	4c 89 f0             	mov    %r14,%rax
    3b6a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    3b6e:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamWaitForClient);

    union pal_handle *client;

    int ret = _DkStreamWaitForClient(handle, &client);
    3b71:	48 8d 75 88          	lea    -0x78(%rbp),%rsi
    3b75:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    3b79:	e8 32 ff ff ff       	callq  3ab0 <_DkStreamWaitForClient>

    if (ret < 0) {
    3b7e:	85 c0                	test   %eax,%eax
    3b80:	78 0e                	js     3b90 <DkStreamWaitForClient+0x90>
        notify_failure (-ret);
        return NULL;
    }

    return client;
    3b82:	48 8b 45 88          	mov    -0x78(%rbp),%rax
}
    3b86:	c9                   	leaveq 
    3b87:	c3                   	retq   
    3b88:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    3b8f:	00 
    union pal_handle *client;

    int ret = _DkStreamWaitForClient(handle, &client);

    if (ret < 0) {
        notify_failure (-ret);
    3b90:	f7 d8                	neg    %eax
    3b92:	48 63 f8             	movslq %eax,%rdi
    3b95:	e8 b6 12 01 00       	callq  14e50 <notify_failure>
        return NULL;
    3b9a:	31 c0                	xor    %eax,%eax
    }

    return client;
}
    3b9c:	c9                   	leaveq 
    3b9d:	c3                   	retq   
    3b9e:	66 90                	xchg   %ax,%ax

0000000000003ba0 <_DkStreamDelete>:

/* _DkStreamDelete for internal use. This function will explicit delete
   the stream. For example, file will be deleted, socket witll be
   disconnected, etc */
int _DkStreamDelete (PAL_HANDLE handle, int access)
{
    3ba0:	48 63 07             	movslq (%rdi),%rax
    3ba3:	55                   	push   %rbp
    3ba4:	48 89 e5             	mov    %rsp,%rbp
    if (UNKNOWN_HANDLE(handle))
    3ba7:	8d 50 ff             	lea    -0x1(%rax),%edx
    3baa:	83 fa 10             	cmp    $0x10,%edx
    3bad:	77 21                	ja     3bd0 <_DkStreamDelete+0x30>
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(handle);
    3baf:	48 8b 15 4a fe 21 00 	mov    0x21fe4a(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
    3bb6:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax

    /* No ops or ops->delete being defined, inferring the handle can never
       be deleted */
    if (!ops || !ops->delete)
    3bba:	48 85 c0             	test   %rax,%rax
    3bbd:	74 21                	je     3be0 <_DkStreamDelete+0x40>
    3bbf:	48 8b 40 40          	mov    0x40(%rax),%rax
    3bc3:	48 85 c0             	test   %rax,%rax
    3bc6:	74 18                	je     3be0 <_DkStreamDelete+0x40>
        return -PAL_ERROR_NOTSUPPORT;

    return ops->delete(handle, access);
}
    3bc8:	5d                   	pop    %rbp
    /* No ops or ops->delete being defined, inferring the handle can never
       be deleted */
    if (!ops || !ops->delete)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->delete(handle, access);
    3bc9:	ff e0                	jmpq   *%rax
    3bcb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   the stream. For example, file will be deleted, socket witll be
   disconnected, etc */
int _DkStreamDelete (PAL_HANDLE handle, int access)
{
    if (UNKNOWN_HANDLE(handle))
        return -PAL_ERROR_BADHANDLE;
    3bd0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
       be deleted */
    if (!ops || !ops->delete)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->delete(handle, access);
}
    3bd5:	5d                   	pop    %rbp
    3bd6:	c3                   	retq   
    3bd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3bde:	00 00 
    const struct handle_ops * ops = HANDLE_OPS(handle);

    /* No ops or ops->delete being defined, inferring the handle can never
       be deleted */
    if (!ops || !ops->delete)
        return -PAL_ERROR_NOTSUPPORT;
    3be0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

    return ops->delete(handle, access);
}
    3be5:	5d                   	pop    %rbp
    3be6:	c3                   	retq   
    3be7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3bee:	00 00 

0000000000003bf0 <DkStreamDelete>:

/* PAL call DkStreamDelete: Explicitly delete stream as given handle. No
   return value, error code is notified. */
void DkStreamDelete (PAL_HANDLE handle, PAL_FLG access)
{
    3bf0:	55                   	push   %rbp
    3bf1:	48 89 e5             	mov    %rsp,%rbp
    3bf4:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3bf8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    3bfc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    3c03:	00 
    frame->retval = NULL;
    3c04:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    3c0b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3c0c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    3c10:	48 8b 05 79 ff 21 00 	mov    0x21ff79(%rip),%rax        # 223b90 <_DYNAMIC+0x3a8>
    3c17:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    3c1b:	48 8d 05 a5 4a 01 00 	lea    0x14aa5(%rip),%rax        # 186c7 <write_config+0x117>
    3c22:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    3c26:	48 89 e0             	mov    %rsp,%rax
    3c29:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    3c2d:	48 89 e8             	mov    %rbp,%rax
    3c30:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    3c34:	48 89 d8             	mov    %rbx,%rax
    3c37:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    3c3b:	48 89 f0             	mov    %rsi,%rax
    3c3e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    3c42:	48 89 f8             	mov    %rdi,%rax
    3c45:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    3c49:	4c 89 e0             	mov    %r12,%rax
    3c4c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    3c50:	4c 89 e8             	mov    %r13,%rax
    3c53:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    3c57:	4c 89 f0             	mov    %r14,%rax
    3c5a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    3c5e:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamDelete);

    if (handle == NULL) {
    3c61:	48 85 ff             	test   %rdi,%rdi
    3c64:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    3c68:	74 16                	je     3c80 <DkStreamDelete+0x90>
        notify_failure (PAL_ERROR_INVAL);
        return;
    }

    int ret = _DkStreamDelete(handle, access);
    3c6a:	e8 31 ff ff ff       	callq  3ba0 <_DkStreamDelete>

    if (ret < 0)
    3c6f:	85 c0                	test   %eax,%eax
    3c71:	78 02                	js     3c75 <DkStreamDelete+0x85>
        notify_failure(-ret);
}
    3c73:	c9                   	leaveq 
    3c74:	c3                   	retq   
    3c75:	c9                   	leaveq 
    }

    int ret = _DkStreamDelete(handle, access);

    if (ret < 0)
        notify_failure(-ret);
    3c76:	f7 d8                	neg    %eax
    3c78:	48 63 f8             	movslq %eax,%rdi
    3c7b:	e9 d0 11 01 00       	jmpq   14e50 <notify_failure>
}
    3c80:	c9                   	leaveq 
void DkStreamDelete (PAL_HANDLE handle, PAL_FLG access)
{
    store_frame(StreamDelete);

    if (handle == NULL) {
        notify_failure (PAL_ERROR_INVAL);
    3c81:	40 b7 04             	mov    $0x4,%dil
    3c84:	e9 c7 11 01 00       	jmpq   14e50 <notify_failure>
    3c89:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000003c90 <_DkStreamRead>:

/* _DkStreamRead for internal use. Read from stream as absolute offset.
   The actual behavior of stream read is defined by handler */
int _DkStreamRead (PAL_HANDLE handle, int offset, int count, void * buf,
                   char * addr, int addrlen)
{
    3c90:	48 63 07             	movslq (%rdi),%rax
    3c93:	55                   	push   %rbp
    3c94:	48 89 e5             	mov    %rsp,%rbp
    if (UNKNOWN_HANDLE(handle))
    3c97:	44 8d 50 ff          	lea    -0x1(%rax),%r10d
    3c9b:	41 83 fa 10          	cmp    $0x10,%r10d
    3c9f:	77 3f                	ja     3ce0 <_DkStreamRead+0x50>
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(handle);
    3ca1:	4c 8b 15 58 fd 21 00 	mov    0x21fd58(%rip),%r10        # 223a00 <_DYNAMIC+0x218>
    3ca8:	49 8b 04 c2          	mov    (%r10,%rax,8),%rax

    /* if ops or ops->read is not defined, it infers that the stream can
       never be read */
    if (!ops)
    3cac:	48 85 c0             	test   %rax,%rax
    3caf:	74 4f                	je     3d00 <_DkStreamRead+0x70>
        return -PAL_ERROR_NOTSUPPORT;

    if (!count)
    3cb1:	85 d2                	test   %edx,%edx
    3cb3:	74 3b                	je     3cf0 <_DkStreamRead+0x60>
        return -PAL_ERROR_ZEROSIZE;

    int ret;
    // pal_printf("Raj--> %d",handle->file.fd);
    if (addr) {
    3cb5:	4d 85 c0             	test   %r8,%r8
    3cb8:	74 17                	je     3cd1 <_DkStreamRead+0x41>
        if (!ops->readbyaddr)
    3cba:	48 8b 40 28          	mov    0x28(%rax),%rax
    3cbe:	48 85 c0             	test   %rax,%rax
    3cc1:	74 3d                	je     3d00 <_DkStreamRead+0x70>
            return -PAL_ERROR_NOTSUPPORT;

        ret = ops->readbyaddr(handle, offset, count, buf, addr, addrlen);
    3cc3:	ff d0                	callq  *%rax
            return -PAL_ERROR_NOTSUPPORT;

        ret = ops->read(handle, offset, count, buf);
    }

    return ret ? : -PAL_ERROR_ENDOFSTREAM;
    3cc5:	85 c0                	test   %eax,%eax
    3cc7:	ba ec ff ff ff       	mov    $0xffffffec,%edx
    3ccc:	0f 44 c2             	cmove  %edx,%eax
}
    3ccf:	5d                   	pop    %rbp
    3cd0:	c3                   	retq   
        if (!ops->readbyaddr)
            return -PAL_ERROR_NOTSUPPORT;

        ret = ops->readbyaddr(handle, offset, count, buf, addr, addrlen);
    } else {
        if (!ops->read)
    3cd1:	48 8b 40 18          	mov    0x18(%rax),%rax
    3cd5:	48 85 c0             	test   %rax,%rax
    3cd8:	74 26                	je     3d00 <_DkStreamRead+0x70>
            return -PAL_ERROR_NOTSUPPORT;

        ret = ops->read(handle, offset, count, buf);
    3cda:	ff d0                	callq  *%rax
    3cdc:	eb e7                	jmp    3cc5 <_DkStreamRead+0x35>
    3cde:	66 90                	xchg   %ax,%ax
   The actual behavior of stream read is defined by handler */
int _DkStreamRead (PAL_HANDLE handle, int offset, int count, void * buf,
                   char * addr, int addrlen)
{
    if (UNKNOWN_HANDLE(handle))
        return -PAL_ERROR_BADHANDLE;
    3ce0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

        ret = ops->read(handle, offset, count, buf);
    }

    return ret ? : -PAL_ERROR_ENDOFSTREAM;
}
    3ce5:	5d                   	pop    %rbp
    3ce6:	c3                   	retq   
    3ce7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3cee:	00 00 
       never be read */
    if (!ops)
        return -PAL_ERROR_NOTSUPPORT;

    if (!count)
        return -PAL_ERROR_ZEROSIZE;
    3cf0:	b8 e9 ff ff ff       	mov    $0xffffffe9,%eax

        ret = ops->read(handle, offset, count, buf);
    }

    return ret ? : -PAL_ERROR_ENDOFSTREAM;
}
    3cf5:	5d                   	pop    %rbp
    3cf6:	c3                   	retq   
    3cf7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3cfe:	00 00 
    const struct handle_ops * ops = HANDLE_OPS(handle);

    /* if ops or ops->read is not defined, it infers that the stream can
       never be read */
    if (!ops)
        return -PAL_ERROR_NOTSUPPORT;
    3d00:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

        ret = ops->read(handle, offset, count, buf);
    }

    return ret ? : -PAL_ERROR_ENDOFSTREAM;
}
    3d05:	5d                   	pop    %rbp
    3d06:	c3                   	retq   
    3d07:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3d0e:	00 00 

0000000000003d10 <DkStreamRead>:
/* PAL call DkStreamRead: Read from stream at absolute offset. Return number
   of bytes if succeeded, or 0 for failure. Error code is notified. */
PAL_NUM
DkStreamRead (PAL_HANDLE handle, PAL_NUM offset, PAL_NUM count,
              PAL_BUF buffer, PAL_BUF source, PAL_NUM size)
{
    3d10:	55                   	push   %rbp
    3d11:	48 89 e5             	mov    %rsp,%rbp
    3d14:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3d18:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    3d1c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    3d23:	00 
    frame->retval = NULL;
    3d24:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    3d2b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3d2c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    3d30:	48 8b 05 e1 fd 21 00 	mov    0x21fde1(%rip),%rax        # 223b18 <_DYNAMIC+0x330>
    3d37:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    3d3b:	48 8d 05 94 49 01 00 	lea    0x14994(%rip),%rax        # 186d6 <write_config+0x126>
    3d42:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    3d46:	48 89 e0             	mov    %rsp,%rax
    3d49:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    3d4d:	48 89 e8             	mov    %rbp,%rax
    3d50:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    3d54:	48 89 d8             	mov    %rbx,%rax
    3d57:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    3d5b:	48 89 f0             	mov    %rsi,%rax
    3d5e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    3d62:	48 89 f8             	mov    %rdi,%rax
    3d65:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    3d69:	4c 89 e0             	mov    %r12,%rax
    3d6c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    3d70:	4c 89 e8             	mov    %r13,%rax
    3d73:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    3d77:	4c 89 f0             	mov    %r14,%rax
    3d7a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    3d7e:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamRead);

    if (!handle || !buffer) {
    3d81:	48 85 ff             	test   %rdi,%rdi
    3d84:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    3d88:	74 36                	je     3dc0 <DkStreamRead+0xb0>
    3d8a:	48 85 c9             	test   %rcx,%rcx
    3d8d:	74 31                	je     3dc0 <DkStreamRead+0xb0>
        notify_failure (PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkStreamRead(handle, offset, count, buffer,
    3d8f:	4d 85 c0             	test   %r8,%r8
    3d92:	b8 00 00 00 00       	mov    $0x0,%eax
    3d97:	41 0f 45 c1          	cmovne %r9d,%eax
    3d9b:	4d 85 c9             	test   %r9,%r9
    3d9e:	41 b9 00 00 00 00    	mov    $0x0,%r9d
    3da4:	4d 0f 44 c1          	cmove  %r9,%r8
    3da8:	41 89 c1             	mov    %eax,%r9d
    3dab:	e8 e0 fe ff ff       	callq  3c90 <_DkStreamRead>
                            size ? (char *) source : NULL,
                            source ? size : 0);

    if (ret < 0) {
    3db0:	85 c0                	test   %eax,%eax
    3db2:	78 1c                	js     3dd0 <DkStreamRead+0xc0>
    3db4:	48 98                	cltq   
        notify_failure(-ret);
        ret = 0;
    }

    return ret;
}
    3db6:	c9                   	leaveq 
    3db7:	c3                   	retq   
    3db8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    3dbf:	00 
              PAL_BUF buffer, PAL_BUF source, PAL_NUM size)
{
    store_frame(StreamRead);

    if (!handle || !buffer) {
        notify_failure (PAL_ERROR_INVAL);
    3dc0:	bf 04 00 00 00       	mov    $0x4,%edi
    3dc5:	e8 86 10 01 00       	callq  14e50 <notify_failure>
        return 0;
    3dca:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        ret = 0;
    }

    return ret;
}
    3dcc:	c9                   	leaveq 
    3dcd:	c3                   	retq   
    3dce:	66 90                	xchg   %ax,%ax
    int ret = _DkStreamRead(handle, offset, count, buffer,
                            size ? (char *) source : NULL,
                            source ? size : 0);

    if (ret < 0) {
        notify_failure(-ret);
    3dd0:	f7 d8                	neg    %eax
    3dd2:	48 63 f8             	movslq %eax,%rdi
    3dd5:	e8 76 10 01 00       	callq  14e50 <notify_failure>
    3dda:	31 c0                	xor    %eax,%eax
        ret = 0;
    }

    return ret;
}
    3ddc:	c9                   	leaveq 
    3ddd:	c3                   	retq   
    3dde:	66 90                	xchg   %ax,%ax

0000000000003de0 <_DkStreamWrite>:

/* _DkStreamWrite for internal use, write to stream at absolute offset.
   The actual behavior of stream write is defined by handler */
int _DkStreamWrite (PAL_HANDLE handle, int offset, int count, const void * buf,
                    const char * addr, int addrlen)
{
    3de0:	48 63 07             	movslq (%rdi),%rax
    3de3:	55                   	push   %rbp
    3de4:	48 89 e5             	mov    %rsp,%rbp
    if (UNKNOWN_HANDLE(handle))
    3de7:	44 8d 50 ff          	lea    -0x1(%rax),%r10d
    3deb:	41 83 fa 10          	cmp    $0x10,%r10d
    3def:	77 3f                	ja     3e30 <_DkStreamWrite+0x50>
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(handle);
    3df1:	4c 8b 15 08 fc 21 00 	mov    0x21fc08(%rip),%r10        # 223a00 <_DYNAMIC+0x218>
    3df8:	49 8b 04 c2          	mov    (%r10,%rax,8),%rax

    if (!ops)
    3dfc:	48 85 c0             	test   %rax,%rax
    3dff:	74 4f                	je     3e50 <_DkStreamWrite+0x70>
        return -PAL_ERROR_NOTSUPPORT;

    if (!count)
    3e01:	85 d2                	test   %edx,%edx
    3e03:	74 3b                	je     3e40 <_DkStreamWrite+0x60>
        return -PAL_ERROR_ZEROSIZE;

    int ret;

    if (addr) {
    3e05:	4d 85 c0             	test   %r8,%r8
    3e08:	74 17                	je     3e21 <_DkStreamWrite+0x41>
        if (!ops->writebyaddr)
    3e0a:	48 8b 40 30          	mov    0x30(%rax),%rax
    3e0e:	48 85 c0             	test   %rax,%rax
    3e11:	74 3d                	je     3e50 <_DkStreamWrite+0x70>
            return -PAL_ERROR_NOTSUPPORT;

        ret = ops->writebyaddr(handle, offset, count, buf, addr, addrlen);
    3e13:	ff d0                	callq  *%rax
            return -PAL_ERROR_NOTSUPPORT;

        ret = ops->write(handle, offset, count, buf);
    }

    return ret ? : -PAL_ERROR_ENDOFSTREAM;
    3e15:	85 c0                	test   %eax,%eax
    3e17:	ba ec ff ff ff       	mov    $0xffffffec,%edx
    3e1c:	0f 44 c2             	cmove  %edx,%eax
}
    3e1f:	5d                   	pop    %rbp
    3e20:	c3                   	retq   
        if (!ops->writebyaddr)
            return -PAL_ERROR_NOTSUPPORT;

        ret = ops->writebyaddr(handle, offset, count, buf, addr, addrlen);
    } else {
        if (!ops->write)
    3e21:	48 8b 40 20          	mov    0x20(%rax),%rax
    3e25:	48 85 c0             	test   %rax,%rax
    3e28:	74 26                	je     3e50 <_DkStreamWrite+0x70>
            return -PAL_ERROR_NOTSUPPORT;

        ret = ops->write(handle, offset, count, buf);
    3e2a:	ff d0                	callq  *%rax
    3e2c:	eb e7                	jmp    3e15 <_DkStreamWrite+0x35>
    3e2e:	66 90                	xchg   %ax,%ax
   The actual behavior of stream write is defined by handler */
int _DkStreamWrite (PAL_HANDLE handle, int offset, int count, const void * buf,
                    const char * addr, int addrlen)
{
    if (UNKNOWN_HANDLE(handle))
        return -PAL_ERROR_BADHANDLE;
    3e30:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

        ret = ops->write(handle, offset, count, buf);
    }

    return ret ? : -PAL_ERROR_ENDOFSTREAM;
}
    3e35:	5d                   	pop    %rbp
    3e36:	c3                   	retq   
    3e37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3e3e:	00 00 

    if (!ops)
        return -PAL_ERROR_NOTSUPPORT;

    if (!count)
        return -PAL_ERROR_ZEROSIZE;
    3e40:	b8 e9 ff ff ff       	mov    $0xffffffe9,%eax

        ret = ops->write(handle, offset, count, buf);
    }

    return ret ? : -PAL_ERROR_ENDOFSTREAM;
}
    3e45:	5d                   	pop    %rbp
    3e46:	c3                   	retq   
    3e47:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3e4e:	00 00 
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(handle);

    if (!ops)
        return -PAL_ERROR_NOTSUPPORT;
    3e50:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

        ret = ops->write(handle, offset, count, buf);
    }

    return ret ? : -PAL_ERROR_ENDOFSTREAM;
}
    3e55:	5d                   	pop    %rbp
    3e56:	c3                   	retq   
    3e57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3e5e:	00 00 

0000000000003e60 <DkStreamWrite>:
/* PAL call DkStreamWrite: Write to stream at absolute offset. Return number
   of bytes if succeeded, or 0 for failure. Error code is notified. */
PAL_NUM
DkStreamWrite (PAL_HANDLE handle, PAL_NUM offset, PAL_NUM count,
               const PAL_PTR buffer, PAL_STR dest)
{
    3e60:	55                   	push   %rbp
    3e61:	48 89 e5             	mov    %rsp,%rbp
    3e64:	53                   	push   %rbx
    3e65:	48 89 fb             	mov    %rdi,%rbx

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3e68:	48 8d 45 80          	lea    -0x80(%rbp),%rax
    3e6c:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    3e73:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    3e7a:	00 
    frame->retval = NULL;
    3e7b:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    3e82:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    3e83:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->func = func;
    3e87:	48 8b 05 82 fb 21 00 	mov    0x21fb82(%rip),%rax        # 223a10 <_DYNAMIC+0x228>
    3e8e:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    frame->funcname = funcname;
    3e92:	48 8d 05 4a 48 01 00 	lea    0x1484a(%rip),%rax        # 186e3 <write_config+0x133>
    3e99:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    3e9d:	48 89 e0             	mov    %rsp,%rax
    3ea0:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    3ea4:	48 89 e8             	mov    %rbp,%rax
    3ea7:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    3eab:	48 89 d8             	mov    %rbx,%rax
    3eae:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    3eb2:	48 89 f0             	mov    %rsi,%rax
    3eb5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    3eb9:	48 89 f8             	mov    %rdi,%rax
    3ebc:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    3ec0:	4c 89 e0             	mov    %r12,%rax
    3ec3:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    3ec7:	4c 89 e8             	mov    %r13,%rax
    3eca:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    3ece:	4c 89 f0             	mov    %r14,%rax
    3ed1:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    3ed5:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamWrite);

    if (handle == NULL || buffer == NULL) {
    3ed8:	48 85 ff             	test   %rdi,%rdi
    3edb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    3edf:	74 6f                	je     3f50 <DkStreamWrite+0xf0>
    3ee1:	48 85 c9             	test   %rcx,%rcx
    3ee4:	74 6a                	je     3f50 <DkStreamWrite+0xf0>
        notify_failure (PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkStreamWrite(handle, offset, count, buffer, dest,
    3ee6:	45 31 c9             	xor    %r9d,%r9d
    3ee9:	4d 85 c0             	test   %r8,%r8
    3eec:	74 43                	je     3f31 <DkStreamWrite+0xd1>
                             dest ? strlen(dest) : 0);
    3eee:	4c 89 c7             	mov    %r8,%rdi
    3ef1:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
    3ef8:	48 89 95 68 ff ff ff 	mov    %rdx,-0x98(%rbp)
    3eff:	48 89 b5 70 ff ff ff 	mov    %rsi,-0x90(%rbp)
    3f06:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
    3f0d:	e8 8e 28 01 00       	callq  167a0 <strlen>
    if (handle == NULL || buffer == NULL) {
        notify_failure (PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkStreamWrite(handle, offset, count, buffer, dest,
    3f12:	48 8b 8d 60 ff ff ff 	mov    -0xa0(%rbp),%rcx
    3f19:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
    3f20:	41 89 c1             	mov    %eax,%r9d
    3f23:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
    3f2a:	4c 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%r8
    3f31:	48 89 df             	mov    %rbx,%rdi
    3f34:	e8 a7 fe ff ff       	callq  3de0 <_DkStreamWrite>
                             dest ? strlen(dest) : 0);

    if (ret < 0) {
    3f39:	85 c0                	test   %eax,%eax
    3f3b:	78 33                	js     3f70 <DkStreamWrite+0x110>
        notify_failure(-ret);
        ret = 0;
    }

    return ret;
}
    3f3d:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
    3f44:	48 98                	cltq   
    3f46:	5b                   	pop    %rbx
    3f47:	5d                   	pop    %rbp
    3f48:	c3                   	retq   
    3f49:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
               const PAL_PTR buffer, PAL_STR dest)
{
    store_frame(StreamWrite);

    if (handle == NULL || buffer == NULL) {
        notify_failure (PAL_ERROR_INVAL);
    3f50:	bf 04 00 00 00       	mov    $0x4,%edi
    3f55:	e8 f6 0e 01 00       	callq  14e50 <notify_failure>
        notify_failure(-ret);
        ret = 0;
    }

    return ret;
}
    3f5a:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
{
    store_frame(StreamWrite);

    if (handle == NULL || buffer == NULL) {
        notify_failure (PAL_ERROR_INVAL);
        return 0;
    3f61:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        ret = 0;
    }

    return ret;
}
    3f63:	5b                   	pop    %rbx
    3f64:	5d                   	pop    %rbp
    3f65:	c3                   	retq   
    3f66:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f6d:	00 00 00 

    int ret = _DkStreamWrite(handle, offset, count, buffer, dest,
                             dest ? strlen(dest) : 0);

    if (ret < 0) {
        notify_failure(-ret);
    3f70:	f7 d8                	neg    %eax
    3f72:	48 63 f8             	movslq %eax,%rdi
    3f75:	e8 d6 0e 01 00       	callq  14e50 <notify_failure>
        ret = 0;
    }

    return ret;
}
    3f7a:	48 81 c4 98 00 00 00 	add    $0x98,%rsp

    int ret = _DkStreamWrite(handle, offset, count, buffer, dest,
                             dest ? strlen(dest) : 0);

    if (ret < 0) {
        notify_failure(-ret);
    3f81:	31 c0                	xor    %eax,%eax
        ret = 0;
    }

    return ret;
}
    3f83:	5b                   	pop    %rbx
    3f84:	5d                   	pop    %rbp
    3f85:	c3                   	retq   
    3f86:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3f8d:	00 00 00 

0000000000003f90 <_DkStreamAttributesQuery>:

/* _DkStreamAttributesQuery of internal use. The function query attribute
   of streams by their URI */
int _DkStreamAttributesQuery (PAL_STR uri, PAL_STREAM_ATTR * attr)
{
    3f90:	55                   	push   %rbp
    3f91:	48 89 e5             	mov    %rsp,%rbp
    3f94:	53                   	push   %rbx
    3f95:	48 89 f3             	mov    %rsi,%rbx
    struct handle_ops * ops = NULL;
    const char * type = NULL;

    int ret = parse_stream_uri (&uri, &type, &ops);
    3f98:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
    3f9c:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
}

/* _DkStreamAttributesQuery of internal use. The function query attribute
   of streams by their URI */
int _DkStreamAttributesQuery (PAL_STR uri, PAL_STREAM_ATTR * attr)
{
    3fa0:	48 83 ec 28          	sub    $0x28,%rsp
    3fa4:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    struct handle_ops * ops = NULL;
    const char * type = NULL;

    int ret = parse_stream_uri (&uri, &type, &ops);
    3fa8:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi

/* _DkStreamAttributesQuery of internal use. The function query attribute
   of streams by their URI */
int _DkStreamAttributesQuery (PAL_STR uri, PAL_STREAM_ATTR * attr)
{
    struct handle_ops * ops = NULL;
    3fac:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    3fb3:	00 
    const char * type = NULL;
    3fb4:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    3fbb:	00 

    int ret = parse_stream_uri (&uri, &type, &ops);
    3fbc:	e8 4f f7 ff ff       	callq  3710 <parse_stream_uri>

    if (ret < 0)
    3fc1:	85 c0                	test   %eax,%eax
    3fc3:	78 1a                	js     3fdf <_DkStreamAttributesQuery+0x4f>
        return ret;

    if (!ops->attrquery)
    3fc5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    3fc9:	48 8b 40 68          	mov    0x68(%rax),%rax
    3fcd:	48 85 c0             	test   %rax,%rax
    3fd0:	74 1e                	je     3ff0 <_DkStreamAttributesQuery+0x60>
        return -PAL_ERROR_NOTSUPPORT;

    return ops->attrquery(type, uri, attr);
    3fd2:	48 89 da             	mov    %rbx,%rdx
    3fd5:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
    3fd9:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
    3fdd:	ff d0                	callq  *%rax
}
    3fdf:	48 83 c4 28          	add    $0x28,%rsp
    3fe3:	5b                   	pop    %rbx
    3fe4:	5d                   	pop    %rbp
    3fe5:	c3                   	retq   
    3fe6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    3fed:	00 00 00 

    if (ret < 0)
        return ret;

    if (!ops->attrquery)
        return -PAL_ERROR_NOTSUPPORT;
    3ff0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    3ff5:	eb e8                	jmp    3fdf <_DkStreamAttributesQuery+0x4f>
    3ff7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    3ffe:	00 00 

0000000000004000 <DkStreamAttributesQuery>:
/* PAL call DkStreamAttributeQuery: query attribute of a stream by its
   URI, attr is memory given by user space. Return the pointer of attr
   if succeeded, or NULL if failed. Error code is notified */
PAL_BOL
DkStreamAttributesQuery (PAL_STR uri, PAL_STREAM_ATTR * attr)
{
    4000:	55                   	push   %rbp
    4001:	48 89 e5             	mov    %rsp,%rbp
    4004:	41 55                	push   %r13
    4006:	41 54                	push   %r12

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4008:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
    400f:	53                   	push   %rbx
    4010:	49 89 f4             	mov    %rsi,%r12
    4013:	48 81 ec e8 00 00 00 	sub    $0xe8,%rsp
    401a:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
    frame->func = func;
    4021:	48 8b 05 70 fa 21 00 	mov    0x21fa70(%rip),%rax        # 223a98 <_DYNAMIC+0x2b0>
    frame->funcname = funcname;
    frame->context = NULL;
    4028:	48 c7 85 60 ff ff ff 	movq   $0x0,-0xa0(%rbp)
    402f:	00 00 00 00 
    frame->retval = NULL;
    4033:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
    403a:	00 00 00 00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    403e:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
    frame->funcname = funcname;
    4045:	48 8d 05 a5 46 01 00 	lea    0x146a5(%rip),%rax        # 186f1 <write_config+0x141>
    404c:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4053:	48 89 e0             	mov    %rsp,%rax
    4056:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
    405d:	48 89 e8             	mov    %rbp,%rax
    4060:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
    4067:	48 89 d8             	mov    %rbx,%rax
    406a:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    4071:	48 89 f0             	mov    %rsi,%rax
    4074:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
    407b:	48 89 f8             	mov    %rdi,%rax
    407e:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
    4085:	4c 89 e0             	mov    %r12,%rax
    4088:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    408f:	4c 89 e8             	mov    %r13,%rax
    4092:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    4099:	4c 89 f0             	mov    %r14,%rax
    409c:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
    40a3:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamAttributesQuery);

    if (!uri || !attr) {
    40a6:	48 85 ff             	test   %rdi,%rdi
    40a9:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
    40b0:	0f 94 c3             	sete   %bl
    40b3:	48 85 f6             	test   %rsi,%rsi
    40b6:	0f 94 c0             	sete   %al
    40b9:	08 c3                	or     %al,%bl
    40bb:	75 38                	jne    40f5 <DkStreamAttributesQuery+0xf5>
        return PAL_FALSE;
    }

    PAL_STREAM_ATTR attr_buf;

    int ret = _DkStreamAttributesQuery(uri, &attr_buf);
    40bd:	4c 8d ad 70 ff ff ff 	lea    -0x90(%rbp),%r13
    40c4:	4c 89 ee             	mov    %r13,%rsi
    40c7:	e8 c4 fe ff ff       	callq  3f90 <_DkStreamAttributesQuery>

    if (ret < 0) {
    40cc:	85 c0                	test   %eax,%eax
    40ce:	78 41                	js     4111 <DkStreamAttributesQuery+0x111>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    memcpy(attr, &attr_buf, sizeof(PAL_STREAM_ATTR));
    40d0:	4c 89 ee             	mov    %r13,%rsi
    40d3:	4c 89 e7             	mov    %r12,%rdi
    40d6:	ba 70 00 00 00       	mov    $0x70,%edx
    40db:	e8 a0 21 01 00       	callq  16280 <memcpy>
    return PAL_TRUE;
    40e0:	bb 01 00 00 00       	mov    $0x1,%ebx
}
    40e5:	48 81 c4 e8 00 00 00 	add    $0xe8,%rsp
    40ec:	89 d8                	mov    %ebx,%eax
    40ee:	5b                   	pop    %rbx
    40ef:	41 5c                	pop    %r12
    40f1:	41 5d                	pop    %r13
    40f3:	5d                   	pop    %rbp
    40f4:	c3                   	retq   
DkStreamAttributesQuery (PAL_STR uri, PAL_STREAM_ATTR * attr)
{
    store_frame(StreamAttributesQuery);

    if (!uri || !attr) {
        notify_failure(PAL_ERROR_INVAL);
    40f5:	bf 04 00 00 00       	mov    $0x4,%edi
        return PAL_FALSE;
    40fa:	31 db                	xor    %ebx,%ebx
DkStreamAttributesQuery (PAL_STR uri, PAL_STREAM_ATTR * attr)
{
    store_frame(StreamAttributesQuery);

    if (!uri || !attr) {
        notify_failure(PAL_ERROR_INVAL);
    40fc:	e8 4f 0d 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    }

    memcpy(attr, &attr_buf, sizeof(PAL_STREAM_ATTR));
    return PAL_TRUE;
}
    4101:	48 81 c4 e8 00 00 00 	add    $0xe8,%rsp
    4108:	89 d8                	mov    %ebx,%eax
    410a:	5b                   	pop    %rbx
    410b:	41 5c                	pop    %r12
    410d:	41 5d                	pop    %r13
    410f:	5d                   	pop    %rbp
    4110:	c3                   	retq   
    PAL_STREAM_ATTR attr_buf;

    int ret = _DkStreamAttributesQuery(uri, &attr_buf);

    if (ret < 0) {
        notify_failure(-ret);
    4111:	f7 d8                	neg    %eax
    4113:	48 63 f8             	movslq %eax,%rdi
    4116:	e8 35 0d 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    }

    memcpy(attr, &attr_buf, sizeof(PAL_STREAM_ATTR));
    return PAL_TRUE;
}
    411b:	48 81 c4 e8 00 00 00 	add    $0xe8,%rsp
    4122:	89 d8                	mov    %ebx,%eax
    4124:	5b                   	pop    %rbx
    4125:	41 5c                	pop    %r12
    4127:	41 5d                	pop    %r13
    4129:	5d                   	pop    %rbp
    412a:	c3                   	retq   
    412b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000004130 <_DkStreamAttributesQuerybyHandle>:

/* _DkStreamAttributesQuerybyHandle for internal use. Query attribute
   of streams by their handle */
int _DkStreamAttributesQuerybyHandle (PAL_HANDLE hdl, PAL_STREAM_ATTR * attr)
{
    4130:	48 63 07             	movslq (%rdi),%rax
    4133:	8d 50 ff             	lea    -0x1(%rax),%edx
    4136:	83 fa 10             	cmp    $0x10,%edx
    4139:	77 75                	ja     41b0 <_DkStreamAttributesQuerybyHandle+0x80>
    413b:	55                   	push   %rbp
    413c:	48 89 e5             	mov    %rsp,%rbp
    413f:	41 55                	push   %r13
    4141:	41 54                	push   %r12
    4143:	53                   	push   %rbx
    4144:	49 89 f4             	mov    %rsi,%r12
    4147:	48 89 fb             	mov    %rdi,%rbx
    414a:	48 83 ec 08          	sub    $0x8,%rsp
    if (UNKNOWN_HANDLE(hdl))
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(hdl);
    414e:	48 8b 15 ab f8 21 00 	mov    0x21f8ab(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
    4155:	4c 8b 2c c2          	mov    (%rdx,%rax,8),%r13

    assert(ops);
    4159:	4d 85 ed             	test   %r13,%r13
    415c:	74 1b                	je     4179 <_DkStreamAttributesQuerybyHandle+0x49>

    /* if ops->attrquerybyhdl is not defined, the stream cannot be queried */
    if (!ops->attrquerybyhdl)
    415e:	49 8b 45 70          	mov    0x70(%r13),%rax
    4162:	48 85 c0             	test   %rax,%rax
    4165:	74 59                	je     41c0 <_DkStreamAttributesQuerybyHandle+0x90>
        return -PAL_ERROR_NOTSUPPORT;

    return ops->attrquerybyhdl(hdl, attr);
}
    4167:	48 83 c4 08          	add    $0x8,%rsp

    /* if ops->attrquerybyhdl is not defined, the stream cannot be queried */
    if (!ops->attrquerybyhdl)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->attrquerybyhdl(hdl, attr);
    416b:	4c 89 e6             	mov    %r12,%rsi
    416e:	48 89 df             	mov    %rbx,%rdi
}
    4171:	5b                   	pop    %rbx
    4172:	41 5c                	pop    %r12
    4174:	41 5d                	pop    %r13
    4176:	5d                   	pop    %rbp

    /* if ops->attrquerybyhdl is not defined, the stream cannot be queried */
    if (!ops->attrquerybyhdl)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->attrquerybyhdl(hdl, attr);
    4177:	ff e0                	jmpq   *%rax
    if (UNKNOWN_HANDLE(hdl))
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(hdl);

    assert(ops);
    4179:	48 8d 15 9e 44 01 00 	lea    0x1449e(%rip),%rdx        # 1861e <write_config+0x6e>
    4180:	48 8d 35 a4 44 01 00 	lea    0x144a4(%rip),%rsi        # 1862b <write_config+0x7b>
    4187:	48 8d 3d aa 45 01 00 	lea    0x145aa(%rip),%rdi        # 18738 <write_config+0x188>
    418e:	b9 a2 01 00 00       	mov    $0x1a2,%ecx
    4193:	31 c0                	xor    %eax,%eax
    4195:	e8 86 4c 00 00       	callq  8e20 <pal_printf>
    419a:	e8 d1 28 00 00       	callq  6a70 <__assert>
    419f:	bf 01 00 00 00       	mov    $0x1,%edi
    41a4:	e8 d7 e3 00 00       	callq  12580 <_DkProcessExit>
    41a9:	eb b3                	jmp    415e <_DkStreamAttributesQuerybyHandle+0x2e>
    41ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
/* _DkStreamAttributesQuerybyHandle for internal use. Query attribute
   of streams by their handle */
int _DkStreamAttributesQuerybyHandle (PAL_HANDLE hdl, PAL_STREAM_ATTR * attr)
{
    if (UNKNOWN_HANDLE(hdl))
        return -PAL_ERROR_BADHANDLE;
    41b0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    /* if ops->attrquerybyhdl is not defined, the stream cannot be queried */
    if (!ops->attrquerybyhdl)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->attrquerybyhdl(hdl, attr);
}
    41b5:	c3                   	retq   
    41b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    41bd:	00 00 00 
    41c0:	48 83 c4 08          	add    $0x8,%rsp

    assert(ops);

    /* if ops->attrquerybyhdl is not defined, the stream cannot be queried */
    if (!ops->attrquerybyhdl)
        return -PAL_ERROR_NOTSUPPORT;
    41c4:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

    return ops->attrquerybyhdl(hdl, attr);
}
    41c9:	5b                   	pop    %rbx
    41ca:	41 5c                	pop    %r12
    41cc:	41 5d                	pop    %r13
    41ce:	5d                   	pop    %rbp
    41cf:	c3                   	retq   

00000000000041d0 <DkStreamAttributesQuerybyHandle>:
/* PAL call DkStreamAttributesQuerybyHandle: Query attribute of a stream by
   its handle, attr is memory given by user space. Return the pointer of attr
   if succeeded, or NULL if failed. Error code is notified */
PAL_BOL
DkStreamAttributesQuerybyHandle (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    41d0:	55                   	push   %rbp
    41d1:	48 89 e5             	mov    %rsp,%rbp
    41d4:	53                   	push   %rbx

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    41d5:	48 8d 45 80          	lea    -0x80(%rbp),%rax
    41d9:	48 83 ec 78          	sub    $0x78,%rsp
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    41dd:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    41e4:	00 
    frame->retval = NULL;
    41e5:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    41ec:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    41ed:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->func = func;
    41f1:	48 8b 05 78 f7 21 00 	mov    0x21f778(%rip),%rax        # 223970 <_DYNAMIC+0x188>
    41f8:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    frame->funcname = funcname;
    41fc:	48 8d 05 55 45 01 00 	lea    0x14555(%rip),%rax        # 18758 <write_config+0x1a8>
    4203:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4207:	48 89 e0             	mov    %rsp,%rax
    420a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    420e:	48 89 e8             	mov    %rbp,%rax
    4211:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    4215:	48 89 d8             	mov    %rbx,%rax
    4218:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    421c:	48 89 f0             	mov    %rsi,%rax
    421f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4223:	48 89 f8             	mov    %rdi,%rax
    4226:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    422a:	4c 89 e0             	mov    %r12,%rax
    422d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4231:	4c 89 e8             	mov    %r13,%rax
    4234:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4238:	4c 89 f0             	mov    %r14,%rax
    423b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    423f:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamAttributesQuerybyHandle);

    if (!handle || !attr) {
    4242:	48 85 ff             	test   %rdi,%rdi
    4245:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    4249:	0f 94 c3             	sete   %bl
    424c:	48 85 f6             	test   %rsi,%rsi
    424f:	0f 94 c0             	sete   %al
    4252:	08 c3                	or     %al,%bl
    4254:	75 1a                	jne    4270 <DkStreamAttributesQuerybyHandle+0xa0>
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    int ret = _DkStreamAttributesQuerybyHandle(handle, attr);
    4256:	e8 d5 fe ff ff       	callq  4130 <_DkStreamAttributesQuerybyHandle>

    if (ret < 0) {
    425b:	85 c0                	test   %eax,%eax
    425d:	78 26                	js     4285 <DkStreamAttributesQuerybyHandle+0xb5>
        notify_failure (-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    425f:	bb 01 00 00 00       	mov    $0x1,%ebx
}
    4264:	48 83 c4 78          	add    $0x78,%rsp
    4268:	89 d8                	mov    %ebx,%eax
    426a:	5b                   	pop    %rbx
    426b:	5d                   	pop    %rbp
    426c:	c3                   	retq   
    426d:	0f 1f 00             	nopl   (%rax)
DkStreamAttributesQuerybyHandle (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    store_frame(StreamAttributesQuerybyHandle);

    if (!handle || !attr) {
        notify_failure(PAL_ERROR_INVAL);
    4270:	bf 04 00 00 00       	mov    $0x4,%edi
        return PAL_FALSE;
    4275:	31 db                	xor    %ebx,%ebx
DkStreamAttributesQuerybyHandle (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    store_frame(StreamAttributesQuerybyHandle);

    if (!handle || !attr) {
        notify_failure(PAL_ERROR_INVAL);
    4277:	e8 d4 0b 01 00       	callq  14e50 <notify_failure>
        notify_failure (-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    427c:	48 83 c4 78          	add    $0x78,%rsp
    4280:	89 d8                	mov    %ebx,%eax
    4282:	5b                   	pop    %rbx
    4283:	5d                   	pop    %rbp
    4284:	c3                   	retq   
    }

    int ret = _DkStreamAttributesQuerybyHandle(handle, attr);

    if (ret < 0) {
        notify_failure (-ret);
    4285:	f7 d8                	neg    %eax
    4287:	48 63 f8             	movslq %eax,%rdi
    428a:	e8 c1 0b 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    428f:	48 83 c4 78          	add    $0x78,%rsp
    4293:	89 d8                	mov    %ebx,%eax
    4295:	5b                   	pop    %rbx
    4296:	5d                   	pop    %rbp
    4297:	c3                   	retq   
    4298:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    429f:	00 

00000000000042a0 <_DkStreamMap>:

/* _DkStreamMap for internal use. Map specific handle to certain memory,
   with given protection, offset and size */
int _DkStreamMap (PAL_HANDLE handle, void ** paddr, int prot, int offset,
                  size_t size)
{
    42a0:	55                   	push   %rbp
    42a1:	48 89 e5             	mov    %rsp,%rbp
    42a4:	53                   	push   %rbx
    42a5:	48 89 f3             	mov    %rsi,%rbx
    42a8:	48 83 ec 18          	sub    $0x18,%rsp
    void * addr = *paddr;
    int ret;

    const struct handle_ops * ops = HANDLE_OPS(handle);
    42ac:	4c 63 0f             	movslq (%rdi),%r9
/* _DkStreamMap for internal use. Map specific handle to certain memory,
   with given protection, offset and size */
int _DkStreamMap (PAL_HANDLE handle, void ** paddr, int prot, int offset,
                  size_t size)
{
    void * addr = *paddr;
    42af:	48 8b 06             	mov    (%rsi),%rax
    42b2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    const struct handle_ops * ops = HANDLE_OPS(handle);

    /* if ops or ops->map is not defined, the stream cannot be mapped */
    if (!ops || !ops->map)
        return -PAL_ERROR_NOTSUPPORT;
    42b6:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
                  size_t size)
{
    void * addr = *paddr;
    int ret;

    const struct handle_ops * ops = HANDLE_OPS(handle);
    42bb:	41 8d 71 ff          	lea    -0x1(%r9),%esi
    42bf:	83 fe 10             	cmp    $0x10,%esi
    42c2:	77 2d                	ja     42f1 <_DkStreamMap+0x51>
    42c4:	48 8b 35 35 f7 21 00 	mov    0x21f735(%rip),%rsi        # 223a00 <_DYNAMIC+0x218>
    42cb:	4a 8b 34 ce          	mov    (%rsi,%r9,8),%rsi

    /* if ops or ops->map is not defined, the stream cannot be mapped */
    if (!ops || !ops->map)
    42cf:	48 85 f6             	test   %rsi,%rsi
    42d2:	74 1d                	je     42f1 <_DkStreamMap+0x51>
    42d4:	4c 8b 4e 48          	mov    0x48(%rsi),%r9
    42d8:	4d 85 c9             	test   %r9,%r9
    42db:	74 14                	je     42f1 <_DkStreamMap+0x51>
        return -PAL_ERROR_NOTSUPPORT;

    if ((ret = ops->map(handle, &addr, prot, offset, size)) < 0)
    42dd:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
    42e1:	41 ff d1             	callq  *%r9
    42e4:	85 c0                	test   %eax,%eax
    42e6:	78 09                	js     42f1 <_DkStreamMap+0x51>
        return ret;

    *paddr = addr;
    42e8:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    42ec:	48 89 03             	mov    %rax,(%rbx)
    return 0;
    42ef:	31 c0                	xor    %eax,%eax
}
    42f1:	48 83 c4 18          	add    $0x18,%rsp
    42f5:	5b                   	pop    %rbx
    42f6:	5d                   	pop    %rbp
    42f7:	c3                   	retq   
    42f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    42ff:	00 

0000000000004300 <DkStreamMap>:
   mapping. Return the address if succeeded or NULL if failed. Error code
   is notified. */
PAL_BUF
DkStreamMap (PAL_HANDLE handle, PAL_BUF addr, PAL_FLG prot, PAL_NUM offset,
             PAL_NUM size)
{
    4300:	55                   	push   %rbp
    4301:	48 89 e5             	mov    %rsp,%rbp
    4304:	53                   	push   %rbx
    4305:	48 89 fb             	mov    %rdi,%rbx

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4308:	48 8d 45 80          	lea    -0x80(%rbp),%rax
    430c:	48 81 ec 98 00 00 00 	sub    $0x98,%rsp
    4313:	48 89 b5 78 ff ff ff 	mov    %rsi,-0x88(%rbp)
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    431a:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    4321:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4322:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->func = func;
    4326:	48 8b 05 0b f8 21 00 	mov    0x21f80b(%rip),%rax        # 223b38 <_DYNAMIC+0x350>
    frame->funcname = funcname;
    frame->context = NULL;
    frame->retval = NULL;
    432d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    4334:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    4335:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    frame->funcname = funcname;
    4339:	48 8d 05 c9 43 01 00 	lea    0x143c9(%rip),%rax        # 18709 <write_config+0x159>
    4340:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4344:	48 89 e0             	mov    %rsp,%rax
    4347:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    434b:	48 89 e8             	mov    %rbp,%rax
    434e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    4352:	48 89 d8             	mov    %rbx,%rax
    4355:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4359:	48 89 f0             	mov    %rsi,%rax
    435c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4360:	48 89 f8             	mov    %rdi,%rax
    4363:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4367:	4c 89 e0             	mov    %r12,%rax
    436a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    436e:	4c 89 e8             	mov    %r13,%rax
    4371:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4375:	4c 89 f0             	mov    %r14,%rax
    4378:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    437c:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamMap);

    if (!handle) {
    437f:	48 85 ff             	test   %rdi,%rdi
    4382:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    4386:	0f 84 a6 00 00 00    	je     4432 <DkStreamMap+0x132>
        notify_failure(PAL_ERROR_INVAL);
        return NULL;
    }

    if ((addr && !ALLOC_ALIGNED(addr)) || !size || !ALLOC_ALIGNED(size) ||
    438c:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    4393:	48 85 ff             	test   %rdi,%rdi
    4396:	0f 84 b4 00 00 00    	je     4450 <DkStreamMap+0x150>
    439c:	48 8b 05 ed f5 21 00 	mov    0x21f5ed(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
    43a3:	48 83 38 00          	cmpq   $0x0,(%rax)
    43a7:	0f 84 85 00 00 00    	je     4432 <DkStreamMap+0x132>
    43ad:	48 8b 05 44 f7 21 00 	mov    0x21f744(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    43b4:	48 89 fe             	mov    %rdi,%rsi
    43b7:	48 8b 00             	mov    (%rax),%rax
    43ba:	48 21 c6             	and    %rax,%rsi
    43bd:	48 39 f7             	cmp    %rsi,%rdi
    43c0:	75 70                	jne    4432 <DkStreamMap+0x132>
    43c2:	4d 85 c0             	test   %r8,%r8
    43c5:	74 6b                	je     4432 <DkStreamMap+0x132>
    43c7:	48 89 c6             	mov    %rax,%rsi
    43ca:	89 95 74 ff ff ff    	mov    %edx,-0x8c(%rbp)
    43d0:	4c 21 c6             	and    %r8,%rsi
    43d3:	4c 39 c6             	cmp    %r8,%rsi
    43d6:	75 5a                	jne    4432 <DkStreamMap+0x132>
        !ALLOC_ALIGNED(offset)) {
    43d8:	48 21 c8             	and    %rcx,%rax
    43db:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
    43e2:	48 39 c8             	cmp    %rcx,%rax
    43e5:	75 4b                	jne    4432 <DkStreamMap+0x132>
        notify_failure(PAL_ERROR_INVAL);
        return NULL;
    }

    if (check_memory_overlap(addr, size)) {
    43e7:	4c 89 c6             	mov    %r8,%rsi
    43ea:	4c 89 85 60 ff ff ff 	mov    %r8,-0xa0(%rbp)
    43f1:	e8 9a 03 00 00       	callq  4790 <check_memory_overlap>
    43f6:	84 c0                	test   %al,%al
    43f8:	4c 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%r8
    43ff:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
    4406:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
    440c:	75 63                	jne    4471 <DkStreamMap+0x171>
        notify_failure(PAL_ERROR_DENIED);
        return NULL;
    }

    int ret = _DkStreamMap(handle, &addr, prot, offset, size);
    440e:	48 8d b5 78 ff ff ff 	lea    -0x88(%rbp),%rsi
    4415:	48 89 df             	mov    %rbx,%rdi
    4418:	e8 83 fe ff ff       	callq  42a0 <_DkStreamMap>

    if (ret < 0) {
    441d:	85 c0                	test   %eax,%eax
    441f:	78 5e                	js     447f <DkStreamMap+0x17f>
        notify_failure(-ret);
        return NULL;
    }

    return addr;
    4421:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
}
    4428:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
    442f:	5b                   	pop    %rbx
    4430:	5d                   	pop    %rbp
    4431:	c3                   	retq   
             PAL_NUM size)
{
    store_frame(StreamMap);

    if (!handle) {
        notify_failure(PAL_ERROR_INVAL);
    4432:	bf 04 00 00 00       	mov    $0x4,%edi
    4437:	e8 14 0a 01 00       	callq  14e50 <notify_failure>
        return NULL;
    443c:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        return NULL;
    }

    return addr;
}
    443e:	48 81 c4 98 00 00 00 	add    $0x98,%rsp
    4445:	5b                   	pop    %rbx
    4446:	5d                   	pop    %rbp
    4447:	c3                   	retq   
    4448:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    444f:	00 
    if (!handle) {
        notify_failure(PAL_ERROR_INVAL);
        return NULL;
    }

    if ((addr && !ALLOC_ALIGNED(addr)) || !size || !ALLOC_ALIGNED(size) ||
    4450:	4d 85 c0             	test   %r8,%r8
    4453:	74 dd                	je     4432 <DkStreamMap+0x132>
    4455:	48 8b 05 34 f5 21 00 	mov    0x21f534(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
    445c:	48 83 38 00          	cmpq   $0x0,(%rax)
    4460:	74 d0                	je     4432 <DkStreamMap+0x132>
    4462:	48 8b 05 8f f6 21 00 	mov    0x21f68f(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    4469:	48 8b 00             	mov    (%rax),%rax
    446c:	e9 56 ff ff ff       	jmpq   43c7 <DkStreamMap+0xc7>
        notify_failure(PAL_ERROR_INVAL);
        return NULL;
    }

    if (check_memory_overlap(addr, size)) {
        notify_failure(PAL_ERROR_DENIED);
    4471:	bf 06 00 00 00       	mov    $0x6,%edi
    4476:	e8 d5 09 01 00       	callq  14e50 <notify_failure>
        return NULL;
    447b:	31 c0                	xor    %eax,%eax
    447d:	eb bf                	jmp    443e <DkStreamMap+0x13e>
    }

    int ret = _DkStreamMap(handle, &addr, prot, offset, size);

    if (ret < 0) {
        notify_failure(-ret);
    447f:	f7 d8                	neg    %eax
    4481:	48 63 f8             	movslq %eax,%rdi
    4484:	e8 c7 09 01 00       	callq  14e50 <notify_failure>
        return NULL;
    4489:	31 c0                	xor    %eax,%eax
    448b:	eb b1                	jmp    443e <DkStreamMap+0x13e>
    448d:	0f 1f 00             	nopl   (%rax)

0000000000004490 <_DkStreamSetLength>:
}

/* _DkStreamSetLength for internal use. This function truncate the stream
   to certain length. This call might not be support for certain streams */
int _DkStreamSetLength (PAL_HANDLE handle, size_t length)
{
    4490:	48 63 07             	movslq (%rdi),%rax
    4493:	55                   	push   %rbp
    4494:	48 89 e5             	mov    %rsp,%rbp
    if (UNKNOWN_HANDLE(handle))
    4497:	8d 50 ff             	lea    -0x1(%rax),%edx
    449a:	83 fa 10             	cmp    $0x10,%edx
    449d:	77 21                	ja     44c0 <_DkStreamSetLength+0x30>
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(handle);
    449f:	48 8b 15 5a f5 21 00 	mov    0x21f55a(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
    44a6:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax

    if (!ops || !ops->setlength)
    44aa:	48 85 c0             	test   %rax,%rax
    44ad:	74 21                	je     44d0 <_DkStreamSetLength+0x40>
    44af:	48 8b 40 50          	mov    0x50(%rax),%rax
    44b3:	48 85 c0             	test   %rax,%rax
    44b6:	74 18                	je     44d0 <_DkStreamSetLength+0x40>
        return -PAL_ERROR_NOTSUPPORT;

    return ops->setlength(handle, length);
}
    44b8:	5d                   	pop    %rbp
    const struct handle_ops * ops = HANDLE_OPS(handle);

    if (!ops || !ops->setlength)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->setlength(handle, length);
    44b9:	ff e0                	jmpq   *%rax
    44bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
/* _DkStreamSetLength for internal use. This function truncate the stream
   to certain length. This call might not be support for certain streams */
int _DkStreamSetLength (PAL_HANDLE handle, size_t length)
{
    if (UNKNOWN_HANDLE(handle))
        return -PAL_ERROR_BADHANDLE;
    44c0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

    if (!ops || !ops->setlength)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->setlength(handle, length);
}
    44c5:	5d                   	pop    %rbp
    44c6:	c3                   	retq   
    44c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    44ce:	00 00 
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(handle);

    if (!ops || !ops->setlength)
        return -PAL_ERROR_NOTSUPPORT;
    44d0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

    return ops->setlength(handle, length);
}
    44d5:	5d                   	pop    %rbp
    44d6:	c3                   	retq   
    44d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    44de:	00 00 

00000000000044e0 <DkStreamSetLength>:

/* PAL call DkStreamSetLength: Truncate the stream at certain length.
   Return the length if succeeded or 0 if failed. Error code is notified. */
PAL_NUM
DkStreamSetLength (PAL_HANDLE handle, PAL_NUM length)
{
    44e0:	55                   	push   %rbp
    44e1:	48 89 e5             	mov    %rsp,%rbp
    44e4:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    44e8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    44ec:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    44f3:	00 
    frame->retval = NULL;
    44f4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    44fb:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    44fc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    4500:	48 8b 05 e9 f4 21 00 	mov    0x21f4e9(%rip),%rax        # 2239f0 <_DYNAMIC+0x208>
    4507:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    450b:	48 8d 05 03 42 01 00 	lea    0x14203(%rip),%rax        # 18715 <write_config+0x165>
    4512:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4516:	48 89 e0             	mov    %rsp,%rax
    4519:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    451d:	48 89 e8             	mov    %rbp,%rax
    4520:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4524:	48 89 d8             	mov    %rbx,%rax
    4527:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    452b:	48 89 f0             	mov    %rsi,%rax
    452e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4532:	48 89 f8             	mov    %rdi,%rax
    4535:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4539:	4c 89 e0             	mov    %r12,%rax
    453c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    4540:	4c 89 e8             	mov    %r13,%rax
    4543:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    4547:	4c 89 f0             	mov    %r14,%rax
    454a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    454e:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamSetLength);

    if (!handle) {
    4551:	48 85 ff             	test   %rdi,%rdi
    4554:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    4558:	74 26                	je     4580 <DkStreamSetLength+0xa0>
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkStreamSetLength(handle, length);
    455a:	e8 31 ff ff ff       	callq  4490 <_DkStreamSetLength>
    455f:	48 98                	cltq   

    if (ret < 0) {
    4561:	85 c0                	test   %eax,%eax
    if (!handle) {
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkStreamSetLength(handle, length);
    4563:	48 89 c7             	mov    %rax,%rdi

    if (ret < 0) {
    4566:	78 08                	js     4570 <DkStreamSetLength+0x90>
        notify_failure(-ret);
        return 0;
    }

    return ret;
}
    4568:	c9                   	leaveq 
    4569:	c3                   	retq   
    456a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    }

    int ret = _DkStreamSetLength(handle, length);

    if (ret < 0) {
        notify_failure(-ret);
    4570:	f7 df                	neg    %edi
    4572:	48 63 ff             	movslq %edi,%rdi
    4575:	e8 d6 08 01 00       	callq  14e50 <notify_failure>
        return 0;
    457a:	31 c0                	xor    %eax,%eax
    }

    return ret;
}
    457c:	c9                   	leaveq 
    457d:	c3                   	retq   
    457e:	66 90                	xchg   %ax,%ax
DkStreamSetLength (PAL_HANDLE handle, PAL_NUM length)
{
    store_frame(StreamSetLength);

    if (!handle) {
        notify_failure(PAL_ERROR_INVAL);
    4580:	40 b7 04             	mov    $0x4,%dil
    4583:	e8 c8 08 01 00       	callq  14e50 <notify_failure>
        return 0;
    4588:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        return 0;
    }

    return ret;
}
    458a:	c9                   	leaveq 
    458b:	c3                   	retq   
    458c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000004590 <_DkStreamFlush>:

/* _DkStreamFlush for internal use. This function sync up the handle with
   devices. Some streams may not support this operations. */
int _DkStreamFlush (PAL_HANDLE handle)
{
    4590:	48 63 07             	movslq (%rdi),%rax
    4593:	55                   	push   %rbp
    4594:	48 89 e5             	mov    %rsp,%rbp
    if (UNKNOWN_HANDLE(handle))
    4597:	8d 50 ff             	lea    -0x1(%rax),%edx
    459a:	83 fa 10             	cmp    $0x10,%edx
    459d:	77 21                	ja     45c0 <_DkStreamFlush+0x30>
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(handle);
    459f:	48 8b 15 5a f4 21 00 	mov    0x21f45a(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
    45a6:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax

    if (!ops || !ops->flush)
    45aa:	48 85 c0             	test   %rax,%rax
    45ad:	74 21                	je     45d0 <_DkStreamFlush+0x40>
    45af:	48 8b 40 58          	mov    0x58(%rax),%rax
    45b3:	48 85 c0             	test   %rax,%rax
    45b6:	74 18                	je     45d0 <_DkStreamFlush+0x40>
        return -PAL_ERROR_NOTSUPPORT;

    return ops->flush(handle);
}
    45b8:	5d                   	pop    %rbp
    const struct handle_ops * ops = HANDLE_OPS(handle);

    if (!ops || !ops->flush)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->flush(handle);
    45b9:	ff e0                	jmpq   *%rax
    45bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
/* _DkStreamFlush for internal use. This function sync up the handle with
   devices. Some streams may not support this operations. */
int _DkStreamFlush (PAL_HANDLE handle)
{
    if (UNKNOWN_HANDLE(handle))
        return -PAL_ERROR_BADHANDLE;
    45c0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

    if (!ops || !ops->flush)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->flush(handle);
}
    45c5:	5d                   	pop    %rbp
    45c6:	c3                   	retq   
    45c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    45ce:	00 00 
        return -PAL_ERROR_BADHANDLE;

    const struct handle_ops * ops = HANDLE_OPS(handle);

    if (!ops || !ops->flush)
        return -PAL_ERROR_NOTSUPPORT;
    45d0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

    return ops->flush(handle);
}
    45d5:	5d                   	pop    %rbp
    45d6:	c3                   	retq   
    45d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    45de:	00 00 

00000000000045e0 <DkStreamFlush>:

/* PAL call DkStreamFlush: Sync up a stream of a given handle. No return
   value. Error code is notified. */
PAL_BOL DkStreamFlush (PAL_HANDLE handle)
{
    45e0:	55                   	push   %rbp
    45e1:	48 89 e5             	mov    %rsp,%rbp
    45e4:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    45e8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    45ec:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    45f3:	00 
    frame->retval = NULL;
    45f4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    45fb:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    45fc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    4600:	48 8b 05 59 f5 21 00 	mov    0x21f559(%rip),%rax        # 223b60 <_DYNAMIC+0x378>
    4607:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    460b:	48 8d 05 15 41 01 00 	lea    0x14115(%rip),%rax        # 18727 <write_config+0x177>
    4612:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4616:	48 89 e0             	mov    %rsp,%rax
    4619:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    461d:	48 89 e8             	mov    %rbp,%rax
    4620:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4624:	48 89 d8             	mov    %rbx,%rax
    4627:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    462b:	48 89 f0             	mov    %rsi,%rax
    462e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4632:	48 89 f8             	mov    %rdi,%rax
    4635:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4639:	4c 89 e0             	mov    %r12,%rax
    463c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    4640:	4c 89 e8             	mov    %r13,%rax
    4643:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    4647:	4c 89 f0             	mov    %r14,%rax
    464a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    464e:	4c 89 f8             	mov    %r15,%rax
    store_frame(StreamFlush);

    if (!handle) {
    4651:	48 85 ff             	test   %rdi,%rdi
    4654:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    4658:	74 26                	je     4680 <DkStreamFlush+0xa0>
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    int ret = _DkStreamFlush(handle);
    465a:	e8 31 ff ff ff       	callq  4590 <_DkStreamFlush>
    465f:	89 c7                	mov    %eax,%edi
    if (ret < 0) {
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    4661:	b8 01 00 00 00       	mov    $0x1,%eax
        return PAL_FALSE;
    }

    int ret = _DkStreamFlush(handle);

    if (ret < 0) {
    4666:	85 ff                	test   %edi,%edi
    4668:	78 06                	js     4670 <DkStreamFlush+0x90>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    466a:	c9                   	leaveq 
    466b:	c3                   	retq   
    466c:	0f 1f 40 00          	nopl   0x0(%rax)
    }

    int ret = _DkStreamFlush(handle);

    if (ret < 0) {
        notify_failure(-ret);
    4670:	f7 df                	neg    %edi
    4672:	48 63 ff             	movslq %edi,%rdi
    4675:	e8 d6 07 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    467a:	31 c0                	xor    %eax,%eax
    }

    return PAL_TRUE;
}
    467c:	c9                   	leaveq 
    467d:	c3                   	retq   
    467e:	66 90                	xchg   %ax,%ax
PAL_BOL DkStreamFlush (PAL_HANDLE handle)
{
    store_frame(StreamFlush);

    if (!handle) {
        notify_failure(PAL_ERROR_INVAL);
    4680:	40 b7 04             	mov    $0x4,%dil
    4683:	e8 c8 07 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    4688:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    468a:	c9                   	leaveq 
    468b:	c3                   	retq   
    468c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000004690 <DkStreamChangeName>:

    return remalloc(&cargo, handle_size(&cargo));
}

PAL_BOL DkStreamChangeName (PAL_HANDLE hdl, PAL_STR uri)
{
    4690:	55                   	push   %rbp
    4691:	48 89 e5             	mov    %rsp,%rbp
    4694:	41 54                	push   %r12
    4696:	53                   	push   %rbx
    4697:	49 89 fc             	mov    %rdi,%r12
    469a:	48 83 ec 20          	sub    $0x20,%rsp
    struct handle_ops * ops = NULL;
    const char * type = NULL;
    int ret;

    if (uri) {
    469e:	48 85 f6             	test   %rsi,%rsi

    return remalloc(&cargo, handle_size(&cargo));
}

PAL_BOL DkStreamChangeName (PAL_HANDLE hdl, PAL_STR uri)
{
    46a1:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
    struct handle_ops * ops = NULL;
    46a5:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    46ac:	00 
    const char * type = NULL;
    46ad:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    46b4:	00 
    int ret;

    if (uri) {
    46b5:	74 15                	je     46cc <DkStreamChangeName+0x3c>
        ret = parse_stream_uri(&uri, &type, &ops);
    46b7:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
    46bb:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
    46bf:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
    46c3:	e8 48 f0 ff ff       	callq  3710 <parse_stream_uri>

        if (ret < 0) {
    46c8:	85 c0                	test   %eax,%eax
    46ca:	78 75                	js     4741 <DkStreamChangeName+0xb1>
            notify_failure(-ret);
            return PAL_FALSE;
        }
    }

    const struct handle_ops * hops = HANDLE_OPS(hdl);
    46cc:	49 63 04 24          	movslq (%r12),%rax
    46d0:	8d 50 ff             	lea    -0x1(%rax),%edx
    46d3:	83 fa 10             	cmp    $0x10,%edx
    46d6:	77 30                	ja     4708 <DkStreamChangeName+0x78>
    46d8:	48 8b 15 21 f3 21 00 	mov    0x21f321(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
    46df:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax

    if (!hops || !hops->rename || (ops && hops != ops)) {
    46e3:	48 85 c0             	test   %rax,%rax
    46e6:	74 20                	je     4708 <DkStreamChangeName+0x78>
    46e8:	48 8b 88 88 00 00 00 	mov    0x88(%rax),%rcx
    46ef:	48 85 c9             	test   %rcx,%rcx
    46f2:	74 14                	je     4708 <DkStreamChangeName+0x78>
    46f4:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
    46f8:	48 39 d0             	cmp    %rdx,%rax
    46fb:	0f 95 c3             	setne  %bl
    46fe:	48 85 d2             	test   %rdx,%rdx
    4701:	0f 95 c0             	setne  %al
    4704:	20 c3                	and    %al,%bl
    4706:	74 18                	je     4720 <DkStreamChangeName+0x90>
        notify_failure(PAL_ERROR_NOTSUPPORT);
    4708:	bf 03 00 00 00       	mov    $0x3,%edi
        return PAL_FALSE;
    470d:	31 db                	xor    %ebx,%ebx
    }

    const struct handle_ops * hops = HANDLE_OPS(hdl);

    if (!hops || !hops->rename || (ops && hops != ops)) {
        notify_failure(PAL_ERROR_NOTSUPPORT);
    470f:	e8 3c 07 01 00       	callq  14e50 <notify_failure>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    4714:	48 83 c4 20          	add    $0x20,%rsp
    4718:	89 d8                	mov    %ebx,%eax
    471a:	5b                   	pop    %rbx
    471b:	41 5c                	pop    %r12
    471d:	5d                   	pop    %rbp
    471e:	c3                   	retq   
    471f:	90                   	nop    
    if (!hops || !hops->rename || (ops && hops != ops)) {
        notify_failure(PAL_ERROR_NOTSUPPORT);
        return PAL_FALSE;
    }

    ret = hops->rename(hdl, type, uri);
    4720:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    4724:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
    4728:	4c 89 e7             	mov    %r12,%rdi
    472b:	ff d1                	callq  *%rcx

    if (ret < 0) {
    472d:	85 c0                	test   %eax,%eax
    472f:	78 1f                	js     4750 <DkStreamChangeName+0xc0>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    4731:	48 83 c4 20          	add    $0x20,%rsp
    if (ret < 0) {
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    4735:	bb 01 00 00 00       	mov    $0x1,%ebx
}
    473a:	89 d8                	mov    %ebx,%eax
    473c:	5b                   	pop    %rbx
    473d:	41 5c                	pop    %r12
    473f:	5d                   	pop    %rbp
    4740:	c3                   	retq   

    if (uri) {
        ret = parse_stream_uri(&uri, &type, &ops);

        if (ret < 0) {
            notify_failure(-ret);
    4741:	f7 d8                	neg    %eax
            return PAL_FALSE;
    4743:	31 db                	xor    %ebx,%ebx

    if (uri) {
        ret = parse_stream_uri(&uri, &type, &ops);

        if (ret < 0) {
            notify_failure(-ret);
    4745:	48 63 f8             	movslq %eax,%rdi
    4748:	e8 03 07 01 00       	callq  14e50 <notify_failure>
            return PAL_FALSE;
    474d:	eb c5                	jmp    4714 <DkStreamChangeName+0x84>
    474f:	90                   	nop    
    }

    ret = hops->rename(hdl, type, uri);

    if (ret < 0) {
        notify_failure(-ret);
    4750:	f7 d8                	neg    %eax
    4752:	48 63 f8             	movslq %eax,%rdi
    4755:	e8 f6 06 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    475a:	eb b8                	jmp    4714 <DkStreamChangeName+0x84>
    475c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000004760 <_DkStreamRealpath>:
}

/* _DkStreamRealpath is used to obtain the real path of a stream. Some
   streams may not have a real path. */
const char * _DkStreamRealpath (PAL_HANDLE hdl)
{
    4760:	48 63 07             	movslq (%rdi),%rax
    4763:	55                   	push   %rbp
    4764:	48 89 e5             	mov    %rsp,%rbp
    const struct handle_ops * ops = HANDLE_OPS(hdl);
    4767:	8d 50 ff             	lea    -0x1(%rax),%edx
    476a:	83 fa 10             	cmp    $0x10,%edx
    476d:	76 04                	jbe    4773 <_DkStreamRealpath+0x13>

    if (!ops || !ops->getrealpath)
        return NULL;

    return ops->getrealpath(hdl);
}
    476f:	31 c0                	xor    %eax,%eax
    4771:	5d                   	pop    %rbp
    4772:	c3                   	retq   

/* _DkStreamRealpath is used to obtain the real path of a stream. Some
   streams may not have a real path. */
const char * _DkStreamRealpath (PAL_HANDLE hdl)
{
    const struct handle_ops * ops = HANDLE_OPS(hdl);
    4773:	48 8b 15 86 f2 21 00 	mov    0x21f286(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
    477a:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax

    if (!ops || !ops->getrealpath)
    477e:	48 85 c0             	test   %rax,%rax
    4781:	74 ec                	je     476f <_DkStreamRealpath+0xf>
    4783:	48 8b 00             	mov    (%rax),%rax
    4786:	48 85 c0             	test   %rax,%rax
    4789:	74 e4                	je     476f <_DkStreamRealpath+0xf>
        return NULL;

    return ops->getrealpath(hdl);
}
    478b:	5d                   	pop    %rbp
    const struct handle_ops * ops = HANDLE_OPS(hdl);

    if (!ops || !ops->getrealpath)
        return NULL;

    return ops->getrealpath(hdl);
    478c:	ff e0                	jmpq   *%rax
    478e:	90                   	nop    
    478f:	90                   	nop    

0000000000004790 <check_memory_overlap>:
#include "pal_error.h"
#include "pal_debug.h"
#include "api.h"

bool check_memory_overlap (void * addr, size_t size)
{
    4790:	48 8b 05 89 f2 21 00 	mov    0x21f289(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
    void * pal_min = pal_config.lib_text_start;
    void * pal_max = pal_config.lib_data_end;

    void * overlap_start = pal_min < addr ? addr : pal_min;
    4797:	48 8b 50 58          	mov    0x58(%rax),%rdx
    void * overlap_end = addr + size < pal_max ? addr + size : pal_max;
    479b:	48 8b 40 70          	mov    0x70(%rax),%rax
bool check_memory_overlap (void * addr, size_t size)
{
    void * pal_min = pal_config.lib_text_start;
    void * pal_max = pal_config.lib_data_end;

    void * overlap_start = pal_min < addr ? addr : pal_min;
    479f:	48 39 d7             	cmp    %rdx,%rdi
    47a2:	48 0f 43 d7          	cmovae %rdi,%rdx
    void * overlap_end = addr + size < pal_max ? addr + size : pal_max;
    47a6:	48 01 fe             	add    %rdi,%rsi
    47a9:	48 39 f0             	cmp    %rsi,%rax
    47ac:	48 0f 42 f0          	cmovb  %rax,%rsi
    if (overlap_start < overlap_end) {
        printf("WARNING: Attempt to change PAL-internal memory!!!!"
               "   You seriously don't want to do this.\n");
        return true;
    }
    return false;
    47b0:	31 c0                	xor    %eax,%eax
    void * pal_max = pal_config.lib_data_end;

    void * overlap_start = pal_min < addr ? addr : pal_min;
    void * overlap_end = addr + size < pal_max ? addr + size : pal_max;

    if (overlap_start < overlap_end) {
    47b2:	48 39 f2             	cmp    %rsi,%rdx
    47b5:	72 09                	jb     47c0 <check_memory_overlap+0x30>
        printf("WARNING: Attempt to change PAL-internal memory!!!!"
               "   You seriously don't want to do this.\n");
        return true;
    }
    return false;
}
    47b7:	c3                   	retq   
    47b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    47bf:	00 
#include "pal_error.h"
#include "pal_debug.h"
#include "api.h"

bool check_memory_overlap (void * addr, size_t size)
{
    47c0:	55                   	push   %rbp

    void * overlap_start = pal_min < addr ? addr : pal_min;
    void * overlap_end = addr + size < pal_max ? addr + size : pal_max;

    if (overlap_start < overlap_end) {
        printf("WARNING: Attempt to change PAL-internal memory!!!!"
    47c1:	48 8d 3d 00 40 01 00 	lea    0x14000(%rip),%rdi        # 187c8 <handle_sizes.1924+0x48>
#include "pal_error.h"
#include "pal_debug.h"
#include "api.h"

bool check_memory_overlap (void * addr, size_t size)
{
    47c8:	48 89 e5             	mov    %rsp,%rbp

    void * overlap_start = pal_min < addr ? addr : pal_min;
    void * overlap_end = addr + size < pal_max ? addr + size : pal_max;

    if (overlap_start < overlap_end) {
        printf("WARNING: Attempt to change PAL-internal memory!!!!"
    47cb:	e8 50 46 00 00       	callq  8e20 <pal_printf>
               "   You seriously don't want to do this.\n");
        return true;
    47d0:	b8 01 00 00 00       	mov    $0x1,%eax
    }
    return false;
}
    47d5:	5d                   	pop    %rbp
    47d6:	c3                   	retq   
    47d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    47de:	00 00 

00000000000047e0 <DkVirtualMemoryAlloc>:

PAL_BUF
DkVirtualMemoryAlloc (PAL_BUF addr, PAL_NUM size, PAL_FLG alloc_type,
                      PAL_FLG prot)
{
    47e0:	55                   	push   %rbp
    47e1:	48 89 e5             	mov    %rsp,%rbp
    47e4:	53                   	push   %rbx
    47e5:	48 89 f3             	mov    %rsi,%rbx

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    47e8:	48 8d 45 80          	lea    -0x80(%rbp),%rax
    47ec:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    47f3:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    47fa:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    4801:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4802:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->func = func;
    4806:	48 8b 05 63 f3 21 00 	mov    0x21f363(%rip),%rax        # 223b70 <_DYNAMIC+0x388>
    frame->funcname = funcname;
    frame->context = NULL;
    frame->retval = NULL;
    480d:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    4814:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    4815:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    frame->funcname = funcname;
    4819:	48 8d 05 03 40 01 00 	lea    0x14003(%rip),%rax        # 18823 <handle_sizes.1924+0xa3>
    4820:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4824:	48 89 e0             	mov    %rsp,%rax
    4827:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    482b:	48 89 e8             	mov    %rbp,%rax
    482e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    4832:	48 89 d8             	mov    %rbx,%rax
    4835:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4839:	48 89 f0             	mov    %rsi,%rax
    483c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4840:	48 89 f8             	mov    %rdi,%rax
    4843:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4847:	4c 89 e0             	mov    %r12,%rax
    484a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    484e:	4c 89 e8             	mov    %r13,%rax
    4851:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4855:	4c 89 f0             	mov    %r14,%rax
    4858:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    485c:	4c 89 f8             	mov    %r15,%rax
    store_frame(VirtualMemoryAlloc);

    if ((addr && !ALLOC_ALIGNED(addr)) || !size || !ALLOC_ALIGNED(size)) {
    485f:	48 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%rdi
    4866:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    486a:	48 85 ff             	test   %rdi,%rdi
    486d:	0f 84 9d 00 00 00    	je     4910 <DkVirtualMemoryAlloc+0x130>
    4873:	48 8b 05 16 f1 21 00 	mov    0x21f116(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
    487a:	48 83 38 00          	cmpq   $0x0,(%rax)
    487e:	74 70                	je     48f0 <DkVirtualMemoryAlloc+0x110>
    4880:	48 8b 05 71 f2 21 00 	mov    0x21f271(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    4887:	48 89 fe             	mov    %rdi,%rsi
    488a:	48 8b 00             	mov    (%rax),%rax
    488d:	48 21 c6             	and    %rax,%rsi
    4890:	48 39 f7             	cmp    %rsi,%rdi
    4893:	75 5b                	jne    48f0 <DkVirtualMemoryAlloc+0x110>
    4895:	48 85 db             	test   %rbx,%rbx
    4898:	74 56                	je     48f0 <DkVirtualMemoryAlloc+0x110>
    489a:	48 21 d8             	and    %rbx,%rax
    489d:	48 39 d8             	cmp    %rbx,%rax
    48a0:	75 4e                	jne    48f0 <DkVirtualMemoryAlloc+0x110>
        notify_failure(PAL_ERROR_INVAL);
        return NULL;
    }

    if (check_memory_overlap(addr, size)) {
    48a2:	48 89 de             	mov    %rbx,%rsi
    48a5:	89 8d 70 ff ff ff    	mov    %ecx,-0x90(%rbp)
    48ab:	89 95 74 ff ff ff    	mov    %edx,-0x8c(%rbp)
    48b1:	e8 da fe ff ff       	callq  4790 <check_memory_overlap>
    48b6:	84 c0                	test   %al,%al
    48b8:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
    48be:	8b 8d 70 ff ff ff    	mov    -0x90(%rbp),%ecx
    48c4:	75 6b                	jne    4931 <DkVirtualMemoryAlloc+0x151>
        notify_failure(PAL_ERROR_DENIED);
        return NULL;
    }

    int ret = _DkVirtualMemoryAlloc(&addr, size, alloc_type, prot);
    48c6:	48 8d bd 78 ff ff ff 	lea    -0x88(%rbp),%rdi
    48cd:	48 89 de             	mov    %rbx,%rsi
    48d0:	e8 bb b8 00 00       	callq  10190 <_DkVirtualMemoryAlloc>

    if (ret < 0) {
    48d5:	85 c0                	test   %eax,%eax
    48d7:	78 66                	js     493f <DkVirtualMemoryAlloc+0x15f>
        notify_failure(-ret);
        return NULL;
    }

    return addr;
    48d9:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
}
    48e0:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    48e7:	5b                   	pop    %rbx
    48e8:	5d                   	pop    %rbp
    48e9:	c3                   	retq   
    48ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                      PAL_FLG prot)
{
    store_frame(VirtualMemoryAlloc);

    if ((addr && !ALLOC_ALIGNED(addr)) || !size || !ALLOC_ALIGNED(size)) {
        notify_failure(PAL_ERROR_INVAL);
    48f0:	bf 04 00 00 00       	mov    $0x4,%edi
    48f5:	e8 56 05 01 00       	callq  14e50 <notify_failure>
        return NULL;
    48fa:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        return NULL;
    }

    return addr;
}
    48fc:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    4903:	5b                   	pop    %rbx
    4904:	5d                   	pop    %rbp
    4905:	c3                   	retq   
    4906:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    490d:	00 00 00 
DkVirtualMemoryAlloc (PAL_BUF addr, PAL_NUM size, PAL_FLG alloc_type,
                      PAL_FLG prot)
{
    store_frame(VirtualMemoryAlloc);

    if ((addr && !ALLOC_ALIGNED(addr)) || !size || !ALLOC_ALIGNED(size)) {
    4910:	48 85 f6             	test   %rsi,%rsi
    4913:	74 db                	je     48f0 <DkVirtualMemoryAlloc+0x110>
    4915:	48 8b 05 74 f0 21 00 	mov    0x21f074(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
    491c:	48 83 38 00          	cmpq   $0x0,(%rax)
    4920:	74 ce                	je     48f0 <DkVirtualMemoryAlloc+0x110>
    4922:	48 8b 05 cf f1 21 00 	mov    0x21f1cf(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    4929:	48 8b 00             	mov    (%rax),%rax
    492c:	e9 69 ff ff ff       	jmpq   489a <DkVirtualMemoryAlloc+0xba>
        notify_failure(PAL_ERROR_INVAL);
        return NULL;
    }

    if (check_memory_overlap(addr, size)) {
        notify_failure(PAL_ERROR_DENIED);
    4931:	bf 06 00 00 00       	mov    $0x6,%edi
    4936:	e8 15 05 01 00       	callq  14e50 <notify_failure>
        return NULL;
    493b:	31 c0                	xor    %eax,%eax
    493d:	eb bd                	jmp    48fc <DkVirtualMemoryAlloc+0x11c>
    }

    int ret = _DkVirtualMemoryAlloc(&addr, size, alloc_type, prot);

    if (ret < 0) {
        notify_failure(-ret);
    493f:	f7 d8                	neg    %eax
    4941:	48 63 f8             	movslq %eax,%rdi
    4944:	e8 07 05 01 00       	callq  14e50 <notify_failure>
        return NULL;
    4949:	31 c0                	xor    %eax,%eax
    494b:	eb af                	jmp    48fc <DkVirtualMemoryAlloc+0x11c>
    494d:	0f 1f 00             	nopl   (%rax)

0000000000004950 <DkVirtualMemoryFree>:
    return addr;
}

void
DkVirtualMemoryFree (PAL_BUF addr, PAL_NUM size)
{
    4950:	55                   	push   %rbp
    4951:	48 89 e5             	mov    %rsp,%rbp
    4954:	41 54                	push   %r12
    4956:	53                   	push   %rbx

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4957:	48 8d 45 80          	lea    -0x80(%rbp),%rax
    495b:	48 83 ec 70          	sub    $0x70,%rsp
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    495f:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    4966:	00 
    frame->retval = NULL;
    4967:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    496e:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    496f:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->func = func;
    4973:	48 8b 05 be f0 21 00 	mov    0x21f0be(%rip),%rax        # 223a38 <_DYNAMIC+0x250>
    497a:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    frame->funcname = funcname;
    497e:	48 8d 05 b3 3e 01 00 	lea    0x13eb3(%rip),%rax        # 18838 <handle_sizes.1924+0xb8>
    4985:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4989:	48 89 e0             	mov    %rsp,%rax
    498c:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    4990:	48 89 e8             	mov    %rbp,%rax
    4993:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    4997:	48 89 d8             	mov    %rbx,%rax
    499a:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    499e:	48 89 f0             	mov    %rsi,%rax
    49a1:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    49a5:	48 89 f8             	mov    %rdi,%rax
    49a8:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    49ac:	4c 89 e0             	mov    %r12,%rax
    49af:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    49b3:	4c 89 e8             	mov    %r13,%rax
    49b6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    49ba:	4c 89 f0             	mov    %r14,%rax
    49bd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    49c1:	4c 89 f8             	mov    %r15,%rax
    store_frame(VirtualMemoryFree);

    if (!addr || !size) {
    49c4:	48 85 ff             	test   %rdi,%rdi
    49c7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    49cb:	74 27                	je     49f4 <DkVirtualMemoryFree+0xa4>
    49cd:	48 85 f6             	test   %rsi,%rsi
    49d0:	74 22                	je     49f4 <DkVirtualMemoryFree+0xa4>
        notify_failure(PAL_ERROR_INVAL);
        return;
    }

    if (!ALLOC_ALIGNED(addr) || !ALLOC_ALIGNED(size)) {
    49d2:	48 8b 05 b7 ef 21 00 	mov    0x21efb7(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
    49d9:	48 83 38 00          	cmpq   $0x0,(%rax)
    49dd:	74 15                	je     49f4 <DkVirtualMemoryFree+0xa4>
    49df:	48 8b 05 12 f1 21 00 	mov    0x21f112(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    49e6:	48 89 fa             	mov    %rdi,%rdx
    49e9:	48 8b 00             	mov    (%rax),%rax
    49ec:	48 21 c2             	and    %rax,%rdx
    49ef:	48 39 d7             	cmp    %rdx,%rdi
    49f2:	74 1c                	je     4a10 <DkVirtualMemoryFree+0xc0>
DkVirtualMemoryFree (PAL_BUF addr, PAL_NUM size)
{
    store_frame(VirtualMemoryFree);

    if (!addr || !size) {
        notify_failure(PAL_ERROR_INVAL);
    49f4:	bf 04 00 00 00       	mov    $0x4,%edi
    }

    int ret = _DkVirtualMemoryFree(addr, size);
    if (ret < 0)
        notify_failure(-ret);
}
    49f9:	48 83 c4 70          	add    $0x70,%rsp
    49fd:	5b                   	pop    %rbx
    49fe:	41 5c                	pop    %r12
    4a00:	5d                   	pop    %rbp
        return;
    }

    int ret = _DkVirtualMemoryFree(addr, size);
    if (ret < 0)
        notify_failure(-ret);
    4a01:	e9 4a 04 01 00       	jmpq   14e50 <notify_failure>
    4a06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    4a0d:	00 00 00 
    if (!addr || !size) {
        notify_failure(PAL_ERROR_INVAL);
        return;
    }

    if (!ALLOC_ALIGNED(addr) || !ALLOC_ALIGNED(size)) {
    4a10:	48 21 f0             	and    %rsi,%rax
    4a13:	48 39 f0             	cmp    %rsi,%rax
    4a16:	49 89 c4             	mov    %rax,%r12
    4a19:	75 d9                	jne    49f4 <DkVirtualMemoryFree+0xa4>
        notify_failure(PAL_ERROR_INVAL);
        return;
    }

    if (check_memory_overlap(addr, size)) {
    4a1b:	48 89 c6             	mov    %rax,%rsi
    4a1e:	48 89 fb             	mov    %rdi,%rbx
    4a21:	e8 6a fd ff ff       	callq  4790 <check_memory_overlap>
    4a26:	84 c0                	test   %al,%al
        notify_failure(PAL_ERROR_DENIED);
    4a28:	bf 06 00 00 00       	mov    $0x6,%edi
    if (!ALLOC_ALIGNED(addr) || !ALLOC_ALIGNED(size)) {
        notify_failure(PAL_ERROR_INVAL);
        return;
    }

    if (check_memory_overlap(addr, size)) {
    4a2d:	75 ca                	jne    49f9 <DkVirtualMemoryFree+0xa9>
        notify_failure(PAL_ERROR_DENIED);
        return;
    }

    int ret = _DkVirtualMemoryFree(addr, size);
    4a2f:	4c 89 e6             	mov    %r12,%rsi
    4a32:	48 89 df             	mov    %rbx,%rdi
    4a35:	e8 d6 b8 00 00       	callq  10310 <_DkVirtualMemoryFree>
    if (ret < 0)
    4a3a:	85 c0                	test   %eax,%eax
    4a3c:	78 09                	js     4a47 <DkVirtualMemoryFree+0xf7>
        notify_failure(-ret);
}
    4a3e:	48 83 c4 70          	add    $0x70,%rsp
    4a42:	5b                   	pop    %rbx
    4a43:	41 5c                	pop    %r12
    4a45:	5d                   	pop    %rbp
    4a46:	c3                   	retq   
        return;
    }

    int ret = _DkVirtualMemoryFree(addr, size);
    if (ret < 0)
        notify_failure(-ret);
    4a47:	f7 d8                	neg    %eax
    4a49:	48 63 f8             	movslq %eax,%rdi
    4a4c:	eb ab                	jmp    49f9 <DkVirtualMemoryFree+0xa9>
    4a4e:	66 90                	xchg   %ax,%ax

0000000000004a50 <DkVirtualMemoryProtect>:
}

PAL_BOL
DkVirtualMemoryProtect (PAL_BUF addr, PAL_NUM size, PAL_FLG prot)
{
    4a50:	55                   	push   %rbp
    4a51:	48 89 e5             	mov    %rsp,%rbp
    4a54:	41 55                	push   %r13
    4a56:	41 54                	push   %r12

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4a58:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
    4a5f:	53                   	push   %rbx
    4a60:	49 89 fc             	mov    %rdi,%r12
    4a63:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    4a6a:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    frame->func = func;
    4a71:	48 8b 05 d0 ee 21 00 	mov    0x21eed0(%rip),%rax        # 223948 <_DYNAMIC+0x160>
    frame->funcname = funcname;
    frame->context = NULL;
    4a78:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    4a7f:	00 
    frame->retval = NULL;
    4a80:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    4a87:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    4a88:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    frame->funcname = funcname;
    4a8f:	48 8d 05 b6 3d 01 00 	lea    0x13db6(%rip),%rax        # 1884c <handle_sizes.1924+0xcc>
    4a96:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4a9a:	48 89 e0             	mov    %rsp,%rax
    4a9d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    4aa1:	48 89 e8             	mov    %rbp,%rax
    4aa4:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    4aa8:	48 89 d8             	mov    %rbx,%rax
    4aab:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    4aaf:	48 89 f0             	mov    %rsi,%rax
    4ab2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    4ab6:	48 89 f8             	mov    %rdi,%rax
    4ab9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4abd:	4c 89 e0             	mov    %r12,%rax
    4ac0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4ac4:	4c 89 e8             	mov    %r13,%rax
    4ac7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4acb:	4c 89 f0             	mov    %r14,%rax
    4ace:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4ad2:	4c 89 f8             	mov    %r15,%rax
    store_frame(VirtualMemoryProtect);

    if (!addr || !size) {
    4ad5:	48 85 ff             	test   %rdi,%rdi
    4ad8:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4adc:	0f 94 c3             	sete   %bl
    4adf:	48 85 f6             	test   %rsi,%rsi
    4ae2:	0f 94 c0             	sete   %al
    4ae5:	08 c3                	or     %al,%bl
    4ae7:	75 22                	jne    4b0b <DkVirtualMemoryProtect+0xbb>
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    if (!ALLOC_ALIGNED(addr) || !ALLOC_ALIGNED(size)) {
    4ae9:	48 8b 05 a0 ee 21 00 	mov    0x21eea0(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
    4af0:	48 83 38 00          	cmpq   $0x0,(%rax)
    4af4:	74 15                	je     4b0b <DkVirtualMemoryProtect+0xbb>
    4af6:	48 8b 05 fb ef 21 00 	mov    0x21effb(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    4afd:	48 89 f9             	mov    %rdi,%rcx
    4b00:	48 8b 00             	mov    (%rax),%rax
    4b03:	48 21 c1             	and    %rax,%rcx
    4b06:	48 39 cf             	cmp    %rcx,%rdi
    4b09:	74 25                	je     4b30 <DkVirtualMemoryProtect+0xe0>
DkVirtualMemoryProtect (PAL_BUF addr, PAL_NUM size, PAL_FLG prot)
{
    store_frame(VirtualMemoryProtect);

    if (!addr || !size) {
        notify_failure(PAL_ERROR_INVAL);
    4b0b:	bf 04 00 00 00       	mov    $0x4,%edi
        return PAL_FALSE;
    4b10:	31 db                	xor    %ebx,%ebx
DkVirtualMemoryProtect (PAL_BUF addr, PAL_NUM size, PAL_FLG prot)
{
    store_frame(VirtualMemoryProtect);

    if (!addr || !size) {
        notify_failure(PAL_ERROR_INVAL);
    4b12:	e8 39 03 01 00       	callq  14e50 <notify_failure>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    4b17:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    4b1e:	89 d8                	mov    %ebx,%eax
    4b20:	5b                   	pop    %rbx
    4b21:	41 5c                	pop    %r12
    4b23:	41 5d                	pop    %r13
    4b25:	5d                   	pop    %rbp
    4b26:	c3                   	retq   
    4b27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    4b2e:	00 00 
    if (!addr || !size) {
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    if (!ALLOC_ALIGNED(addr) || !ALLOC_ALIGNED(size)) {
    4b30:	48 21 f0             	and    %rsi,%rax
    4b33:	48 39 f0             	cmp    %rsi,%rax
    4b36:	49 89 c5             	mov    %rax,%r13
    4b39:	75 d0                	jne    4b0b <DkVirtualMemoryProtect+0xbb>
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    if (check_memory_overlap(addr, size)) {
    4b3b:	48 89 c6             	mov    %rax,%rsi
    4b3e:	89 95 6c ff ff ff    	mov    %edx,-0x94(%rbp)
    4b44:	e8 47 fc ff ff       	callq  4790 <check_memory_overlap>
    4b49:	84 c0                	test   %al,%al
    4b4b:	8b 95 6c ff ff ff    	mov    -0x94(%rbp),%edx
    4b51:	75 1d                	jne    4b70 <DkVirtualMemoryProtect+0x120>
        notify_failure(PAL_ERROR_DENIED);
        return NULL;
    }

    int ret = _DkVirtualMemoryProtect(addr, size, prot);
    4b53:	4c 89 ee             	mov    %r13,%rsi
    4b56:	4c 89 e7             	mov    %r12,%rdi
    4b59:	e8 c2 b8 00 00       	callq  10420 <_DkVirtualMemoryProtect>

    if (ret < 0) {
    4b5e:	85 c0                	test   %eax,%eax
    4b60:	78 1a                	js     4b7c <DkVirtualMemoryProtect+0x12c>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    4b62:	bb 01 00 00 00       	mov    $0x1,%ebx
    4b67:	eb ae                	jmp    4b17 <DkVirtualMemoryProtect+0xc7>
    4b69:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    if (check_memory_overlap(addr, size)) {
        notify_failure(PAL_ERROR_DENIED);
    4b70:	bf 06 00 00 00       	mov    $0x6,%edi
    4b75:	e8 d6 02 01 00       	callq  14e50 <notify_failure>
    4b7a:	eb 9b                	jmp    4b17 <DkVirtualMemoryProtect+0xc7>
    }

    int ret = _DkVirtualMemoryProtect(addr, size, prot);

    if (ret < 0) {
        notify_failure(-ret);
    4b7c:	f7 d8                	neg    %eax
    4b7e:	48 63 f8             	movslq %eax,%rdi
    4b81:	e8 ca 02 01 00       	callq  14e50 <notify_failure>
    4b86:	eb 8f                	jmp    4b17 <DkVirtualMemoryProtect+0xc7>
    4b88:	90                   	nop    
    4b89:	90                   	nop    
    4b8a:	90                   	nop    
    4b8b:	90                   	nop    
    4b8c:	90                   	nop    
    4b8d:	90                   	nop    
    4b8e:	90                   	nop    
    4b8f:	90                   	nop    

0000000000004b90 <DkThreadCreate>:

/* PAL call DkThreadCreate: create a thread inside the current
   process */
PAL_HANDLE
DkThreadCreate (PAL_PTR addr, PAL_PTR param, PAL_FLG flags)
{
    4b90:	55                   	push   %rbp
    4b91:	48 89 f8             	mov    %rdi,%rax
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    frame->funcname = funcname;
    4b94:	48 8d 3d c8 3c 01 00 	lea    0x13cc8(%rip),%rdi        # 18863 <handle_sizes.1924+0xe3>
    4b9b:	48 89 e5             	mov    %rsp,%rbp
    4b9e:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4ba2:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
    frame->func = func;
    frame->funcname = funcname;
    4ba6:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
    frame->context = NULL;
    4baa:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    4bb1:	00 
    frame->retval = NULL;
    4bb2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    4bb9:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4bba:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
    frame->func = func;
    4bbe:	48 8b 0d d3 ed 21 00 	mov    0x21edd3(%rip),%rcx        # 223998 <_DYNAMIC+0x1b0>
    4bc5:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
    frame->funcname = funcname;
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4bc9:	48 89 e1             	mov    %rsp,%rcx
    4bcc:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
    4bd0:	48 89 e9             	mov    %rbp,%rcx
    4bd3:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    4bd7:	48 89 d9             	mov    %rbx,%rcx
    4bda:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    4bde:	48 89 f1             	mov    %rsi,%rcx
    4be1:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    4be5:	48 89 f9             	mov    %rdi,%rcx
    4be8:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
    4bec:	4c 89 e1             	mov    %r12,%rcx
    4bef:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    4bf3:	4c 89 e9             	mov    %r13,%rcx
    4bf6:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    4bfa:	4c 89 f1             	mov    %r14,%rcx
    4bfd:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
    4c01:	4c 89 f9             	mov    %r15,%rcx
    store_frame(ThreadCreate);

    PAL_HANDLE handle = NULL;
    int ret = _DkThreadCreate (&handle, (int (*)(void *)) addr,
    4c04:	48 8d 7d 88          	lea    -0x78(%rbp),%rdi
    4c08:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
    4c0c:	89 d1                	mov    %edx,%ecx
    4c0e:	48 89 f2             	mov    %rsi,%rdx
    4c11:	48 89 c6             	mov    %rax,%rsi
PAL_HANDLE
DkThreadCreate (PAL_PTR addr, PAL_PTR param, PAL_FLG flags)
{
    store_frame(ThreadCreate);

    PAL_HANDLE handle = NULL;
    4c14:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    4c1b:	00 
    int ret = _DkThreadCreate (&handle, (int (*)(void *)) addr,
    4c1c:	e8 af ba 00 00       	callq  106d0 <_DkThreadCreate>
                               param, flags);
    if (ret < 0) {
    4c21:	85 c0                	test   %eax,%eax
    4c23:	78 0b                	js     4c30 <DkThreadCreate+0xa0>
        notify_failure (-ret);
        return NULL;
    }

    return handle;
    4c25:	48 8b 45 88          	mov    -0x78(%rbp),%rax
}
    4c29:	c9                   	leaveq 
    4c2a:	c3                   	retq   
    4c2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

    PAL_HANDLE handle = NULL;
    int ret = _DkThreadCreate (&handle, (int (*)(void *)) addr,
                               param, flags);
    if (ret < 0) {
        notify_failure (-ret);
    4c30:	f7 d8                	neg    %eax
    4c32:	48 63 f8             	movslq %eax,%rdi
    4c35:	e8 16 02 01 00       	callq  14e50 <notify_failure>
        return NULL;
    4c3a:	31 c0                	xor    %eax,%eax
    }

    return handle;
}
    4c3c:	c9                   	leaveq 
    4c3d:	c3                   	retq   
    4c3e:	66 90                	xchg   %ax,%ax

0000000000004c40 <DkThreadDelayExecution>:

/* PAL call DkThreadDelayExecution. Delay the current thread
   (sleep) for the given duration */
PAL_NUM
DkThreadDelayExecution (PAL_NUM duration)
{
    4c40:	55                   	push   %rbp
    4c41:	48 89 e5             	mov    %rsp,%rbp
    4c44:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4c48:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    4c4c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    4c53:	00 
    frame->retval = NULL;
    4c54:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    4c5b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4c5c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    4c60:	48 8b 05 51 ed 21 00 	mov    0x21ed51(%rip),%rax        # 2239b8 <_DYNAMIC+0x1d0>
    4c67:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    4c6b:	48 8d 05 00 3c 01 00 	lea    0x13c00(%rip),%rax        # 18872 <handle_sizes.1924+0xf2>
    4c72:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4c76:	48 89 e0             	mov    %rsp,%rax
    4c79:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4c7d:	48 89 e8             	mov    %rbp,%rax
    4c80:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4c84:	48 89 d8             	mov    %rbx,%rax
    4c87:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4c8b:	48 89 f0             	mov    %rsi,%rax
    4c8e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4c92:	48 89 f8             	mov    %rdi,%rax
    4c95:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4c99:	4c 89 e0             	mov    %r12,%rax
    4c9c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    4ca0:	4c 89 e8             	mov    %r13,%rax
    4ca3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    4ca7:	4c 89 f0             	mov    %r14,%rax
    4caa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    4cae:	4c 89 f8             	mov    %r15,%rax
    store_frame(ThreadDelayExecution);

    unsigned long dur = duration;
    4cb1:	48 89 7d 88          	mov    %rdi,-0x78(%rbp)
    int ret = _DkThreadDelayExecution(&dur);
    4cb5:	48 8d 7d 88          	lea    -0x78(%rbp),%rdi
    4cb9:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    4cbd:	e8 1e b9 00 00       	callq  105e0 <_DkThreadDelayExecution>

    if (ret < 0)
    4cc2:	85 c0                	test   %eax,%eax
    4cc4:	78 0a                	js     4cd0 <DkThreadDelayExecution+0x90>
        notify_failure(PAL_ERROR_INTERRUPTED);

    return dur;
}
    4cc6:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    4cca:	c9                   	leaveq 
    4ccb:	c3                   	retq   
    4ccc:	0f 1f 40 00          	nopl   0x0(%rax)

    unsigned long dur = duration;
    int ret = _DkThreadDelayExecution(&dur);

    if (ret < 0)
        notify_failure(PAL_ERROR_INTERRUPTED);
    4cd0:	bf 0d 00 00 00       	mov    $0xd,%edi
    4cd5:	e8 76 01 01 00       	callq  14e50 <notify_failure>

    return dur;
}
    4cda:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    4cde:	c9                   	leaveq 
    4cdf:	c3                   	retq   

0000000000004ce0 <DkThreadExit>:
}

/* PAL call DkThreadExit: simply exit the current thread
   no matter what */
void DkThreadExit (void)
{
    4ce0:	55                   	push   %rbp
    4ce1:	48 89 e5             	mov    %rsp,%rbp
    4ce4:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4ce8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    4cec:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    4cf3:	00 
    frame->retval = NULL;
    4cf4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    4cfb:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4cfc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    4d00:	48 8b 05 71 ed 21 00 	mov    0x21ed71(%rip),%rax        # 223a78 <_DYNAMIC+0x290>
    4d07:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    4d0b:	48 8d 05 77 3b 01 00 	lea    0x13b77(%rip),%rax        # 18889 <handle_sizes.1924+0x109>
    4d12:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4d16:	48 89 e0             	mov    %rsp,%rax
    4d19:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4d1d:	48 89 e8             	mov    %rbp,%rax
    4d20:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4d24:	48 89 d8             	mov    %rbx,%rax
    4d27:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4d2b:	48 89 f0             	mov    %rsi,%rax
    4d2e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4d32:	48 89 f8             	mov    %rdi,%rax
    4d35:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4d39:	4c 89 e0             	mov    %r12,%rax
    4d3c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    4d40:	4c 89 e8             	mov    %r13,%rax
    4d43:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    4d47:	4c 89 f0             	mov    %r14,%rax
    4d4a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    4d4e:	4c 89 f8             	mov    %r15,%rax
    store_frame(ThreadExit);

    _DkThreadExit(0);
    4d51:	31 ff                	xor    %edi,%edi
    4d53:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    4d57:	e8 54 b9 00 00       	callq  106b0 <_DkThreadExit>

    notify_failure(PAL_ERROR_NOTKILLABLE);
}
    4d5c:	c9                   	leaveq 
{
    store_frame(ThreadExit);

    _DkThreadExit(0);

    notify_failure(PAL_ERROR_NOTKILLABLE);
    4d5d:	bf 11 00 00 00       	mov    $0x11,%edi
    4d62:	e9 e9 00 01 00       	jmpq   14e50 <notify_failure>
    4d67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    4d6e:	00 00 

0000000000004d70 <DkThreadResume>:
}

/* PAL call DkThreadResume: resume the execution of a thread
   which is delayed before */
PAL_BOL DkThreadResume (PAL_HANDLE threadHandle)
{
    4d70:	55                   	push   %rbp
    4d71:	48 89 e5             	mov    %rsp,%rbp
    4d74:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4d78:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    4d7c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    4d83:	00 
    frame->retval = NULL;
    4d84:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    4d8b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4d8c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    4d90:	48 8b 05 f9 ec 21 00 	mov    0x21ecf9(%rip),%rax        # 223a90 <_DYNAMIC+0x2a8>
    4d97:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    4d9b:	48 8d 05 f4 3a 01 00 	lea    0x13af4(%rip),%rax        # 18896 <handle_sizes.1924+0x116>
    4da2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4da6:	48 89 e0             	mov    %rsp,%rax
    4da9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4dad:	48 89 e8             	mov    %rbp,%rax
    4db0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4db4:	48 89 d8             	mov    %rbx,%rax
    4db7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4dbb:	48 89 f0             	mov    %rsi,%rax
    4dbe:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4dc2:	48 89 f8             	mov    %rdi,%rax
    4dc5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4dc9:	4c 89 e0             	mov    %r12,%rax
    4dcc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    4dd0:	4c 89 e8             	mov    %r13,%rax
    4dd3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    4dd7:	4c 89 f0             	mov    %r14,%rax
    4dda:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    4dde:	4c 89 f8             	mov    %r15,%rax
    store_frame(ThreadResume);

    if (!threadHandle ||
    4de1:	48 85 ff             	test   %rdi,%rdi
    4de4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    4de8:	74 05                	je     4def <DkThreadResume+0x7f>
    4dea:	83 3f 0e             	cmpl   $0xe,(%rdi)
    4ded:	74 11                	je     4e00 <DkThreadResume+0x90>
        !IS_HANDLE_TYPE(threadHandle, thread)) {
        notify_failure(PAL_ERROR_INVAL);
    4def:	bf 04 00 00 00       	mov    $0x4,%edi
    4df4:	e8 57 00 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    4df9:	31 c0                	xor    %eax,%eax
        notify_failure(PAL_ERROR_DENIED);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    4dfb:	c9                   	leaveq 
    4dfc:	c3                   	retq   
    4dfd:	0f 1f 00             	nopl   (%rax)
        !IS_HANDLE_TYPE(threadHandle, thread)) {
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    int ret = _DkThreadResume(threadHandle);
    4e00:	e8 6b b9 00 00       	callq  10770 <_DkThreadResume>
    4e05:	89 c2                	mov    %eax,%edx
    if (ret < 0) {
        notify_failure(PAL_ERROR_DENIED);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    4e07:	b8 01 00 00 00       	mov    $0x1,%eax
        return PAL_FALSE;
    }

    int ret = _DkThreadResume(threadHandle);

    if (ret < 0) {
    4e0c:	85 d2                	test   %edx,%edx
    4e0e:	79 eb                	jns    4dfb <DkThreadResume+0x8b>
        notify_failure(PAL_ERROR_DENIED);
    4e10:	bf 06 00 00 00       	mov    $0x6,%edi
    4e15:	e8 36 00 01 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    4e1a:	31 c0                	xor    %eax,%eax
    }

    return PAL_TRUE;
}
    4e1c:	c9                   	leaveq 
    4e1d:	c3                   	retq   
    4e1e:	66 90                	xchg   %ax,%ax

0000000000004e20 <DkThreadPrivate>:

    return handle;
}

PAL_BUF DkThreadPrivate (PAL_BUF addr)
{
    4e20:	55                   	push   %rbp
    4e21:	48 89 e5             	mov    %rsp,%rbp
    4e24:	48 83 ec 10          	sub    $0x10,%rsp
    void * ret = _DkThreadPrivate(addr);
    4e28:	e8 13 b7 00 00       	callq  10540 <_DkThreadPrivate>

    if (ret == NULL)
    4e2d:	48 85 c0             	test   %rax,%rax
    4e30:	74 02                	je     4e34 <DkThreadPrivate+0x14>
        notify_failure(PAL_ERROR_DENIED);

    return ret;
}
    4e32:	c9                   	leaveq 
    4e33:	c3                   	retq   
PAL_BUF DkThreadPrivate (PAL_BUF addr)
{
    void * ret = _DkThreadPrivate(addr);

    if (ret == NULL)
        notify_failure(PAL_ERROR_DENIED);
    4e34:	bf 06 00 00 00       	mov    $0x6,%edi
    4e39:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    4e3d:	e8 0e 00 01 00       	callq  14e50 <notify_failure>
    4e42:	48 8b 45 f8          	mov    -0x8(%rbp),%rax

    return ret;
}
    4e46:	c9                   	leaveq 
    4e47:	c3                   	retq   
    4e48:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    4e4f:	00 

0000000000004e50 <DkThreadYieldExecution>:
}

/* PAL call DkThreadYieldExecution. Yield the execution
   of the current thread. */
void DkThreadYieldExecution (void)
{
    4e50:	55                   	push   %rbp
    4e51:	48 89 e5             	mov    %rsp,%rbp
    _DkThreadYieldExecution();
}
    4e54:	5d                   	pop    %rbp

/* PAL call DkThreadYieldExecution. Yield the execution
   of the current thread. */
void DkThreadYieldExecution (void)
{
    _DkThreadYieldExecution();
    4e55:	e9 36 b8 00 00       	jmpq   10690 <_DkThreadYieldExecution>
    4e5a:	90                   	nop    
    4e5b:	90                   	nop    
    4e5c:	90                   	nop    
    4e5d:	90                   	nop    
    4e5e:	90                   	nop    
    4e5f:	90                   	nop    

0000000000004e60 <DkSemaphoreCreate>:
#include "pal_error.h"
#include "api.h"

PAL_HANDLE
DkSemaphoreCreate (PAL_NUM initialCount, PAL_NUM maxCount)
{
    4e60:	55                   	push   %rbp
    4e61:	48 89 e5             	mov    %rsp,%rbp
    4e64:	41 55                	push   %r13
    4e66:	41 54                	push   %r12

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4e68:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
    4e6f:	53                   	push   %rbx
    4e70:	49 89 fc             	mov    %rdi,%r12
    4e73:	49 89 f5             	mov    %rsi,%r13
    4e76:	48 83 ec 78          	sub    $0x78,%rsp
    4e7a:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    frame->func = func;
    4e81:	48 8b 05 d0 ec 21 00 	mov    0x21ecd0(%rip),%rax        # 223b58 <_DYNAMIC+0x370>
    frame->funcname = funcname;
    frame->context = NULL;
    4e88:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    4e8f:	00 
    frame->retval = NULL;
    4e90:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    4e97:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    4e98:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    frame->funcname = funcname;
    4e9f:	48 8d 05 ff 39 01 00 	lea    0x139ff(%rip),%rax        # 188a5 <handle_sizes.1924+0x125>
    4ea6:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4eaa:	48 89 e0             	mov    %rsp,%rax
    4ead:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    4eb1:	48 89 e8             	mov    %rbp,%rax
    4eb4:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    4eb8:	48 89 d8             	mov    %rbx,%rax
    4ebb:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    4ebf:	48 89 f0             	mov    %rsi,%rax
    4ec2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    4ec6:	48 89 f8             	mov    %rdi,%rax
    4ec9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4ecd:	4c 89 e0             	mov    %r12,%rax
    4ed0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4ed4:	4c 89 e8             	mov    %r13,%rax
    4ed7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4edb:	4c 89 f0             	mov    %r14,%rax
    4ede:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4ee2:	4c 89 f8             	mov    %r15,%rax
    store_frame(SemaphoreCreate);

    PAL_HANDLE handle = (PAL_HANDLE) malloc(HANDLE_SIZE(semaphore));
    4ee5:	bf 20 00 00 00       	mov    $0x20,%edi
    4eea:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4eee:	e8 0d 3b 00 00       	callq  8a00 <malloc>

    int ret = _DkSemaphoreCreate(handle, initialCount, maxCount);
    4ef3:	44 89 ea             	mov    %r13d,%edx
    4ef6:	44 89 e6             	mov    %r12d,%esi
    4ef9:	48 89 c7             	mov    %rax,%rdi
PAL_HANDLE
DkSemaphoreCreate (PAL_NUM initialCount, PAL_NUM maxCount)
{
    store_frame(SemaphoreCreate);

    PAL_HANDLE handle = (PAL_HANDLE) malloc(HANDLE_SIZE(semaphore));
    4efc:	48 89 c3             	mov    %rax,%rbx

    int ret = _DkSemaphoreCreate(handle, initialCount, maxCount);
    4eff:	e8 bc b8 00 00       	callq  107c0 <_DkSemaphoreCreate>

    if (ret < 0) {
    4f04:	85 c0                	test   %eax,%eax
    4f06:	78 18                	js     4f20 <DkSemaphoreCreate+0xc0>
        notify_failure (-ret);
        return NULL;
    }

    return handle;
    4f08:	48 89 d8             	mov    %rbx,%rax
}
    4f0b:	48 83 c4 78          	add    $0x78,%rsp
    4f0f:	5b                   	pop    %rbx
    4f10:	41 5c                	pop    %r12
    4f12:	41 5d                	pop    %r13
    4f14:	5d                   	pop    %rbp
    4f15:	c3                   	retq   
    4f16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    4f1d:	00 00 00 
    PAL_HANDLE handle = (PAL_HANDLE) malloc(HANDLE_SIZE(semaphore));

    int ret = _DkSemaphoreCreate(handle, initialCount, maxCount);

    if (ret < 0) {
        notify_failure (-ret);
    4f20:	f7 d8                	neg    %eax
    4f22:	48 63 f8             	movslq %eax,%rdi
    4f25:	e8 26 ff 00 00       	callq  14e50 <notify_failure>
        return NULL;
    4f2a:	31 c0                	xor    %eax,%eax
    4f2c:	eb dd                	jmp    4f0b <DkSemaphoreCreate+0xab>
    4f2e:	66 90                	xchg   %ax,%ax

0000000000004f30 <DkSemaphoreDestroy>:
    return handle;
}

void
DkSemaphoreDestroy (PAL_HANDLE semaphoreHandle)
{
    4f30:	55                   	push   %rbp
    4f31:	48 89 e5             	mov    %rsp,%rbp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4f34:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    4f38:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    4f3c:	48 8b 05 a5 ea 21 00 	mov    0x21eaa5(%rip),%rax        # 2239e8 <_DYNAMIC+0x200>
    frame->funcname = funcname;
    frame->context = NULL;
    4f43:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    4f4a:	00 
    frame->retval = NULL;
    4f4b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    4f52:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    4f53:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    4f57:	48 8d 05 59 39 01 00 	lea    0x13959(%rip),%rax        # 188b7 <handle_sizes.1924+0x137>
    4f5e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4f62:	48 89 e0             	mov    %rsp,%rax
    4f65:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4f69:	48 89 e8             	mov    %rbp,%rax
    4f6c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    4f70:	48 89 d8             	mov    %rbx,%rax
    4f73:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    4f77:	48 89 f0             	mov    %rsi,%rax
    4f7a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    4f7e:	48 89 f8             	mov    %rdi,%rax
    4f81:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    4f85:	4c 89 e0             	mov    %r12,%rax
    4f88:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    4f8c:	4c 89 e8             	mov    %r13,%rax
    4f8f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    4f93:	4c 89 f0             	mov    %r14,%rax
    4f96:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    4f9a:	4c 89 f8             	mov    %r15,%rax
    store_frame(SemaphoreDestroy);

    if (!semaphoreHandle) {
    4f9d:	48 85 ff             	test   %rdi,%rdi
    4fa0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    4fa4:	74 0a                	je     4fb0 <DkSemaphoreDestroy+0x80>
        notify_failure(PAL_ERROR_INVAL);
        return;
    }

    _DkSemaphoreDestroy(semaphoreHandle);
}
    4fa6:	5d                   	pop    %rbp
    if (!semaphoreHandle) {
        notify_failure(PAL_ERROR_INVAL);
        return;
    }

    _DkSemaphoreDestroy(semaphoreHandle);
    4fa7:	e9 54 b8 00 00       	jmpq   10800 <_DkSemaphoreDestroy>
    4fac:	0f 1f 40 00          	nopl   0x0(%rax)
}
    4fb0:	5d                   	pop    %rbp
DkSemaphoreDestroy (PAL_HANDLE semaphoreHandle)
{
    store_frame(SemaphoreDestroy);

    if (!semaphoreHandle) {
        notify_failure(PAL_ERROR_INVAL);
    4fb1:	40 b7 04             	mov    $0x4,%dil
    4fb4:	e9 97 fe 00 00       	jmpq   14e50 <notify_failure>
    4fb9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000004fc0 <DkSemaphoreRelease>:

    _DkSemaphoreDestroy(semaphoreHandle);
}

void DkSemaphoreRelease (PAL_HANDLE handle, PAL_NUM count)
{
    4fc0:	55                   	push   %rbp
    4fc1:	48 89 e5             	mov    %rsp,%rbp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    4fc4:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    4fc8:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    4fcc:	48 8b 05 5d eb 21 00 	mov    0x21eb5d(%rip),%rax        # 223b30 <_DYNAMIC+0x348>
    frame->funcname = funcname;
    frame->context = NULL;
    4fd3:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    4fda:	00 
    frame->retval = NULL;
    4fdb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    4fe2:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    4fe3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    4fe7:	48 8d 05 dc 38 01 00 	lea    0x138dc(%rip),%rax        # 188ca <handle_sizes.1924+0x14a>
    4fee:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    4ff2:	48 89 e0             	mov    %rsp,%rax
    4ff5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    4ff9:	48 89 e8             	mov    %rbp,%rax
    4ffc:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5000:	48 89 d8             	mov    %rbx,%rax
    5003:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    5007:	48 89 f0             	mov    %rsi,%rax
    500a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    500e:	48 89 f8             	mov    %rdi,%rax
    5011:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    5015:	4c 89 e0             	mov    %r12,%rax
    5018:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    501c:	4c 89 e8             	mov    %r13,%rax
    501f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    5023:	4c 89 f0             	mov    %r14,%rax
    5026:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    502a:	4c 89 f8             	mov    %r15,%rax
    store_frame(SemaphoreRelease);

    if (!handle ||
    502d:	48 85 ff             	test   %rdi,%rdi
    5030:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    5034:	74 05                	je     503b <DkSemaphoreRelease+0x7b>
    5036:	83 3f 0f             	cmpl   $0xf,(%rdi)
    5039:	74 05                	je     5040 <DkSemaphoreRelease+0x80>
        !IS_HANDLE_TYPE(handle, semaphore))
        return;

    _DkSemaphoreRelease (handle, count);
}
    503b:	5d                   	pop    %rbp
    503c:	c3                   	retq   
    503d:	0f 1f 00             	nopl   (%rax)
    5040:	5d                   	pop    %rbp

    if (!handle ||
        !IS_HANDLE_TYPE(handle, semaphore))
        return;

    _DkSemaphoreRelease (handle, count);
    5041:	e9 8a bb 00 00       	jmpq   10bd0 <_DkSemaphoreRelease>
    5046:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    504d:	00 00 00 

0000000000005050 <sem_wait>:
}

static int sem_wait (PAL_HANDLE handle, int timeout)
{
    5050:	55                   	push   %rbp
    5051:	89 f2                	mov    %esi,%edx
    return _DkSemaphoreAcquireTimeout(handle, 1, timeout);
    5053:	be 01 00 00 00       	mov    $0x1,%esi

    _DkSemaphoreRelease (handle, count);
}

static int sem_wait (PAL_HANDLE handle, int timeout)
{
    5058:	48 89 e5             	mov    %rsp,%rbp
    return _DkSemaphoreAcquireTimeout(handle, 1, timeout);
}
    505b:	5d                   	pop    %rbp
    _DkSemaphoreRelease (handle, count);
}

static int sem_wait (PAL_HANDLE handle, int timeout)
{
    return _DkSemaphoreAcquireTimeout(handle, 1, timeout);
    505c:	e9 3f b9 00 00       	jmpq   109a0 <_DkSemaphoreAcquireTimeout>
    5061:	90                   	nop    
    5062:	90                   	nop    
    5063:	90                   	nop    
    5064:	90                   	nop    
    5065:	90                   	nop    
    5066:	90                   	nop    
    5067:	90                   	nop    
    5068:	90                   	nop    
    5069:	90                   	nop    
    506a:	90                   	nop    
    506b:	90                   	nop    
    506c:	90                   	nop    
    506d:	90                   	nop    
    506e:	90                   	nop    
    506f:	90                   	nop    

0000000000005070 <DkNotificationEventCreate>:
#include "pal_internal.h"
#include "pal_error.h"
#include "api.h"

PAL_HANDLE DkNotificationEventCreate (PAL_BOL initialState)
{
    5070:	55                   	push   %rbp
    5071:	48 89 e5             	mov    %rsp,%rbp
    5074:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    5078:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    507c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    5083:	00 
    frame->retval = NULL;
    5084:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    508b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    508c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    5090:	48 8b 05 69 ea 21 00 	mov    0x21ea69(%rip),%rax        # 223b00 <_DYNAMIC+0x318>
    5097:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    509b:	48 8d 05 3b 38 01 00 	lea    0x1383b(%rip),%rax        # 188dd <handle_sizes.1924+0x15d>
    50a2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    50a6:	48 89 e0             	mov    %rsp,%rax
    50a9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    50ad:	48 89 e8             	mov    %rbp,%rax
    50b0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    50b4:	48 89 d8             	mov    %rbx,%rax
    50b7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    50bb:	48 89 f0             	mov    %rsi,%rax
    50be:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    50c2:	48 89 f8             	mov    %rdi,%rax
    50c5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    50c9:	4c 89 e0             	mov    %r12,%rax
    50cc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    50d0:	4c 89 e8             	mov    %r13,%rax
    50d3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    50d7:	4c 89 f0             	mov    %r14,%rax
    50da:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    50de:	4c 89 f8             	mov    %r15,%rax
    store_frame(NotificationEventCreate);

    PAL_HANDLE handle = NULL;
    int ret = _DkEventCreate(&handle, initialState, true);
    50e1:	40 0f b6 f7          	movzbl %dil,%esi
    50e5:	48 8d 7d 88          	lea    -0x78(%rbp),%rdi
    50e9:	ba 01 00 00 00       	mov    $0x1,%edx
    50ee:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

PAL_HANDLE DkNotificationEventCreate (PAL_BOL initialState)
{
    store_frame(NotificationEventCreate);

    PAL_HANDLE handle = NULL;
    50f2:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    50f9:	00 
    int ret = _DkEventCreate(&handle, initialState, true);
    50fa:	e8 21 be 00 00       	callq  10f20 <_DkEventCreate>

    if (ret < 0) {
    50ff:	85 c0                	test   %eax,%eax
    5101:	78 0d                	js     5110 <DkNotificationEventCreate+0xa0>
        notify_failure(-ret);
        return NULL;
    }

    return handle;
    5103:	48 8b 45 88          	mov    -0x78(%rbp),%rax
}
    5107:	c9                   	leaveq 
    5108:	c3                   	retq   
    5109:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

    PAL_HANDLE handle = NULL;
    int ret = _DkEventCreate(&handle, initialState, true);

    if (ret < 0) {
        notify_failure(-ret);
    5110:	f7 d8                	neg    %eax
    5112:	48 63 f8             	movslq %eax,%rdi
    5115:	e8 36 fd 00 00       	callq  14e50 <notify_failure>
        return NULL;
    511a:	31 c0                	xor    %eax,%eax
    }

    return handle;
}
    511c:	c9                   	leaveq 
    511d:	c3                   	retq   
    511e:	66 90                	xchg   %ax,%ax

0000000000005120 <DkSynchronizationEventCreate>:

PAL_HANDLE DkSynchronizationEventCreate (PAL_BOL initialState)
{
    5120:	55                   	push   %rbp
    5121:	48 89 e5             	mov    %rsp,%rbp
    5124:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    5128:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    512c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    5133:	00 
    frame->retval = NULL;
    5134:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    513b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    513c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    5140:	48 8b 05 f9 e8 21 00 	mov    0x21e8f9(%rip),%rax        # 223a40 <_DYNAMIC+0x258>
    5147:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    514b:	48 8d 05 a5 37 01 00 	lea    0x137a5(%rip),%rax        # 188f7 <handle_sizes.1924+0x177>
    5152:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    5156:	48 89 e0             	mov    %rsp,%rax
    5159:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    515d:	48 89 e8             	mov    %rbp,%rax
    5160:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5164:	48 89 d8             	mov    %rbx,%rax
    5167:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    516b:	48 89 f0             	mov    %rsi,%rax
    516e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    5172:	48 89 f8             	mov    %rdi,%rax
    5175:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    5179:	4c 89 e0             	mov    %r12,%rax
    517c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5180:	4c 89 e8             	mov    %r13,%rax
    5183:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    5187:	4c 89 f0             	mov    %r14,%rax
    518a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    518e:	4c 89 f8             	mov    %r15,%rax
    store_frame(SynchronizationEventCreate);

    PAL_HANDLE handle = NULL;
    int ret = _DkEventCreate(&handle, initialState, false);
    5191:	40 0f b6 f7          	movzbl %dil,%esi
    5195:	48 8d 7d 88          	lea    -0x78(%rbp),%rdi
    5199:	31 d2                	xor    %edx,%edx
    519b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

PAL_HANDLE DkSynchronizationEventCreate (PAL_BOL initialState)
{
    store_frame(SynchronizationEventCreate);

    PAL_HANDLE handle = NULL;
    519f:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    51a6:	00 
    int ret = _DkEventCreate(&handle, initialState, false);
    51a7:	e8 74 bd 00 00       	callq  10f20 <_DkEventCreate>

    if (ret < 0) {
    51ac:	85 c0                	test   %eax,%eax
    51ae:	78 10                	js     51c0 <DkSynchronizationEventCreate+0xa0>
        notify_failure(-ret);
        return NULL;
    }

    return handle;
    51b0:	48 8b 45 88          	mov    -0x78(%rbp),%rax
}
    51b4:	c9                   	leaveq 
    51b5:	c3                   	retq   
    51b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    51bd:	00 00 00 

    PAL_HANDLE handle = NULL;
    int ret = _DkEventCreate(&handle, initialState, false);

    if (ret < 0) {
        notify_failure(-ret);
    51c0:	f7 d8                	neg    %eax
    51c2:	48 63 f8             	movslq %eax,%rdi
    51c5:	e8 86 fc 00 00       	callq  14e50 <notify_failure>
        return NULL;
    51ca:	31 c0                	xor    %eax,%eax
    }

    return handle;
}
    51cc:	c9                   	leaveq 
    51cd:	c3                   	retq   
    51ce:	66 90                	xchg   %ax,%ax

00000000000051d0 <DkEventDestroy>:

void DkEventDestroy (PAL_HANDLE handle)
{
    51d0:	55                   	push   %rbp
    51d1:	48 89 e5             	mov    %rsp,%rbp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    51d4:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    51d8:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    51dc:	48 8b 05 ed e8 21 00 	mov    0x21e8ed(%rip),%rax        # 223ad0 <_DYNAMIC+0x2e8>
    frame->funcname = funcname;
    frame->context = NULL;
    51e3:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    51ea:	00 
    frame->retval = NULL;
    51eb:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    51f2:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    51f3:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    51f7:	48 8d 05 16 37 01 00 	lea    0x13716(%rip),%rax        # 18914 <handle_sizes.1924+0x194>
    51fe:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    5202:	48 89 e0             	mov    %rsp,%rax
    5205:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    5209:	48 89 e8             	mov    %rbp,%rax
    520c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5210:	48 89 d8             	mov    %rbx,%rax
    5213:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    5217:	48 89 f0             	mov    %rsi,%rax
    521a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    521e:	48 89 f8             	mov    %rdi,%rax
    5221:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    5225:	4c 89 e0             	mov    %r12,%rax
    5228:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    522c:	4c 89 e8             	mov    %r13,%rax
    522f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    5233:	4c 89 f0             	mov    %r14,%rax
    5236:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    523a:	4c 89 f8             	mov    %r15,%rax
    store_frame(EventDestroy);

    if (!handle || !IS_HANDLE_TYPE(handle, event)) {
    523d:	48 85 ff             	test   %rdi,%rdi
    5240:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    5244:	74 05                	je     524b <DkEventDestroy+0x7b>
    5246:	83 3f 10             	cmpl   $0x10,(%rdi)
    5249:	74 15                	je     5260 <DkEventDestroy+0x90>
        notify_failure(PAL_ERROR_INVAL);
        return;
    }

    _DkEventDestroy(handle);
}
    524b:	5d                   	pop    %rbp
void DkEventDestroy (PAL_HANDLE handle)
{
    store_frame(EventDestroy);

    if (!handle || !IS_HANDLE_TYPE(handle, event)) {
        notify_failure(PAL_ERROR_INVAL);
    524c:	bf 04 00 00 00       	mov    $0x4,%edi
    5251:	e9 fa fb 00 00       	jmpq   14e50 <notify_failure>
    5256:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    525d:	00 00 00 
        return;
    }

    _DkEventDestroy(handle);
}
    5260:	5d                   	pop    %rbp
    if (!handle || !IS_HANDLE_TYPE(handle, event)) {
        notify_failure(PAL_ERROR_INVAL);
        return;
    }

    _DkEventDestroy(handle);
    5261:	e9 1a bd 00 00       	jmpq   10f80 <_DkEventDestroy>
    5266:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    526d:	00 00 00 

0000000000005270 <event_close>:
    if (ret < 0)
        notify_failure(-ret);
}

static int event_close (PAL_HANDLE handle)
{
    5270:	55                   	push   %rbp
    5271:	48 89 e5             	mov    %rsp,%rbp
    return _DkEventClear(handle);
}
    5274:	5d                   	pop    %rbp
        notify_failure(-ret);
}

static int event_close (PAL_HANDLE handle)
{
    return _DkEventClear(handle);
    5275:	e9 46 bd 00 00       	jmpq   10fc0 <_DkEventClear>
    527a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000005280 <event_wait>:
}

static int event_wait (PAL_HANDLE handle, int timeout)
{
    5280:	55                   	push   %rbp
    return timeout >=0 ? _DkEventWaitTimeout(handle, timeout) :
    5281:	85 f6                	test   %esi,%esi
{
    return _DkEventClear(handle);
}

static int event_wait (PAL_HANDLE handle, int timeout)
{
    5283:	48 89 e5             	mov    %rsp,%rbp
    return timeout >=0 ? _DkEventWaitTimeout(handle, timeout) :
    5286:	78 08                	js     5290 <event_wait+0x10>
           _DkEventWait(handle);
}
    5288:	5d                   	pop    %rbp
    return _DkEventClear(handle);
}

static int event_wait (PAL_HANDLE handle, int timeout)
{
    return timeout >=0 ? _DkEventWaitTimeout(handle, timeout) :
    5289:	e9 12 bd 00 00       	jmpq   10fa0 <_DkEventWaitTimeout>
    528e:	66 90                	xchg   %ax,%ax
           _DkEventWait(handle);
}
    5290:	5d                   	pop    %rbp
    return _DkEventClear(handle);
}

static int event_wait (PAL_HANDLE handle, int timeout)
{
    return timeout >=0 ? _DkEventWaitTimeout(handle, timeout) :
    5291:	e9 1a bd 00 00       	jmpq   10fb0 <_DkEventWait>
    5296:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    529d:	00 00 00 

00000000000052a0 <DkEventSet>:

    _DkEventDestroy(handle);
}

void DkEventSet (PAL_HANDLE handle)
{
    52a0:	55                   	push   %rbp
    52a1:	48 89 e5             	mov    %rsp,%rbp
    52a4:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    52a8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    52ac:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    52b3:	00 
    frame->retval = NULL;
    52b4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    52bb:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    52bc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    52c0:	48 8b 05 61 e7 21 00 	mov    0x21e761(%rip),%rax        # 223a28 <_DYNAMIC+0x240>
    52c7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    52cb:	48 8d 05 51 36 01 00 	lea    0x13651(%rip),%rax        # 18923 <handle_sizes.1924+0x1a3>
    52d2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    52d6:	48 89 e0             	mov    %rsp,%rax
    52d9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    52dd:	48 89 e8             	mov    %rbp,%rax
    52e0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    52e4:	48 89 d8             	mov    %rbx,%rax
    52e7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    52eb:	48 89 f0             	mov    %rsi,%rax
    52ee:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    52f2:	48 89 f8             	mov    %rdi,%rax
    52f5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    52f9:	4c 89 e0             	mov    %r12,%rax
    52fc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5300:	4c 89 e8             	mov    %r13,%rax
    5303:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    5307:	4c 89 f0             	mov    %r14,%rax
    530a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    530e:	4c 89 f8             	mov    %r15,%rax
    store_frame(EventSet);

    if (!handle || !IS_HANDLE_TYPE(handle, event)) {
    5311:	48 85 ff             	test   %rdi,%rdi
    5314:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    5318:	74 05                	je     531f <DkEventSet+0x7f>
    531a:	83 3f 10             	cmpl   $0x10,(%rdi)
    531d:	74 11                	je     5330 <DkEventSet+0x90>

    int ret = _DkEventSet (handle);

    if (ret < 0)
        notify_failure(-ret);
}
    531f:	c9                   	leaveq 
void DkEventSet (PAL_HANDLE handle)
{
    store_frame(EventSet);

    if (!handle || !IS_HANDLE_TYPE(handle, event)) {
        notify_failure(PAL_ERROR_INVAL);
    5320:	bf 04 00 00 00       	mov    $0x4,%edi
    5325:	e9 26 fb 00 00       	jmpq   14e50 <notify_failure>
    532a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        return;
    }

    int ret = _DkEventSet (handle);
    5330:	e8 5b bc 00 00       	callq  10f90 <_DkEventSet>

    if (ret < 0)
    5335:	85 c0                	test   %eax,%eax
    5337:	78 07                	js     5340 <DkEventSet+0xa0>
        notify_failure(-ret);
}
    5339:	c9                   	leaveq 
    533a:	c3                   	retq   
    533b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    5340:	c9                   	leaveq 
    }

    int ret = _DkEventSet (handle);

    if (ret < 0)
        notify_failure(-ret);
    5341:	f7 d8                	neg    %eax
    5343:	48 63 f8             	movslq %eax,%rdi
    5346:	e9 05 fb 00 00       	jmpq   14e50 <notify_failure>
    534b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000005350 <DkEventWait>:
}

void DkEventWait (PAL_HANDLE handle)
{
    5350:	55                   	push   %rbp
    5351:	48 89 e5             	mov    %rsp,%rbp
    5354:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    5358:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    535c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    5363:	00 
    frame->retval = NULL;
    5364:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    536b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    536c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    5370:	48 8b 05 91 e6 21 00 	mov    0x21e691(%rip),%rax        # 223a08 <_DYNAMIC+0x220>
    5377:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    537b:	48 8d 05 ac 35 01 00 	lea    0x135ac(%rip),%rax        # 1892e <handle_sizes.1924+0x1ae>
    5382:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    5386:	48 89 e0             	mov    %rsp,%rax
    5389:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    538d:	48 89 e8             	mov    %rbp,%rax
    5390:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5394:	48 89 d8             	mov    %rbx,%rax
    5397:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    539b:	48 89 f0             	mov    %rsi,%rax
    539e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    53a2:	48 89 f8             	mov    %rdi,%rax
    53a5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    53a9:	4c 89 e0             	mov    %r12,%rax
    53ac:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    53b0:	4c 89 e8             	mov    %r13,%rax
    53b3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    53b7:	4c 89 f0             	mov    %r14,%rax
    53ba:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    53be:	4c 89 f8             	mov    %r15,%rax
    store_frame(EventWait);

    if (!handle || !IS_HANDLE_TYPE(handle, event)) {
    53c1:	48 85 ff             	test   %rdi,%rdi
    53c4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    53c8:	74 05                	je     53cf <DkEventWait+0x7f>
    53ca:	83 3f 10             	cmpl   $0x10,(%rdi)
    53cd:	74 11                	je     53e0 <DkEventWait+0x90>

    int ret = _DkEventWait(handle);

    if (ret < 0)
        notify_failure(-ret);
}
    53cf:	c9                   	leaveq 
void DkEventWait (PAL_HANDLE handle)
{
    store_frame(EventWait);

    if (!handle || !IS_HANDLE_TYPE(handle, event)) {
        notify_failure(PAL_ERROR_INVAL);
    53d0:	bf 04 00 00 00       	mov    $0x4,%edi
    53d5:	e9 76 fa 00 00       	jmpq   14e50 <notify_failure>
    53da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        return;
    }

    int ret = _DkEventWait(handle);
    53e0:	e8 cb bb 00 00       	callq  10fb0 <_DkEventWait>

    if (ret < 0)
    53e5:	85 c0                	test   %eax,%eax
    53e7:	78 07                	js     53f0 <DkEventWait+0xa0>
        notify_failure(-ret);
}
    53e9:	c9                   	leaveq 
    53ea:	c3                   	retq   
    53eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    53f0:	c9                   	leaveq 
    }

    int ret = _DkEventWait(handle);

    if (ret < 0)
        notify_failure(-ret);
    53f1:	f7 d8                	neg    %eax
    53f3:	48 63 f8             	movslq %eax,%rdi
    53f6:	e9 55 fa 00 00       	jmpq   14e50 <notify_failure>
    53fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000005400 <DkEventClear>:
}

void DkEventClear (PAL_HANDLE handle)
{
    5400:	55                   	push   %rbp
    5401:	48 89 e5             	mov    %rsp,%rbp
    5404:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    5408:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    540c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    5413:	00 
    frame->retval = NULL;
    5414:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    541b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    541c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    5420:	48 8b 05 89 e6 21 00 	mov    0x21e689(%rip),%rax        # 223ab0 <_DYNAMIC+0x2c8>
    5427:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    542b:	48 8d 05 08 35 01 00 	lea    0x13508(%rip),%rax        # 1893a <handle_sizes.1924+0x1ba>
    5432:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    5436:	48 89 e0             	mov    %rsp,%rax
    5439:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    543d:	48 89 e8             	mov    %rbp,%rax
    5440:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5444:	48 89 d8             	mov    %rbx,%rax
    5447:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    544b:	48 89 f0             	mov    %rsi,%rax
    544e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    5452:	48 89 f8             	mov    %rdi,%rax
    5455:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    5459:	4c 89 e0             	mov    %r12,%rax
    545c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5460:	4c 89 e8             	mov    %r13,%rax
    5463:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    5467:	4c 89 f0             	mov    %r14,%rax
    546a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    546e:	4c 89 f8             	mov    %r15,%rax
    store_frame(EventClear);

    if (!handle || !IS_HANDLE_TYPE(handle, event)) {
    5471:	48 85 ff             	test   %rdi,%rdi
    5474:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    5478:	74 05                	je     547f <DkEventClear+0x7f>
    547a:	83 3f 10             	cmpl   $0x10,(%rdi)
    547d:	74 11                	je     5490 <DkEventClear+0x90>

    int ret = _DkEventClear(handle);

    if (ret < 0)
        notify_failure(-ret);
}
    547f:	c9                   	leaveq 
void DkEventClear (PAL_HANDLE handle)
{
    store_frame(EventClear);

    if (!handle || !IS_HANDLE_TYPE(handle, event)) {
        notify_failure(PAL_ERROR_INVAL);
    5480:	bf 04 00 00 00       	mov    $0x4,%edi
    5485:	e9 c6 f9 00 00       	jmpq   14e50 <notify_failure>
    548a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        return;
    }

    int ret = _DkEventClear(handle);
    5490:	e8 2b bb 00 00       	callq  10fc0 <_DkEventClear>

    if (ret < 0)
    5495:	85 c0                	test   %eax,%eax
    5497:	78 07                	js     54a0 <DkEventClear+0xa0>
        notify_failure(-ret);
}
    5499:	c9                   	leaveq 
    549a:	c3                   	retq   
    549b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    54a0:	c9                   	leaveq 
    }

    int ret = _DkEventClear(handle);

    if (ret < 0)
        notify_failure(-ret);
    54a1:	f7 d8                	neg    %eax
    54a3:	48 63 f8             	movslq %eax,%rdi
    54a6:	e9 a5 f9 00 00       	jmpq   14e50 <notify_failure>
    54ab:	90                   	nop    
    54ac:	90                   	nop    
    54ad:	90                   	nop    
    54ae:	90                   	nop    
    54af:	90                   	nop    

00000000000054b0 <DkProcessCreate>:
#include "pal_debug.h"
#include "pal_error.h"
#include "api.h"
PAL_HANDLE
DkProcessCreate (PAL_STR uri, PAL_FLG flags, PAL_STR * args)
{
    54b0:	55                   	push   %rbp
    54b1:	48 89 f8             	mov    %rdi,%rax
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    frame->funcname = funcname;
    54b4:	48 8d 3d 8c 34 01 00 	lea    0x1348c(%rip),%rdi        # 18947 <handle_sizes.1924+0x1c7>
    54bb:	48 89 e5             	mov    %rsp,%rbp
    54be:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    54c2:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
    frame->func = func;
    frame->funcname = funcname;
    54c6:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
    frame->context = NULL;
    54ca:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    54d1:	00 
    frame->retval = NULL;
    54d2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    54d9:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    54da:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
    frame->func = func;
    54de:	48 8b 0d cb e4 21 00 	mov    0x21e4cb(%rip),%rcx        # 2239b0 <_DYNAMIC+0x1c8>
    54e5:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
    frame->funcname = funcname;
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    54e9:	48 89 e1             	mov    %rsp,%rcx
    54ec:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
    54f0:	48 89 e9             	mov    %rbp,%rcx
    54f3:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    54f7:	48 89 d9             	mov    %rbx,%rcx
    54fa:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    54fe:	48 89 f1             	mov    %rsi,%rcx
    5501:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    5505:	48 89 f9             	mov    %rdi,%rcx
    5508:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
    550c:	4c 89 e1             	mov    %r12,%rcx
    550f:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    5513:	4c 89 e9             	mov    %r13,%rcx
    5516:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    551a:	4c 89 f1             	mov    %r14,%rcx
    551d:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
    5521:	4c 89 f9             	mov    %r15,%rcx
    store_frame(ProcessCreate);

    PAL_HANDLE handle = NULL;
    int ret = _DkProcessCreate(&handle, uri, flags, args);
    5524:	48 8d 7d 88          	lea    -0x78(%rbp),%rdi
    5528:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
    552c:	48 89 d1             	mov    %rdx,%rcx
    552f:	89 f2                	mov    %esi,%edx
    5531:	48 89 c6             	mov    %rax,%rsi
PAL_HANDLE
DkProcessCreate (PAL_STR uri, PAL_FLG flags, PAL_STR * args)
{
    store_frame(ProcessCreate);

    PAL_HANDLE handle = NULL;
    5534:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    553b:	00 
    int ret = _DkProcessCreate(&handle, uri, flags, args);
    553c:	e8 bf c5 00 00       	callq  11b00 <_DkProcessCreate>
    if (ret < 0) {
    5541:	85 c0                	test   %eax,%eax
    5543:	78 0b                	js     5550 <DkProcessCreate+0xa0>
        notify_failure(-ret);
        return NULL;
    }

    return handle;
    5545:	48 8b 45 88          	mov    -0x78(%rbp),%rax
}
    5549:	c9                   	leaveq 
    554a:	c3                   	retq   
    554b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    store_frame(ProcessCreate);

    PAL_HANDLE handle = NULL;
    int ret = _DkProcessCreate(&handle, uri, flags, args);
    if (ret < 0) {
        notify_failure(-ret);
    5550:	f7 d8                	neg    %eax
    5552:	48 63 f8             	movslq %eax,%rdi
    5555:	e8 f6 f8 00 00       	callq  14e50 <notify_failure>
        return NULL;
    555a:	31 c0                	xor    %eax,%eax
    }

    return handle;
}
    555c:	c9                   	leaveq 
    555d:	c3                   	retq   
    555e:	66 90                	xchg   %ax,%ax

0000000000005560 <DkProcessExit>:

void DkProcessExit (PAL_NUM exitcode)
{
    5560:	55                   	push   %rbp
    5561:	48 89 e5             	mov    %rsp,%rbp
    5564:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    5568:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    556c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    5573:	00 
    frame->retval = NULL;
    5574:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    557b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    557c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    5580:	48 8b 05 01 e4 21 00 	mov    0x21e401(%rip),%rax        # 223988 <_DYNAMIC+0x1a0>
    5587:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    558b:	48 8d 05 c5 33 01 00 	lea    0x133c5(%rip),%rax        # 18957 <handle_sizes.1924+0x1d7>
    5592:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    5596:	48 89 e0             	mov    %rsp,%rax
    5599:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    559d:	48 89 e8             	mov    %rbp,%rax
    55a0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    55a4:	48 89 d8             	mov    %rbx,%rax
    55a7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    55ab:	48 89 f0             	mov    %rsi,%rax
    55ae:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    55b2:	48 89 f8             	mov    %rdi,%rax
    55b5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    55b9:	4c 89 e0             	mov    %r12,%rax
    55bc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    55c0:	4c 89 e8             	mov    %r13,%rax
    55c3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    55c7:	4c 89 f0             	mov    %r14,%rax
    55ca:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    55ce:	4c 89 f8             	mov    %r15,%rax
    55d1:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    store_frame(ProcessExit);

    _DkProcessExit(exitcode);
    55d5:	e8 a6 cf 00 00       	callq  12580 <_DkProcessExit>

    notify_failure(PAL_ERROR_NOTKILLABLE);
}
    55da:	c9                   	leaveq 
{
    store_frame(ProcessExit);

    _DkProcessExit(exitcode);

    notify_failure(PAL_ERROR_NOTKILLABLE);
    55db:	bf 11 00 00 00       	mov    $0x11,%edi
    55e0:	e9 6b f8 00 00       	jmpq   14e50 <notify_failure>
    55e5:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
    55ec:	00 00 00 00 

00000000000055f0 <DkProcessSandboxCreate>:
}

PAL_BOL DkProcessSandboxCreate (PAL_STR manifest, PAL_FLG flags)
{
    55f0:	55                   	push   %rbp
    55f1:	48 89 e5             	mov    %rsp,%rbp
    55f4:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    55f8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    55fc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    5603:	00 
    frame->retval = NULL;
    5604:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    560b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    560c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    5610:	48 8b 05 89 e3 21 00 	mov    0x21e389(%rip),%rax        # 2239a0 <_DYNAMIC+0x1b8>
    5617:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    561b:	48 8d 05 43 33 01 00 	lea    0x13343(%rip),%rax        # 18965 <handle_sizes.1924+0x1e5>
    5622:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    5626:	48 89 e0             	mov    %rsp,%rax
    5629:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    562d:	48 89 e8             	mov    %rbp,%rax
    5630:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    5634:	48 89 d8             	mov    %rbx,%rax
    5637:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    563b:	48 89 f0             	mov    %rsi,%rax
    563e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    5642:	48 89 f8             	mov    %rdi,%rax
    5645:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    5649:	4c 89 e0             	mov    %r12,%rax
    564c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5650:	4c 89 e8             	mov    %r13,%rax
    5653:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    5657:	4c 89 f0             	mov    %r14,%rax
    565a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    565e:	4c 89 f8             	mov    %r15,%rax
    5661:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    store_frame(ProcessSandboxCreate);

    int ret = _DkProcessSandboxCreate(manifest, flags);
    5665:	e8 66 cf 00 00       	callq  125d0 <_DkProcessSandboxCreate>
    566a:	89 c7                	mov    %eax,%edi
    if (ret < 0) {
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    566c:	b8 01 00 00 00       	mov    $0x1,%eax
{
    store_frame(ProcessSandboxCreate);

    int ret = _DkProcessSandboxCreate(manifest, flags);

    if (ret < 0) {
    5671:	85 ff                	test   %edi,%edi
    5673:	78 0b                	js     5680 <DkProcessSandboxCreate+0x90>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    5675:	c9                   	leaveq 
    5676:	c3                   	retq   
    5677:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    567e:	00 00 
    store_frame(ProcessSandboxCreate);

    int ret = _DkProcessSandboxCreate(manifest, flags);

    if (ret < 0) {
        notify_failure(-ret);
    5680:	f7 df                	neg    %edi
    5682:	48 63 ff             	movslq %edi,%rdi
    5685:	e8 c6 f7 00 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    568a:	31 c0                	xor    %eax,%eax
    }

    return PAL_TRUE;
}
    568c:	c9                   	leaveq 
    568d:	c3                   	retq   
    568e:	90                   	nop    
    568f:	90                   	nop    

0000000000005690 <DkObjectsWaitAny>:
/* PAL call DkObjectsWaitAny: wait for any of the handles in the handle array.
   The wait can be timed out, unless NO_TIMEOUT is given for the timeout
   argument. */
PAL_HANDLE
DkObjectsWaitAny (PAL_NUM count, PAL_HANDLE * handleArray, PAL_NUM timeout)
{
    5690:	55                   	push   %rbp
    5691:	48 89 e5             	mov    %rsp,%rbp
    5694:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    5698:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    569c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    56a3:	00 
    frame->retval = NULL;
    56a4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    56ab:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    56ac:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    56b0:	48 8b 05 99 e2 21 00 	mov    0x21e299(%rip),%rax        # 223950 <_DYNAMIC+0x168>
    56b7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    56bb:	48 8d 05 ba 32 01 00 	lea    0x132ba(%rip),%rax        # 1897c <handle_sizes.1924+0x1fc>
    56c2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    56c6:	48 89 e0             	mov    %rsp,%rax
    56c9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    56cd:	48 89 e8             	mov    %rbp,%rax
    56d0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    56d4:	48 89 d8             	mov    %rbx,%rax
    56d7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    56db:	48 89 f0             	mov    %rsi,%rax
    56de:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    56e2:	48 89 f8             	mov    %rdi,%rax
    56e5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    56e9:	4c 89 e0             	mov    %r12,%rax
    56ec:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    56f0:	4c 89 e8             	mov    %r13,%rax
    56f3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    56f7:	4c 89 f0             	mov    %r14,%rax
    56fa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    56fe:	4c 89 f8             	mov    %r15,%rax
    store_frame(ObjectsWaitAny);

    if (!count || !handleArray) {
    5701:	48 85 ff             	test   %rdi,%rdi
    5704:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    5708:	74 4e                	je     5758 <DkObjectsWaitAny+0xc8>
    570a:	48 85 f6             	test   %rsi,%rsi
    570d:	48 89 f0             	mov    %rsi,%rax
    5710:	4c 8d 04 fe          	lea    (%rsi,%rdi,8),%r8
    5714:	74 42                	je     5758 <DkObjectsWaitAny+0xc8>
    5716:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    571d:	00 00 00 
        notify_failure(PAL_ERROR_INVAL);
        return NULL;
    }

    for (int i = 0 ; i < count ; i++)
        if (UNKNOWN_HANDLE(handleArray[i]))
    5720:	48 8b 08             	mov    (%rax),%rcx
    5723:	8b 09                	mov    (%rcx),%ecx
    5725:	83 e9 01             	sub    $0x1,%ecx
    5728:	83 f9 10             	cmp    $0x10,%ecx
    572b:	76 07                	jbe    5734 <DkObjectsWaitAny+0xa4>
            handleArray[i] = NULL;
    572d:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    5734:	48 83 c0 08          	add    $0x8,%rax
    if (!count || !handleArray) {
        notify_failure(PAL_ERROR_INVAL);
        return NULL;
    }

    for (int i = 0 ; i < count ; i++)
    5738:	4c 39 c0             	cmp    %r8,%rax
    573b:	75 e3                	jne    5720 <DkObjectsWaitAny+0x90>
        if (UNKNOWN_HANDLE(handleArray[i]))
            handleArray[i] = NULL;

    PAL_HANDLE polled = NULL;

    int ret = _DkObjectsWaitAny (count, handleArray,
    573d:	48 8d 4d 88          	lea    -0x78(%rbp),%rcx

    for (int i = 0 ; i < count ; i++)
        if (UNKNOWN_HANDLE(handleArray[i]))
            handleArray[i] = NULL;

    PAL_HANDLE polled = NULL;
    5741:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    5748:	00 

    int ret = _DkObjectsWaitAny (count, handleArray,
    5749:	e8 92 ce 00 00       	callq  125e0 <_DkObjectsWaitAny>
                                 timeout == NO_TIMEOUT ? -1 : timeout,
                                 &polled);

    if (ret < 0) {
    574e:	85 c0                	test   %eax,%eax
    5750:	78 14                	js     5766 <DkObjectsWaitAny+0xd6>
        notify_failure(-ret);
        return NULL;
    }

    return polled;
    5752:	48 8b 45 88          	mov    -0x78(%rbp),%rax
}
    5756:	c9                   	leaveq 
    5757:	c3                   	retq   
DkObjectsWaitAny (PAL_NUM count, PAL_HANDLE * handleArray, PAL_NUM timeout)
{
    store_frame(ObjectsWaitAny);

    if (!count || !handleArray) {
        notify_failure(PAL_ERROR_INVAL);
    5758:	bf 04 00 00 00       	mov    $0x4,%edi
    575d:	e8 ee f6 00 00       	callq  14e50 <notify_failure>
        return NULL;
    5762:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        return NULL;
    }

    return polled;
}
    5764:	c9                   	leaveq 
    5765:	c3                   	retq   
    int ret = _DkObjectsWaitAny (count, handleArray,
                                 timeout == NO_TIMEOUT ? -1 : timeout,
                                 &polled);

    if (ret < 0) {
        notify_failure(-ret);
    5766:	f7 d8                	neg    %eax
    5768:	48 63 f8             	movslq %eax,%rdi
    576b:	e8 e0 f6 00 00       	callq  14e50 <notify_failure>
        return NULL;
    5770:	31 c0                	xor    %eax,%eax
    }

    return polled;
}
    5772:	c9                   	leaveq 
    5773:	c3                   	retq   
    5774:	66 66 66 2e 0f 1f 84 	nopw   %cs:0x0(%rax,%rax,1)
    577b:	00 00 00 00 00 

0000000000005780 <_DkObjectReference>:
#include "pal_error.h"
#include "pal_debug.h"
#include "api.h"

int _DkObjectReference (PAL_HANDLE objectHandle)
{
    5780:	55                   	push   %rbp
    if (!objectHandle || UNKNOWN_HANDLE(objectHandle))
    5781:	48 85 ff             	test   %rdi,%rdi
#include "pal_error.h"
#include "pal_debug.h"
#include "api.h"

int _DkObjectReference (PAL_HANDLE objectHandle)
{
    5784:	48 89 e5             	mov    %rsp,%rbp
    if (!objectHandle || UNKNOWN_HANDLE(objectHandle))
    5787:	74 17                	je     57a0 <_DkObjectReference+0x20>
    5789:	8b 07                	mov    (%rdi),%eax
    578b:	83 e8 01             	sub    $0x1,%eax
    578e:	83 f8 10             	cmp    $0x10,%eax
    5791:	77 0d                	ja     57a0 <_DkObjectReference+0x20>
}


static inline void atomic_inc (struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "incl %0"
    5793:	f0 ff 47 04          	lock incl 0x4(%rdi)
        return -PAL_ERROR_INVAL;

    atomic_inc(&objectHandle->__in.ref);
    return 0;
    5797:	31 c0                	xor    %eax,%eax
}
    5799:	5d                   	pop    %rbp
    579a:	c3                   	retq   
    579b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
#include "api.h"

int _DkObjectReference (PAL_HANDLE objectHandle)
{
    if (!objectHandle || UNKNOWN_HANDLE(objectHandle))
        return -PAL_ERROR_INVAL;
    57a0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

    atomic_inc(&objectHandle->__in.ref);
    return 0;
}
    57a5:	5d                   	pop    %rbp
    57a6:	c3                   	retq   
    57a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    57ae:	00 00 

00000000000057b0 <DkObjectReference>:

void DkObjectReference (PAL_HANDLE objectHandle)
{
    57b0:	55                   	push   %rbp
    57b1:	48 89 e5             	mov    %rsp,%rbp
    57b4:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    57b8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    57bc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    57c3:	00 
    frame->retval = NULL;
    57c4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    57cb:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    57cc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    57d0:	48 8b 05 a9 e2 21 00 	mov    0x21e2a9(%rip),%rax        # 223a80 <_DYNAMIC+0x298>
    57d7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    57db:	48 8d 05 ab 31 01 00 	lea    0x131ab(%rip),%rax        # 1898d <handle_sizes.1924+0x20d>
    57e2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    57e6:	48 89 e0             	mov    %rsp,%rax
    57e9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    57ed:	48 89 e8             	mov    %rbp,%rax
    57f0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    57f4:	48 89 d8             	mov    %rbx,%rax
    57f7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    57fb:	48 89 f0             	mov    %rsi,%rax
    57fe:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    5802:	48 89 f8             	mov    %rdi,%rax
    5805:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    5809:	4c 89 e0             	mov    %r12,%rax
    580c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5810:	4c 89 e8             	mov    %r13,%rax
    5813:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    5817:	4c 89 f0             	mov    %r14,%rax
    581a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    581e:	4c 89 f8             	mov    %r15,%rax
    5821:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    store_frame(ObjectReference);

    int ret = _DkObjectReference(objectHandle);
    5825:	e8 56 ff ff ff       	callq  5780 <_DkObjectReference>

    if (ret < 0)
    582a:	85 c0                	test   %eax,%eax
    582c:	78 02                	js     5830 <DkObjectReference+0x80>
        notify_failure(-ret);
}
    582e:	c9                   	leaveq 
    582f:	c3                   	retq   
    5830:	c9                   	leaveq 
    store_frame(ObjectReference);

    int ret = _DkObjectReference(objectHandle);

    if (ret < 0)
        notify_failure(-ret);
    5831:	f7 d8                	neg    %eax
    5833:	48 63 f8             	movslq %eax,%rdi
    5836:	e9 15 f6 00 00       	jmpq   14e50 <notify_failure>
    583b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000005840 <_DkObjectClose>:
}

int _DkObjectClose (PAL_HANDLE objectHandle)
{
    5840:	55                   	push   %rbp
    if (!objectHandle || UNKNOWN_HANDLE(objectHandle))
    5841:	48 85 ff             	test   %rdi,%rdi
    if (ret < 0)
        notify_failure(-ret);
}

int _DkObjectClose (PAL_HANDLE objectHandle)
{
    5844:	48 89 e5             	mov    %rsp,%rbp
    if (!objectHandle || UNKNOWN_HANDLE(objectHandle))
    5847:	74 4b                	je     5894 <_DkObjectClose+0x54>
    5849:	8b 07                	mov    (%rdi),%eax
    584b:	83 e8 01             	sub    $0x1,%eax
    584e:	83 f8 10             	cmp    $0x10,%eax
    5851:	77 41                	ja     5894 <_DkObjectClose+0x54>

/* Return 0 if the value drops below zero, 1 if >= 0 */
static inline int atomic_dec_and_test_nonnegative (struct atomic_int * v)
{
    unsigned char c;
    asm volatile(LOCK_PREFIX "decl %0; setns %1"
    5853:	f0 ff 4f 04          	lock decl 0x4(%rdi)
    5857:	0f 99 c0             	setns  %al
        return -PAL_ERROR_INVAL;

    if (atomic_dec_and_test_nonnegative(&objectHandle->__in.ref))
    585a:	84 c0                	test   %al,%al
    585c:	75 32                	jne    5890 <_DkObjectClose+0x50>
        return 0;

    const struct handle_ops * ops = HANDLE_OPS(objectHandle);
    585e:	48 63 07             	movslq (%rdi),%rax
    5861:	8d 50 ff             	lea    -0x1(%rax),%edx
    5864:	83 fa 10             	cmp    $0x10,%edx
    5867:	77 1c                	ja     5885 <_DkObjectClose+0x45>
    5869:	48 8b 15 90 e1 21 00 	mov    0x21e190(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
    5870:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax

    /* if the operation 'close' is defined, call the function. */
    if (ops && ops->close)
    5874:	48 85 c0             	test   %rax,%rax
    5877:	74 0c                	je     5885 <_DkObjectClose+0x45>
    5879:	48 8b 40 38          	mov    0x38(%rax),%rax
    587d:	48 85 c0             	test   %rax,%rax
    5880:	74 03                	je     5885 <_DkObjectClose+0x45>
        return ops->close(objectHandle);

    free(objectHandle);
    return 0;
}
    5882:	5d                   	pop    %rbp

    const struct handle_ops * ops = HANDLE_OPS(objectHandle);

    /* if the operation 'close' is defined, call the function. */
    if (ops && ops->close)
        return ops->close(objectHandle);
    5883:	ff e0                	jmpq   *%rax

    free(objectHandle);
    5885:	e8 06 34 00 00       	callq  8c90 <free>
    return 0;
    588a:	31 c0                	xor    %eax,%eax
}
    588c:	5d                   	pop    %rbp
    588d:	c3                   	retq   
    588e:	66 90                	xchg   %ax,%ax
{
    if (!objectHandle || UNKNOWN_HANDLE(objectHandle))
        return -PAL_ERROR_INVAL;

    if (atomic_dec_and_test_nonnegative(&objectHandle->__in.ref))
        return 0;
    5890:	31 c0                	xor    %eax,%eax
    if (ops && ops->close)
        return ops->close(objectHandle);

    free(objectHandle);
    return 0;
}
    5892:	5d                   	pop    %rbp
    5893:	c3                   	retq   
}

int _DkObjectClose (PAL_HANDLE objectHandle)
{
    if (!objectHandle || UNKNOWN_HANDLE(objectHandle))
        return -PAL_ERROR_INVAL;
    5894:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    if (ops && ops->close)
        return ops->close(objectHandle);

    free(objectHandle);
    return 0;
}
    5899:	5d                   	pop    %rbp
    589a:	c3                   	retq   
    589b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000058a0 <DkObjectClose>:
/* PAL call DkObjectClose: Close the given object handle. This function is
   different from DkStreamDelete. It works on all kinds of handles, and it
   simply close the reference to the object, the stream is not actually
   deleted. */
void DkObjectClose (PAL_HANDLE objectHandle)
{
    58a0:	55                   	push   %rbp
    58a1:	48 89 e5             	mov    %rsp,%rbp
    58a4:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    58a8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    58ac:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    58b3:	00 
    frame->retval = NULL;
    58b4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    58bb:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    58bc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    58c0:	48 8b 05 49 e2 21 00 	mov    0x21e249(%rip),%rax        # 223b10 <_DYNAMIC+0x328>
    58c7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    58cb:	48 8d 05 cd 30 01 00 	lea    0x130cd(%rip),%rax        # 1899f <handle_sizes.1924+0x21f>
    58d2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    58d6:	48 89 e0             	mov    %rsp,%rax
    58d9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    58dd:	48 89 e8             	mov    %rbp,%rax
    58e0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    58e4:	48 89 d8             	mov    %rbx,%rax
    58e7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    58eb:	48 89 f0             	mov    %rsi,%rax
    58ee:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    58f2:	48 89 f8             	mov    %rdi,%rax
    58f5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    58f9:	4c 89 e0             	mov    %r12,%rax
    58fc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    5900:	4c 89 e8             	mov    %r13,%rax
    5903:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    5907:	4c 89 f0             	mov    %r14,%rax
    590a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    590e:	4c 89 f8             	mov    %r15,%rax
    5911:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    store_frame(ObjectClose);

    int ret = _DkObjectClose(objectHandle);
    5915:	e8 26 ff ff ff       	callq  5840 <_DkObjectClose>

    if (ret < 0)
    591a:	85 c0                	test   %eax,%eax
    591c:	78 02                	js     5920 <DkObjectClose+0x80>
        notify_failure(-ret);
}
    591e:	c9                   	leaveq 
    591f:	c3                   	retq   
    5920:	c9                   	leaveq 
    store_frame(ObjectClose);

    int ret = _DkObjectClose(objectHandle);

    if (ret < 0)
        notify_failure(-ret);
    5921:	f7 d8                	neg    %eax
    5923:	48 63 f8             	movslq %eax,%rdi
    5926:	e9 25 f5 00 00       	jmpq   14e50 <notify_failure>
    592b:	90                   	nop    
    592c:	90                   	nop    
    592d:	90                   	nop    
    592e:	90                   	nop    
    592f:	90                   	nop    

0000000000005930 <read_envs>:

    return 0;
}

static void read_envs (const char ** envp)
{
    5930:	55                   	push   %rbp
    5931:	48 89 e5             	mov    %rsp,%rbp
    5934:	41 57                	push   %r15
    5936:	41 56                	push   %r14
    5938:	41 55                	push   %r13
    593a:	41 54                	push   %r12
    593c:	53                   	push   %rbx
    593d:	48 81 ec 48 02 00 00 	sub    $0x248,%rsp
    if (!pal_config.root_config)
    5944:	48 8b 05 d5 e0 21 00 	mov    0x21e0d5(%rip),%rax        # 223a20 <_DYNAMIC+0x238>

    return 0;
}

static void read_envs (const char ** envp)
{
    594b:	48 89 bd b8 fd ff ff 	mov    %rdi,-0x248(%rbp)
    if (!pal_config.root_config)
    5952:	48 8b 78 20          	mov    0x20(%rax),%rdi
    5956:	48 85 ff             	test   %rdi,%rdi
    5959:	0f 84 13 03 00 00    	je     5c72 <read_envs+0x342>

    char cfgbuf[CONFIG_MAX];

   /* loader.env.* and loader.exclude.env: filtering host environment
     * variables */
    int nenvs = get_config_entries(pal_config.root_config, "loader.env", cfgbuf,
    595f:	48 8d 85 d0 fd ff ff 	lea    -0x230(%rbp),%rax
    5966:	48 8d 35 40 30 01 00 	lea    0x13040(%rip),%rsi        # 189ad <handle_sizes.1924+0x22d>
    596d:	b9 00 01 00 00       	mov    $0x100,%ecx
    5972:	48 89 c2             	mov    %rax,%rdx
    5975:	48 89 c3             	mov    %rax,%rbx
    5978:	48 89 85 c0 fd ff ff 	mov    %rax,-0x240(%rbp)
    597f:	e8 9c 25 01 00       	callq  17f20 <get_config_entries>
                                   CONFIG_MAX);
    printf("config -- %s",cfgbuf);
    5984:	48 8d 3d 2d 30 01 00 	lea    0x1302d(%rip),%rdi        # 189b8 <handle_sizes.1924+0x238>

    char cfgbuf[CONFIG_MAX];

   /* loader.env.* and loader.exclude.env: filtering host environment
     * variables */
    int nenvs = get_config_entries(pal_config.root_config, "loader.env", cfgbuf,
    598b:	41 89 c7             	mov    %eax,%r15d
    598e:	89 85 a0 fd ff ff    	mov    %eax,-0x260(%rbp)
                                   CONFIG_MAX);
    printf("config -- %s",cfgbuf);
    5994:	48 89 de             	mov    %rbx,%rsi
    5997:	31 c0                	xor    %eax,%eax
    5999:	e8 82 34 00 00       	callq  8e20 <pal_printf>

    if (nenvs > 0) {
    599e:	49 63 c7             	movslq %r15d,%rax
    59a1:	85 c0                	test   %eax,%eax
    59a3:	0f 8e c9 02 00 00    	jle    5c72 <read_envs+0x342>
        struct env { const char * str; int len, idx; } * envs
                                    = __alloca(sizeof(struct env) * nenvs);
    59a9:	48 c1 e0 04          	shl    $0x4,%rax
        char * cfg = cfgbuf;
        for (int i = 0 ; i < nenvs ; i++) {
            int len = strlen(cfg);
            char * str = __alloca(len + 1);
    59ad:	41 bc 10 00 00 00    	mov    $0x10,%r12d
    int nenvs = get_config_entries(pal_config.root_config, "loader.env", cfgbuf,
                                   CONFIG_MAX);
    printf("config -- %s",cfgbuf);

    if (nenvs > 0) {
        struct env { const char * str; int len, idx; } * envs
    59b3:	48 83 c0 10          	add    $0x10,%rax
    59b7:	48 29 c4             	sub    %rax,%rsp
    59ba:	44 89 f8             	mov    %r15d,%eax
    59bd:	4c 8d 74 24 0f       	lea    0xf(%rsp),%r14
    59c2:	83 e8 01             	sub    $0x1,%eax
    59c5:	48 89 85 98 fd ff ff 	mov    %rax,-0x268(%rbp)
    59cc:	48 c1 e0 04          	shl    $0x4,%rax
    59d0:	49 83 e6 f0          	and    $0xfffffffffffffff0,%r14
    59d4:	49 8d 44 06 18       	lea    0x18(%r14,%rax,1),%rax
    59d9:	4d 8d 6e 08          	lea    0x8(%r14),%r13
    59dd:	4c 89 b5 b0 fd ff ff 	mov    %r14,-0x250(%rbp)
    59e4:	48 89 85 a8 fd ff ff 	mov    %rax,-0x258(%rbp)
    59eb:	4d 89 ee             	mov    %r13,%r14
                                    = __alloca(sizeof(struct env) * nenvs);
        char * cfg = cfgbuf;
        for (int i = 0 ; i < nenvs ; i++) {
            int len = strlen(cfg);
            char * str = __alloca(len + 1);
    59ee:	4c 89 ad c8 fd ff ff 	mov    %r13,-0x238(%rbp)
    59f5:	49 89 c7             	mov    %rax,%r15
    59f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    59ff:	00 
    if (nenvs > 0) {
        struct env { const char * str; int len, idx; } * envs
                                    = __alloca(sizeof(struct env) * nenvs);
        char * cfg = cfgbuf;
        for (int i = 0 ; i < nenvs ; i++) {
            int len = strlen(cfg);
    5a00:	48 89 df             	mov    %rbx,%rdi
    5a03:	49 83 c6 10          	add    $0x10,%r14
    5a07:	e8 94 0d 01 00       	callq  167a0 <strlen>
            char * str = __alloca(len + 1);
    5a0c:	8d 70 01             	lea    0x1(%rax),%esi
    if (nenvs > 0) {
        struct env { const char * str; int len, idx; } * envs
                                    = __alloca(sizeof(struct env) * nenvs);
        char * cfg = cfgbuf;
        for (int i = 0 ; i < nenvs ; i++) {
            int len = strlen(cfg);
    5a0f:	49 89 c5             	mov    %rax,%r13
            char * str = __alloca(len + 1);
    5a12:	31 d2                	xor    %edx,%edx
            envs[i].str = str;
            envs[i].len = len;
    5a14:	45 89 6e f0          	mov    %r13d,-0x10(%r14)
            envs[i].idx = -1;
    5a18:	41 c7 46 f4 ff ff ff 	movl   $0xffffffff,-0xc(%r14)
    5a1f:	ff 
        struct env { const char * str; int len, idx; } * envs
                                    = __alloca(sizeof(struct env) * nenvs);
        char * cfg = cfgbuf;
        for (int i = 0 ; i < nenvs ; i++) {
            int len = strlen(cfg);
            char * str = __alloca(len + 1);
    5a20:	48 63 f6             	movslq %esi,%rsi
    5a23:	48 8d 46 1e          	lea    0x1e(%rsi),%rax
    5a27:	49 f7 f4             	div    %r12
            envs[i].str = str;
            envs[i].len = len;
            envs[i].idx = -1;
            memcpy(str, cfg, len + 1);
    5a2a:	48 89 f2             	mov    %rsi,%rdx
    5a2d:	48 89 de             	mov    %rbx,%rsi
        struct env { const char * str; int len, idx; } * envs
                                    = __alloca(sizeof(struct env) * nenvs);
        char * cfg = cfgbuf;
        for (int i = 0 ; i < nenvs ; i++) {
            int len = strlen(cfg);
            char * str = __alloca(len + 1);
    5a30:	48 c1 e0 04          	shl    $0x4,%rax
    5a34:	48 29 c4             	sub    %rax,%rsp
    5a37:	48 8d 7c 24 0f       	lea    0xf(%rsp),%rdi
    5a3c:	48 83 e7 f0          	and    $0xfffffffffffffff0,%rdi
            envs[i].str = str;
    5a40:	49 89 7e e8          	mov    %rdi,-0x18(%r14)
            envs[i].len = len;
            envs[i].idx = -1;
            memcpy(str, cfg, len + 1);
    5a44:	e8 37 08 01 00       	callq  16280 <memcpy>
            cfg += len + 1;
    5a49:	4d 63 c5             	movslq %r13d,%r8

    if (nenvs > 0) {
        struct env { const char * str; int len, idx; } * envs
                                    = __alloca(sizeof(struct env) * nenvs);
        char * cfg = cfgbuf;
        for (int i = 0 ; i < nenvs ; i++) {
    5a4c:	4d 39 fe             	cmp    %r15,%r14
            char * str = __alloca(len + 1);
            envs[i].str = str;
            envs[i].len = len;
            envs[i].idx = -1;
            memcpy(str, cfg, len + 1);
            cfg += len + 1;
    5a4f:	4a 8d 5c 03 01       	lea    0x1(%rbx,%r8,1),%rbx

    if (nenvs > 0) {
        struct env { const char * str; int len, idx; } * envs
                                    = __alloca(sizeof(struct env) * nenvs);
        char * cfg = cfgbuf;
        for (int i = 0 ; i < nenvs ; i++) {
    5a54:	75 aa                	jne    5a00 <read_envs+0xd0>
            memcpy(str, cfg, len + 1);
            cfg += len + 1;
        }

        int envc = 0, add = nenvs;
        for (const char ** e = envp ; *e ; e++) {
    5a56:	48 8b 85 b8 fd ff ff 	mov    -0x248(%rbp),%rax
    5a5d:	4c 8b ad c8 fd ff ff 	mov    -0x238(%rbp),%r13
    5a64:	48 8b 30             	mov    (%rax),%rsi
    5a67:	48 85 f6             	test   %rsi,%rsi
    5a6a:	0f 84 59 02 00 00    	je     5cc9 <read_envs+0x399>
    5a70:	4c 8b 8d 98 fd ff ff 	mov    -0x268(%rbp),%r9
    5a77:	48 8b 8d b0 fd ff ff 	mov    -0x250(%rbp),%rcx
    5a7e:	45 31 ff             	xor    %r15d,%r15d
    5a81:	4c 89 ad 98 fd ff ff 	mov    %r13,-0x268(%rbp)
    5a88:	49 89 c5             	mov    %rax,%r13
    5a8b:	49 83 c1 01          	add    $0x1,%r9
    5a8f:	49 c1 e1 04          	shl    $0x4,%r9
    5a93:	4e 8d 24 09          	lea    (%rcx,%r9,1),%r12
    5a97:	4d 89 e6             	mov    %r12,%r14
    5a9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            envc++;
    5aa0:	41 8d 47 01          	lea    0x1(%r15),%eax
            const char * p = *e;
            while (*p && *p != '=')
    5aa4:	49 89 f4             	mov    %rsi,%r12
            cfg += len + 1;
        }

        int envc = 0, add = nenvs;
        for (const char ** e = envp ; *e ; e++) {
            envc++;
    5aa7:	89 85 c8 fd ff ff    	mov    %eax,-0x238(%rbp)
            const char * p = *e;
            while (*p && *p != '=')
    5aad:	0f b6 06             	movzbl (%rsi),%eax
    5ab0:	3c 3d                	cmp    $0x3d,%al
    5ab2:	75 19                	jne    5acd <read_envs+0x19d>
    5ab4:	eb 1b                	jmp    5ad1 <read_envs+0x1a1>
    5ab6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    5abd:	00 00 00 
                p++;
    5ac0:	49 83 c4 01          	add    $0x1,%r12

        int envc = 0, add = nenvs;
        for (const char ** e = envp ; *e ; e++) {
            envc++;
            const char * p = *e;
            while (*p && *p != '=')
    5ac4:	41 0f b6 04 24       	movzbl (%r12),%eax
    5ac9:	3c 3d                	cmp    $0x3d,%al
    5acb:	74 04                	je     5ad1 <read_envs+0x1a1>
    5acd:	84 c0                	test   %al,%al
    5acf:	75 ef                	jne    5ac0 <read_envs+0x190>
    5ad1:	48 8b 9d b0 fd ff ff 	mov    -0x250(%rbp),%rbx
    5ad8:	eb 13                	jmp    5aed <read_envs+0x1bd>
    5ada:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    5ae0:	48 83 c3 10          	add    $0x10,%rbx
                p++;

            for (int i = 0 ; i < nenvs ; i++)
    5ae4:	4c 39 f3             	cmp    %r14,%rbx
    5ae7:	74 2a                	je     5b13 <read_envs+0x1e3>
    5ae9:	49 8b 75 00          	mov    0x0(%r13),%rsi
                if (envs[i].len == p - *e && !memcmp(envs[i].str, *e, p - *e)) {
    5aed:	48 63 53 08          	movslq 0x8(%rbx),%rdx
    5af1:	4c 89 e0             	mov    %r12,%rax
    5af4:	48 29 f0             	sub    %rsi,%rax
    5af7:	48 39 c2             	cmp    %rax,%rdx
    5afa:	75 e4                	jne    5ae0 <read_envs+0x1b0>
    5afc:	48 8b 3b             	mov    (%rbx),%rdi
    5aff:	e8 0c 08 01 00       	callq  16310 <memcmp>
    5b04:	85 c0                	test   %eax,%eax
    5b06:	75 d8                	jne    5ae0 <read_envs+0x1b0>
                    envs[i].idx = envc - 1;
                    add--;
    5b08:	83 ad a0 fd ff ff 01 	subl   $0x1,-0x260(%rbp)
            while (*p && *p != '=')
                p++;

            for (int i = 0 ; i < nenvs ; i++)
                if (envs[i].len == p - *e && !memcmp(envs[i].str, *e, p - *e)) {
                    envs[i].idx = envc - 1;
    5b0f:	44 89 7b 0c          	mov    %r15d,0xc(%rbx)
            memcpy(str, cfg, len + 1);
            cfg += len + 1;
        }

        int envc = 0, add = nenvs;
        for (const char ** e = envp ; *e ; e++) {
    5b13:	49 83 c5 08          	add    $0x8,%r13
    5b17:	49 8b 75 00          	mov    0x0(%r13),%rsi
            envc++;
    5b1b:	44 8b bd c8 fd ff ff 	mov    -0x238(%rbp),%r15d
            memcpy(str, cfg, len + 1);
            cfg += len + 1;
        }

        int envc = 0, add = nenvs;
        for (const char ** e = envp ; *e ; e++) {
    5b22:	48 85 f6             	test   %rsi,%rsi
    5b25:	0f 85 75 ff ff ff    	jne    5aa0 <read_envs+0x170>
                    add--;
                    break;
                }
        }

        if (add) {
    5b2b:	8b 95 a0 fd ff ff    	mov    -0x260(%rbp),%edx
    5b31:	4d 63 e7             	movslq %r15d,%r12
    5b34:	4c 8b ad 98 fd ff ff 	mov    -0x268(%rbp),%r13
    5b3b:	49 c1 e4 03          	shl    $0x3,%r12
            cfg += len + 1;
        }

        int envc = 0, add = nenvs;
        for (const char ** e = envp ; *e ; e++) {
            envc++;
    5b3f:	44 89 bd 98 fd ff ff 	mov    %r15d,-0x268(%rbp)
                    add--;
                    break;
                }
        }

        if (add) {
    5b46:	85 d2                	test   %edx,%edx
    5b48:	0f 85 88 01 00 00    	jne    5cd6 <read_envs+0x3a6>
            memcpy(new_envp, envp, sizeof(const char *) * envc);
            envp = new_envp;
            envp[envc + add] = NULL;
        }

        char key[CONFIG_MAX] = "loader.env.";
    5b4e:	48 b8 6c 6f 61 64 65 	mov    $0x652e726564616f6c,%rax
    5b55:	72 2e 65 
    5b58:	48 8d bd e0 fe ff ff 	lea    -0x120(%rbp),%rdi
    5b5f:	b9 1e 00 00 00       	mov    $0x1e,%ecx
    5b64:	48 89 85 d0 fe ff ff 	mov    %rax,-0x130(%rbp)
    5b6b:	31 c0                	xor    %eax,%eax
    5b6d:	48 c7 85 d8 fe ff ff 	movq   $0x2e766e,-0x128(%rbp)
    5b74:	6e 76 2e 00 
    5b78:	f3 48 ab             	rep stos %rax,%es:(%rdi)
    5b7b:	48 8d 85 d0 fe ff ff 	lea    -0x130(%rbp),%rax
    5b82:	48 89 85 b0 fd ff ff 	mov    %rax,-0x250(%rbp)
            const char * str = envs[i].str;
            int len = envs[i].len;
            int idx = envs[i].idx;
            int bytes;
            ptr = &envp[(idx == -1) ? envc++ : idx];
            memcpy(key + 11, str, len + 1);
    5b89:	48 83 c0 0b          	add    $0xb,%rax
    5b8d:	48 89 85 a0 fd ff ff 	mov    %rax,-0x260(%rbp)
    5b94:	e9 a1 00 00 00       	jmpq   5c3a <read_envs+0x30a>
    5b99:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    5ba0:	48 8b bd a0 fd ff ff 	mov    -0x260(%rbp),%rdi
    5ba7:	8d 53 01             	lea    0x1(%rbx),%edx
    5baa:	4c 89 f6             	mov    %r14,%rsi
        for (int i = 0 ; i < nenvs ; i++) {
            const char * str = envs[i].str;
            int len = envs[i].len;
            int idx = envs[i].idx;
            int bytes;
            ptr = &envp[(idx == -1) ? envc++ : idx];
    5bad:	4c 03 a5 b8 fd ff ff 	add    -0x248(%rbp),%r12
            memcpy(key + 11, str, len + 1);
    5bb4:	48 63 d2             	movslq %edx,%rdx
    5bb7:	e8 c4 06 01 00       	callq  16280 <memcpy>
            if ((bytes = get_config(pal_config.root_config, key, cfgbuf,
    5bbc:	48 8b 05 5d de 21 00 	mov    0x21de5d(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
    5bc3:	48 8b 95 c0 fd ff ff 	mov    -0x240(%rbp),%rdx
    5bca:	b9 00 01 00 00       	mov    $0x100,%ecx
    5bcf:	48 8b b5 b0 fd ff ff 	mov    -0x250(%rbp),%rsi
    5bd6:	48 8b 78 20          	mov    0x20(%rax),%rdi
    5bda:	e8 d1 22 01 00       	callq  17eb0 <get_config>
    5bdf:	85 c0                	test   %eax,%eax
    5be1:	0f 8e ac 00 00 00    	jle    5c93 <read_envs+0x363>
                                    CONFIG_MAX)) > 0) {
                char * e = malloc(len + bytes + 2);
    5be7:	8d 7c 03 02          	lea    0x2(%rbx,%rax,1),%edi
    5beb:	89 85 c8 fd ff ff    	mov    %eax,-0x238(%rbp)
    5bf1:	e8 0a 2e 00 00       	callq  8a00 <malloc>
                memcpy(e, str, len);
    5bf6:	48 89 da             	mov    %rbx,%rdx
    5bf9:	4c 89 f6             	mov    %r14,%rsi
    5bfc:	48 89 c7             	mov    %rax,%rdi
            int bytes;
            ptr = &envp[(idx == -1) ? envc++ : idx];
            memcpy(key + 11, str, len + 1);
            if ((bytes = get_config(pal_config.root_config, key, cfgbuf,
                                    CONFIG_MAX)) > 0) {
                char * e = malloc(len + bytes + 2);
    5bff:	49 89 c7             	mov    %rax,%r15
                memcpy(e, str, len);
    5c02:	e8 79 06 01 00       	callq  16280 <memcpy>
                e[len] = '=';
                memcpy(e + len + 1, cfgbuf, bytes + 1);
    5c07:	8b 8d c8 fd ff ff    	mov    -0x238(%rbp),%ecx
    5c0d:	48 8b b5 c0 fd ff ff 	mov    -0x240(%rbp),%rsi
    5c14:	49 8d 7c 1f 01       	lea    0x1(%r15,%rbx,1),%rdi
            memcpy(key + 11, str, len + 1);
            if ((bytes = get_config(pal_config.root_config, key, cfgbuf,
                                    CONFIG_MAX)) > 0) {
                char * e = malloc(len + bytes + 2);
                memcpy(e, str, len);
                e[len] = '=';
    5c19:	41 c6 04 1f 3d       	movb   $0x3d,(%r15,%rbx,1)
                memcpy(e + len + 1, cfgbuf, bytes + 1);
    5c1e:	8d 51 01             	lea    0x1(%rcx),%edx
    5c21:	48 63 d2             	movslq %edx,%rdx
    5c24:	e8 57 06 01 00       	callq  16280 <memcpy>
                *ptr = e;
    5c29:	4d 89 3c 24          	mov    %r15,(%r12)
    5c2d:	49 83 c5 10          	add    $0x10,%r13
        }

        char key[CONFIG_MAX] = "loader.env.";
        const char ** ptr;

        for (int i = 0 ; i < nenvs ; i++) {
    5c31:	4c 3b ad a8 fd ff ff 	cmp    -0x258(%rbp),%r13
    5c38:	74 38                	je     5c72 <read_envs+0x342>
            const char * str = envs[i].str;
            int len = envs[i].len;
            int idx = envs[i].idx;
    5c3a:	4d 63 65 04          	movslq 0x4(%r13),%r12

        char key[CONFIG_MAX] = "loader.env.";
        const char ** ptr;

        for (int i = 0 ; i < nenvs ; i++) {
            const char * str = envs[i].str;
    5c3e:	4d 8b 75 f8          	mov    -0x8(%r13),%r14
            int len = envs[i].len;
    5c42:	49 63 5d 00          	movslq 0x0(%r13),%rbx
            int idx = envs[i].idx;
    5c46:	4c 89 e0             	mov    %r12,%rax
            int bytes;
            ptr = &envp[(idx == -1) ? envc++ : idx];
    5c49:	49 c1 e4 03          	shl    $0x3,%r12
    5c4d:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    5c50:	0f 85 4a ff ff ff    	jne    5ba0 <read_envs+0x270>
    5c56:	4c 63 a5 98 fd ff ff 	movslq -0x268(%rbp),%r12
    5c5d:	4c 89 e0             	mov    %r12,%rax
    5c60:	49 c1 e4 03          	shl    $0x3,%r12
    5c64:	83 c0 01             	add    $0x1,%eax
    5c67:	89 85 98 fd ff ff    	mov    %eax,-0x268(%rbp)
    5c6d:	e9 2e ff ff ff       	jmpq   5ba0 <read_envs+0x270>
            }
        }
    }

done:
    pal_config.environments = envp;
    5c72:	48 8b 8d b8 fd ff ff 	mov    -0x248(%rbp),%rcx
    5c79:	48 8b 05 a0 dd 21 00 	mov    0x21dda0(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
    5c80:	48 89 48 30          	mov    %rcx,0x30(%rax)
}
    5c84:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    5c88:	5b                   	pop    %rbx
    5c89:	41 5c                	pop    %r12
    5c8b:	41 5d                	pop    %r13
    5c8d:	41 5e                	pop    %r14
    5c8f:	41 5f                	pop    %r15
    5c91:	5d                   	pop    %rbp
    5c92:	c3                   	retq   
                memcpy(e, str, len);
                e[len] = '=';
                memcpy(e + len + 1, cfgbuf, bytes + 1);
                *ptr = e;
            } else {
                char * e = malloc(len + 2);
    5c93:	8d 7b 02             	lea    0x2(%rbx),%edi
    5c96:	e8 65 2d 00 00       	callq  8a00 <malloc>
                memcpy(e, str, len);
    5c9b:	48 89 da             	mov    %rbx,%rdx
    5c9e:	4c 89 f6             	mov    %r14,%rsi
    5ca1:	48 89 c7             	mov    %rax,%rdi
    5ca4:	48 89 85 c8 fd ff ff 	mov    %rax,-0x238(%rbp)
    5cab:	e8 d0 05 01 00       	callq  16280 <memcpy>
                e[len] = '=';
    5cb0:	48 8b 8d c8 fd ff ff 	mov    -0x238(%rbp),%rcx
    5cb7:	c6 04 19 3d          	movb   $0x3d,(%rcx,%rbx,1)
                e[len + 1] = 0;
    5cbb:	c6 44 19 01 00       	movb   $0x0,0x1(%rcx,%rbx,1)
                *ptr = e;
    5cc0:	49 89 0c 24          	mov    %rcx,(%r12)
    5cc4:	e9 64 ff ff ff       	jmpq   5c2d <read_envs+0x2fd>
            memcpy(str, cfg, len + 1);
            cfg += len + 1;
        }

        int envc = 0, add = nenvs;
        for (const char ** e = envp ; *e ; e++) {
    5cc9:	45 31 e4             	xor    %r12d,%r12d
    5ccc:	c7 85 98 fd ff ff 00 	movl   $0x0,-0x268(%rbp)
    5cd3:	00 00 00 
                }
        }

        if (add) {
            const char ** new_envp =
                        malloc(sizeof(const char *) * (envc + add + 1));
    5cd6:	8b 9d a0 fd ff ff    	mov    -0x260(%rbp),%ebx
    5cdc:	03 9d 98 fd ff ff    	add    -0x268(%rbp),%ebx
    5ce2:	8d 3c dd 08 00 00 00 	lea    0x8(,%rbx,8),%edi
            memcpy(new_envp, envp, sizeof(const char *) * envc);
            envp = new_envp;
            envp[envc + add] = NULL;
    5ce9:	48 63 db             	movslq %ebx,%rbx
                    break;
                }
        }

        if (add) {
            const char ** new_envp =
    5cec:	e8 0f 2d 00 00       	callq  8a00 <malloc>
                        malloc(sizeof(const char *) * (envc + add + 1));
            memcpy(new_envp, envp, sizeof(const char *) * envc);
    5cf1:	48 8b b5 b8 fd ff ff 	mov    -0x248(%rbp),%rsi
                    break;
                }
        }

        if (add) {
            const char ** new_envp =
    5cf8:	49 89 c6             	mov    %rax,%r14
                        malloc(sizeof(const char *) * (envc + add + 1));
            memcpy(new_envp, envp, sizeof(const char *) * envc);
    5cfb:	4c 89 e2             	mov    %r12,%rdx
    5cfe:	48 89 c7             	mov    %rax,%rdi
    5d01:	e8 7a 05 01 00       	callq  16280 <memcpy>
            envp = new_envp;
            envp[envc + add] = NULL;
    5d06:	49 c7 04 de 00 00 00 	movq   $0x0,(%r14,%rbx,8)
    5d0d:	00 

        if (add) {
            const char ** new_envp =
                        malloc(sizeof(const char *) * (envc + add + 1));
            memcpy(new_envp, envp, sizeof(const char *) * envc);
            envp = new_envp;
    5d0e:	4c 89 b5 b8 fd ff ff 	mov    %r14,-0x248(%rbp)
    5d15:	e9 34 fe ff ff       	jmpq   5b4e <read_envs+0x21e>
    5d1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000005d20 <pal_control_addr>:
/* allocate memory for page size constants */
PAL_NUM allocsize, allocshift, allocmask;

PAL_CONTROL __pal_control;
PAL_CONTROL * pal_control_addr (void)
{
    5d20:	55                   	push   %rbp
    return &__pal_control;
}
    5d21:	48 8b 05 50 de 21 00 	mov    0x21de50(%rip),%rax        # 223b78 <_DYNAMIC+0x390>
/* allocate memory for page size constants */
PAL_NUM allocsize, allocshift, allocmask;

PAL_CONTROL __pal_control;
PAL_CONTROL * pal_control_addr (void)
{
    5d28:	48 89 e5             	mov    %rsp,%rbp
    return &__pal_control;
}
    5d2b:	5d                   	pop    %rbp
    5d2c:	c3                   	retq   
    5d2d:	0f 1f 00             	nopl   (%rax)

0000000000005d30 <load_libraries>:
#define leave \
    do { printf("PAL terminated at " __FILE__ ":%d\n", __LINE__); \
         _DkProcessExit(1); } while (0)

int load_libraries (struct config_store * root_config, const char ** msg)
{
    5d30:	55                   	push   %rbp
    char cfgbuf[CONFIG_MAX];
    int len, ret = 0;

    /* loader.preload: any other libraries to preload. The can be multiple
       URIs, seperated by commas */
    if ((len = get_config(root_config, "loader.preload", cfgbuf,
    5d31:	b9 00 01 00 00       	mov    $0x100,%ecx
#define leave \
    do { printf("PAL terminated at " __FILE__ ":%d\n", __LINE__); \
         _DkProcessExit(1); } while (0)

int load_libraries (struct config_store * root_config, const char ** msg)
{
    5d36:	48 89 e5             	mov    %rsp,%rbp
    5d39:	41 54                	push   %r12
    5d3b:	53                   	push   %rbx
    char cfgbuf[CONFIG_MAX];
    int len, ret = 0;

    /* loader.preload: any other libraries to preload. The can be multiple
       URIs, seperated by commas */
    if ((len = get_config(root_config, "loader.preload", cfgbuf,
    5d3c:	48 8d 9d f0 fe ff ff 	lea    -0x110(%rbp),%rbx
#define leave \
    do { printf("PAL terminated at " __FILE__ ":%d\n", __LINE__); \
         _DkProcessExit(1); } while (0)

int load_libraries (struct config_store * root_config, const char ** msg)
{
    5d43:	49 89 f4             	mov    %rsi,%r12
    char cfgbuf[CONFIG_MAX];
    int len, ret = 0;

    /* loader.preload: any other libraries to preload. The can be multiple
       URIs, seperated by commas */
    if ((len = get_config(root_config, "loader.preload", cfgbuf,
    5d46:	48 8d 35 78 2c 01 00 	lea    0x12c78(%rip),%rsi        # 189c5 <handle_sizes.1924+0x245>
#define leave \
    do { printf("PAL terminated at " __FILE__ ":%d\n", __LINE__); \
         _DkProcessExit(1); } while (0)

int load_libraries (struct config_store * root_config, const char ** msg)
{
    5d4d:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
    char cfgbuf[CONFIG_MAX];
    int len, ret = 0;

    /* loader.preload: any other libraries to preload. The can be multiple
       URIs, seperated by commas */
    if ((len = get_config(root_config, "loader.preload", cfgbuf,
    5d54:	48 89 da             	mov    %rbx,%rdx
    5d57:	e8 54 21 01 00       	callq  17eb0 <get_config>
    5d5c:	85 c0                	test   %eax,%eax
    5d5e:	48 89 df             	mov    %rbx,%rdi
    5d61:	7e 4d                	jle    5db0 <load_libraries+0x80>
                          CONFIG_MAX)) > 0) {
        char * c = cfgbuf, * token = c;
        do {
            if (*c == ',' || !(*(c))) {
    5d63:	0f b6 03             	movzbl (%rbx),%eax
    5d66:	84 c0                	test   %al,%al
    5d68:	74 0f                	je     5d79 <load_libraries+0x49>
    5d6a:	3c 2c                	cmp    $0x2c,%al
    5d6c:	74 0b                	je     5d79 <load_libraries+0x49>
    5d6e:	48 83 c3 01          	add    $0x1,%rbx
    5d72:	0f b6 03             	movzbl (%rbx),%eax
    5d75:	84 c0                	test   %al,%al
    5d77:	75 f1                	jne    5d6a <load_libraries+0x3a>
                if (c > token) {
    5d79:	48 39 fb             	cmp    %rdi,%rbx
    5d7c:	77 12                	ja     5d90 <load_libraries+0x60>
                            *msg = "Unable to load preload library\n";
                        return ret;
                    }
                }

                token = c + 1;
    5d7e:	48 83 c3 01          	add    $0x1,%rbx
            }
        } while (*(c++));
    5d82:	84 c0                	test   %al,%al
    5d84:	74 2a                	je     5db0 <load_libraries+0x80>
                            *msg = "Unable to load preload library\n";
                        return ret;
                    }
                }

                token = c + 1;
    5d86:	48 89 df             	mov    %rbx,%rdi
    5d89:	eb d8                	jmp    5d63 <load_libraries+0x33>
    5d8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                          CONFIG_MAX)) > 0) {
        char * c = cfgbuf, * token = c;
        do {
            if (*c == ',' || !(*(c))) {
                if (c > token) {
                    *c = 0;
    5d90:	c6 03 00             	movb   $0x0,(%rbx)
                    if ((ret = load_elf_object(token, OBJECT_PRELOAD)) < 0) {
    5d93:	be 02 00 00 00       	mov    $0x2,%esi
    5d98:	e8 d3 27 00 00       	callq  8570 <load_elf_object>
    5d9d:	85 c0                	test   %eax,%eax
    5d9f:	78 1d                	js     5dbe <load_libraries+0x8e>
    5da1:	0f b6 03             	movzbl (%rbx),%eax
                            *msg = "Unable to load preload library\n";
                        return ret;
                    }
                }

                token = c + 1;
    5da4:	48 83 c3 01          	add    $0x1,%rbx
            }
        } while (*(c++));
    5da8:	84 c0                	test   %al,%al
    5daa:	75 da                	jne    5d86 <load_libraries+0x56>
    5dac:	0f 1f 40 00          	nopl   0x0(%rax)
    }

    return 0;
    5db0:	31 c0                	xor    %eax,%eax
}
    5db2:	48 81 c4 00 01 00 00 	add    $0x100,%rsp
    5db9:	5b                   	pop    %rbx
    5dba:	41 5c                	pop    %r12
    5dbc:	5d                   	pop    %rbp
    5dbd:	c3                   	retq   
        do {
            if (*c == ',' || !(*(c))) {
                if (c > token) {
                    *c = 0;
                    if ((ret = load_elf_object(token, OBJECT_PRELOAD)) < 0) {
                        if (msg)
    5dbe:	4d 85 e4             	test   %r12,%r12
    5dc1:	74 ef                	je     5db2 <load_libraries+0x82>
                            *msg = "Unable to load preload library\n";
    5dc3:	48 8d 15 86 2e 01 00 	lea    0x12e86(%rip),%rdx        # 18c50 <handle_sizes.1924+0x4d0>
    5dca:	49 89 14 24          	mov    %rdx,(%r12)
                        return ret;
    5dce:	eb e2                	jmp    5db2 <load_libraries+0x82>

0000000000005dd0 <pal_main>:
}

void start_execution (int argc, const char ** argv);

void pal_main (int argc, const char ** argv, const char ** envp)
{
    5dd0:	55                   	push   %rbp
    5dd1:	48 89 e5             	mov    %rsp,%rbp
    5dd4:	41 57                	push   %r15
    5dd6:	41 56                	push   %r14
    5dd8:	41 55                	push   %r13
    5dda:	41 54                	push   %r12
    5ddc:	49 89 d5             	mov    %rdx,%r13
    5ddf:	53                   	push   %rbx
    5de0:	48 81 ec 38 01 00 00 	sub    $0x138,%rsp
    5de7:	89 bd bc fe ff ff    	mov    %edi,-0x144(%rbp)
    5ded:	48 89 b5 b0 fe ff ff 	mov    %rsi,-0x150(%rbp)
    char cfgbuf[CONFIG_MAX];
    int ret;

    pal_config.pagesize    = _DkGetPagesize();
    5df4:	e8 27 cf 00 00       	callq  12d20 <_DkGetPagesize>
    5df9:	48 8b 1d 20 dc 21 00 	mov    0x21dc20(%rip),%rbx        # 223a20 <_DYNAMIC+0x238>
    5e00:	48 89 43 38          	mov    %rax,0x38(%rbx)
    pal_config.alloc_align = _DkGetAllocationAlignment();
    5e04:	e8 27 cf 00 00       	callq  12d30 <_DkGetAllocationAlignment>

    /* some constants for page manipulation and allocation alignment */
    allocsize  = pal_config.alloc_align;
    5e09:	4c 8b 3d 80 db 21 00 	mov    0x21db80(%rip),%r15        # 223990 <_DYNAMIC+0x1a8>
    allocshift = allocsize - 1;
    5e10:	48 8b 0d 31 dd 21 00 	mov    0x21dd31(%rip),%rcx        # 223b48 <_DYNAMIC+0x360>
{
    char cfgbuf[CONFIG_MAX];
    int ret;

    pal_config.pagesize    = _DkGetPagesize();
    pal_config.alloc_align = _DkGetAllocationAlignment();
    5e17:	48 89 43 40          	mov    %rax,0x40(%rbx)

    /* some constants for page manipulation and allocation alignment */
    allocsize  = pal_config.alloc_align;
    5e1b:	49 89 07             	mov    %rax,(%r15)
    allocshift = allocsize - 1;
    5e1e:	48 83 e8 01          	sub    $0x1,%rax
    5e22:	48 89 01             	mov    %rax,(%rcx)
    allocmask  = ~allocshift;
    5e25:	48 8b 0d cc dc 21 00 	mov    0x21dccc(%rip),%rcx        # 223af8 <_DYNAMIC+0x310>
    5e2c:	48 f7 d0             	not    %rax
    5e2f:	48 89 01             	mov    %rax,(%rcx)

    init_slab_mgr();
    5e32:	e8 89 2a 00 00       	callq  88c0 <init_slab_mgr>

    /* reloaction of loader is done here. starting from this point, the global
       symbols of loader should be accessible. */
    pal_config.lib_text_start = (void *) &text_start;
    pal_config.lib_text_end   = (void *) &text_end;
    5e37:	48 8b 05 9a db 21 00 	mov    0x21db9a(%rip),%rax        # 2239d8 <_DYNAMIC+0x1f0>
    pal_config.lib_data_start = (void *) &data_start;
    pal_config.lib_data_end   = (void *) &data_end;

    __pal_control.pagesize      = pal_config.pagesize;
    5e3e:	4c 8b 25 33 dd 21 00 	mov    0x21dd33(%rip),%r12        # 223b78 <_DYNAMIC+0x390>
     *     pal_config.manifest_handle
     *     pal_config.exec
     *     pal_config.exec_handle
     *     pal_config.root_config
     */
    if (_DkInitHost(&argc, &argv) < 0)
    5e45:	48 8d b5 b0 fe ff ff 	lea    -0x150(%rbp),%rsi
    pal_config.lib_text_start = (void *) &text_start;
    pal_config.lib_text_end   = (void *) &text_end;
    pal_config.lib_data_start = (void *) &data_start;
    pal_config.lib_data_end   = (void *) &data_end;

    __pal_control.pagesize      = pal_config.pagesize;
    5e4c:	48 8b 4b 38          	mov    0x38(%rbx),%rcx

    init_slab_mgr();

    /* reloaction of loader is done here. starting from this point, the global
       symbols of loader should be accessible. */
    pal_config.lib_text_start = (void *) &text_start;
    5e50:	48 8b 15 61 dc 21 00 	mov    0x21dc61(%rip),%rdx        # 223ab8 <_DYNAMIC+0x2d0>
     *     pal_config.manifest_handle
     *     pal_config.exec
     *     pal_config.exec_handle
     *     pal_config.root_config
     */
    if (_DkInitHost(&argc, &argv) < 0)
    5e57:	48 8d bd bc fe ff ff 	lea    -0x144(%rbp),%rdi
    init_slab_mgr();

    /* reloaction of loader is done here. starting from this point, the global
       symbols of loader should be accessible. */
    pal_config.lib_text_start = (void *) &text_start;
    pal_config.lib_text_end   = (void *) &text_end;
    5e5e:	48 89 43 60          	mov    %rax,0x60(%rbx)
    pal_config.lib_data_start = (void *) &data_start;
    5e62:	48 8b 05 57 dc 21 00 	mov    0x21dc57(%rip),%rax        # 223ac0 <_DYNAMIC+0x2d8>
    pal_config.lib_data_end   = (void *) &data_end;

    __pal_control.pagesize      = pal_config.pagesize;
    5e69:	49 89 4c 24 30       	mov    %rcx,0x30(%r12)
    __pal_control.alloc_align   = allocsize;
    5e6e:	49 8b 0f             	mov    (%r15),%rcx

    init_slab_mgr();

    /* reloaction of loader is done here. starting from this point, the global
       symbols of loader should be accessible. */
    pal_config.lib_text_start = (void *) &text_start;
    5e71:	48 89 53 58          	mov    %rdx,0x58(%rbx)
    pal_config.lib_data_start = (void *) &data_start;
    pal_config.lib_data_end   = (void *) &data_end;

    __pal_control.pagesize      = pal_config.pagesize;
    __pal_control.alloc_align   = allocsize;
    __pal_control.library_begin = &text_start;
    5e75:	49 89 54 24 20       	mov    %rdx,0x20(%r12)

    /* reloaction of loader is done here. starting from this point, the global
       symbols of loader should be accessible. */
    pal_config.lib_text_start = (void *) &text_start;
    pal_config.lib_text_end   = (void *) &text_end;
    pal_config.lib_data_start = (void *) &data_start;
    5e7a:	48 89 43 68          	mov    %rax,0x68(%rbx)
    pal_config.lib_data_end   = (void *) &data_end;
    5e7e:	48 8b 05 fb dc 21 00 	mov    0x21dcfb(%rip),%rax        # 223b80 <_DYNAMIC+0x398>

    __pal_control.pagesize      = pal_config.pagesize;
    __pal_control.alloc_align   = allocsize;
    5e85:	49 89 4c 24 38       	mov    %rcx,0x38(%r12)
    /* reloaction of loader is done here. starting from this point, the global
       symbols of loader should be accessible. */
    pal_config.lib_text_start = (void *) &text_start;
    pal_config.lib_text_end   = (void *) &text_end;
    pal_config.lib_data_start = (void *) &data_start;
    pal_config.lib_data_end   = (void *) &data_end;
    5e8a:	48 89 43 70          	mov    %rax,0x70(%rbx)

    __pal_control.pagesize      = pal_config.pagesize;
    __pal_control.alloc_align   = allocsize;
    __pal_control.library_begin = &text_start;
    __pal_control.library_end   = &data_end;
    5e8e:	49 89 44 24 28       	mov    %rax,0x28(%r12)
     *     pal_config.manifest_handle
     *     pal_config.exec
     *     pal_config.exec_handle
     *     pal_config.root_config
     */
    if (_DkInitHost(&argc, &argv) < 0)
    5e93:	e8 e8 d9 00 00       	callq  13880 <_DkInitHost>
    5e98:	85 c0                	test   %eax,%eax
    5e9a:	0f 88 b0 02 00 00    	js     6150 <pal_main+0x380>
        leave;
    //printf("Arguments: db_main : %s\n",argv);
    __pal_control.manifest_handle = pal_config.manifest_handle;
    5ea0:	48 8b 43 10          	mov    0x10(%rbx),%rax
    __pal_control.executable = pal_config.exec;

    /* all of the preloaded libraries are loaded,
       time to play with executable */
    if (pal_config.exec_handle) {
    5ea4:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
     *     pal_config.root_config
     */
    if (_DkInitHost(&argc, &argv) < 0)
        leave;
    //printf("Arguments: db_main : %s\n",argv);
    __pal_control.manifest_handle = pal_config.manifest_handle;
    5ea8:	49 89 04 24          	mov    %rax,(%r12)
    __pal_control.executable = pal_config.exec;
    5eac:	48 8b 43 08          	mov    0x8(%rbx),%rax

    /* all of the preloaded libraries are loaded,
       time to play with executable */
    if (pal_config.exec_handle) {
    5eb0:	48 85 ff             	test   %rdi,%rdi
     */
    if (_DkInitHost(&argc, &argv) < 0)
        leave;
    //printf("Arguments: db_main : %s\n",argv);
    __pal_control.manifest_handle = pal_config.manifest_handle;
    __pal_control.executable = pal_config.exec;
    5eb3:	49 89 44 24 08       	mov    %rax,0x8(%r12)

    /* all of the preloaded libraries are loaded,
       time to play with executable */
    if (pal_config.exec_handle) {
    5eb8:	74 12                	je     5ecc <pal_main+0xfc>
        ret = load_elf_object_by_handle(pal_config.exec_handle, OBJECT_EXEC);
    5eba:	be 01 00 00 00       	mov    $0x1,%esi
    5ebf:	e8 6c 21 00 00       	callq  8030 <load_elf_object_by_handle>

        if (ret < 0) {
    5ec4:	85 c0                	test   %eax,%eax
    5ec6:	0f 88 34 02 00 00    	js     6100 <pal_main+0x330>
            printf("Unable to load executable (%d)\n", PAL_STRERROR(ret));
            leave;
        }
    }

    read_envs(envp);
    5ecc:	4c 89 ef             	mov    %r13,%rdi
    5ecf:	e8 5c fa ff ff       	callq  5930 <read_envs>

    if (!pal_config.heap_base)
    5ed4:	4c 8b 53 50          	mov    0x50(%rbx),%r10
    5ed8:	4d 85 d2             	test   %r10,%r10
    5edb:	0f 84 cf 02 00 00    	je     61b0 <pal_main+0x3e0>
        pal_config.heap_base = find_heap_base();

    if (pal_config.root_config) {
    5ee1:	4c 8b 6b 20          	mov    0x20(%rbx),%r13
    5ee5:	4d 85 ed             	test   %r13,%r13
    5ee8:	0f 84 0c 01 00 00    	je     5ffa <pal_main+0x22a>
        struct config_store * cfg = pal_config.root_config;
        const char * msg;

        if (load_libraries(cfg, &msg) < 0) {
    5eee:	48 8d b5 c0 fe ff ff 	lea    -0x140(%rbp),%rsi
    5ef5:	4c 89 ef             	mov    %r13,%rdi
    5ef8:	e8 33 fe ff ff       	callq  5d30 <load_libraries>
    5efd:	85 c0                	test   %eax,%eax
    5eff:	0f 88 6d 02 00 00    	js     6172 <pal_main+0x3a2>
            printf("%s\n", msg);
            leave;
        }

        if (get_config(cfg, "loader.daemonize", cfgbuf,
    5f05:	4c 8d b5 d0 fe ff ff 	lea    -0x130(%rbp),%r14
    5f0c:	48 8d 35 e7 2a 01 00 	lea    0x12ae7(%rip),%rsi        # 189fa <handle_sizes.1924+0x27a>
    5f13:	b9 00 01 00 00       	mov    $0x100,%ecx
    5f18:	4c 89 ef             	mov    %r13,%rdi
    5f1b:	4c 89 f2             	mov    %r14,%rdx
    5f1e:	e8 8d 1f 01 00       	callq  17eb0 <get_config>
    5f23:	85 c0                	test   %eax,%eax
    5f25:	7e 0d                	jle    5f34 <pal_main+0x164>
                       CONFIG_MAX) > 0 &&
    5f27:	80 bd d0 fe ff ff 31 	cmpb   $0x31,-0x130(%rbp)
    5f2e:	0f 84 ae 01 00 00    	je     60e2 <pal_main+0x312>
            cfgbuf[0] == '1' && !cfgbuf[1])
            pal_config.daemonize = true;

        if (get_config(cfg, "loader.debug_type", cfgbuf,
    5f34:	48 8d 35 d0 2a 01 00 	lea    0x12ad0(%rip),%rsi        # 18a0b <handle_sizes.1924+0x28b>
    5f3b:	b9 00 01 00 00       	mov    $0x100,%ecx
    5f40:	4c 89 f2             	mov    %r14,%rdx
    5f43:	4c 89 ef             	mov    %r13,%rdi
    5f46:	e8 65 1f 01 00       	callq  17eb0 <get_config>
    5f4b:	85 c0                	test   %eax,%eax
    5f4d:	7e 53                	jle    5fa2 <pal_main+0x1d2>
                       CONFIG_MAX) > 0) {
            PAL_HANDLE handle = NULL;

            if (!memcmp(cfgbuf, "inline", 7)) {
    5f4f:	48 8d 35 c7 2a 01 00 	lea    0x12ac7(%rip),%rsi        # 18a1d <handle_sizes.1924+0x29d>
    5f56:	ba 07 00 00 00       	mov    $0x7,%edx
    5f5b:	4c 89 f7             	mov    %r14,%rdi
            cfgbuf[0] == '1' && !cfgbuf[1])
            pal_config.daemonize = true;

        if (get_config(cfg, "loader.debug_type", cfgbuf,
                       CONFIG_MAX) > 0) {
            PAL_HANDLE handle = NULL;
    5f5e:	48 c7 85 c8 fe ff ff 	movq   $0x0,-0x138(%rbp)
    5f65:	00 00 00 00 

            if (!memcmp(cfgbuf, "inline", 7)) {
    5f69:	e8 a2 03 01 00       	callq  16310 <memcmp>
    5f6e:	85 c0                	test   %eax,%eax
    5f70:	0f 85 0a 01 00 00    	jne    6080 <pal_main+0x2b0>
                _DkStreamOpen(&handle, "dev:tty", PAL_ACCESS_RDWR, 0, 0, 0);
    5f76:	48 8d bd c8 fe ff ff 	lea    -0x138(%rbp),%rdi
    5f7d:	48 8d 35 a0 2a 01 00 	lea    0x12aa0(%rip),%rsi        # 18a24 <handle_sizes.1924+0x2a4>
    5f84:	45 31 c9             	xor    %r9d,%r9d
    5f87:	45 31 c0             	xor    %r8d,%r8d
    5f8a:	31 c9                	xor    %ecx,%ecx
    5f8c:	ba 02 00 00 00       	mov    $0x2,%edx
    5f91:	e8 9a d9 ff ff       	callq  3930 <_DkStreamOpen>
                                  PAL_SHARE_OWNER_R|PAL_SHARE_OWNER_W,
                                  PAL_CREAT_TRY, 0);
                }
            }

            __pal_control.debug_stream = handle;
    5f96:	48 8b 85 c8 fe ff ff 	mov    -0x138(%rbp),%rax
    5f9d:	49 89 44 24 50       	mov    %rax,0x50(%r12)
        }

        if ((ret = get_config(cfg, "loader.syscall_symbol", cfgbuf,
    5fa2:	48 8d 35 95 2a 01 00 	lea    0x12a95(%rip),%rsi        # 18a3e <handle_sizes.1924+0x2be>
    5fa9:	b9 00 01 00 00       	mov    $0x100,%ecx
    5fae:	4c 89 f2             	mov    %r14,%rdx
    5fb1:	4c 89 ef             	mov    %r13,%rdi
    5fb4:	e8 f7 1e 01 00       	callq  17eb0 <get_config>
    5fb9:	85 c0                	test   %eax,%eax
    5fbb:	7e 12                	jle    5fcf <pal_main+0x1ff>
                              CONFIG_MAX)) > 0)
            pal_config.syscall_sym_name = remalloc(cfgbuf, ret + 1);
    5fbd:	8d 70 01             	lea    0x1(%rax),%esi
    5fc0:	4c 89 f7             	mov    %r14,%rdi
    5fc3:	e8 38 2c 00 00       	callq  8c00 <remalloc>
    5fc8:	48 89 83 80 00 00 00 	mov    %rax,0x80(%rbx)

        free_config(cfg);
    5fcf:	4c 89 ef             	mov    %r13,%rdi
    5fd2:	e8 a9 24 01 00       	callq  18480 <free_config>
        _DkStreamUnmap(cfg->raw_data, ALLOC_ALIGNUP(cfg->raw_size));
    5fd7:	49 83 3f 00          	cmpq   $0x0,(%r15)
    5fdb:	49 8b 75 28          	mov    0x28(%r13),%rsi
    5fdf:	75 7f                	jne    6060 <pal_main+0x290>
    5fe1:	49 8b 7d 20          	mov    0x20(%r13),%rdi
    5fe5:	e8 16 98 00 00       	callq  f800 <_DkStreamUnmap>
        free(cfg);
    5fea:	4c 89 ef             	mov    %r13,%rdi
    5fed:	e8 9e 2c 00 00       	callq  8c90 <free>
        pal_config.root_config = NULL;
    5ff2:	48 c7 43 20 00 00 00 	movq   $0x0,0x20(%rbx)
    5ff9:	00 
    }

    __pal_control.manifest_handle = pal_config.manifest_handle;
    5ffa:	48 8b 43 10          	mov    0x10(%rbx),%rax
    __pal_control.executable = pal_config.exec;

    /* Now we will start the execution */
    start_execution(argc, argv);
    5ffe:	48 8b b5 b0 fe ff ff 	mov    -0x150(%rbp),%rsi
    6005:	8b bd bc fe ff ff    	mov    -0x144(%rbp),%edi
        _DkStreamUnmap(cfg->raw_data, ALLOC_ALIGNUP(cfg->raw_size));
        free(cfg);
        pal_config.root_config = NULL;
    }

    __pal_control.manifest_handle = pal_config.manifest_handle;
    600b:	49 89 04 24          	mov    %rax,(%r12)
    __pal_control.executable = pal_config.exec;
    600f:	48 8b 43 08          	mov    0x8(%rbx),%rax
    6013:	49 89 44 24 08       	mov    %rax,0x8(%r12)

    /* Now we will start the execution */
    start_execution(argc, argv);
    6018:	e8 d3 25 00 00       	callq  85f0 <start_execution>

    /* We wish we will never reached here */
    printf("unexpected termination\n");
    601d:	48 8d 3d 30 2a 01 00 	lea    0x12a30(%rip),%rdi        # 18a54 <handle_sizes.1924+0x2d4>
    6024:	31 c0                	xor    %eax,%eax
    6026:	e8 f5 2d 00 00       	callq  8e20 <pal_printf>
    leave;
    602b:	48 8d 3d 3e 2c 01 00 	lea    0x12c3e(%rip),%rdi        # 18c70 <handle_sizes.1924+0x4f0>
    6032:	be 40 01 00 00       	mov    $0x140,%esi
    6037:	31 c0                	xor    %eax,%eax
    6039:	e8 e2 2d 00 00       	callq  8e20 <pal_printf>
    603e:	bf 01 00 00 00       	mov    $0x1,%edi
    6043:	e8 38 c5 00 00       	callq  12580 <_DkProcessExit>
}
    6048:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    604c:	5b                   	pop    %rbx
    604d:	41 5c                	pop    %r12
    604f:	41 5d                	pop    %r13
    6051:	41 5e                	pop    %r14
    6053:	41 5f                	pop    %r15
    6055:	5d                   	pop    %rbp
    6056:	c3                   	retq   
    6057:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    605e:	00 00 
        if ((ret = get_config(cfg, "loader.syscall_symbol", cfgbuf,
                              CONFIG_MAX)) > 0)
            pal_config.syscall_sym_name = remalloc(cfgbuf, ret + 1);

        free_config(cfg);
        _DkStreamUnmap(cfg->raw_data, ALLOC_ALIGNUP(cfg->raw_size));
    6060:	48 8b 05 e1 da 21 00 	mov    0x21dae1(%rip),%rax        # 223b48 <_DYNAMIC+0x360>
    6067:	48 03 30             	add    (%rax),%rsi
    606a:	48 8b 05 87 da 21 00 	mov    0x21da87(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    6071:	48 23 30             	and    (%rax),%rsi
    6074:	e9 68 ff ff ff       	jmpq   5fe1 <pal_main+0x211>
    6079:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                       CONFIG_MAX) > 0) {
            PAL_HANDLE handle = NULL;

            if (!memcmp(cfgbuf, "inline", 7)) {
                _DkStreamOpen(&handle, "dev:tty", PAL_ACCESS_RDWR, 0, 0, 0);
            } else if (!memcmp(cfgbuf, "file", 5)) {
    6080:	48 8d 35 2e 98 01 00 	lea    0x1982e(%rip),%rsi        # 1f8b5 <sys_nerr_internal+0x779>
    6087:	ba 05 00 00 00       	mov    $0x5,%edx
    608c:	4c 89 f7             	mov    %r14,%rdi
    608f:	e8 7c 02 01 00       	callq  16310 <memcmp>
    6094:	85 c0                	test   %eax,%eax
    6096:	0f 85 fa fe ff ff    	jne    5f96 <pal_main+0x1c6>
                if (get_config(cfg, "loader.debug_file", cfgbuf,
    609c:	48 8d 35 89 29 01 00 	lea    0x12989(%rip),%rsi        # 18a2c <handle_sizes.1924+0x2ac>
    60a3:	b9 00 01 00 00       	mov    $0x100,%ecx
    60a8:	4c 89 f2             	mov    %r14,%rdx
    60ab:	4c 89 ef             	mov    %r13,%rdi
    60ae:	e8 fd 1d 01 00       	callq  17eb0 <get_config>
    60b3:	85 c0                	test   %eax,%eax
    60b5:	0f 8e db fe ff ff    	jle    5f96 <pal_main+0x1c6>
                               CONFIG_MAX) > 0) {
                    _DkStreamOpen(&handle, cfgbuf, PAL_ACCESS_RDWR,
    60bb:	48 8d bd c8 fe ff ff 	lea    -0x138(%rbp),%rdi
    60c2:	45 31 c9             	xor    %r9d,%r9d
    60c5:	41 b8 00 02 00 00    	mov    $0x200,%r8d
    60cb:	b9 80 01 00 00       	mov    $0x180,%ecx
    60d0:	ba 02 00 00 00       	mov    $0x2,%edx
    60d5:	4c 89 f6             	mov    %r14,%rsi
    60d8:	e8 53 d8 ff ff       	callq  3930 <_DkStreamOpen>
    60dd:	e9 b4 fe ff ff       	jmpq   5f96 <pal_main+0x1c6>
            leave;
        }

        if (get_config(cfg, "loader.daemonize", cfgbuf,
                       CONFIG_MAX) > 0 &&
            cfgbuf[0] == '1' && !cfgbuf[1])
    60e2:	80 bd d1 fe ff ff 00 	cmpb   $0x0,-0x12f(%rbp)
    60e9:	0f 85 45 fe ff ff    	jne    5f34 <pal_main+0x164>
            pal_config.daemonize = true;
    60ef:	c6 43 48 01          	movb   $0x1,0x48(%rbx)
    60f3:	e9 3c fe ff ff       	jmpq   5f34 <pal_main+0x164>
    60f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    60ff:	00 
       time to play with executable */
    if (pal_config.exec_handle) {
        ret = load_elf_object_by_handle(pal_config.exec_handle, OBJECT_EXEC);

        if (ret < 0) {
            printf("Unable to load executable (%d)\n", PAL_STRERROR(ret));
    6100:	f7 d8                	neg    %eax
    6102:	48 8d 35 cb 28 01 00 	lea    0x128cb(%rip),%rsi        # 189d4 <handle_sizes.1924+0x254>
    6109:	8d 50 ff             	lea    -0x1(%rax),%edx
    610c:	83 fa 18             	cmp    $0x18,%edx
    610f:	77 0d                	ja     611e <pal_main+0x34e>
    6111:	48 8d 15 a8 d0 21 00 	lea    0x21d0a8(%rip),%rdx        # 2231c0 <pal_errstring>
    6118:	48 98                	cltq   
    611a:	48 8b 34 c2          	mov    (%rdx,%rax,8),%rsi
    611e:	48 8d 3d 6b 2b 01 00 	lea    0x12b6b(%rip),%rdi        # 18c90 <handle_sizes.1924+0x510>
    6125:	31 c0                	xor    %eax,%eax
    6127:	e8 f4 2c 00 00       	callq  8e20 <pal_printf>
            leave;
    612c:	48 8d 3d 3d 2b 01 00 	lea    0x12b3d(%rip),%rdi        # 18c70 <handle_sizes.1924+0x4f0>
    6133:	be 05 01 00 00       	mov    $0x105,%esi
    6138:	31 c0                	xor    %eax,%eax
    613a:	e8 e1 2c 00 00       	callq  8e20 <pal_printf>
    613f:	bf 01 00 00 00       	mov    $0x1,%edi
    6144:	e8 37 c4 00 00       	callq  12580 <_DkProcessExit>
    6149:	e9 7e fd ff ff       	jmpq   5ecc <pal_main+0xfc>
    614e:	66 90                	xchg   %ax,%ax
     *     pal_config.exec
     *     pal_config.exec_handle
     *     pal_config.root_config
     */
    if (_DkInitHost(&argc, &argv) < 0)
        leave;
    6150:	48 8d 3d 19 2b 01 00 	lea    0x12b19(%rip),%rdi        # 18c70 <handle_sizes.1924+0x4f0>
    6157:	be f9 00 00 00       	mov    $0xf9,%esi
    615c:	31 c0                	xor    %eax,%eax
    615e:	e8 bd 2c 00 00       	callq  8e20 <pal_printf>
    6163:	bf 01 00 00 00       	mov    $0x1,%edi
    6168:	e8 13 c4 00 00       	callq  12580 <_DkProcessExit>
    616d:	e9 2e fd ff ff       	jmpq   5ea0 <pal_main+0xd0>
    if (pal_config.root_config) {
        struct config_store * cfg = pal_config.root_config;
        const char * msg;

        if (load_libraries(cfg, &msg) < 0) {
            printf("%s\n", msg);
    6172:	48 8b b5 c0 fe ff ff 	mov    -0x140(%rbp),%rsi
    6179:	48 8d 3d 6d 89 01 00 	lea    0x1896d(%rip),%rdi        # 1eaed <slab_levels+0x584d>
    6180:	31 c0                	xor    %eax,%eax
    6182:	e8 99 2c 00 00       	callq  8e20 <pal_printf>
            leave;
    6187:	48 8d 3d e2 2a 01 00 	lea    0x12ae2(%rip),%rdi        # 18c70 <handle_sizes.1924+0x4f0>
    618e:	be 14 01 00 00       	mov    $0x114,%esi
    6193:	31 c0                	xor    %eax,%eax
    6195:	e8 86 2c 00 00       	callq  8e20 <pal_printf>
    619a:	bf 01 00 00 00       	mov    $0x1,%edi
    619f:	e8 dc c3 00 00       	callq  12580 <_DkProcessExit>
    61a4:	e9 5c fd ff ff       	jmpq   5f05 <pal_main+0x135>
    61a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                             pal_config.lib_data_end;
#endif
    unsigned long base = allocsize;
    unsigned long temp = base >> 12; 
    void * addr = (void *) heap_base;
    printf("\n\n-- Debugging -- Heap base: %016x pal_size: %x base: %x alloc_mask: %x base-->>12: %x Address: %p\n\n",heap_base, pal_size, base, allocmask, temp, addr);
    61b0:	48 83 ec 08          	sub    $0x8,%rsp
    61b4:	48 b8 a8 5a 24 01 08 	mov    $0x801245aa8,%rax
    61bb:	00 00 00 
    // heap_base = 0x80139e000;
    heap_base = 0x801245aa8;
    unsigned long pal_size = pal_config.lib_text_start -
                             pal_config.lib_data_end;
#endif
    unsigned long base = allocsize;
    61be:	4d 8b 2f             	mov    (%r15),%r13
    unsigned long pal_size = pal_config.lib_data_end -
                            pal_config.lib_text_start;
#else
    // heap_base = 0x80139e000;
    heap_base = 0x801245aa8;
    unsigned long pal_size = pal_config.lib_text_start -
    61c1:	4c 8b 73 58          	mov    0x58(%rbx),%r14
    61c5:	4c 2b 73 70          	sub    0x70(%rbx),%r14
                             pal_config.lib_data_end;
#endif
    unsigned long base = allocsize;
    unsigned long temp = base >> 12; 
    void * addr = (void *) heap_base;
    printf("\n\n-- Debugging -- Heap base: %016x pal_size: %x base: %x alloc_mask: %x base-->>12: %x Address: %p\n\n",heap_base, pal_size, base, allocmask, temp, addr);
    61c9:	48 8d 3d e0 2a 01 00 	lea    0x12ae0(%rip),%rdi        # 18cb0 <handle_sizes.1924+0x530>
    61d0:	50                   	push   %rax
    61d1:	48 8b 05 20 d9 21 00 	mov    0x21d920(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    61d8:	48 be a8 5a 24 01 08 	mov    $0x801245aa8,%rsi
    61df:	00 00 00 
    heap_base = 0x801245aa8;
    unsigned long pal_size = pal_config.lib_text_start -
                             pal_config.lib_data_end;
#endif
    unsigned long base = allocsize;
    unsigned long temp = base >> 12; 
    61e2:	4d 89 eb             	mov    %r13,%r11
    void * addr = (void *) heap_base;
    printf("\n\n-- Debugging -- Heap base: %016x pal_size: %x base: %x alloc_mask: %x base-->>12: %x Address: %p\n\n",heap_base, pal_size, base, allocmask, temp, addr);
    61e5:	4c 89 e9             	mov    %r13,%rcx
    61e8:	4c 89 95 a0 fe ff ff 	mov    %r10,-0x160(%rbp)
    heap_base = 0x801245aa8;
    unsigned long pal_size = pal_config.lib_text_start -
                             pal_config.lib_data_end;
#endif
    unsigned long base = allocsize;
    unsigned long temp = base >> 12; 
    61ef:	49 c1 eb 0c          	shr    $0xc,%r11
    void * addr = (void *) heap_base;
    printf("\n\n-- Debugging -- Heap base: %016x pal_size: %x base: %x alloc_mask: %x base-->>12: %x Address: %p\n\n",heap_base, pal_size, base, allocmask, temp, addr);
    61f3:	4c 8b 00             	mov    (%rax),%r8
    61f6:	4d 89 d9             	mov    %r11,%r9
    61f9:	4c 89 f2             	mov    %r14,%rdx
    61fc:	31 c0                	xor    %eax,%eax
    61fe:	4c 89 9d a8 fe ff ff 	mov    %r11,-0x158(%rbp)
    6205:	e8 16 2c 00 00       	callq  8e20 <pal_printf>
    
    while ((base >> 12) < pal_size)
    620a:	4c 8b 9d a8 fe ff ff 	mov    -0x158(%rbp),%r11
    6211:	4c 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%r10
    6218:	5a                   	pop    %rdx
    6219:	59                   	pop    %rcx
    621a:	4d 39 de             	cmp    %r11,%r14
    621d:	76 10                	jbe    622f <pal_main+0x45f>
    621f:	90                   	nop    
        base <<= 1;
    6220:	4d 01 ed             	add    %r13,%r13
    unsigned long base = allocsize;
    unsigned long temp = base >> 12; 
    void * addr = (void *) heap_base;
    printf("\n\n-- Debugging -- Heap base: %016x pal_size: %x base: %x alloc_mask: %x base-->>12: %x Address: %p\n\n",heap_base, pal_size, base, allocmask, temp, addr);
    
    while ((base >> 12) < pal_size)
    6223:	4c 89 e8             	mov    %r13,%rax
    6226:	48 c1 e8 0c          	shr    $0xc,%rax
    622a:	49 39 c6             	cmp    %rax,%r14
    622d:	77 f1                	ja     6220 <pal_main+0x450>
        base <<= 1;
    while ((base << 6) < heap_base)
    622f:	4c 89 e8             	mov    %r13,%rax
    6232:	48 ba a7 5a 24 01 08 	mov    $0x801245aa7,%rdx
    6239:	00 00 00 
    623c:	48 c1 e0 06          	shl    $0x6,%rax
    6240:	48 39 d0             	cmp    %rdx,%rax
    6243:	77 0f                	ja     6254 <pal_main+0x484>
        base <<= 1;
    6245:	4d 01 ed             	add    %r13,%r13
    void * addr = (void *) heap_base;
    printf("\n\n-- Debugging -- Heap base: %016x pal_size: %x base: %x alloc_mask: %x base-->>12: %x Address: %p\n\n",heap_base, pal_size, base, allocmask, temp, addr);
    
    while ((base >> 12) < pal_size)
        base <<= 1;
    while ((base << 6) < heap_base)
    6248:	4c 89 e8             	mov    %r13,%rax
    624b:	48 c1 e0 06          	shl    $0x6,%rax
    624f:	48 39 d0             	cmp    %rdx,%rax
    6252:	76 f1                	jbe    6245 <pal_main+0x475>
        base <<= 1;

    heap_base &= allocmask;
    6254:	48 8b 05 9d d8 21 00 	mov    0x21d89d(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    625b:	49 b8 a8 5a 24 01 08 	mov    $0x801245aa8,%r8
    6262:	00 00 00 
    6265:	4c 8d b5 d0 fe ff ff 	lea    -0x130(%rbp),%r14
    626c:	4c 23 00             	and    (%rax),%r8
    // printf("\n\n-- Debugging -- Heap base: %x pal_size: %x base: %x alloc_mask: %x base-->>12: %x Address: %p\n\n",heap_base, pal_size, base, allocmask, temp, addr);
//     base = 0;
    while ((heap_base -= base) > base) {
    626f:	4d 29 e8             	sub    %r13,%r8
    6272:	4d 39 c5             	cmp    %r8,%r13
    6275:	73 70                	jae    62e7 <pal_main+0x517>
    6277:	4c 89 b5 a8 fe ff ff 	mov    %r14,-0x158(%rbp)
    627e:	4c 89 95 a0 fe ff ff 	mov    %r10,-0x160(%rbp)
    6285:	4d 89 c6             	mov    %r8,%r14
    6288:	eb 0e                	jmp    6298 <pal_main+0x4c8>
    628a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    6290:	4d 29 ee             	sub    %r13,%r14
    6293:	4d 39 ee             	cmp    %r13,%r14
    6296:	76 48                	jbe    62e0 <pal_main+0x510>
        void * heap = (void *) heap_base;
        printf("\n\n == Returning Heap Value: %p \n\n",heap);
    6298:	48 8d 3d 79 2a 01 00 	lea    0x12a79(%rip),%rdi        # 18d18 <handle_sizes.1924+0x598>
    629f:	4c 89 f6             	mov    %r14,%rsi
    62a2:	31 c0                	xor    %eax,%eax

    heap_base &= allocmask;
    // printf("\n\n-- Debugging -- Heap base: %x pal_size: %x base: %x alloc_mask: %x base-->>12: %x Address: %p\n\n",heap_base, pal_size, base, allocmask, temp, addr);
//     base = 0;
    while ((heap_base -= base) > base) {
        void * heap = (void *) heap_base;
    62a4:	4c 89 b5 d0 fe ff ff 	mov    %r14,-0x130(%rbp)
        printf("\n\n == Returning Heap Value: %p \n\n",heap);
    62ab:	e8 70 2b 00 00       	callq  8e20 <pal_printf>
        if (!_DkVirtualMemoryAlloc(&heap, allocsize, PAL_ALLOC_RESERVE,
    62b0:	49 8b 37             	mov    (%r15),%rsi
    62b3:	48 8b bd a8 fe ff ff 	mov    -0x158(%rbp),%rdi
    62ba:	31 c9                	xor    %ecx,%ecx
    62bc:	ba 02 00 00 00       	mov    $0x2,%edx
    62c1:	e8 ca 9e 00 00       	callq  10190 <_DkVirtualMemoryAlloc>
    62c6:	85 c0                	test   %eax,%eax
    62c8:	75 c6                	jne    6290 <pal_main+0x4c0>
                                   PAL_PROT_NONE)){
            // printf("\n\n == Returning Heap Value: %p \n\n",heap);
            return heap;
    62ca:	4c 8b 95 d0 fe ff ff 	mov    -0x130(%rbp),%r10
    }

    read_envs(envp);

    if (!pal_config.heap_base)
        pal_config.heap_base = find_heap_base();
    62d1:	4c 89 53 50          	mov    %r10,0x50(%rbx)
    62d5:	e9 07 fc ff ff       	jmpq   5ee1 <pal_main+0x111>
    62da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    62e0:	4c 8b 95 a0 fe ff ff 	mov    -0x160(%rbp),%r10
                                   PAL_PROT_NONE)){
            // printf("\n\n == Returning Heap Value: %p \n\n",heap);
            return heap;
	}
    }
    printf("\n\n == Returning Null \n\n");
    62e7:	48 8d 3d f4 26 01 00 	lea    0x126f4(%rip),%rdi        # 189e2 <handle_sizes.1924+0x262>
    62ee:	31 c0                	xor    %eax,%eax
    62f0:	4c 89 95 a8 fe ff ff 	mov    %r10,-0x158(%rbp)
    62f7:	e8 24 2b 00 00       	callq  8e20 <pal_printf>
    62fc:	4c 8b 95 a8 fe ff ff 	mov    -0x158(%rbp),%r10
    6303:	eb cc                	jmp    62d1 <pal_main+0x501>
    6305:	90                   	nop    
    6306:	90                   	nop    
    6307:	90                   	nop    
    6308:	90                   	nop    
    6309:	90                   	nop    
    630a:	90                   	nop    
    630b:	90                   	nop    
    630c:	90                   	nop    
    630d:	90                   	nop    
    630e:	90                   	nop    
    630f:	90                   	nop    

0000000000006310 <DkSystemTimeQuery>:
#include "pal_internal.h"
#include "pal_error.h"
#include "api.h"

PAL_NUM DkSystemTimeQuery (void)
{
    6310:	55                   	push   %rbp
    6311:	48 89 e5             	mov    %rsp,%rbp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    6314:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    6318:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    631c:	48 8b 05 bd d7 21 00 	mov    0x21d7bd(%rip),%rax        # 223ae0 <_DYNAMIC+0x2f8>
    frame->funcname = funcname;
    frame->context = NULL;
    6323:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    632a:	00 
    frame->retval = NULL;
    632b:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    6332:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
    6333:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    6337:	48 8d 05 fc 29 01 00 	lea    0x129fc(%rip),%rax        # 18d3a <handle_sizes.1924+0x5ba>
    633e:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    6342:	48 89 e0             	mov    %rsp,%rax
    6345:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    6349:	48 89 e8             	mov    %rbp,%rax
    634c:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    6350:	48 89 d8             	mov    %rbx,%rax
    6353:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    6357:	48 89 f0             	mov    %rsi,%rax
    635a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    635e:	48 89 f8             	mov    %rdi,%rax
    6361:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    6365:	4c 89 e0             	mov    %r12,%rax
    6368:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    636c:	4c 89 e8             	mov    %r13,%rax
    636f:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    6373:	4c 89 f0             	mov    %r14,%rax
    6376:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    637a:	4c 89 f8             	mov    %r15,%rax
    637d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    store_frame(SystemTimeQuery);

    unsigned long time = _DkSystemTimeQuery();

    return time;
}
    6381:	5d                   	pop    %rbp

PAL_NUM DkSystemTimeQuery (void)
{
    store_frame(SystemTimeQuery);

    unsigned long time = _DkSystemTimeQuery();
    6382:	e9 49 dd 00 00       	jmpq   140d0 <_DkSystemTimeQuery>
    6387:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    638e:	00 00 

0000000000006390 <DkRandomBitsRead>:

    return bytes;
}

PAL_NUM DkRandomBitsRead (PAL_BUF buffer, PAL_NUM size)
{
    6390:	55                   	push   %rbp
    6391:	48 89 e5             	mov    %rsp,%rbp
    6394:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    6398:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    639c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    63a3:	00 
    frame->retval = NULL;
    63a4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    63ab:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    63ac:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    63b0:	48 8b 05 69 d7 21 00 	mov    0x21d769(%rip),%rax        # 223b20 <_DYNAMIC+0x338>
    63b7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    63bb:	48 8d 05 8a 29 01 00 	lea    0x1298a(%rip),%rax        # 18d4c <handle_sizes.1924+0x5cc>
    63c2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    63c6:	48 89 e0             	mov    %rsp,%rax
    63c9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    63cd:	48 89 e8             	mov    %rbp,%rax
    63d0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    63d4:	48 89 d8             	mov    %rbx,%rax
    63d7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    63db:	48 89 f0             	mov    %rsi,%rax
    63de:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    63e2:	48 89 f8             	mov    %rdi,%rax
    63e5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    63e9:	4c 89 e0             	mov    %r12,%rax
    63ec:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    63f0:	4c 89 e8             	mov    %r13,%rax
    63f3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    63f7:	4c 89 f0             	mov    %r14,%rax
    63fa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    63fe:	4c 89 f8             	mov    %r15,%rax
    store_frame(RandomBitsRead);

    if (!buffer || !size) {
    6401:	48 85 ff             	test   %rdi,%rdi
    6404:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    6408:	74 16                	je     6420 <DkRandomBitsRead+0x90>
    640a:	48 85 f6             	test   %rsi,%rsi
    640d:	74 11                	je     6420 <DkRandomBitsRead+0x90>
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkRandomBitsRead(buffer, size);
    640f:	e8 3c dd 00 00       	callq  14150 <_DkRandomBitsRead>
    6414:	48 98                	cltq   

    if (ret < 0) {
    6416:	85 c0                	test   %eax,%eax
    if (!buffer || !size) {
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkRandomBitsRead(buffer, size);
    6418:	48 89 c7             	mov    %rax,%rdi

    if (ret < 0) {
    641b:	78 13                	js     6430 <DkRandomBitsRead+0xa0>
        notify_failure(-ret);
        return 0;
    }

    return ret;
}
    641d:	c9                   	leaveq 
    641e:	c3                   	retq   
    641f:	90                   	nop    
PAL_NUM DkRandomBitsRead (PAL_BUF buffer, PAL_NUM size)
{
    store_frame(RandomBitsRead);

    if (!buffer || !size) {
        notify_failure(PAL_ERROR_INVAL);
    6420:	bf 04 00 00 00       	mov    $0x4,%edi
    6425:	e8 26 ea 00 00       	callq  14e50 <notify_failure>
        return 0;
    642a:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        return 0;
    }

    return ret;
}
    642c:	c9                   	leaveq 
    642d:	c3                   	retq   
    642e:	66 90                	xchg   %ax,%ax
    }

    int ret = _DkRandomBitsRead(buffer, size);

    if (ret < 0) {
        notify_failure(-ret);
    6430:	f7 df                	neg    %edi
    6432:	48 63 ff             	movslq %edi,%rdi
    6435:	e8 16 ea 00 00       	callq  14e50 <notify_failure>
        return 0;
    643a:	31 c0                	xor    %eax,%eax
    }

    return ret;
}
    643c:	c9                   	leaveq 
    643d:	c3                   	retq   
    643e:	66 90                	xchg   %ax,%ax

0000000000006440 <DkInstructionCacheFlush>:

PAL_BOL DkInstructionCacheFlush (PAL_PTR addr, PAL_NUM size)
{
    6440:	55                   	push   %rbp
    6441:	48 89 e5             	mov    %rsp,%rbp
    6444:	53                   	push   %rbx

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    6445:	48 8d 45 80          	lea    -0x80(%rbp),%rax
    6449:	48 83 ec 78          	sub    $0x78,%rsp
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    644d:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    6454:	00 
    frame->retval = NULL;
    6455:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    645c:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    645d:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->func = func;
    6461:	48 8b 05 00 d6 21 00 	mov    0x21d600(%rip),%rax        # 223a68 <_DYNAMIC+0x280>
    6468:	48 89 45 88          	mov    %rax,-0x78(%rbp)
    frame->funcname = funcname;
    646c:	48 8d 05 ea 28 01 00 	lea    0x128ea(%rip),%rax        # 18d5d <handle_sizes.1924+0x5dd>
    6473:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    6477:	48 89 e0             	mov    %rsp,%rax
    647a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    647e:	48 89 e8             	mov    %rbp,%rax
    6481:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    6485:	48 89 d8             	mov    %rbx,%rax
    6488:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    648c:	48 89 f0             	mov    %rsi,%rax
    648f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    6493:	48 89 f8             	mov    %rdi,%rax
    6496:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    649a:	4c 89 e0             	mov    %r12,%rax
    649d:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    64a1:	4c 89 e8             	mov    %r13,%rax
    64a4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    64a8:	4c 89 f0             	mov    %r14,%rax
    64ab:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    64af:	4c 89 f8             	mov    %r15,%rax
    store_frame(InstructionCacheFlush);

    if (!addr || !size) {
    64b2:	48 85 ff             	test   %rdi,%rdi
    64b5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    64b9:	0f 94 c3             	sete   %bl
    64bc:	48 85 f6             	test   %rsi,%rsi
    64bf:	0f 94 c0             	sete   %al
    64c2:	08 c3                	or     %al,%bl
    64c4:	75 1a                	jne    64e0 <DkInstructionCacheFlush+0xa0>
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    int ret = _DkInstructionCacheFlush(addr, size);
    64c6:	e8 25 dd 00 00       	callq  141f0 <_DkInstructionCacheFlush>

    if (ret < 0) {
    64cb:	85 c0                	test   %eax,%eax
    64cd:	78 26                	js     64f5 <DkInstructionCacheFlush+0xb5>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    64cf:	bb 01 00 00 00       	mov    $0x1,%ebx
}
    64d4:	48 83 c4 78          	add    $0x78,%rsp
    64d8:	89 d8                	mov    %ebx,%eax
    64da:	5b                   	pop    %rbx
    64db:	5d                   	pop    %rbp
    64dc:	c3                   	retq   
    64dd:	0f 1f 00             	nopl   (%rax)
PAL_BOL DkInstructionCacheFlush (PAL_PTR addr, PAL_NUM size)
{
    store_frame(InstructionCacheFlush);

    if (!addr || !size) {
        notify_failure(PAL_ERROR_INVAL);
    64e0:	bf 04 00 00 00       	mov    $0x4,%edi
        return PAL_FALSE;
    64e5:	31 db                	xor    %ebx,%ebx
PAL_BOL DkInstructionCacheFlush (PAL_PTR addr, PAL_NUM size)
{
    store_frame(InstructionCacheFlush);

    if (!addr || !size) {
        notify_failure(PAL_ERROR_INVAL);
    64e7:	e8 64 e9 00 00       	callq  14e50 <notify_failure>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    64ec:	48 83 c4 78          	add    $0x78,%rsp
    64f0:	89 d8                	mov    %ebx,%eax
    64f2:	5b                   	pop    %rbx
    64f3:	5d                   	pop    %rbp
    64f4:	c3                   	retq   
    }

    int ret = _DkInstructionCacheFlush(addr, size);

    if (ret < 0) {
        notify_failure(-ret);
    64f5:	f7 d8                	neg    %eax
    64f7:	48 63 f8             	movslq %eax,%rdi
    64fa:	e8 51 e9 00 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    64ff:	48 83 c4 78          	add    $0x78,%rsp
    6503:	89 d8                	mov    %ebx,%eax
    6505:	5b                   	pop    %rbx
    6506:	5d                   	pop    %rbp
    6507:	c3                   	retq   
    6508:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    650f:	00 

0000000000006510 <getrand>:

    return 0;
}

int getrand (void * buffer, int size)
{
    6510:	55                   	push   %rbp
    6511:	48 89 e5             	mov    %rsp,%rbp
    6514:	41 56                	push   %r14
    6516:	41 55                	push   %r13
    6518:	41 54                	push   %r12
    651a:	53                   	push   %rbx
    651b:	48 89 fb             	mov    %rdi,%rbx
    unsigned long val;
    int bytes = 0;

    _DkMutexLock(&lock);
    651e:	48 8d 3d ab d8 21 00 	lea    0x21d8ab(%rip),%rdi        # 223dd0 <lock>

    return 0;
}

int getrand (void * buffer, int size)
{
    6525:	41 89 f4             	mov    %esi,%r12d
    6528:	48 83 ec 10          	sub    $0x10,%rsp
    unsigned long val;
    int bytes = 0;

    _DkMutexLock(&lock);
    652c:	e8 1f a7 00 00       	callq  10c50 <_DkMutexLock>
    while (!randval) {
    6531:	4c 8b 2d c8 e4 21 00 	mov    0x21e4c8(%rip),%r13        # 224a00 <randval>
    6538:	4d 85 ed             	test   %r13,%r13
    653b:	75 73                	jne    65b0 <getrand+0xa0>
    653d:	4c 8d 75 d8          	lea    -0x28(%rbp),%r14
    6541:	eb 3b                	jmp    657e <getrand+0x6e>
    unsigned long val;

    if (_DkRandomBitsRead(&val, sizeof(val)) < sizeof(val))
        return -PAL_ERROR_DENIED;

    _DkMutexLock(&lock);
    6543:	48 8d 3d 86 d8 21 00 	lea    0x21d886(%rip),%rdi        # 223dd0 <lock>
    654a:	e8 01 a7 00 00       	callq  10c50 <_DkMutexLock>
    randval = val;
    654f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
    _DkMutexUnlock(&lock);
    6553:	48 8d 3d 76 d8 21 00 	lea    0x21d876(%rip),%rdi        # 223dd0 <lock>

    if (_DkRandomBitsRead(&val, sizeof(val)) < sizeof(val))
        return -PAL_ERROR_DENIED;

    _DkMutexLock(&lock);
    randval = val;
    655a:	48 89 05 9f e4 21 00 	mov    %rax,0x21e49f(%rip)        # 224a00 <randval>
    _DkMutexUnlock(&lock);
    6561:	e8 5a a9 00 00       	callq  10ec0 <_DkMutexUnlock>
    _DkMutexLock(&lock);
    while (!randval) {
        _DkMutexUnlock(&lock);
        if (init_randgen() < 0)
            return -PAL_ERROR_DENIED;
        _DkMutexLock(&lock);
    6566:	48 8d 3d 63 d8 21 00 	lea    0x21d863(%rip),%rdi        # 223dd0 <lock>
    656d:	e8 de a6 00 00       	callq  10c50 <_DkMutexLock>
{
    unsigned long val;
    int bytes = 0;

    _DkMutexLock(&lock);
    while (!randval) {
    6572:	4c 8b 2d 87 e4 21 00 	mov    0x21e487(%rip),%r13        # 224a00 <randval>
    6579:	4d 85 ed             	test   %r13,%r13
    657c:	75 32                	jne    65b0 <getrand+0xa0>
        _DkMutexUnlock(&lock);
    657e:	48 8d 3d 4b d8 21 00 	lea    0x21d84b(%rip),%rdi        # 223dd0 <lock>
    6585:	e8 36 a9 00 00       	callq  10ec0 <_DkMutexUnlock>

static int init_randgen (void)
{
    unsigned long val;

    if (_DkRandomBitsRead(&val, sizeof(val)) < sizeof(val))
    658a:	be 08 00 00 00       	mov    $0x8,%esi
    658f:	4c 89 f7             	mov    %r14,%rdi
    6592:	e8 b9 db 00 00       	callq  14150 <_DkRandomBitsRead>
    6597:	83 f8 07             	cmp    $0x7,%eax
    659a:	77 a7                	ja     6543 <getrand+0x33>
    _DkMutexLock(&lock);
    randval = val;
    _DkMutexUnlock(&lock);

    return bytes;
}
    659c:	48 83 c4 10          	add    $0x10,%rsp

    _DkMutexLock(&lock);
    while (!randval) {
        _DkMutexUnlock(&lock);
        if (init_randgen() < 0)
            return -PAL_ERROR_DENIED;
    65a0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    _DkMutexLock(&lock);
    randval = val;
    _DkMutexUnlock(&lock);

    return bytes;
}
    65a5:	5b                   	pop    %rbx
    65a6:	41 5c                	pop    %r12
    65a8:	41 5d                	pop    %r13
    65aa:	41 5e                	pop    %r14
    65ac:	5d                   	pop    %rbp
    65ad:	c3                   	retq   
    65ae:	66 90                	xchg   %ax,%ax
            return -PAL_ERROR_DENIED;
        _DkMutexLock(&lock);
    }

    val = randval;
    randval++;
    65b0:	49 8d 45 01          	lea    0x1(%r13),%rax
    _DkMutexUnlock(&lock);
    65b4:	48 8d 3d 15 d8 21 00 	lea    0x21d815(%rip),%rdi        # 223dd0 <lock>

    while (bytes + sizeof(unsigned long) <= size) {
    65bb:	45 31 f6             	xor    %r14d,%r14d
            return -PAL_ERROR_DENIED;
        _DkMutexLock(&lock);
    }

    val = randval;
    randval++;
    65be:	48 89 05 3b e4 21 00 	mov    %rax,0x21e43b(%rip)        # 224a00 <randval>
    _DkMutexUnlock(&lock);
    65c5:	e8 f6 a8 00 00       	callq  10ec0 <_DkMutexUnlock>

    while (bytes + sizeof(unsigned long) <= size) {
    65ca:	49 63 cc             	movslq %r12d,%rcx
    65cd:	31 c0                	xor    %eax,%eax
    65cf:	48 83 f9 07          	cmp    $0x7,%rcx
    65d3:	76 66                	jbe    663b <getrand+0x12b>
    return key;
}

static inline uint64_t hash64 (uint64_t key)
{
    key = (~key) + (key << 21);
    65d5:	4c 89 ea             	mov    %r13,%rdx
        *(unsigned long *) (buffer + bytes) = val;
    65d8:	4c 89 2c 03          	mov    %r13,(%rbx,%rax,1)
    65dc:	41 83 c6 08          	add    $0x8,%r14d
    65e0:	48 c1 e2 15          	shl    $0x15,%rdx
    65e4:	4c 29 ea             	sub    %r13,%rdx
    65e7:	48 83 ea 01          	sub    $0x1,%rdx
    key = key ^ (key >> 24);
    65eb:	48 89 d0             	mov    %rdx,%rax
    65ee:	48 c1 e8 18          	shr    $0x18,%rax
    65f2:	48 31 c2             	xor    %rax,%rdx
    key = (key + (key << 3)) + (key << 8);
    65f5:	48 89 d0             	mov    %rdx,%rax
    65f8:	48 c1 e0 08          	shl    $0x8,%rax
    65fc:	48 8d 04 d0          	lea    (%rax,%rdx,8),%rax
    6600:	48 01 c2             	add    %rax,%rdx
    key = key ^ (key >> 14);
    6603:	48 89 d0             	mov    %rdx,%rax
    6606:	48 c1 e8 0e          	shr    $0xe,%rax
    660a:	48 31 c2             	xor    %rax,%rdx
    key = (key + (key << 2)) + (key << 4);
    660d:	48 89 d0             	mov    %rdx,%rax
    6610:	48 c1 e0 04          	shl    $0x4,%rax
    6614:	48 8d 04 90          	lea    (%rax,%rdx,4),%rax
    6618:	48 01 c2             	add    %rax,%rdx
    key = key ^ (key >> 28);
    661b:	48 89 d0             	mov    %rdx,%rax
    661e:	48 c1 e8 1c          	shr    $0x1c,%rax
    6622:	48 31 c2             	xor    %rax,%rdx

    val = randval;
    randval++;
    _DkMutexUnlock(&lock);

    while (bytes + sizeof(unsigned long) <= size) {
    6625:	49 63 c6             	movslq %r14d,%rax
    key = key + (key << 31);
    6628:	49 89 d5             	mov    %rdx,%r13
    662b:	49 c1 e5 1f          	shl    $0x1f,%r13
    662f:	49 01 d5             	add    %rdx,%r13
    6632:	48 8d 50 08          	lea    0x8(%rax),%rdx
    6636:	48 39 ca             	cmp    %rcx,%rdx
    6639:	76 9a                	jbe    65d5 <getrand+0xc5>
        *(unsigned long *) (buffer + bytes) = val;
        val = hash64(val);
        bytes += sizeof(unsigned long);
    }

    if (bytes < size) {
    663b:	45 39 f4             	cmp    %r14d,%r12d
    663e:	0f 8e 84 00 00 00    	jle    66c8 <getrand+0x1b8>
        switch (size - bytes) {
    6644:	45 29 f4             	sub    %r14d,%r12d
                *(unsigned int *) (buffer + bytes) = randval & 0xffffffff;
                bytes += 4;
                break;

            case 2:
                *(unsigned short *) (buffer + bytes) = randval & 0xffff;
    6647:	48 8b 15 b2 e3 21 00 	mov    0x21e3b2(%rip),%rdx        # 224a00 <randval>
        val = hash64(val);
        bytes += sizeof(unsigned long);
    }

    if (bytes < size) {
        switch (size - bytes) {
    664e:	41 83 fc 02          	cmp    $0x2,%r12d
    6652:	0f 84 9f 00 00 00    	je     66f7 <getrand+0x1e7>
    6658:	41 83 fc 04          	cmp    $0x4,%r12d
    665c:	0f 84 a2 00 00 00    	je     6704 <getrand+0x1f4>
    6662:	41 83 fc 01          	cmp    $0x1,%r12d
    6666:	75 07                	jne    666f <getrand+0x15f>
                *(unsigned short *) (buffer + bytes) = randval & 0xffff;
                bytes += 2;
                break;

            case 1:
                *(unsigned char *) (buffer + bytes) = randval & 0xff;
    6668:	88 14 03             	mov    %dl,(%rbx,%rax,1)
                bytes++;
    666b:	41 83 c6 01          	add    $0x1,%r14d
    return key;
}

static inline uint64_t hash64 (uint64_t key)
{
    key = (~key) + (key << 21);
    666f:	48 89 d0             	mov    %rdx,%rax
    6672:	48 c1 e0 15          	shl    $0x15,%rax
    6676:	48 29 d0             	sub    %rdx,%rax
    6679:	48 83 e8 01          	sub    $0x1,%rax
    key = key ^ (key >> 24);
    667d:	48 89 c2             	mov    %rax,%rdx
    6680:	48 c1 ea 18          	shr    $0x18,%rdx
    6684:	48 31 d0             	xor    %rdx,%rax
    key = (key + (key << 3)) + (key << 8);
    6687:	48 89 c2             	mov    %rax,%rdx
    668a:	48 c1 e2 08          	shl    $0x8,%rdx
    668e:	48 8d 14 c2          	lea    (%rdx,%rax,8),%rdx
    6692:	48 01 d0             	add    %rdx,%rax
    key = key ^ (key >> 14);
    6695:	48 89 c2             	mov    %rax,%rdx
    6698:	48 c1 ea 0e          	shr    $0xe,%rdx
    669c:	48 31 d0             	xor    %rdx,%rax
    key = (key + (key << 2)) + (key << 4);
    669f:	48 89 c2             	mov    %rax,%rdx
    66a2:	48 c1 e2 04          	shl    $0x4,%rdx
    66a6:	48 8d 14 82          	lea    (%rdx,%rax,4),%rdx
    66aa:	48 01 d0             	add    %rdx,%rax
    key = key ^ (key >> 28);
    66ad:	48 89 c2             	mov    %rax,%rdx
    66b0:	48 c1 ea 1c          	shr    $0x1c,%rdx
    66b4:	48 31 d0             	xor    %rdx,%rax
    key = key + (key << 31);
    66b7:	48 89 c2             	mov    %rax,%rdx
    66ba:	48 c1 e2 1f          	shl    $0x1f,%rdx
    66be:	48 01 d0             	add    %rdx,%rax
    66c1:	48 89 05 38 e3 21 00 	mov    %rax,0x21e338(%rip)        # 224a00 <randval>
            default: break;
        }
        randval = hash64(randval);
    }

    _DkMutexLock(&lock);
    66c8:	48 8d 3d 01 d7 21 00 	lea    0x21d701(%rip),%rdi        # 223dd0 <lock>
    66cf:	e8 7c a5 00 00       	callq  10c50 <_DkMutexLock>
    randval = val;
    _DkMutexUnlock(&lock);
    66d4:	48 8d 3d f5 d6 21 00 	lea    0x21d6f5(%rip),%rdi        # 223dd0 <lock>
        }
        randval = hash64(randval);
    }

    _DkMutexLock(&lock);
    randval = val;
    66db:	4c 89 2d 1e e3 21 00 	mov    %r13,0x21e31e(%rip)        # 224a00 <randval>
    _DkMutexUnlock(&lock);
    66e2:	e8 d9 a7 00 00       	callq  10ec0 <_DkMutexUnlock>

    return bytes;
}
    66e7:	48 83 c4 10          	add    $0x10,%rsp

    _DkMutexLock(&lock);
    randval = val;
    _DkMutexUnlock(&lock);

    return bytes;
    66eb:	44 89 f0             	mov    %r14d,%eax
}
    66ee:	5b                   	pop    %rbx
    66ef:	41 5c                	pop    %r12
    66f1:	41 5d                	pop    %r13
    66f3:	41 5e                	pop    %r14
    66f5:	5d                   	pop    %rbp
    66f6:	c3                   	retq   
                *(unsigned int *) (buffer + bytes) = randval & 0xffffffff;
                bytes += 4;
                break;

            case 2:
                *(unsigned short *) (buffer + bytes) = randval & 0xffff;
    66f7:	66 89 14 03          	mov    %dx,(%rbx,%rax,1)
                bytes += 2;
    66fb:	41 83 c6 02          	add    $0x2,%r14d
                break;
    66ff:	e9 6b ff ff ff       	jmpq   666f <getrand+0x15f>
    }

    if (bytes < size) {
        switch (size - bytes) {
            case 4:
                *(unsigned int *) (buffer + bytes) = randval & 0xffffffff;
    6704:	89 14 03             	mov    %edx,(%rbx,%rax,1)
                bytes += 4;
    6707:	41 83 c6 04          	add    $0x4,%r14d
                break;
    670b:	e9 5f ff ff ff       	jmpq   666f <getrand+0x15f>

0000000000006710 <DkCreatePhysicalMemoryChannel>:
#include "pal_error.h"
#include "api.h"

PAL_HANDLE
DkCreatePhysicalMemoryChannel (PAL_NUM * key)
{
    6710:	55                   	push   %rbp
    6711:	48 89 fe             	mov    %rdi,%rsi
    6714:	48 89 e5             	mov    %rsp,%rbp
    6717:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    671b:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    671f:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    6726:	00 
    frame->retval = NULL;
    6727:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    672e:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    672f:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    6733:	48 8b 05 6e d2 21 00 	mov    0x21d26e(%rip),%rax        # 2239a8 <_DYNAMIC+0x1c0>
    673a:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    673e:	48 8d 05 30 26 01 00 	lea    0x12630(%rip),%rax        # 18d75 <handle_sizes.1924+0x5f5>
    6745:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    6749:	48 89 e0             	mov    %rsp,%rax
    674c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    6750:	48 89 e8             	mov    %rbp,%rax
    6753:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    6757:	48 89 d8             	mov    %rbx,%rax
    675a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    675e:	48 89 f0             	mov    %rsi,%rax
    6761:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    6765:	48 89 f8             	mov    %rdi,%rax
    6768:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    676c:	4c 89 e0             	mov    %r12,%rax
    676f:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    6773:	4c 89 e8             	mov    %r13,%rax
    6776:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    677a:	4c 89 f0             	mov    %r14,%rax
    677d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    6781:	4c 89 f8             	mov    %r15,%rax
    store_frame(CreatePhysicalMemoryChannel);

    PAL_HANDLE handle = NULL;
    int ret = _DkCreatePhysicalMemoryChannel(&handle, key);
    6784:	48 8d 7d 88          	lea    -0x78(%rbp),%rdi
    6788:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
PAL_HANDLE
DkCreatePhysicalMemoryChannel (PAL_NUM * key)
{
    store_frame(CreatePhysicalMemoryChannel);

    PAL_HANDLE handle = NULL;
    678c:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
    6793:	00 
    int ret = _DkCreatePhysicalMemoryChannel(&handle, key);
    6794:	e8 a7 db 00 00       	callq  14340 <_DkCreatePhysicalMemoryChannel>
    if (ret < 0) {
    6799:	85 c0                	test   %eax,%eax
    679b:	78 06                	js     67a3 <DkCreatePhysicalMemoryChannel+0x93>
        notify_failure(-ret);
        return NULL;
    }

    return handle;
    679d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
}
    67a1:	c9                   	leaveq 
    67a2:	c3                   	retq   
    store_frame(CreatePhysicalMemoryChannel);

    PAL_HANDLE handle = NULL;
    int ret = _DkCreatePhysicalMemoryChannel(&handle, key);
    if (ret < 0) {
        notify_failure(-ret);
    67a3:	f7 d8                	neg    %eax
    67a5:	48 63 f8             	movslq %eax,%rdi
    67a8:	e8 a3 e6 00 00       	callq  14e50 <notify_failure>
        return NULL;
    67ad:	31 c0                	xor    %eax,%eax
    }

    return handle;
}
    67af:	c9                   	leaveq 
    67b0:	c3                   	retq   
    67b1:	66 66 66 66 66 66 2e 	nopw   %cs:0x0(%rax,%rax,1)
    67b8:	0f 1f 84 00 00 00 00 
    67bf:	00 

00000000000067c0 <DkPhysicalMemoryCommit>:

PAL_NUM
DkPhysicalMemoryCommit (PAL_HANDLE channel, PAL_NUM entries, PAL_BUF * addrs,
                        PAL_NUM * sizes, PAL_FLG flags)
{
    67c0:	55                   	push   %rbp
    67c1:	48 89 e5             	mov    %rsp,%rbp
    67c4:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    67c8:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    67cc:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    67d3:	00 
    frame->retval = NULL;
    67d4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    67db:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    67dc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    67e0:	48 8b 05 11 d2 21 00 	mov    0x21d211(%rip),%rax        # 2239f8 <_DYNAMIC+0x210>
    67e7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    67eb:	48 8d 05 a1 25 01 00 	lea    0x125a1(%rip),%rax        # 18d93 <handle_sizes.1924+0x613>
    67f2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    67f6:	48 89 e0             	mov    %rsp,%rax
    67f9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    67fd:	48 89 e8             	mov    %rbp,%rax
    6800:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    6804:	48 89 d8             	mov    %rbx,%rax
    6807:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    680b:	48 89 f0             	mov    %rsi,%rax
    680e:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    6812:	48 89 f8             	mov    %rdi,%rax
    6815:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    6819:	4c 89 e0             	mov    %r12,%rax
    681c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    6820:	4c 89 e8             	mov    %r13,%rax
    6823:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    6827:	4c 89 f0             	mov    %r14,%rax
    682a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    682e:	4c 89 f8             	mov    %r15,%rax
    store_frame(PhysicalMemoryCommit);

    if (!addrs || !sizes || !channel ||
    6831:	48 85 c9             	test   %rcx,%rcx
    6834:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    6838:	41 0f 94 c1          	sete   %r9b
    683c:	48 85 ff             	test   %rdi,%rdi
    683f:	0f 94 c0             	sete   %al
    6842:	41 08 c1             	or     %al,%r9b
    6845:	75 0a                	jne    6851 <DkPhysicalMemoryCommit+0x91>
    6847:	48 85 d2             	test   %rdx,%rdx
    684a:	74 05                	je     6851 <DkPhysicalMemoryCommit+0x91>
    684c:	83 3f 11             	cmpl   $0x11,(%rdi)
    684f:	74 0f                	je     6860 <DkPhysicalMemoryCommit+0xa0>
        !IS_HANDLE_TYPE(channel, gipc)) {
        notify_failure(PAL_ERROR_INVAL);
    6851:	bf 04 00 00 00       	mov    $0x4,%edi
    6856:	e8 f5 e5 00 00       	callq  14e50 <notify_failure>
        return 0;
    685b:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        return 0;
    }

    return ret;
}
    685d:	c9                   	leaveq 
    685e:	c3                   	retq   
    685f:	90                   	nop    
        !IS_HANDLE_TYPE(channel, gipc)) {
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkPhysicalMemoryCommit(channel, entries, addrs, sizes, flags);
    6860:	e8 1b dc 00 00       	callq  14480 <_DkPhysicalMemoryCommit>
    6865:	48 98                	cltq   

    if (ret < 0) {
    6867:	85 c0                	test   %eax,%eax
        !IS_HANDLE_TYPE(channel, gipc)) {
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkPhysicalMemoryCommit(channel, entries, addrs, sizes, flags);
    6869:	48 89 c2             	mov    %rax,%rdx

    if (ret < 0) {
    686c:	79 ef                	jns    685d <DkPhysicalMemoryCommit+0x9d>
        notify_failure(-ret);
    686e:	f7 da                	neg    %edx
    6870:	48 63 fa             	movslq %edx,%rdi
    6873:	e8 d8 e5 00 00       	callq  14e50 <notify_failure>
        return 0;
    6878:	31 c0                	xor    %eax,%eax
    }

    return ret;
}
    687a:	c9                   	leaveq 
    687b:	c3                   	retq   
    687c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000006880 <DkPhysicalMemoryMap>:

PAL_NUM
DkPhysicalMemoryMap (PAL_HANDLE channel, PAL_NUM entries, PAL_BUF * addrs,
                     PAL_NUM * sizes, PAL_FLG * prots)
{
    6880:	55                   	push   %rbp
    6881:	48 89 e5             	mov    %rsp,%rbp
    6884:	48 83 ec 70          	sub    $0x70,%rsp

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    6888:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    frame->func = func;
    frame->funcname = funcname;
    frame->context = NULL;
    688c:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
    6893:	00 
    frame->retval = NULL;
    6894:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
    689b:	00 

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    689c:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    frame->func = func;
    68a0:	48 8b 05 31 d2 21 00 	mov    0x21d231(%rip),%rax        # 223ad8 <_DYNAMIC+0x2f0>
    68a7:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    frame->funcname = funcname;
    68ab:	48 8d 05 f8 24 01 00 	lea    0x124f8(%rip),%rax        # 18daa <handle_sizes.1924+0x62a>
    68b2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
    68b6:	48 89 e0             	mov    %rsp,%rax
    68b9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    68bd:	48 89 e8             	mov    %rbp,%rax
    68c0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    68c4:	48 89 d8             	mov    %rbx,%rax
    68c7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    68cb:	48 89 f0             	mov    %rsi,%rax
    68ce:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    68d2:	48 89 f8             	mov    %rdi,%rax
    68d5:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    68d9:	4c 89 e0             	mov    %r12,%rax
    68dc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    68e0:	4c 89 e8             	mov    %r13,%rax
    68e3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    68e7:	4c 89 f0             	mov    %r14,%rax
    68ea:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    68ee:	4c 89 f8             	mov    %r15,%rax
    store_frame(PhysicalMemoryMap);

    if (!sizes || !channel || !IS_HANDLE_TYPE(channel, gipc)) {
    68f1:	48 85 c9             	test   %rcx,%rcx
    68f4:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    68f8:	74 0a                	je     6904 <DkPhysicalMemoryMap+0x84>
    68fa:	48 85 ff             	test   %rdi,%rdi
    68fd:	74 05                	je     6904 <DkPhysicalMemoryMap+0x84>
    68ff:	83 3f 11             	cmpl   $0x11,(%rdi)
    6902:	74 0e                	je     6912 <DkPhysicalMemoryMap+0x92>
        notify_failure(PAL_ERROR_INVAL);
    6904:	bf 04 00 00 00       	mov    $0x4,%edi
    6909:	e8 42 e5 00 00       	callq  14e50 <notify_failure>
        return 0;
    690e:	31 c0                	xor    %eax,%eax
        notify_failure(-ret);
        return 0;
    }

    return ret;
}
    6910:	c9                   	leaveq 
    6911:	c3                   	retq   
    if (!sizes || !channel || !IS_HANDLE_TYPE(channel, gipc)) {
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkPhysicalMemoryMap(channel, entries, addrs, sizes, prots);
    6912:	e8 49 dc 00 00       	callq  14560 <_DkPhysicalMemoryMap>
    6917:	48 98                	cltq   

    if (ret < 0) {
    6919:	85 c0                	test   %eax,%eax
    if (!sizes || !channel || !IS_HANDLE_TYPE(channel, gipc)) {
        notify_failure(PAL_ERROR_INVAL);
        return 0;
    }

    int ret = _DkPhysicalMemoryMap(channel, entries, addrs, sizes, prots);
    691b:	48 89 c2             	mov    %rax,%rdx

    if (ret < 0) {
    691e:	79 f0                	jns    6910 <DkPhysicalMemoryMap+0x90>
        notify_failure(-ret);
    6920:	f7 da                	neg    %edx
    6922:	48 63 fa             	movslq %edx,%rdi
    6925:	e8 26 e5 00 00       	callq  14e50 <notify_failure>
        return 0;
    692a:	31 c0                	xor    %eax,%eax
    }

    return ret;
}
    692c:	c9                   	leaveq 
    692d:	c3                   	retq   
    692e:	90                   	nop    
    692f:	90                   	nop    

0000000000006930 <DkSetExceptionHandler>:

PAL_BOL
DkSetExceptionHandler (void (*handler) (PAL_PTR event, PAL_NUM arg,
                                        PAL_CONTEXT * context),
                       PAL_NUM event, PAL_FLG flags)
{
    6930:	55                   	push   %rbp
    if (!handler || event <= 0 || event > PAL_EVENT_NUM_BOUND) {
    6931:	48 8d 46 ff          	lea    -0x1(%rsi),%rax

PAL_BOL
DkSetExceptionHandler (void (*handler) (PAL_PTR event, PAL_NUM arg,
                                        PAL_CONTEXT * context),
                       PAL_NUM event, PAL_FLG flags)
{
    6935:	48 89 f1             	mov    %rsi,%rcx
    6938:	48 89 e5             	mov    %rsp,%rbp
    693b:	53                   	push   %rbx
    693c:	48 83 ec 08          	sub    $0x8,%rsp
    if (!handler || event <= 0 || event > PAL_EVENT_NUM_BOUND) {
    6940:	48 83 f8 07          	cmp    $0x7,%rax
    6944:	0f 97 c3             	seta   %bl
    6947:	48 85 ff             	test   %rdi,%rdi
    694a:	0f 94 c0             	sete   %al
    694d:	08 c3                	or     %al,%bl
    694f:	74 1f                	je     6970 <DkSetExceptionHandler+0x40>
        notify_failure(PAL_ERROR_INVAL);
    6951:	bf 04 00 00 00       	mov    $0x4,%edi
        return PAL_FALSE;
    6956:	31 db                	xor    %ebx,%ebx
DkSetExceptionHandler (void (*handler) (PAL_PTR event, PAL_NUM arg,
                                        PAL_CONTEXT * context),
                       PAL_NUM event, PAL_FLG flags)
{
    if (!handler || event <= 0 || event > PAL_EVENT_NUM_BOUND) {
        notify_failure(PAL_ERROR_INVAL);
    6958:	e8 f3 e4 00 00       	callq  14e50 <notify_failure>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
}
    695d:	48 83 c4 08          	add    $0x8,%rsp
    6961:	89 d8                	mov    %ebx,%eax
    6963:	5b                   	pop    %rbx
    6964:	5d                   	pop    %rbp
    6965:	c3                   	retq   
    6966:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    696d:	00 00 00 
    if (!handler || event <= 0 || event > PAL_EVENT_NUM_BOUND) {
        notify_failure(PAL_ERROR_INVAL);
        return PAL_FALSE;
    }

    int ret = _DkExceptionHandlers[event](event, handler, flags);
    6970:	48 8b 05 c9 d1 21 00 	mov    0x21d1c9(%rip),%rax        # 223b40 <_DYNAMIC+0x358>
    6977:	48 89 fe             	mov    %rdi,%rsi
    697a:	89 cf                	mov    %ecx,%edi
    697c:	ff 14 c8             	callq  *(%rax,%rcx,8)

    if (ret < 0) {
    697f:	85 c0                	test   %eax,%eax
    6981:	78 0e                	js     6991 <DkSetExceptionHandler+0x61>
        notify_failure(-ret);
        return PAL_FALSE;
    }

    return PAL_TRUE;
    6983:	bb 01 00 00 00       	mov    $0x1,%ebx
}
    6988:	48 83 c4 08          	add    $0x8,%rsp
    698c:	89 d8                	mov    %ebx,%eax
    698e:	5b                   	pop    %rbx
    698f:	5d                   	pop    %rbp
    6990:	c3                   	retq   
    }

    int ret = _DkExceptionHandlers[event](event, handler, flags);

    if (ret < 0) {
        notify_failure(-ret);
    6991:	f7 d8                	neg    %eax
    6993:	48 63 f8             	movslq %eax,%rdi
    6996:	e8 b5 e4 00 00       	callq  14e50 <notify_failure>
        return PAL_FALSE;
    699b:	eb c0                	jmp    695d <DkSetExceptionHandler+0x2d>
    699d:	0f 1f 00             	nopl   (%rax)

00000000000069a0 <DkExceptionReturn>:

    return PAL_TRUE;
}

void DkExceptionReturn (PAL_PTR event)
{
    69a0:	55                   	push   %rbp
    69a1:	48 89 e5             	mov    %rsp,%rbp
    _DkExceptionReturn(event);
}
    69a4:	5d                   	pop    %rbp
    return PAL_TRUE;
}

void DkExceptionReturn (PAL_PTR event)
{
    _DkExceptionReturn(event);
    69a5:	e9 b6 e7 00 00       	jmpq   15160 <_DkExceptionReturn>
    69aa:	90                   	nop    
    69ab:	90                   	nop    
    69ac:	90                   	nop    
    69ad:	90                   	nop    
    69ae:	90                   	nop    
    69af:	90                   	nop    

00000000000069b0 <_dl_debug_state>:
   examining the r_brk member of struct r_debug, but GDB 4.15 in fact looks
   for this particular symbol name in the PT_INTERP file.  */

/* The special symbol name is set as breakpoint in gdb */
void __attribute__((noinline)) pal_dl_debug_state (void)
{
    69b0:	55                   	push   %rbp
    69b1:	48 89 e5             	mov    %rsp,%rbp
}
    69b4:	5d                   	pop    %rbp
    69b5:	c3                   	retq   
    69b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    69bd:	00 00 00 

00000000000069c0 <check_match>:
    return hash;
}

/* Nested routine to check whether the symbol matches.  */
static ElfW(Sym) * check_match (ElfW(Sym) *sym, const char * strtab, const char * undef_name, ElfW(Sym) * ref)
    {
    69c0:	55                   	push   %rbp
    69c1:	48 89 e5             	mov    %rsp,%rbp
    69c4:	41 56                	push   %r14
    69c6:	41 55                	push   %r13
    69c8:	41 54                	push   %r12
    69ca:	53                   	push   %rbx
        unsigned int stt = ELFW(ST_TYPE) (sym->st_info);
    69cb:	0f b6 47 04          	movzbl 0x4(%rdi),%eax
    69cf:	83 e0 0f             	and    $0xf,%eax
        assert (ELF_RTYPE_CLASS_PLT == 1);

        if (__builtin_expect ((sym->st_value == 0 /* No value.  */
    69d2:	3c 06                	cmp    $0x6,%al
    69d4:	74 0b                	je     69e1 <check_match+0x21>
    69d6:	48 83 7f 08 00       	cmpq   $0x0,0x8(%rdi)
    69db:	0f 84 7f 00 00 00    	je     6a60 <check_match+0xa0>
    69e1:	66 83 7f 06 00       	cmpw   $0x0,0x6(%rdi)
    69e6:	74 78                	je     6a60 <check_match+0xa0>
           code/data definitions.  */
#define ALLOWED_STT     \
        ((1 << STT_NOTYPE) | (1 << STT_OBJECT) | (1 << STT_FUNC)        \
       | (1 << STT_COMMON) | (1 << STT_TLS)    | (1 << STT_GNU_IFUNC))

        if (__builtin_expect (((1 << stt) & ALLOWED_STT) == 0, 0))
    69e8:	41 b8 67 04 00 00    	mov    $0x467,%r8d
    69ee:	41 0f a3 c0          	bt     %eax,%r8d
    69f2:	73 6c                	jae    6a60 <check_match+0xa0>
            return NULL;

        if (sym != ref) {
    69f4:	48 39 cf             	cmp    %rcx,%rdi
    69f7:	49 89 fe             	mov    %rdi,%r14
    69fa:	74 67                	je     6a63 <check_match+0xa3>
    69fc:	49 89 fd             	mov    %rdi,%r13
            int i = 0, len = strlen(undef_name);
    69ff:	48 89 d7             	mov    %rdx,%rdi
    6a02:	49 89 f4             	mov    %rsi,%r12
    6a05:	48 89 d3             	mov    %rdx,%rbx
    6a08:	e8 93 fd 00 00       	callq  167a0 <strlen>
            for (; i < len ; i++)
    6a0d:	85 c0                	test   %eax,%eax

        if (__builtin_expect (((1 << stt) & ALLOWED_STT) == 0, 0))
            return NULL;

        if (sym != ref) {
            int i = 0, len = strlen(undef_name);
    6a0f:	48 89 c6             	mov    %rax,%rsi
            for (; i < len ; i++)
    6a12:	7e 4f                	jle    6a63 <check_match+0xa3>
                if (strtab[sym->st_name + i] != undef_name[i])
    6a14:	41 8b 16             	mov    (%r14),%edx
    6a17:	0f b6 3b             	movzbl (%rbx),%edi
    6a1a:	41 38 3c 14          	cmp    %dil,(%r12,%rdx,1)
    6a1e:	48 89 d0             	mov    %rdx,%rax
    6a21:	75 3d                	jne    6a60 <check_match+0xa0>
    6a23:	8d 4a 01             	lea    0x1(%rdx),%ecx
    6a26:	01 f0                	add    %esi,%eax
    6a28:	48 8d 53 01          	lea    0x1(%rbx),%rdx
    6a2c:	eb 16                	jmp    6a44 <check_match+0x84>
    6a2e:	66 90                	xchg   %ax,%ax
    6a30:	41 89 c9             	mov    %ecx,%r9d
    6a33:	44 0f b6 02          	movzbl (%rdx),%r8d
    6a37:	83 c1 01             	add    $0x1,%ecx
    6a3a:	48 83 c2 01          	add    $0x1,%rdx
    6a3e:	47 38 04 0c          	cmp    %r8b,(%r12,%r9,1)
    6a42:	75 1c                	jne    6a60 <check_match+0xa0>
        if (__builtin_expect (((1 << stt) & ALLOWED_STT) == 0, 0))
            return NULL;

        if (sym != ref) {
            int i = 0, len = strlen(undef_name);
            for (; i < len ; i++)
    6a44:	39 c1                	cmp    %eax,%ecx
    6a46:	75 e8                	jne    6a30 <check_match+0x70>
    6a48:	4d 89 ee             	mov    %r13,%r14
                    return NULL;
        }	    

        /* There cannot be another entry for this symbol so stop here.  */
        return sym;
    }
    6a4b:	5b                   	pop    %rbx
    6a4c:	4c 89 f0             	mov    %r14,%rax
    6a4f:	41 5c                	pop    %r12
    6a51:	41 5d                	pop    %r13
    6a53:	41 5e                	pop    %r14
    6a55:	5d                   	pop    %rbp
    6a56:	c3                   	retq   
    6a57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    6a5e:	00 00 
        assert (ELF_RTYPE_CLASS_PLT == 1);

        if (__builtin_expect ((sym->st_value == 0 /* No value.  */
                               && stt != STT_TLS)
            || sym->st_shndx == SHN_UNDEF, 0))
            return NULL;
    6a60:	45 31 f6             	xor    %r14d,%r14d
                    return NULL;
        }	    

        /* There cannot be another entry for this symbol so stop here.  */
        return sym;
    }
    6a63:	5b                   	pop    %rbx
    6a64:	4c 89 f0             	mov    %r14,%rax
    6a67:	41 5c                	pop    %r12
    6a69:	41 5d                	pop    %r13
    6a6b:	41 5e                	pop    %r14
    6a6d:	5d                   	pop    %rbp
    6a6e:	c3                   	retq   
    6a6f:	90                   	nop    

0000000000006a70 <__assert>:
struct link_map * lookup_symbol (const char *undef_name, ElfW(Sym) **ref);

#ifdef assert
/* This function can be used as a breakpoint to debug assertion */
void __attribute__((noinline)) __assert (void)
{
    6a70:	55                   	push   %rbp
    6a71:	48 89 e5             	mov    %rsp,%rbp
    BREAK();
    6a74:	cc                   	int3   
}
    6a75:	5d                   	pop    %rbp
    6a76:	c3                   	retq   
    6a77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    6a7e:	00 00 

0000000000006a80 <_dl_debug_state_trigger>:

extern __typeof(pal_dl_debug_state) _dl_debug_state
    __attribute ((alias ("pal_dl_debug_state")));

void __attribute__((noinline)) _dl_debug_state_trigger (void)
{
    6a80:	55                   	push   %rbp
    6a81:	48 89 e5             	mov    %rsp,%rbp
    6a84:	53                   	push   %rbx
    6a85:	48 83 ec 08          	sub    $0x8,%rsp
    struct link_map *l = pal_r_debug.r_map;
    6a89:	48 8b 05 b8 cf 21 00 	mov    0x21cfb8(%rip),%rax        # 223a48 <_DYNAMIC+0x260>
    6a90:	48 8b 58 08          	mov    0x8(%rax),%rbx
    for ( ; l ; l = l->l_next)
    6a94:	48 85 db             	test   %rbx,%rbx
    6a97:	74 2e                	je     6ac7 <_dl_debug_state_trigger+0x47>
    6a99:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        if (!memcmp(l->l_name, "file:", 5))
    6aa0:	48 8b 7b 08          	mov    0x8(%rbx),%rdi
    6aa4:	48 8d 35 13 23 01 00 	lea    0x12313(%rip),%rsi        # 18dbe <handle_sizes.1924+0x63e>
    6aab:	ba 05 00 00 00       	mov    $0x5,%edx
    6ab0:	e8 5b f8 00 00       	callq  16310 <memcmp>
    6ab5:	85 c0                	test   %eax,%eax
    6ab7:	75 05                	jne    6abe <_dl_debug_state_trigger+0x3e>
            l->l_name += 5;
    6ab9:	48 83 43 08 05       	addq   $0x5,0x8(%rbx)
    __attribute ((alias ("pal_dl_debug_state")));

void __attribute__((noinline)) _dl_debug_state_trigger (void)
{
    struct link_map *l = pal_r_debug.r_map;
    for ( ; l ; l = l->l_next)
    6abe:	48 8b 5b 18          	mov    0x18(%rbx),%rbx
    6ac2:	48 85 db             	test   %rbx,%rbx
    6ac5:	75 d9                	jne    6aa0 <_dl_debug_state_trigger+0x20>
        if (!memcmp(l->l_name, "file:", 5))
            l->l_name += 5;

    pal_dl_debug_state();
}
    6ac7:	48 83 c4 08          	add    $0x8,%rsp
    6acb:	5b                   	pop    %rbx
    6acc:	5d                   	pop    %rbp
    struct link_map *l = pal_r_debug.r_map;
    for ( ; l ; l = l->l_next)
        if (!memcmp(l->l_name, "file:", 5))
            l->l_name += 5;

    pal_dl_debug_state();
    6acd:	e9 de fe ff ff       	jmpq   69b0 <_dl_debug_state>
    6ad2:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
    6ad9:	1f 84 00 00 00 00 00 

0000000000006ae0 <new_elf_object>:

/* Allocate a `struct link_map' for a new object being loaded,
   and enter it into the _dl_loaded list.  */
struct link_map *
new_elf_object (const char * realname, enum object_type type)
{
    6ae0:	55                   	push   %rbp
    6ae1:	48 89 e5             	mov    %rsp,%rbp
    6ae4:	41 55                	push   %r13
    6ae6:	41 54                	push   %r12
    6ae8:	53                   	push   %rbx
    6ae9:	49 89 fc             	mov    %rdi,%r12
    struct link_map *new;

    new = (struct link_map *) malloc(sizeof (struct link_map));
    6aec:	bf 38 03 00 00       	mov    $0x338,%edi

/* Allocate a `struct link_map' for a new object being loaded,
   and enter it into the _dl_loaded list.  */
struct link_map *
new_elf_object (const char * realname, enum object_type type)
{
    6af1:	41 89 f5             	mov    %esi,%r13d
    6af4:	48 83 ec 08          	sub    $0x8,%rsp
    struct link_map *new;

    new = (struct link_map *) malloc(sizeof (struct link_map));
    6af8:	e8 03 1f 00 00       	callq  8a00 <malloc>
    if (new == NULL)
    6afd:	48 85 c0             	test   %rax,%rax
struct link_map *
new_elf_object (const char * realname, enum object_type type)
{
    struct link_map *new;

    new = (struct link_map *) malloc(sizeof (struct link_map));
    6b00:	48 89 c3             	mov    %rax,%rbx
    if (new == NULL)
    6b03:	74 3f                	je     6b44 <new_elf_object+0x64>
        return NULL;

    /* We apparently expect this to be zeroed. */
    memset(new, 0, sizeof(struct link_map));
    6b05:	31 f6                	xor    %esi,%esi
    6b07:	ba 38 03 00 00       	mov    $0x338,%edx
    6b0c:	48 89 c7             	mov    %rax,%rdi
    6b0f:	e8 8c f6 00 00       	callq  161a0 <memset>

    new->l_name = realname ?
                  remalloc(realname, strlen(realname) + 1) :
    6b14:	31 c0                	xor    %eax,%eax
    6b16:	4d 85 e4             	test   %r12,%r12
    6b19:	74 13                	je     6b2e <new_elf_object+0x4e>
    6b1b:	4c 89 e7             	mov    %r12,%rdi
    6b1e:	e8 7d fc 00 00       	callq  167a0 <strlen>
    6b23:	8d 70 01             	lea    0x1(%rax),%esi
    6b26:	4c 89 e7             	mov    %r12,%rdi
    6b29:	e8 d2 20 00 00       	callq  8c00 <remalloc>
        return NULL;

    /* We apparently expect this to be zeroed. */
    memset(new, 0, sizeof(struct link_map));

    new->l_name = realname ?
    6b2e:	48 89 43 08          	mov    %rax,0x8(%rbx)
                  remalloc(realname, strlen(realname) + 1) :
                  NULL;
    new->l_type = type;
    6b32:	44 89 6b 28          	mov    %r13d,0x28(%rbx)
    return new;
    6b36:	48 89 d8             	mov    %rbx,%rax
}
    6b39:	48 83 c4 08          	add    $0x8,%rsp
    6b3d:	5b                   	pop    %rbx
    6b3e:	41 5c                	pop    %r12
    6b40:	41 5d                	pop    %r13
    6b42:	5d                   	pop    %rbp
    6b43:	c3                   	retq   
{
    struct link_map *new;

    new = (struct link_map *) malloc(sizeof (struct link_map));
    if (new == NULL)
        return NULL;
    6b44:	31 c0                	xor    %eax,%eax
    6b46:	eb f1                	jmp    6b39 <new_elf_object+0x59>
    6b48:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    6b4f:	00 

0000000000006b50 <setup_elf_hash>:
    return new;
}

/* Cache the location of MAP's hash table.  */
void setup_elf_hash (struct link_map *map)
{
    6b50:	48 8b 87 a0 02 00 00 	mov    0x2a0(%rdi),%rax
    6b57:	48 85 c0             	test   %rax,%rax
    6b5a:	0f 84 b2 00 00 00    	je     6c12 <setup_elf_hash+0xc2>
    6b60:	55                   	push   %rbp
    6b61:	48 89 e5             	mov    %rsp,%rbp
    6b64:	41 57                	push   %r15
    6b66:	41 56                	push   %r14
    6b68:	41 55                	push   %r13
    6b6a:	41 54                	push   %r12
    6b6c:	53                   	push   %rbx
    6b6d:	48 89 fb             	mov    %rdi,%rbx
    6b70:	48 83 ec 08          	sub    $0x8,%rsp
    Elf_Symndx * hash;

    if (__builtin_expect (map->l_info[DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM
                    + DT_THISPROCNUM + DT_VERSIONTAGNUM
                    + DT_EXTRANUM + DT_VALNUM] != NULL, 1)) {
        Elf32_Word *hash32
    6b74:	4c 8b 68 08          	mov    0x8(%rax),%r13
            = (void *) D_PTR (map->l_info[DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM
                        + DT_THISPROCNUM + DT_VERSIONTAGNUM
                        + DT_EXTRANUM + DT_VALNUM]);

        map->l_nbuckets = *hash32++;
    6b78:	41 8b 45 00          	mov    0x0(%r13),%eax
    6b7c:	89 87 00 03 00 00    	mov    %eax,0x300(%rdi)

        Elf32_Word symbias = *hash32++;
        Elf32_Word bitmask_nwords = *hash32++;
    6b82:	45 8b 65 08          	mov    0x8(%r13),%r12d
                        + DT_THISPROCNUM + DT_VERSIONTAGNUM
                        + DT_EXTRANUM + DT_VALNUM]);

        map->l_nbuckets = *hash32++;

        Elf32_Word symbias = *hash32++;
    6b86:	45 8b 75 04          	mov    0x4(%r13),%r14d
        Elf32_Word bitmask_nwords = *hash32++;

        /* Must be a power of two.  */
        assert ((bitmask_nwords & (bitmask_nwords - 1)) == 0);
    6b8a:	45 8d 7c 24 ff       	lea    -0x1(%r12),%r15d
    6b8f:	45 85 e7             	test   %r12d,%r15d
    6b92:	74 36                	je     6bca <setup_elf_hash+0x7a>
    6b94:	48 8d 15 29 22 01 00 	lea    0x12229(%rip),%rdx        # 18dc4 <handle_sizes.1924+0x644>
    6b9b:	48 8d 35 b6 22 01 00 	lea    0x122b6(%rip),%rsi        # 18e58 <handle_sizes.1924+0x6d8>
    6ba2:	48 8d 3d 8f 1b 01 00 	lea    0x11b8f(%rip),%rdi        # 18738 <write_config+0x188>
    6ba9:	b9 95 00 00 00       	mov    $0x95,%ecx
    6bae:	31 c0                	xor    %eax,%eax
    6bb0:	e8 6b 22 00 00       	callq  8e20 <pal_printf>
    6bb5:	e8 b6 fe ff ff       	callq  6a70 <__assert>
    6bba:	bf 01 00 00 00       	mov    $0x1,%edi
    6bbf:	e8 bc b9 00 00       	callq  12580 <_DkProcessExit>
    6bc4:	8b 83 00 03 00 00    	mov    0x300(%rbx),%eax
        map->l_gnu_bitmask_idxbits = bitmask_nwords - 1;
        map->l_gnu_shift = *hash32++;
    6bca:	49 8d 55 10          	lea    0x10(%r13),%rdx

        map->l_gnu_bitmask = (ElfW(Addr) *) hash32;
        hash32 += __ELF_NATIVE_CLASS / 32 * bitmask_nwords;
    6bce:	45 01 e4             	add    %r12d,%r12d
        Elf32_Word symbias = *hash32++;
        Elf32_Word bitmask_nwords = *hash32++;

        /* Must be a power of two.  */
        assert ((bitmask_nwords & (bitmask_nwords - 1)) == 0);
        map->l_gnu_bitmask_idxbits = bitmask_nwords - 1;
    6bd1:	44 89 bb 18 03 00 00 	mov    %r15d,0x318(%rbx)
        map->l_gnu_shift = *hash32++;
    6bd8:	41 8b 4d 0c          	mov    0xc(%r13),%ecx
        map->l_gnu_bitmask = (ElfW(Addr) *) hash32;
        hash32 += __ELF_NATIVE_CLASS / 32 * bitmask_nwords;

        map->l_gnu_buckets = hash32;
        hash32 += map->l_nbuckets;
        map->l_gnu_chain_zero = hash32 - symbias;
    6bdc:	4c 29 f0             	sub    %r14,%rax
        /* Must be a power of two.  */
        assert ((bitmask_nwords & (bitmask_nwords - 1)) == 0);
        map->l_gnu_bitmask_idxbits = bitmask_nwords - 1;
        map->l_gnu_shift = *hash32++;

        map->l_gnu_bitmask = (ElfW(Addr) *) hash32;
    6bdf:	48 89 93 20 03 00 00 	mov    %rdx,0x320(%rbx)
        hash32 += __ELF_NATIVE_CLASS / 32 * bitmask_nwords;
    6be6:	4a 8d 14 a2          	lea    (%rdx,%r12,4),%rdx

        map->l_gnu_buckets = hash32;
        hash32 += map->l_nbuckets;
        map->l_gnu_chain_zero = hash32 - symbias;
    6bea:	48 8d 04 82          	lea    (%rdx,%rax,4),%rax
        Elf32_Word bitmask_nwords = *hash32++;

        /* Must be a power of two.  */
        assert ((bitmask_nwords & (bitmask_nwords - 1)) == 0);
        map->l_gnu_bitmask_idxbits = bitmask_nwords - 1;
        map->l_gnu_shift = *hash32++;
    6bee:	89 8b 1c 03 00 00    	mov    %ecx,0x31c(%rbx)

        map->l_gnu_bitmask = (ElfW(Addr) *) hash32;
        hash32 += __ELF_NATIVE_CLASS / 32 * bitmask_nwords;

        map->l_gnu_buckets = hash32;
    6bf4:	48 89 93 28 03 00 00 	mov    %rdx,0x328(%rbx)
        hash32 += map->l_nbuckets;
        map->l_gnu_chain_zero = hash32 - symbias;
    6bfb:	48 89 83 30 03 00 00 	mov    %rax,0x330(%rbx)
    map->l_nbuckets = *hash++;
    hash++;
    map->l_buckets = hash;
    hash += map->l_nbuckets;
    map->l_chain = hash;
}
    6c02:	48 83 c4 08          	add    $0x8,%rsp
    6c06:	5b                   	pop    %rbx
    6c07:	41 5c                	pop    %r12
    6c09:	41 5d                	pop    %r13
    6c0b:	41 5e                	pop    %r14
    6c0d:	41 5f                	pop    %r15
    6c0f:	5d                   	pop    %rbp
    6c10:	f3 c3                	repz retq 
        map->l_gnu_chain_zero = hash32 - symbias;

        return;
    }

    if (!map->l_info[DT_HASH])
    6c12:	48 8b 47 68          	mov    0x68(%rdi),%rax
    6c16:	48 85 c0             	test   %rax,%rax
    6c19:	74 f5                	je     6c10 <setup_elf_hash+0xc0>
        return;

    hash = (void *) D_PTR (map->l_info[DT_HASH]);
    6c1b:	48 8b 40 08          	mov    0x8(%rax),%rax
         [   bucket[nbucket-1]   ]
         [       chain[0]        ]
         [          ...          ]
         [    chain[nchain-1]    ] */

    map->l_nbuckets = *hash++;
    6c1f:	8b 10                	mov    (%rax),%edx
    hash++;
    6c21:	48 83 c0 08          	add    $0x8,%rax
    map->l_buckets = hash;
    6c25:	48 89 87 08 03 00 00 	mov    %rax,0x308(%rdi)
    hash += map->l_nbuckets;
    6c2c:	48 8d 04 90          	lea    (%rax,%rdx,4),%rax
         [   bucket[nbucket-1]   ]
         [       chain[0]        ]
         [          ...          ]
         [    chain[nchain-1]    ] */

    map->l_nbuckets = *hash++;
    6c30:	89 97 00 03 00 00    	mov    %edx,0x300(%rdi)
    hash++;
    map->l_buckets = hash;
    hash += map->l_nbuckets;
    6c36:	48 89 87 10 03 00 00 	mov    %rax,0x310(%rdi)
    6c3d:	c3                   	retq   
    6c3e:	66 90                	xchg   %ax,%ax

0000000000006c40 <map_elf_object_by_handle>:
   opened on FD */
struct link_map *
map_elf_object_by_handle (PAL_HANDLE handle, enum object_type type,
                          void * fbp, size_t fbp_len,
                          bool do_copy_dyn)
{
    6c40:	55                   	push   %rbp
    6c41:	48 89 e5             	mov    %rsp,%rbp
    6c44:	41 57                	push   %r15
    6c46:	41 56                	push   %r14
    6c48:	41 55                	push   %r13
    6c4a:	41 54                	push   %r12
    6c4c:	49 89 ff             	mov    %rdi,%r15
    6c4f:	53                   	push   %rbx
    6c50:	89 f3                	mov    %esi,%ebx
    6c52:	49 89 cc             	mov    %rcx,%r12
    6c55:	48 83 ec 68          	sub    $0x68,%rsp
    6c59:	48 89 7d 90          	mov    %rdi,-0x70(%rbp)
    6c5d:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    6c61:	44 89 45 88          	mov    %r8d,-0x78(%rbp)
    struct link_map * l = new_elf_object(_DkStreamRealpath(handle), type);
    6c65:	e8 f6 da ff ff       	callq  4760 <_DkStreamRealpath>
    6c6a:	89 de                	mov    %ebx,%esi
    6c6c:	48 89 c7             	mov    %rax,%rdi
    6c6f:	e8 6c fe ff ff       	callq  6ae0 <new_elf_object>
    const char * errstring = NULL;
    int errval = 0;
    int ret;

    if (handle == NULL) {
    6c74:	4d 85 ff             	test   %r15,%r15
struct link_map *
map_elf_object_by_handle (PAL_HANDLE handle, enum object_type type,
                          void * fbp, size_t fbp_len,
                          bool do_copy_dyn)
{
    struct link_map * l = new_elf_object(_DkStreamRealpath(handle), type);
    6c77:	48 89 c3             	mov    %rax,%rbx
    const char * errstring = NULL;
    int errval = 0;
    int ret;

    if (handle == NULL) {
    6c7a:	0f 84 5b 09 00 00    	je     75db <map_elf_object_by_handle+0x99b>
    /* This is the ELF header.  We read it in `open_verify'.  */
    const ElfW(Ehdr) * header = (void *) fbp;

    /* Extract the remaining details we need from the ELF header
       and then read in the program header table.  */
    int e_type = header->e_type;
    6c80:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
    l->l_entry = header->e_entry;
    6c84:	48 8b 47 18          	mov    0x18(%rdi),%rax
    /* This is the ELF header.  We read it in `open_verify'.  */
    const ElfW(Ehdr) * header = (void *) fbp;

    /* Extract the remaining details we need from the ELF header
       and then read in the program header table.  */
    int e_type = header->e_type;
    6c88:	0f b7 57 10          	movzwl 0x10(%rdi),%edx
    l->l_entry = header->e_entry;
    6c8c:	48 89 83 b0 02 00 00 	mov    %rax,0x2b0(%rbx)
    l->l_phnum = header->e_phnum;
    6c93:	0f b7 47 38          	movzwl 0x38(%rdi),%eax
    /* This is the ELF header.  We read it in `open_verify'.  */
    const ElfW(Ehdr) * header = (void *) fbp;

    /* Extract the remaining details we need from the ELF header
       and then read in the program header table.  */
    int e_type = header->e_type;
    6c97:	66 89 55 8e          	mov    %dx,-0x72(%rbp)
    l->l_entry = header->e_entry;
    l->l_phnum = header->e_phnum;

    size_t maplength = header->e_phnum * sizeof (ElfW(Phdr));
    6c9b:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
    6ca2:	00 
    6ca3:	48 89 c2             	mov    %rax,%rdx

    /* Extract the remaining details we need from the ELF header
       and then read in the program header table.  */
    int e_type = header->e_type;
    l->l_entry = header->e_entry;
    l->l_phnum = header->e_phnum;
    6ca6:	66 89 83 b8 02 00 00 	mov    %ax,0x2b8(%rbx)

    size_t maplength = header->e_phnum * sizeof (ElfW(Phdr));
    6cad:	48 c1 e2 06          	shl    $0x6,%rdx
    6cb1:	48 29 ca             	sub    %rcx,%rdx
    ElfW(Phdr) * phdr;

    if (header->e_phoff + maplength <= (size_t) fbp_len) {
    6cb4:	48 8b 4f 20          	mov    0x20(%rdi),%rcx
       and then read in the program header table.  */
    int e_type = header->e_type;
    l->l_entry = header->e_entry;
    l->l_phnum = header->e_phnum;

    size_t maplength = header->e_phnum * sizeof (ElfW(Phdr));
    6cb8:	49 89 d5             	mov    %rdx,%r13
    ElfW(Phdr) * phdr;

    if (header->e_phoff + maplength <= (size_t) fbp_len) {
    6cbb:	49 8d 74 0d 00       	lea    0x0(%r13,%rcx,1),%rsi
    6cc0:	4c 39 e6             	cmp    %r12,%rsi
    6cc3:	0f 87 c7 05 00 00    	ja     7290 <map_elf_object_by_handle+0x650>
        phdr = (void *) (fbp + header->e_phoff);
    6cc9:	48 01 f9             	add    %rdi,%rcx
    6ccc:	4c 89 ea             	mov    %r13,%rdx
    6ccf:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
    /* Scan the program header table, collecting its load commands.  */
    struct loadcmd {
        ElfW(Addr) mapstart, mapend, dataend, allocend;
        off_t mapoff;
        int prot;
    } loadcmds[l->l_phnum], *c;
    6cd3:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    6cd7:	48 89 65 98          	mov    %rsp,-0x68(%rbp)
    6cdb:	48 c1 e0 04          	shl    $0x4,%rax
    6cdf:	48 83 c0 16          	add    $0x16,%rax
    6ce3:	25 f0 ff ff 00       	and    $0xfffff0,%eax
    6ce8:	48 29 c4             	sub    %rax,%rsp
    6ceb:	48 8d 44 24 07       	lea    0x7(%rsp),%rax
    6cf0:	48 c1 e8 03          	shr    $0x3,%rax
    6cf4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    6cf8:	4c 8d 2c c5 00 00 00 	lea    0x0(,%rax,8),%r13
    6cff:	00 
       l->l_ld = 0;
       l->l_phdr = 0;
       l->l_addr = 0; */

    const ElfW(Phdr) * ph;
    for (ph = phdr; ph < &phdr[l->l_phnum]; ++ph)
    6d00:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    6d04:	48 01 c2             	add    %rax,%rdx
    6d07:	48 39 d0             	cmp    %rdx,%rax
    6d0a:	0f 83 67 08 00 00    	jae    7577 <map_elf_object_by_handle+0x937>
                break;

            case PT_LOAD:
                /* A load command tells us to map in part of the file.
                   We record the load commands and process them all later.  */
                if (__builtin_expect ((ph->p_align & allocshift) != 0, 0)) {
    6d10:	48 8b 0d 31 ce 21 00 	mov    0x21ce31(%rip),%rcx        # 223b48 <_DYNAMIC+0x360>
                    errval = ENOMEM;
                    goto call_lose;
                }

                c = &loadcmds[nloadcmds++];
                c->mapstart = ALLOC_ALIGNDOWN(ph->p_vaddr);
    6d17:	48 89 c6             	mov    %rax,%rsi
    6d1a:	45 31 f6             	xor    %r14d,%r14d
    6d1d:	45 31 e4             	xor    %r12d,%r12d
                break;

            case PT_LOAD:
                /* A load command tells us to map in part of the file.
                   We record the load commands and process them all later.  */
                if (__builtin_expect ((ph->p_align & allocshift) != 0, 0)) {
    6d20:	4c 8b 09             	mov    (%rcx),%r9
                    errval = ENOMEM;
                    goto call_lose;
                }

                c = &loadcmds[nloadcmds++];
                c->mapstart = ALLOC_ALIGNDOWN(ph->p_vaddr);
    6d23:	48 8b 0d 66 cc 21 00 	mov    0x21cc66(%rip),%rcx        # 223990 <_DYNAMIC+0x1a8>
    6d2a:	48 8b 09             	mov    (%rcx),%rcx
    6d2d:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
    6d31:	48 8b 0d c0 cd 21 00 	mov    0x21cdc0(%rip),%rcx        # 223af8 <_DYNAMIC+0x310>
    6d38:	4c 8b 19             	mov    (%rcx),%r11
    6d3b:	eb 36                	jmp    6d73 <map_elf_object_by_handle+0x133>
    6d3d:	0f 1f 00             	nopl   (%rax)
       l->l_phdr = 0;
       l->l_addr = 0; */

    const ElfW(Phdr) * ph;
    for (ph = phdr; ph < &phdr[l->l_phnum]; ++ph)
        switch (ph->p_type)
    6d40:	83 f8 06             	cmp    $0x6,%eax
    6d43:	0f 84 fa 04 00 00    	je     7243 <map_elf_object_by_handle+0x603>
    6d49:	3d 52 e5 74 64       	cmp    $0x6474e552,%eax
    6d4e:	75 16                	jne    6d66 <map_elf_object_by_handle+0x126>
            case PT_GNU_STACK:
                //stack_flags = ph->p_flags;
                break;

            case PT_GNU_RELRO:
                l->l_relro_addr = ph->p_vaddr;
    6d50:	48 8b 46 10          	mov    0x10(%rsi),%rax
    6d54:	48 89 83 f0 02 00 00 	mov    %rax,0x2f0(%rbx)
                l->l_relro_size = ph->p_memsz;
    6d5b:	48 8b 46 28          	mov    0x28(%rsi),%rax
    6d5f:	48 89 83 f8 02 00 00 	mov    %rax,0x2f8(%rbx)
       l->l_ld = 0;
       l->l_phdr = 0;
       l->l_addr = 0; */

    const ElfW(Phdr) * ph;
    for (ph = phdr; ph < &phdr[l->l_phnum]; ++ph)
    6d66:	48 83 c6 38          	add    $0x38,%rsi
    6d6a:	48 39 d6             	cmp    %rdx,%rsi
    6d6d:	0f 83 dd 00 00 00    	jae    6e50 <map_elf_object_by_handle+0x210>
        switch (ph->p_type)
    6d73:	8b 06                	mov    (%rsi),%eax
    6d75:	83 f8 02             	cmp    $0x2,%eax
    6d78:	0f 84 d5 04 00 00    	je     7253 <map_elf_object_by_handle+0x613>
    6d7e:	77 c0                	ja     6d40 <map_elf_object_by_handle+0x100>
    6d80:	83 f8 01             	cmp    $0x1,%eax
    6d83:	75 e1                	jne    6d66 <map_elf_object_by_handle+0x126>
                break;

            case PT_LOAD:
                /* A load command tells us to map in part of the file.
                   We record the load commands and process them all later.  */
                if (__builtin_expect ((ph->p_align & allocshift) != 0, 0)) {
    6d85:	48 8b 7e 30          	mov    0x30(%rsi),%rdi
    6d89:	4c 85 cf             	test   %r9,%rdi
    6d8c:	0f 85 5e 05 00 00    	jne    72f0 <map_elf_object_by_handle+0x6b0>
                    errstring = "ELF load command alignment not aligned";
                    errval = ENOMEM;
                    goto call_lose;
                }

                if (__builtin_expect (((ph->p_vaddr - ph->p_offset)
    6d92:	48 8b 46 10          	mov    0x10(%rsi),%rax
    6d96:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
                                       & (ph->p_align - 1)) != 0, 0)) {
    6d9a:	48 83 ef 01          	sub    $0x1,%rdi
                    errstring = "ELF load command alignment not aligned";
                    errval = ENOMEM;
                    goto call_lose;
                }

                if (__builtin_expect (((ph->p_vaddr - ph->p_offset)
    6d9e:	49 89 c0             	mov    %rax,%r8
    6da1:	49 29 c8             	sub    %rcx,%r8
    6da4:	4c 85 c7             	test   %r8,%rdi
    6da7:	0f 85 93 05 00 00    	jne    7340 <map_elf_object_by_handle+0x700>
    6dad:	4b 8d 3c 64          	lea    (%r12,%r12,2),%rdi
                        ELF load command address/offset not properly aligned";
                    errval = ENOMEM;
                    goto call_lose;
                }

                c = &loadcmds[nloadcmds++];
    6db1:	4d 8d 44 24 01       	lea    0x1(%r12),%r8
    6db6:	48 c1 e7 04          	shl    $0x4,%rdi
    6dba:	4c 01 ef             	add    %r13,%rdi
                c->mapstart = ALLOC_ALIGNDOWN(ph->p_vaddr);
    6dbd:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
    6dc2:	0f 84 a8 04 00 00    	je     7270 <map_elf_object_by_handle+0x630>
    6dc8:	49 89 c7             	mov    %rax,%r15
    6dcb:	4c 03 7e 20          	add    0x20(%rsi),%r15
    6dcf:	49 89 c2             	mov    %rax,%r10
    6dd2:	4d 21 da             	and    %r11,%r10
                c->mapend = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_filesz);
                c->dataend = ph->p_vaddr + ph->p_filesz;
                c->allocend = ph->p_vaddr + ph->p_memsz;
    6dd5:	48 03 46 28          	add    0x28(%rsi),%rax
                c->mapoff = ALLOC_ALIGNDOWN(ph->p_offset);
    6dd9:	4c 21 d9             	and    %r11,%rcx
                    errval = ENOMEM;
                    goto call_lose;
                }

                c = &loadcmds[nloadcmds++];
                c->mapstart = ALLOC_ALIGNDOWN(ph->p_vaddr);
    6ddc:	4c 89 17             	mov    %r10,(%rdi)
                c->mapend = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_filesz);
    6ddf:	4f 8d 14 0f          	lea    (%r15,%r9,1),%r10
                c->dataend = ph->p_vaddr + ph->p_filesz;
    6de3:	4c 89 7f 10          	mov    %r15,0x10(%rdi)
                c->allocend = ph->p_vaddr + ph->p_memsz;
    6de7:	48 89 47 18          	mov    %rax,0x18(%rdi)
                    goto call_lose;
                }

                c = &loadcmds[nloadcmds++];
                c->mapstart = ALLOC_ALIGNDOWN(ph->p_vaddr);
                c->mapend = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_filesz);
    6deb:	4d 21 da             	and    %r11,%r10
    6dee:	4c 89 57 08          	mov    %r10,0x8(%rdi)
                c->dataend = ph->p_vaddr + ph->p_filesz;
                c->allocend = ph->p_vaddr + ph->p_memsz;
                c->mapoff = ALLOC_ALIGNDOWN(ph->p_offset);
    6df2:	4b 8d 04 64          	lea    (%r12,%r12,2),%rax
    6df6:	48 c1 e0 04          	shl    $0x4,%rax

                /* Determine whether there is a gap between the last segment
                   and this one.  */
                if (nloadcmds > 1 && c[-1].mapend != c->mapstart)
    6dfa:	49 83 f8 01          	cmp    $0x1,%r8
                c = &loadcmds[nloadcmds++];
                c->mapstart = ALLOC_ALIGNDOWN(ph->p_vaddr);
                c->mapend = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_filesz);
                c->dataend = ph->p_vaddr + ph->p_filesz;
                c->allocend = ph->p_vaddr + ph->p_memsz;
                c->mapoff = ALLOC_ALIGNDOWN(ph->p_offset);
    6dfe:	49 8d 7c 05 00       	lea    0x0(%r13,%rax,1),%rdi
    6e03:	48 89 4f 20          	mov    %rcx,0x20(%rdi)

                /* Determine whether there is a gap between the last segment
                   and this one.  */
                if (nloadcmds > 1 && c[-1].mapend != c->mapstart)
    6e07:	76 11                	jbe    6e1a <map_elf_object_by_handle+0x1da>
                    has_holes = true;
    6e09:	48 8b 0f             	mov    (%rdi),%rcx
    6e0c:	49 39 4c 05 d8       	cmp    %rcx,-0x28(%r13,%rax,1)
    6e11:	b8 01 00 00 00       	mov    $0x1,%eax
    6e16:	44 0f 45 f0          	cmovne %eax,%r14d

                /* Optimize a common case.  */
#if (PF_R | PF_W | PF_X) == 7 && (PROT_READ | PROT_WRITE | PROT_EXEC) == 7
                c->prot = (PF_TO_PROT
                          >> ((ph->p_flags & (PF_R | PF_W | PF_X)) * 4)) & 0xf;
    6e1a:	8b 4e 04             	mov    0x4(%rsi),%ecx
    6e1d:	bf 40 62 51 73       	mov    $0x73516240,%edi
                if (nloadcmds > 1 && c[-1].mapend != c->mapstart)
                    has_holes = true;

                /* Optimize a common case.  */
#if (PF_R | PF_W | PF_X) == 7 && (PROT_READ | PROT_WRITE | PROT_EXEC) == 7
                c->prot = (PF_TO_PROT
    6e22:	4b 8d 04 64          	lea    (%r12,%r12,2),%rax
       l->l_ld = 0;
       l->l_phdr = 0;
       l->l_addr = 0; */

    const ElfW(Phdr) * ph;
    for (ph = phdr; ph < &phdr[l->l_phnum]; ++ph)
    6e26:	48 83 c6 38          	add    $0x38,%rsi
                        ELF load command address/offset not properly aligned";
                    errval = ENOMEM;
                    goto call_lose;
                }

                c = &loadcmds[nloadcmds++];
    6e2a:	4d 89 c4             	mov    %r8,%r12
                if (nloadcmds > 1 && c[-1].mapend != c->mapstart)
                    has_holes = true;

                /* Optimize a common case.  */
#if (PF_R | PF_W | PF_X) == 7 && (PROT_READ | PROT_WRITE | PROT_EXEC) == 7
                c->prot = (PF_TO_PROT
    6e2d:	48 c1 e0 04          	shl    $0x4,%rax
                          >> ((ph->p_flags & (PF_R | PF_W | PF_X)) * 4)) & 0xf;
    6e31:	83 e1 07             	and    $0x7,%ecx
    6e34:	c1 e1 02             	shl    $0x2,%ecx
    6e37:	d3 ff                	sar    %cl,%edi
    6e39:	89 f9                	mov    %edi,%ecx
    6e3b:	83 e1 0f             	and    $0xf,%ecx
       l->l_ld = 0;
       l->l_phdr = 0;
       l->l_addr = 0; */

    const ElfW(Phdr) * ph;
    for (ph = phdr; ph < &phdr[l->l_phnum]; ++ph)
    6e3e:	48 39 d6             	cmp    %rdx,%rsi
                    has_holes = true;

                /* Optimize a common case.  */
#if (PF_R | PF_W | PF_X) == 7 && (PROT_READ | PROT_WRITE | PROT_EXEC) == 7
                c->prot = (PF_TO_PROT
                          >> ((ph->p_flags & (PF_R | PF_W | PF_X)) * 4)) & 0xf;
    6e41:	41 89 4c 05 28       	mov    %ecx,0x28(%r13,%rax,1)
       l->l_ld = 0;
       l->l_phdr = 0;
       l->l_addr = 0; */

    const ElfW(Phdr) * ph;
    for (ph = phdr; ph < &phdr[l->l_phnum]; ++ph)
    6e46:	0f 82 27 ff ff ff    	jb     6d73 <map_elf_object_by_handle+0x133>
    6e4c:	0f 1f 40 00          	nopl   0x0(%rax)
                l->l_relro_addr = ph->p_vaddr;
                l->l_relro_size = ph->p_memsz;
                break;
        }

    if (__builtin_expect (nloadcmds == 0, 0)) {
    6e50:	4d 85 e4             	test   %r12,%r12
    6e53:	0f 84 1e 07 00 00    	je     7577 <map_elf_object_by_handle+0x937>

    /* Now process the load commands and map segments into memory.  */
    c = loadcmds;

    /* Length of the sections to be loaded.  */
    maplength = loadcmds[nloadcmds - 1].allocend - c->mapstart;
    6e59:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    6e5d:	4d 8d 4c 24 ff       	lea    -0x1(%r12),%r9
    6e62:	4c 8b 14 c5 00 00 00 	mov    0x0(,%rax,8),%r10
    6e69:	00 
    6e6a:	4b 8d 04 49          	lea    (%r9,%r9,2),%rax
    6e6e:	48 c1 e0 04          	shl    $0x4,%rax
    6e72:	4d 8b 7c 05 18       	mov    0x18(%r13,%rax,1),%r15
    6e77:	4d 29 d7             	sub    %r10,%r15

#define APPEND_WRITECOPY(prot) ((prot)|PAL_PROT_WRITECOPY)

    if (__builtin_expect (e_type, ET_DYN) == ET_DYN) {
    6e7a:	66 83 7d 8e 03       	cmpw   $0x3,-0x72(%rbp)
    6e7f:	0f 85 05 07 00 00    	jne    758a <map_elf_object_by_handle+0x94a>

static void * __heap_base = NULL;

static ElfW(Addr) __get_heap_base (size_t size)
{
    if (__heap_base == (void *) -1)
    6e85:	48 8b 15 94 db 21 00 	mov    0x21db94(%rip),%rdx        # 224a20 <__heap_base>
    6e8c:	48 83 fa ff          	cmp    $0xffffffffffffffff,%rdx
    6e90:	0f 84 17 07 00 00    	je     75ad <map_elf_object_by_handle+0x96d>
        return 0;

    if (!__heap_base &&
    6e96:	48 85 d2             	test   %rdx,%rdx
    6e99:	0f 84 51 06 00 00    	je     74f0 <map_elf_object_by_handle+0x8b0>
        !(__heap_base = pal_config.heap_base)) {
        __heap_base = (void *) -1;
        return 0;
    }

    return (ElfW(Addr)) (__heap_base -= ALLOC_ALIGNUP(size));
    6e9f:	48 8b 0d ea ca 21 00 	mov    0x21caea(%rip),%rcx        # 223990 <_DYNAMIC+0x1a8>
    6ea6:	4c 89 f8             	mov    %r15,%rax
    6ea9:	48 f7 d8             	neg    %rax
    6eac:	48 83 39 00          	cmpq   $0x0,(%rcx)
    6eb0:	0f 85 da 04 00 00    	jne    7390 <map_elf_object_by_handle+0x750>
    6eb6:	48 01 d0             	add    %rdx,%rax
    6eb9:	48 89 05 60 db 21 00 	mov    %rax,0x21db60(%rip)        # 224a20 <__heap_base>
           there to remap from the later segments.

           As a refinement, sometimes we have an address that we would
           prefer to map such objects at; but this is only a preference,
           the OS can do whatever it likes. */
        ElfW(Addr) mappref = __get_heap_base(maplength);
    6ec0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

        /* Remember which part of the address space this object uses.  */
        errval = _DkStreamMap(handle, (void **) &mappref,
                              APPEND_WRITECOPY(c->prot), c->mapoff,
    6ec4:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
           prefer to map such objects at; but this is only a preference,
           the OS can do whatever it likes. */
        ElfW(Addr) mappref = __get_heap_base(maplength);

        /* Remember which part of the address space this object uses.  */
        errval = _DkStreamMap(handle, (void **) &mappref,
    6ec8:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
    6ecc:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    6ed0:	4d 89 f8             	mov    %r15,%r8
    6ed3:	4c 89 95 70 ff ff ff 	mov    %r10,-0x90(%rbp)
    6eda:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
                              APPEND_WRITECOPY(c->prot), c->mapoff,
    6ee1:	44 8b 1c c5 28 00 00 	mov    0x28(,%rax,8),%r11d
    6ee8:	00 
           prefer to map such objects at; but this is only a preference,
           the OS can do whatever it likes. */
        ElfW(Addr) mappref = __get_heap_base(maplength);

        /* Remember which part of the address space this object uses.  */
        errval = _DkStreamMap(handle, (void **) &mappref,
    6ee9:	48 8b 04 c5 20 00 00 	mov    0x20(,%rax,8),%rax
    6ef0:	00 
    6ef1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    6ef5:	8b 4d b8             	mov    -0x48(%rbp),%ecx
    6ef8:	44 89 da             	mov    %r11d,%edx
    6efb:	83 ca 08             	or     $0x8,%edx
    6efe:	44 89 5d 80          	mov    %r11d,-0x80(%rbp)
    6f02:	e8 99 d3 ff ff       	callq  42a0 <_DkStreamMap>
                              APPEND_WRITECOPY(c->prot), c->mapoff,
                              maplength);

        if (__builtin_expect (errval < 0, 0)) {
    6f07:	85 c0                	test   %eax,%eax
           prefer to map such objects at; but this is only a preference,
           the OS can do whatever it likes. */
        ElfW(Addr) mappref = __get_heap_base(maplength);

        /* Remember which part of the address space this object uses.  */
        errval = _DkStreamMap(handle, (void **) &mappref,
    6f09:	89 45 b8             	mov    %eax,-0x48(%rbp)
                              APPEND_WRITECOPY(c->prot), c->mapoff,
                              maplength);

        if (__builtin_expect (errval < 0, 0)) {
    6f0c:	44 8b 5d 80          	mov    -0x80(%rbp),%r11d
    6f10:	4c 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%r9
    6f17:	4c 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%r10
    6f1e:	0f 88 90 06 00 00    	js     75b4 <map_elf_object_by_handle+0x974>
map_error:
            errstring = "failed to map segment from shared object";
            goto call_lose;
        }

        l->l_map_start = mappref;
    6f24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
        l->l_map_end = l->l_map_start + maplength;
    6f28:	49 01 c7             	add    %rax,%r15
map_error:
            errstring = "failed to map segment from shared object";
            goto call_lose;
        }

        l->l_map_start = mappref;
    6f2b:	48 89 83 e0 02 00 00 	mov    %rax,0x2e0(%rbx)
        l->l_map_end = l->l_map_start + maplength;
        l->l_addr = l->l_map_start - c->mapstart;
    6f32:	4c 29 d0             	sub    %r10,%rax

        if (has_holes)
    6f35:	45 84 f6             	test   %r14b,%r14b
            errstring = "failed to map segment from shared object";
            goto call_lose;
        }

        l->l_map_start = mappref;
        l->l_map_end = l->l_map_start + maplength;
    6f38:	4c 89 bb e8 02 00 00 	mov    %r15,0x2e8(%rbx)
        l->l_addr = l->l_map_start - c->mapstart;
    6f3f:	48 89 03             	mov    %rax,(%rbx)

        if (has_holes)
    6f42:	0f 85 c4 04 00 00    	jne    740c <map_elf_object_by_handle+0x7cc>
               mapping.  */
            _DkVirtualMemoryProtect((caddr_t) (l->l_addr + c->mapend),
                                    loadcmds[nloadcmds - 1].mapstart - c->mapend,
                                    PAL_PROT_NONE);

        goto postmap;
    6f48:	4d 89 ee             	mov    %r13,%r14
                goto map_error;
            }
        }

postmap:
        if (c->prot & PROT_EXEC) {
    6f4b:	41 f6 c3 04          	test   $0x4,%r11b
    6f4f:	74 1b                	je     6f6c <map_elf_object_by_handle+0x32c>
            l->l_text_start = l->l_addr + c->mapstart;
    6f51:	48 8b 03             	mov    (%rbx),%rax
    6f54:	48 89 c2             	mov    %rax,%rdx
            l->l_text_end = l->l_addr + c->mapend;
    6f57:	49 03 46 08          	add    0x8(%r14),%rax
            }
        }

postmap:
        if (c->prot & PROT_EXEC) {
            l->l_text_start = l->l_addr + c->mapstart;
    6f5b:	49 03 16             	add    (%r14),%rdx
            l->l_text_end = l->l_addr + c->mapend;
    6f5e:	48 89 83 c8 02 00 00 	mov    %rax,0x2c8(%rbx)
            }
        }

postmap:
        if (c->prot & PROT_EXEC) {
            l->l_text_start = l->l_addr + c->mapstart;
    6f65:	48 89 93 c0 02 00 00 	mov    %rdx,0x2c0(%rbx)
            l->l_text_end = l->l_addr + c->mapend;
        }

        if (c->prot & PROT_WRITE) {
    6f6c:	44 89 da             	mov    %r11d,%edx
    6f6f:	83 e2 02             	and    $0x2,%edx
    6f72:	0f 85 f8 03 00 00    	jne    7370 <map_elf_object_by_handle+0x730>
            l->l_data_start = l->l_addr + c->mapstart;
            l->l_data_end = l->l_addr + c->mapend;
        }

        if (l->l_phdr == 0
    6f78:	48 83 bb a8 02 00 00 	cmpq   $0x0,0x2a8(%rbx)
    6f7f:	00 
    6f80:	0f 84 9a 05 00 00    	je     7520 <map_elf_object_by_handle+0x8e0>
            && ((size_t) (c->mapend - c->mapstart + c->mapoff)
                >= header->e_phoff + header->e_phnum * sizeof (ElfW(Phdr))))
            /* Found the program header in this segment.  */
            l->l_phdr = (void *) (c->mapstart + header->e_phoff - c->mapoff);

        if (c->allocend > c->dataend) {
    6f86:	49 8b 46 18          	mov    0x18(%r14),%rax
    6f8a:	4d 8b 7e 10          	mov    0x10(%r14),%r15
    6f8e:	4c 39 f8             	cmp    %r15,%rax
    6f91:	0f 86 87 00 00 00    	jbe    701e <map_elf_object_by_handle+0x3de>
            /* Extra zero pages should appear at the end of this segment,
               after the data mapped from the file.   */
            ElfW(Addr) zero, zeroend, zerosec;

            zero = l->l_addr + c->dataend;
            zeroend = ALLOC_ALIGNUP(l->l_addr + c->allocend);
    6f97:	48 8b 0d f2 c9 21 00 	mov    0x21c9f2(%rip),%rcx        # 223990 <_DYNAMIC+0x1a8>
        if (c->allocend > c->dataend) {
            /* Extra zero pages should appear at the end of this segment,
               after the data mapped from the file.   */
            ElfW(Addr) zero, zeroend, zerosec;

            zero = l->l_addr + c->dataend;
    6f9e:	4c 8b 03             	mov    (%rbx),%r8
            zeroend = ALLOC_ALIGNUP(l->l_addr + c->allocend);
    6fa1:	48 8b 31             	mov    (%rcx),%rsi
        if (c->allocend > c->dataend) {
            /* Extra zero pages should appear at the end of this segment,
               after the data mapped from the file.   */
            ElfW(Addr) zero, zeroend, zerosec;

            zero = l->l_addr + c->dataend;
    6fa4:	4d 01 c7             	add    %r8,%r15
            zeroend = ALLOC_ALIGNUP(l->l_addr + c->allocend);
    6fa7:	48 85 f6             	test   %rsi,%rsi
    6faa:	0f 84 90 04 00 00    	je     7440 <map_elf_object_by_handle+0x800>
    6fb0:	48 8b 0d 91 cb 21 00 	mov    0x21cb91(%rip),%rcx        # 223b48 <_DYNAMIC+0x360>
    6fb7:	48 8b 3d 3a cb 21 00 	mov    0x21cb3a(%rip),%rdi        # 223af8 <_DYNAMIC+0x310>
    6fbe:	49 01 c0             	add    %rax,%r8
    6fc1:	48 8b 09             	mov    (%rcx),%rcx
    6fc4:	48 8b 3f             	mov    (%rdi),%rdi
    6fc7:	49 01 c8             	add    %rcx,%r8
            zerosec = ALLOC_ALIGNUP(zero);
    6fca:	4c 01 f9             	add    %r15,%rcx
            /* Extra zero pages should appear at the end of this segment,
               after the data mapped from the file.   */
            ElfW(Addr) zero, zeroend, zerosec;

            zero = l->l_addr + c->dataend;
            zeroend = ALLOC_ALIGNUP(l->l_addr + c->allocend);
    6fcd:	49 21 f8             	and    %rdi,%r8
            zerosec = ALLOC_ALIGNUP(zero);
    6fd0:	48 21 f9             	and    %rdi,%rcx
    6fd3:	49 39 c8             	cmp    %rcx,%r8
    6fd6:	49 0f 46 c8          	cmovbe %r8,%rcx
            if (zeroend < zerosec)
                /* All the extra data is in the last section of the segment.
                   We can just zero it.  */
                zerosec = zeroend;

            if (zerosec > zero) {
    6fda:	49 39 cf             	cmp    %rcx,%r15
    6fdd:	73 36                	jae    7015 <map_elf_object_by_handle+0x3d5>
                /* Zero the final part of the last section of the segment.  */
                if (__builtin_expect ((c->prot & PROT_WRITE) == 0, 0))
    6fdf:	85 d2                	test   %edx,%edx
    6fe1:	0f 84 63 06 00 00    	je     764a <map_elf_object_by_handle+0xa0a>
                                                c->prot|PAL_PROT_WRITE) < 0) {
                        errstring = "cannot change memory protections";
                        goto call_lose;
                    }
                }
                memset ((void *) zero, '\0', zerosec - zero);
    6fe7:	48 89 ca             	mov    %rcx,%rdx
    6fea:	31 f6                	xor    %esi,%esi
    6fec:	4c 89 ff             	mov    %r15,%rdi
    6fef:	4c 29 fa             	sub    %r15,%rdx
    6ff2:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
    6ff9:	44 89 5d 80          	mov    %r11d,-0x80(%rbp)
    6ffd:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    7001:	e8 9a f1 00 00       	callq  161a0 <memset>
    7006:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    700a:	44 8b 5d 80          	mov    -0x80(%rbp),%r11d
    700e:	4c 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%r8
                if (__builtin_expect ((c->prot & PROT_WRITE) == 0, 0))
                    _DkVirtualMemoryProtect((void *) ALLOC_ALIGNDOWN(zero),
                                            allocsize, c->prot);
            }

            if (zeroend > zerosec) {
    7015:	49 39 c8             	cmp    %rcx,%r8
    7018:	0f 87 94 04 00 00    	ja     74b2 <map_elf_object_by_handle+0x872>
                    goto call_lose;
                }
            }
        }

        ++c;
    701e:	49 83 c6 30          	add    $0x30,%r14

    /* Remember which part of the address space this object uses.  */
    l->l_map_start = c->mapstart + l->l_addr;
    l->l_map_end = l->l_map_start + maplength;

    while (c < &loadcmds[nloadcmds]) {
    7022:	4b 8d 04 64          	lea    (%r12,%r12,2),%rax
    7026:	48 c1 e0 04          	shl    $0x4,%rax
    702a:	4c 01 e8             	add    %r13,%rax
    702d:	49 39 c6             	cmp    %rax,%r14
    7030:	0f 82 1d 03 00 00    	jb     7353 <map_elf_object_by_handle+0x713>
        }

        ++c;
    }

    if (l->l_ld == 0) {
    7036:	48 8b 7b 30          	mov    0x30(%rbx),%rdi
    703a:	48 85 ff             	test   %rdi,%rdi
    703d:	0f 84 79 05 00 00    	je     75bc <map_elf_object_by_handle+0x97c>
        if (__builtin_expect (e_type == ET_DYN, 0)) {
            errstring = "object file has no dynamic section";
            goto call_lose;
        }
    } else {
        l->l_ld = (ElfW(Dyn) *) ((ElfW(Addr)) l->l_ld + l->l_addr);
    7043:	48 03 3b             	add    (%rbx),%rdi
    7046:	48 89 7b 30          	mov    %rdi,0x30(%rbx)
    }

    l->l_real_ld = l->l_ld;

    if (do_copy_dyn)
    704a:	80 7d 88 00          	cmpb   $0x0,-0x78(%rbp)
        }
    } else {
        l->l_ld = (ElfW(Dyn) *) ((ElfW(Addr)) l->l_ld + l->l_addr);
    }

    l->l_real_ld = l->l_ld;
    704e:	48 89 7b 10          	mov    %rdi,0x10(%rbx)

    if (do_copy_dyn)
    7052:	0f 85 f3 03 00 00    	jne    744b <map_elf_object_by_handle+0x80b>
    typedef Elf32_Word d_tag_utype;
#elif __ELF_NATIVE_CLASS == 64
    typedef Elf64_Xword d_tag_utype;
#endif

    while (dyn->d_tag != DT_NULL) {
    7058:	48 8b 17             	mov    (%rdi),%rdx
        l->l_ld = remalloc(l->l_ld, sizeof(ElfW(Dyn)) * l->l_ldnum);

    elf_get_dynamic_info(l->l_ld, l->l_info, l->l_addr);
    705b:	4c 8b 03             	mov    (%rbx),%r8
    705e:	48 8d 4b 48          	lea    0x48(%rbx),%rcx
    7062:	48 85 d2             	test   %rdx,%rdx
    7065:	74 75                	je     70dc <map_elf_object_by_handle+0x49c>

        else if (dyn->d_tag >= DT_LOPROC &&
                 dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)
            l_info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;

        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
    7067:	be ff ff ff 6f       	mov    $0x6fffffff,%esi

        else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM] = dyn;

        else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)
    706c:	41 bb ff fd ff 6f    	mov    $0x6ffffdff,%r11d
            l_info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;

        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
    7072:	41 bd ff fe ff 6f    	mov    $0x6ffffeff,%r13d
            l_info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;
    7078:	49 be 00 fa ff 7f 03 	mov    $0x37ffffa00,%r14
    707f:	00 00 00 
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM] = dyn;

        else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)
            l_info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;
    7082:	49 bc a0 f1 ff 7f 03 	mov    $0x37ffff1a0,%r12
    7089:	00 00 00 
        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
            l_info[VERSYMIDX (dyn->d_tag)] = dyn;

        else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM] = dyn;
    708c:	41 ba 31 00 00 00    	mov    $0x31,%r10d
        else if (dyn->d_tag >= DT_LOPROC &&
                 dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)
            l_info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;

        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
            l_info[VERSYMIDX (dyn->d_tag)] = dyn;
    7092:	41 b9 21 00 00 70    	mov    $0x70000021,%r9d
    7098:	eb 16                	jmp    70b0 <map_elf_object_by_handle+0x470>
    709a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    typedef Elf64_Xword d_tag_utype;
#endif

    while (dyn->d_tag != DT_NULL) {
        if ((d_tag_utype) dyn->d_tag < DT_NUM)
            l_info[dyn->d_tag] = dyn;
    70a0:	48 89 3c d1          	mov    %rdi,(%rcx,%rdx,8)

        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
            l_info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;

        ++dyn;
    70a4:	48 83 c7 10          	add    $0x10,%rdi
    typedef Elf32_Word d_tag_utype;
#elif __ELF_NATIVE_CLASS == 64
    typedef Elf64_Xword d_tag_utype;
#endif

    while (dyn->d_tag != DT_NULL) {
    70a8:	48 8b 17             	mov    (%rdi),%rdx
    70ab:	48 85 d2             	test   %rdx,%rdx
    70ae:	74 2c                	je     70dc <map_elf_object_by_handle+0x49c>
        if ((d_tag_utype) dyn->d_tag < DT_NUM)
    70b0:	48 83 fa 21          	cmp    $0x21,%rdx
    70b4:	76 ea                	jbe    70a0 <map_elf_object_by_handle+0x460>

        else if (dyn->d_tag >= DT_LOPROC &&
                 dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)
            l_info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;

        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
    70b6:	48 89 f0             	mov    %rsi,%rax
    70b9:	48 29 d0             	sub    %rdx,%rax
    70bc:	48 83 f8 0f          	cmp    $0xf,%rax
    70c0:	0f 87 ea 02 00 00    	ja     73b0 <map_elf_object_by_handle+0x770>
            l_info[VERSYMIDX (dyn->d_tag)] = dyn;
    70c6:	4c 89 c8             	mov    %r9,%rax
    70c9:	48 29 d0             	sub    %rdx,%rax
    70cc:	48 89 3c c1          	mov    %rdi,(%rcx,%rax,8)

        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
            l_info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;

        ++dyn;
    70d0:	48 83 c7 10          	add    $0x10,%rdi
    typedef Elf32_Word d_tag_utype;
#elif __ELF_NATIVE_CLASS == 64
    typedef Elf64_Xword d_tag_utype;
#endif

    while (dyn->d_tag != DT_NULL) {
    70d4:	48 8b 17             	mov    (%rdi),%rdx
    70d7:	48 85 d2             	test   %rdx,%rdx
    70da:	75 d4                	jne    70b0 <map_elf_object_by_handle+0x470>
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;

        ++dyn;
    }

    if (l_addr != 0) {
    70dc:	4d 85 c0             	test   %r8,%r8
    70df:	74 74                	je     7155 <map_elf_object_by_handle+0x515>
            if (l_info[tag]) {                            \
		l_info[tag]->d_un.d_ptr += l_addr;        \
            }                                             \
        } while(0);

        ADJUST_DYN_INFO (DT_HASH);
    70e1:	48 8b 43 68          	mov    0x68(%rbx),%rax
    70e5:	48 85 c0             	test   %rax,%rax
    70e8:	74 04                	je     70ee <map_elf_object_by_handle+0x4ae>
    70ea:	4c 01 40 08          	add    %r8,0x8(%rax)
        ADJUST_DYN_INFO (DT_PLTGOT);
    70ee:	48 8b 43 60          	mov    0x60(%rbx),%rax
    70f2:	48 85 c0             	test   %rax,%rax
    70f5:	74 04                	je     70fb <map_elf_object_by_handle+0x4bb>
    70f7:	4c 01 40 08          	add    %r8,0x8(%rax)
        ADJUST_DYN_INFO (DT_STRTAB);
    70fb:	48 8b 43 70          	mov    0x70(%rbx),%rax
    70ff:	48 85 c0             	test   %rax,%rax
    7102:	74 04                	je     7108 <map_elf_object_by_handle+0x4c8>
    7104:	4c 01 40 08          	add    %r8,0x8(%rax)
        ADJUST_DYN_INFO (DT_SYMTAB);
    7108:	48 8b 43 78          	mov    0x78(%rbx),%rax
    710c:	48 85 c0             	test   %rax,%rax
    710f:	74 04                	je     7115 <map_elf_object_by_handle+0x4d5>
    7111:	4c 01 40 08          	add    %r8,0x8(%rax)

# if ! ELF_MACHINE_NO_RELA
        ADJUST_DYN_INFO (DT_RELA);
    7115:	48 8b 83 80 00 00 00 	mov    0x80(%rbx),%rax
    711c:	48 85 c0             	test   %rax,%rax
    711f:	74 04                	je     7125 <map_elf_object_by_handle+0x4e5>
    7121:	4c 01 40 08          	add    %r8,0x8(%rax)

# if ! ELF_MACHINE_NO_REL
        ADJUST_DYN_INFO (DT_REL);
# endif

        ADJUST_DYN_INFO (DT_JMPREL);
    7125:	48 8b 83 00 01 00 00 	mov    0x100(%rbx),%rax
    712c:	48 85 c0             	test   %rax,%rax
    712f:	74 04                	je     7135 <map_elf_object_by_handle+0x4f5>
    7131:	4c 01 40 08          	add    %r8,0x8(%rax)
        ADJUST_DYN_INFO (VERSYMIDX (DT_VERSYM));
    7135:	48 8b 83 d0 01 00 00 	mov    0x1d0(%rbx),%rax
    713c:	48 85 c0             	test   %rax,%rax
    713f:	74 04                	je     7145 <map_elf_object_by_handle+0x505>
    7141:	4c 01 40 08          	add    %r8,0x8(%rax)
        ADJUST_DYN_INFO (DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM + DT_THISPROCNUM
    7145:	48 8b 83 a0 02 00 00 	mov    0x2a0(%rbx),%rax
    714c:	48 85 c0             	test   %rax,%rax
    714f:	74 04                	je     7155 <map_elf_object_by_handle+0x515>
    7151:	4c 01 40 08          	add    %r8,0x8(%rax)
                      + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM);
# undef ADJUST_DYN_INFO
    }

    /* Then a bunch of assertion, we could kind of ignore them */
    if (l_info[DT_PLTREL]) {
    7155:	48 8b 83 e8 00 00 00 	mov    0xe8(%rbx),%rax
    715c:	48 85 c0             	test   %rax,%rax
    715f:	74 37                	je     7198 <map_elf_object_by_handle+0x558>
#if ELF_MACHINE_NO_RELA
        assert (l_info[DT_PLTREL]->d_un.d_val == DT_REL);

#elif ELF_MACHINE_NO_REL
        assert (l_info[DT_PLTREL]->d_un.d_val == DT_RELA);
    7161:	48 83 78 08 07       	cmpq   $0x7,0x8(%rax)
    7166:	74 30                	je     7198 <map_elf_object_by_handle+0x558>
    7168:	48 8d 3d c9 15 01 00 	lea    0x115c9(%rip),%rdi        # 18738 <write_config+0x188>
    716f:	48 8d 15 c6 78 01 00 	lea    0x178c6(%rip),%rdx        # 1ea3c <slab_levels+0x579c>
    7176:	48 8d 35 7b 1e 01 00 	lea    0x11e7b(%rip),%rsi        # 18ff8 <handle_sizes.1924+0x878>
    717d:	b9 96 00 00 00       	mov    $0x96,%ecx
    7182:	31 c0                	xor    %eax,%eax
    7184:	e8 97 1c 00 00       	callq  8e20 <pal_printf>
    7189:	e8 e2 f8 ff ff       	callq  6a70 <__assert>
    718e:	bf 01 00 00 00       	mov    $0x1,%edi
    7193:	e8 e8 b3 00 00       	callq  12580 <_DkProcessExit>
                || l_info[DT_PLTREL]->d_un.d_val == DT_RELA);
#endif
    }

#if ! ELF_MACHINE_NO_RELA
    if (l_info[DT_RELA])
    7198:	48 83 bb 80 00 00 00 	cmpq   $0x0,0x80(%rbx)
    719f:	00 
    71a0:	74 3e                	je     71e0 <map_elf_object_by_handle+0x5a0>
        assert (l_info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela)));
    71a2:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
    71a9:	48 83 78 08 18       	cmpq   $0x18,0x8(%rax)
    71ae:	74 30                	je     71e0 <map_elf_object_by_handle+0x5a0>
    71b0:	48 8d 3d 81 15 01 00 	lea    0x11581(%rip),%rdi        # 18738 <write_config+0x188>
    71b7:	48 8d 15 7e 78 01 00 	lea    0x1787e(%rip),%rdx        # 1ea3c <slab_levels+0x579c>
    71be:	48 8d 35 63 1e 01 00 	lea    0x11e63(%rip),%rsi        # 19028 <handle_sizes.1924+0x8a8>
    71c5:	b9 a0 00 00 00       	mov    $0xa0,%ecx
    71ca:	31 c0                	xor    %eax,%eax
    71cc:	e8 4f 1c 00 00       	callq  8e20 <pal_printf>
    71d1:	e8 9a f8 ff ff       	callq  6a70 <__assert>
    71d6:	bf 01 00 00 00       	mov    $0x1,%edi
    71db:	e8 a0 b3 00 00       	callq  12580 <_DkProcessExit>

    /* When we profile the SONAME might be needed for something else but
       loading.  Add it right away.  */
    if (l->l_info[DT_STRTAB] && l->l_info[DT_SONAME])
    71e0:	48 8b 43 70          	mov    0x70(%rbx),%rax
    71e4:	48 85 c0             	test   %rax,%rax
    71e7:	74 18                	je     7201 <map_elf_object_by_handle+0x5c1>
    71e9:	48 8b 93 b8 00 00 00 	mov    0xb8(%rbx),%rdx
    71f0:	48 85 d2             	test   %rdx,%rdx
    71f3:	74 0c                	je     7201 <map_elf_object_by_handle+0x5c1>
        l->l_soname =  (char *) (D_PTR (l->l_info[DT_STRTAB])
                             + D_PTR (l->l_info[DT_SONAME]));
    71f5:	48 8b 40 08          	mov    0x8(%rax),%rax
    71f9:	48 03 42 08          	add    0x8(%rdx),%rax
    elf_get_dynamic_info(l->l_ld, l->l_info, l->l_addr);

    /* When we profile the SONAME might be needed for something else but
       loading.  Add it right away.  */
    if (l->l_info[DT_STRTAB] && l->l_info[DT_SONAME])
        l->l_soname =  (char *) (D_PTR (l->l_info[DT_STRTAB])
    71fd:	48 89 43 38          	mov    %rax,0x38(%rbx)
                             + D_PTR (l->l_info[DT_SONAME]));

    if (l->l_phdr == NULL) {
    7201:	48 8b 83 a8 02 00 00 	mov    0x2a8(%rbx),%rax
    7208:	48 85 c0             	test   %rax,%rax
    720b:	0f 84 ee 03 00 00    	je     75ff <map_elf_object_by_handle+0x9bf>

        l->l_phdr = memcpy(newp, phdr,
                           header->e_phnum * sizeof (ElfW(Phdr)));
    } else {
        /* Adjust the PT_PHDR value by the runtime load address.  */
        l->l_phdr = (ElfW(Phdr) *) ((ElfW(Addr)) l->l_phdr + l->l_addr);
    7211:	48 8b 13             	mov    (%rbx),%rdx
    7214:	48 01 d0             	add    %rdx,%rax
    7217:	48 89 83 a8 02 00 00 	mov    %rax,0x2a8(%rbx)
    }

    l->l_entry += l->l_addr;
    721e:	48 01 93 b0 02 00 00 	add    %rdx,0x2b0(%rbx)

    /* Set up the symbol hash table.  */
    setup_elf_hash (l);
    7225:	48 89 df             	mov    %rbx,%rdi
    7228:	e8 23 f9 ff ff       	callq  6b50 <setup_elf_hash>

    return l;
    722d:	48 8b 65 98          	mov    -0x68(%rbp),%rsp
}
    7231:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    l->l_entry += l->l_addr;

    /* Set up the symbol hash table.  */
    setup_elf_hash (l);

    return l;
    7235:	48 89 d8             	mov    %rbx,%rax
}
    7238:	5b                   	pop    %rbx
    7239:	41 5c                	pop    %r12
    723b:	41 5d                	pop    %r13
    723d:	41 5e                	pop    %r14
    723f:	41 5f                	pop    %r15
    7241:	5d                   	pop    %rbp
    7242:	c3                   	retq   
                l->l_ld = (void *) ph->p_vaddr;
                l->l_ldnum = ph->p_memsz / sizeof (ElfW(Dyn));
                break;

            case PT_PHDR:
                l->l_phdr = (void *) ph->p_vaddr;
    7243:	48 8b 46 10          	mov    0x10(%rsi),%rax
    7247:	48 89 83 a8 02 00 00 	mov    %rax,0x2a8(%rbx)
                break;
    724e:	e9 13 fb ff ff       	jmpq   6d66 <map_elf_object_by_handle+0x126>
        {
            /* These entries tell us where to find things once the file's
               segments are mapped in.  We record the addresses it says
               verbatim, and later correct for the run-time load address.  */
            case PT_DYNAMIC:
                l->l_ld = (void *) ph->p_vaddr;
    7253:	48 8b 46 10          	mov    0x10(%rsi),%rax
    7257:	48 89 43 30          	mov    %rax,0x30(%rbx)
                l->l_ldnum = ph->p_memsz / sizeof (ElfW(Dyn));
    725b:	48 8b 46 28          	mov    0x28(%rsi),%rax
    725f:	48 c1 e8 04          	shr    $0x4,%rax
    7263:	66 89 83 ba 02 00 00 	mov    %ax,0x2ba(%rbx)
                break;
    726a:	e9 f7 fa ff ff       	jmpq   6d66 <map_elf_object_by_handle+0x126>
    726f:	90                   	nop    
                    goto call_lose;
                }

                c = &loadcmds[nloadcmds++];
                c->mapstart = ALLOC_ALIGNDOWN(ph->p_vaddr);
                c->mapend = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_filesz);
    7270:	49 89 c2             	mov    %rax,%r10
                    errval = ENOMEM;
                    goto call_lose;
                }

                c = &loadcmds[nloadcmds++];
                c->mapstart = ALLOC_ALIGNDOWN(ph->p_vaddr);
    7273:	48 89 07             	mov    %rax,(%rdi)
                c->mapend = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_filesz);
    7276:	4c 03 56 20          	add    0x20(%rsi),%r10
                c->dataend = ph->p_vaddr + ph->p_filesz;
                c->allocend = ph->p_vaddr + ph->p_memsz;
    727a:	48 03 46 28          	add    0x28(%rsi),%rax
                    goto call_lose;
                }

                c = &loadcmds[nloadcmds++];
                c->mapstart = ALLOC_ALIGNDOWN(ph->p_vaddr);
                c->mapend = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_filesz);
    727e:	4c 89 57 08          	mov    %r10,0x8(%rdi)
                c->dataend = ph->p_vaddr + ph->p_filesz;
    7282:	4c 89 57 10          	mov    %r10,0x10(%rdi)
                c->allocend = ph->p_vaddr + ph->p_memsz;
    7286:	48 89 47 18          	mov    %rax,0x18(%rdi)
    728a:	e9 63 fb ff ff       	jmpq   6df2 <map_elf_object_by_handle+0x1b2>
    728f:	90                   	nop    
    ElfW(Phdr) * phdr;

    if (header->e_phoff + maplength <= (size_t) fbp_len) {
        phdr = (void *) (fbp + header->e_phoff);
    } else {
        phdr = (ElfW(Phdr) *) malloc (maplength);
    7290:	44 89 ef             	mov    %r13d,%edi
    7293:	e8 68 17 00 00       	callq  8a00 <malloc>

        if ((ret = _DkStreamRead(handle, header->e_phoff, maplength, phdr,
    7298:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    729c:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    72a0:	45 31 c9             	xor    %r9d,%r9d
    72a3:	45 31 c0             	xor    %r8d,%r8d
    72a6:	48 89 c1             	mov    %rax,%rcx
    ElfW(Phdr) * phdr;

    if (header->e_phoff + maplength <= (size_t) fbp_len) {
        phdr = (void *) (fbp + header->e_phoff);
    } else {
        phdr = (ElfW(Phdr) *) malloc (maplength);
    72a9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

        if ((ret = _DkStreamRead(handle, header->e_phoff, maplength, phdr,
    72ad:	48 8b 52 20          	mov    0x20(%rdx),%rdx
    72b1:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    72b5:	8b 75 b8             	mov    -0x48(%rbp),%esi
    72b8:	44 89 ea             	mov    %r13d,%edx
    72bb:	e8 d0 c9 ff ff       	callq  3c90 <_DkStreamRead>
    72c0:	85 c0                	test   %eax,%eax
    72c2:	0f 88 26 03 00 00    	js     75ee <map_elf_object_by_handle+0x9ae>
    72c8:	0f b7 83 b8 02 00 00 	movzwl 0x2b8(%rbx),%eax
    72cf:	48 8d 0c c5 00 00 00 	lea    0x0(,%rax,8),%rcx
    72d6:	00 
    72d7:	48 89 c2             	mov    %rax,%rdx
    72da:	48 c1 e2 06          	shl    $0x6,%rdx
    72de:	48 29 ca             	sub    %rcx,%rdx
    72e1:	e9 ed f9 ff ff       	jmpq   6cd3 <map_elf_object_by_handle+0x93>
    72e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    72ed:	00 00 00 

            case PT_LOAD:
                /* A load command tells us to map in part of the file.
                   We record the load commands and process them all later.  */
                if (__builtin_expect ((ph->p_align & allocshift) != 0, 0)) {
                    errstring = "ELF load command alignment not aligned";
    72f0:	48 8d 35 91 1b 01 00 	lea    0x11b91(%rip),%rsi        # 18e88 <handle_sizes.1924+0x708>
    72f7:	b9 f3 ff ff ff       	mov    $0xfffffff3,%ecx
    72fc:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
                    errval = ENOMEM;
                    goto call_lose;
    7301:	48 8b 65 98          	mov    -0x68(%rbp),%rsp

    if (handle == NULL) {
        errstring = "cannot stat shared object";
        errval = PAL_ERROR_INVAL;
call_lose:
        printf("%s (%d)\n", errstring, PAL_STRERROR(errval));
    7305:	83 f9 18             	cmp    $0x18,%ecx
    7308:	48 8d 15 c5 16 01 00 	lea    0x116c5(%rip),%rdx        # 189d4 <handle_sizes.1924+0x254>
    730f:	77 0d                	ja     731e <map_elf_object_by_handle+0x6de>
    7311:	48 8d 15 a8 bf 21 00 	lea    0x21bfa8(%rip),%rdx        # 2232c0 <pal_errstring>
    7318:	48 98                	cltq   
    731a:	48 8b 14 c2          	mov    (%rdx,%rax,8),%rdx
    731e:	48 8d 3d d9 1a 01 00 	lea    0x11ad9(%rip),%rdi        # 18dfe <handle_sizes.1924+0x67e>
    7325:	31 c0                	xor    %eax,%eax
    7327:	e8 f4 1a 00 00       	callq  8e20 <pal_printf>

    /* Set up the symbol hash table.  */
    setup_elf_hash (l);

    return l;
}
    732c:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    if (handle == NULL) {
        errstring = "cannot stat shared object";
        errval = PAL_ERROR_INVAL;
call_lose:
        printf("%s (%d)\n", errstring, PAL_STRERROR(errval));
        return NULL;
    7330:	31 c0                	xor    %eax,%eax

    /* Set up the symbol hash table.  */
    setup_elf_hash (l);

    return l;
}
    7332:	5b                   	pop    %rbx
    7333:	41 5c                	pop    %r12
    7335:	41 5d                	pop    %r13
    7337:	41 5e                	pop    %r14
    7339:	41 5f                	pop    %r15
    733b:	5d                   	pop    %rbp
    733c:	c3                   	retq   
    733d:	0f 1f 00             	nopl   (%rax)
    7340:	b9 f3 ff ff ff       	mov    $0xfffffff3,%ecx
    7345:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
                    goto call_lose;
                }

                if (__builtin_expect (((ph->p_vaddr - ph->p_offset)
                                       & (ph->p_align - 1)) != 0, 0)) {
                    errstring = "\
    734a:	48 8d 35 5f 1b 01 00 	lea    0x11b5f(%rip),%rsi        # 18eb0 <handle_sizes.1924+0x730>
    7351:	eb ae                	jmp    7301 <map_elf_object_by_handle+0x6c1>
    /* Remember which part of the address space this object uses.  */
    l->l_map_start = c->mapstart + l->l_addr;
    l->l_map_end = l->l_map_start + maplength;

    while (c < &loadcmds[nloadcmds]) {
        if (c->mapend > c->mapstart) {
    7353:	4d 8b 46 08          	mov    0x8(%r14),%r8
    7357:	49 8b 06             	mov    (%r14),%rax
    735a:	49 39 c0             	cmp    %rax,%r8
    735d:	0f 87 03 01 00 00    	ja     7466 <map_elf_object_by_handle+0x826>
    7363:	45 8b 5e 28          	mov    0x28(%r14),%r11d
    7367:	e9 df fb ff ff       	jmpq   6f4b <map_elf_object_by_handle+0x30b>
    736c:	0f 1f 40 00          	nopl   0x0(%rax)
            l->l_text_start = l->l_addr + c->mapstart;
            l->l_text_end = l->l_addr + c->mapend;
        }

        if (c->prot & PROT_WRITE) {
            l->l_data_start = l->l_addr + c->mapstart;
    7370:	48 8b 03             	mov    (%rbx),%rax
    7373:	48 89 c1             	mov    %rax,%rcx
            l->l_data_end = l->l_addr + c->mapend;
    7376:	49 03 46 08          	add    0x8(%r14),%rax
            l->l_text_start = l->l_addr + c->mapstart;
            l->l_text_end = l->l_addr + c->mapend;
        }

        if (c->prot & PROT_WRITE) {
            l->l_data_start = l->l_addr + c->mapstart;
    737a:	49 03 0e             	add    (%r14),%rcx
            l->l_data_end = l->l_addr + c->mapend;
    737d:	48 89 83 d8 02 00 00 	mov    %rax,0x2d8(%rbx)
            l->l_text_start = l->l_addr + c->mapstart;
            l->l_text_end = l->l_addr + c->mapend;
        }

        if (c->prot & PROT_WRITE) {
            l->l_data_start = l->l_addr + c->mapstart;
    7384:	48 89 8b d0 02 00 00 	mov    %rcx,0x2d0(%rbx)
    738b:	e9 e8 fb ff ff       	jmpq   6f78 <map_elf_object_by_handle+0x338>
        !(__heap_base = pal_config.heap_base)) {
        __heap_base = (void *) -1;
        return 0;
    }

    return (ElfW(Addr)) (__heap_base -= ALLOC_ALIGNUP(size));
    7390:	48 8b 0d b1 c7 21 00 	mov    0x21c7b1(%rip),%rcx        # 223b48 <_DYNAMIC+0x360>
    7397:	4c 89 f8             	mov    %r15,%rax
    739a:	48 03 01             	add    (%rcx),%rax
    739d:	48 8b 0d 54 c7 21 00 	mov    0x21c754(%rip),%rcx        # 223af8 <_DYNAMIC+0x310>
    73a4:	48 23 01             	and    (%rcx),%rax
    73a7:	48 f7 d8             	neg    %rax
    73aa:	e9 07 fb ff ff       	jmpq   6eb6 <map_elf_object_by_handle+0x276>
    73af:	90                   	nop    
            l_info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;

        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
            l_info[VERSYMIDX (dyn->d_tag)] = dyn;

        else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)
    73b0:	8d 04 12             	lea    (%rdx,%rdx,1),%eax
    73b3:	d1 f8                	sar    %eax
    73b5:	83 f8 fc             	cmp    $0xfffffffffffffffc,%eax
    73b8:	76 16                	jbe    73d0 <map_elf_object_by_handle+0x790>
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
    73ba:	44 89 d2             	mov    %r10d,%edx
    73bd:	29 c2                	sub    %eax,%edx
                   + DT_VERSIONTAGNUM] = dyn;
    73bf:	48 89 3c d1          	mov    %rdi,(%rcx,%rdx,8)
    73c3:	e9 dc fc ff ff       	jmpq   70a4 <map_elf_object_by_handle+0x464>
    73c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    73cf:	00 

        else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)
    73d0:	4c 89 d8             	mov    %r11,%rax
    73d3:	48 29 d0             	sub    %rdx,%rax
    73d6:	48 83 f8 0b          	cmp    $0xb,%rax
    73da:	77 10                	ja     73ec <map_elf_object_by_handle+0x7ac>
            l_info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
    73dc:	48 f7 da             	neg    %rdx
                   + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;
    73df:	48 8d 04 d1          	lea    (%rcx,%rdx,8),%rax
    73e3:	4a 89 3c 20          	mov    %rdi,(%rax,%r12,1)
    73e7:	e9 b8 fc ff ff       	jmpq   70a4 <map_elf_object_by_handle+0x464>

        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
    73ec:	4c 89 e8             	mov    %r13,%rax
    73ef:	48 29 d0             	sub    %rdx,%rax
    73f2:	48 83 f8 0a          	cmp    $0xa,%rax
    73f6:	0f 87 a8 fc ff ff    	ja     70a4 <map_elf_object_by_handle+0x464>
            l_info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
    73fc:	48 f7 da             	neg    %rdx
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;
    73ff:	48 8d 04 d1          	lea    (%rcx,%rdx,8),%rax
    7403:	4a 89 3c 30          	mov    %rdi,(%rax,%r14,1)
    7407:	e9 98 fc ff ff       	jmpq   70a4 <map_elf_object_by_handle+0x464>
               the portions we do not remap later will be inaccessible as if
               unallocated.  Then jump into the normal segment-mapping loop to
               handle the portion of the segment past the end of the file
               mapping.  */
            _DkVirtualMemoryProtect((caddr_t) (l->l_addr + c->mapend),
                                    loadcmds[nloadcmds - 1].mapstart - c->mapend,
    740c:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
    7410:	4b 8d 0c 49          	lea    (%r9,%r9,2),%rcx
    7414:	44 89 5d 80          	mov    %r11d,-0x80(%rbp)
    7418:	48 c1 e1 04          	shl    $0x4,%rcx
    741c:	48 8b 14 d5 08 00 00 	mov    0x8(,%rdx,8),%rdx
    7423:	00 
            /* Change protection on the excess portion to disallow all access;
               the portions we do not remap later will be inaccessible as if
               unallocated.  Then jump into the normal segment-mapping loop to
               handle the portion of the segment past the end of the file
               mapping.  */
            _DkVirtualMemoryProtect((caddr_t) (l->l_addr + c->mapend),
    7424:	49 8b 74 0d 00       	mov    0x0(%r13,%rcx,1),%rsi
    7429:	48 8d 3c 10          	lea    (%rax,%rdx,1),%rdi
    742d:	48 29 d6             	sub    %rdx,%rsi
    7430:	31 d2                	xor    %edx,%edx
    7432:	e8 e9 8f 00 00       	callq  10420 <_DkVirtualMemoryProtect>
    7437:	44 8b 5d 80          	mov    -0x80(%rbp),%r11d
    743b:	e9 08 fb ff ff       	jmpq   6f48 <map_elf_object_by_handle+0x308>
            /* Extra zero pages should appear at the end of this segment,
               after the data mapped from the file.   */
            ElfW(Addr) zero, zeroend, zerosec;

            zero = l->l_addr + c->dataend;
            zeroend = ALLOC_ALIGNUP(l->l_addr + c->allocend);
    7440:	49 01 c0             	add    %rax,%r8
        if (c->allocend > c->dataend) {
            /* Extra zero pages should appear at the end of this segment,
               after the data mapped from the file.   */
            ElfW(Addr) zero, zeroend, zerosec;

            zero = l->l_addr + c->dataend;
    7443:	4c 89 f9             	mov    %r15,%rcx
    7446:	e9 88 fb ff ff       	jmpq   6fd3 <map_elf_object_by_handle+0x393>
    }

    l->l_real_ld = l->l_ld;

    if (do_copy_dyn)
        l->l_ld = remalloc(l->l_ld, sizeof(ElfW(Dyn)) * l->l_ldnum);
    744b:	0f b7 b3 ba 02 00 00 	movzwl 0x2ba(%rbx),%esi
    7452:	c1 e6 04             	shl    $0x4,%esi
    7455:	e8 a6 17 00 00       	callq  8c00 <remalloc>
    745a:	48 89 43 30          	mov    %rax,0x30(%rbx)
    745e:	48 89 c7             	mov    %rax,%rdi
    7461:	e9 f2 fb ff ff       	jmpq   7058 <map_elf_object_by_handle+0x418>
    l->l_map_end = l->l_map_start + maplength;

    while (c < &loadcmds[nloadcmds]) {
        if (c->mapend > c->mapstart) {
            /* Map the segment contents from the file.  */
            void * mapaddr = (void *) (l->l_addr + c->mapstart);
    7466:	48 89 c2             	mov    %rax,%rdx
    7469:	48 03 13             	add    (%rbx),%rdx
            int rv;

            if ((rv = _DkStreamMap(handle, &mapaddr, APPEND_WRITECOPY(c->prot),
    746c:	45 8b 5e 28          	mov    0x28(%r14),%r11d
    7470:	41 8b 4e 20          	mov    0x20(%r14),%ecx
    7474:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
    7478:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
    747c:	49 29 c0             	sub    %rax,%r8
    747f:	44 89 5d a0          	mov    %r11d,-0x60(%rbp)
    l->l_map_end = l->l_map_start + maplength;

    while (c < &loadcmds[nloadcmds]) {
        if (c->mapend > c->mapstart) {
            /* Map the segment contents from the file.  */
            void * mapaddr = (void *) (l->l_addr + c->mapstart);
    7483:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
            int rv;

            if ((rv = _DkStreamMap(handle, &mapaddr, APPEND_WRITECOPY(c->prot),
    7487:	44 89 da             	mov    %r11d,%edx
    748a:	83 ca 08             	or     $0x8,%edx
    748d:	e8 0e ce ff ff       	callq  42a0 <_DkStreamMap>
    7492:	85 c0                	test   %eax,%eax
    7494:	44 8b 5d a0          	mov    -0x60(%rbp),%r11d
    7498:	0f 89 ad fa ff ff    	jns    6f4b <map_elf_object_by_handle+0x30b>
    749e:	8b 45 b8             	mov    -0x48(%rbp),%eax
                              maplength);

        if (__builtin_expect (errval < 0, 0)) {
            errval = -errval;
map_error:
            errstring = "failed to map segment from shared object";
    74a1:	48 8d 35 80 1a 01 00 	lea    0x11a80(%rip),%rsi        # 18f28 <handle_sizes.1924+0x7a8>
    74a8:	f7 d8                	neg    %eax
    74aa:	8d 48 ff             	lea    -0x1(%rax),%ecx
    74ad:	e9 4f fe ff ff       	jmpq   7301 <map_elf_object_by_handle+0x6c1>
            }

            if (zeroend > zerosec) {
                /* Map the remaining zero pages in from the zero fill FD. */
                void * mapat = (void *) zerosec;
                errval = _DkVirtualMemoryAlloc(&mapat, zeroend - zerosec,
    74b2:	4c 89 c6             	mov    %r8,%rsi
    74b5:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
                                            allocsize, c->prot);
            }

            if (zeroend > zerosec) {
                /* Map the remaining zero pages in from the zero fill FD. */
                void * mapat = (void *) zerosec;
    74b9:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
                errval = _DkVirtualMemoryAlloc(&mapat, zeroend - zerosec,
    74bd:	48 29 ce             	sub    %rcx,%rsi
    74c0:	31 d2                	xor    %edx,%edx
    74c2:	44 89 d9             	mov    %r11d,%ecx
    74c5:	e8 c6 8c 00 00       	callq  10190 <_DkVirtualMemoryAlloc>
                                               0, c->prot);
                if (__builtin_expect (errval < 0, 0)) {
    74ca:	85 c0                	test   %eax,%eax
            }

            if (zeroend > zerosec) {
                /* Map the remaining zero pages in from the zero fill FD. */
                void * mapat = (void *) zerosec;
                errval = _DkVirtualMemoryAlloc(&mapat, zeroend - zerosec,
    74cc:	89 45 b8             	mov    %eax,-0x48(%rbp)
                                               0, c->prot);
                if (__builtin_expect (errval < 0, 0)) {
    74cf:	0f 89 49 fb ff ff    	jns    701e <map_elf_object_by_handle+0x3de>
    74d5:	f7 d8                	neg    %eax
                    errstring = "cannot map zero-fill allocation";
    74d7:	48 8d 35 a2 1a 01 00 	lea    0x11aa2(%rip),%rsi        # 18f80 <handle_sizes.1924+0x800>
    74de:	8d 48 ff             	lea    -0x1(%rax),%ecx
    74e1:	e9 1b fe ff ff       	jmpq   7301 <map_elf_object_by_handle+0x6c1>
    74e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    74ed:	00 00 00 
{
    if (__heap_base == (void *) -1)
        return 0;

    if (!__heap_base &&
        !(__heap_base = pal_config.heap_base)) {
    74f0:	48 8b 05 29 c5 21 00 	mov    0x21c529(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
    74f7:	48 8b 50 50          	mov    0x50(%rax),%rdx
static ElfW(Addr) __get_heap_base (size_t size)
{
    if (__heap_base == (void *) -1)
        return 0;

    if (!__heap_base &&
    74fb:	48 85 d2             	test   %rdx,%rdx
        !(__heap_base = pal_config.heap_base)) {
    74fe:	48 89 15 1b d5 21 00 	mov    %rdx,0x21d51b(%rip)        # 224a20 <__heap_base>
static ElfW(Addr) __get_heap_base (size_t size)
{
    if (__heap_base == (void *) -1)
        return 0;

    if (!__heap_base &&
    7505:	0f 85 94 f9 ff ff    	jne    6e9f <map_elf_object_by_handle+0x25f>
        !(__heap_base = pal_config.heap_base)) {
        __heap_base = (void *) -1;
    750b:	48 c7 05 0a d5 21 00 	movq   $0xffffffffffffffff,0x21d50a(%rip)        # 224a20 <__heap_base>
    7512:	ff ff ff ff 
        return 0;
    7516:	31 c0                	xor    %eax,%eax
    7518:	e9 a3 f9 ff ff       	jmpq   6ec0 <map_elf_object_by_handle+0x280>
    751d:	0f 1f 00             	nopl   (%rax)
            l->l_data_start = l->l_addr + c->mapstart;
            l->l_data_end = l->l_addr + c->mapend;
        }

        if (l->l_phdr == 0
            && (ElfW(Off)) c->mapoff <= header->e_phoff
    7520:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    7524:	49 8b 76 20          	mov    0x20(%r14),%rsi
    7528:	48 8b 40 20          	mov    0x20(%rax),%rax
    752c:	48 39 c6             	cmp    %rax,%rsi
    752f:	0f 87 51 fa ff ff    	ja     6f86 <map_elf_object_by_handle+0x346>
            && ((size_t) (c->mapend - c->mapstart + c->mapoff)
                >= header->e_phoff + header->e_phnum * sizeof (ElfW(Phdr))))
    7535:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
            l->l_data_end = l->l_addr + c->mapend;
        }

        if (l->l_phdr == 0
            && (ElfW(Off)) c->mapoff <= header->e_phoff
            && ((size_t) (c->mapend - c->mapstart + c->mapoff)
    7539:	49 8b 3e             	mov    (%r14),%rdi
    753c:	49 89 f1             	mov    %rsi,%r9
                >= header->e_phoff + header->e_phnum * sizeof (ElfW(Phdr))))
    753f:	0f b7 49 38          	movzwl 0x38(%rcx),%ecx
    7543:	49 29 f9             	sub    %rdi,%r9
            l->l_data_end = l->l_addr + c->mapend;
        }

        if (l->l_phdr == 0
            && (ElfW(Off)) c->mapoff <= header->e_phoff
            && ((size_t) (c->mapend - c->mapstart + c->mapoff)
    7546:	4d 03 4e 08          	add    0x8(%r14),%r9
                >= header->e_phoff + header->e_phnum * sizeof (ElfW(Phdr))))
    754a:	4c 8d 04 cd 00 00 00 	lea    0x0(,%rcx,8),%r8
    7551:	00 
    7552:	48 c1 e1 06          	shl    $0x6,%rcx
    7556:	4c 29 c1             	sub    %r8,%rcx
    7559:	48 01 c1             	add    %rax,%rcx
            l->l_data_end = l->l_addr + c->mapend;
        }

        if (l->l_phdr == 0
            && (ElfW(Off)) c->mapoff <= header->e_phoff
            && ((size_t) (c->mapend - c->mapstart + c->mapoff)
    755c:	49 39 c9             	cmp    %rcx,%r9
    755f:	0f 82 21 fa ff ff    	jb     6f86 <map_elf_object_by_handle+0x346>
                >= header->e_phoff + header->e_phnum * sizeof (ElfW(Phdr))))
            /* Found the program header in this segment.  */
            l->l_phdr = (void *) (c->mapstart + header->e_phoff - c->mapoff);
    7565:	48 01 f8             	add    %rdi,%rax
    7568:	48 29 f0             	sub    %rsi,%rax
    756b:	48 89 83 a8 02 00 00 	mov    %rax,0x2a8(%rbx)
    7572:	e9 0f fa ff ff       	jmpq   6f86 <map_elf_object_by_handle+0x346>
                    goto call_lose;
                }

                if (__builtin_expect (((ph->p_vaddr - ph->p_offset)
                                       & (ph->p_align - 1)) != 0, 0)) {
                    errstring = "\
    7577:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
    757c:	31 c0                	xor    %eax,%eax

    if (__builtin_expect (nloadcmds == 0, 0)) {
        /* This only happens for a bogus object that will be caught with
           another error below.  But we don't want to go through the
           calculations below using NLOADCMDS - 1.  */
        errstring = "object file has no loadable segments";
    757e:	48 8d 35 7b 19 01 00 	lea    0x1197b(%rip),%rsi        # 18f00 <handle_sizes.1924+0x780>
    7585:	e9 77 fd ff ff       	jmpq   7301 <map_elf_object_by_handle+0x6c1>

        goto postmap;
    }

    /* Remember which part of the address space this object uses.  */
    l->l_map_start = c->mapstart + l->l_addr;
    758a:	4c 03 13             	add    (%rbx),%r10
    l->l_map_end = l->l_map_start + maplength;

    while (c < &loadcmds[nloadcmds]) {
    758d:	4d 89 ee             	mov    %r13,%r14
                          void * fbp, size_t fbp_len,
                          bool do_copy_dyn)
{
    struct link_map * l = new_elf_object(_DkStreamRealpath(handle), type);
    const char * errstring = NULL;
    int errval = 0;
    7590:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
        goto postmap;
    }

    /* Remember which part of the address space this object uses.  */
    l->l_map_start = c->mapstart + l->l_addr;
    l->l_map_end = l->l_map_start + maplength;
    7597:	4d 01 d7             	add    %r10,%r15

        goto postmap;
    }

    /* Remember which part of the address space this object uses.  */
    l->l_map_start = c->mapstart + l->l_addr;
    759a:	4c 89 93 e0 02 00 00 	mov    %r10,0x2e0(%rbx)
    l->l_map_end = l->l_map_start + maplength;
    75a1:	4c 89 bb e8 02 00 00 	mov    %r15,0x2e8(%rbx)

    while (c < &loadcmds[nloadcmds]) {
    75a8:	e9 75 fa ff ff       	jmpq   7022 <map_elf_object_by_handle+0x3e2>
static void * __heap_base = NULL;

static ElfW(Addr) __get_heap_base (size_t size)
{
    if (__heap_base == (void *) -1)
        return 0;
    75ad:	31 c0                	xor    %eax,%eax
    75af:	e9 0c f9 ff ff       	jmpq   6ec0 <map_elf_object_by_handle+0x280>
        errval = _DkStreamMap(handle, (void **) &mappref,
                              APPEND_WRITECOPY(c->prot), c->mapoff,
                              maplength);

        if (__builtin_expect (errval < 0, 0)) {
            errval = -errval;
    75b4:	f7 5d b8             	negl   -0x48(%rbp)
    75b7:	e9 e2 fe ff ff       	jmpq   749e <map_elf_object_by_handle+0x85e>

        ++c;
    }

    if (l->l_ld == 0) {
        if (__builtin_expect (e_type == ET_DYN, 0)) {
    75bc:	66 83 7d 8e 03       	cmpw   $0x3,-0x72(%rbp)
    75c1:	0f 85 83 fa ff ff    	jne    704a <map_elf_object_by_handle+0x40a>
    75c7:	8b 45 b8             	mov    -0x48(%rbp),%eax
            errstring = "object file has no dynamic section";
    75ca:	48 8d 35 cf 19 01 00 	lea    0x119cf(%rip),%rsi        # 18fa0 <handle_sizes.1924+0x820>
    75d1:	f7 d8                	neg    %eax
    75d3:	8d 48 ff             	lea    -0x1(%rax),%ecx
    75d6:	e9 26 fd ff ff       	jmpq   7301 <map_elf_object_by_handle+0x6c1>
    const char * errstring = NULL;
    int errval = 0;
    int ret;

    if (handle == NULL) {
        errstring = "cannot stat shared object";
    75db:	48 8d 35 02 18 01 00 	lea    0x11802(%rip),%rsi        # 18de4 <handle_sizes.1924+0x664>
        errval = PAL_ERROR_INVAL;
call_lose:
        printf("%s (%d)\n", errstring, PAL_STRERROR(errval));
    75e2:	48 8d 15 eb 13 01 00 	lea    0x113eb(%rip),%rdx        # 189d4 <handle_sizes.1924+0x254>
    75e9:	e9 30 fd ff ff       	jmpq   731e <map_elf_object_by_handle+0x6de>
    75ee:	f7 d8                	neg    %eax
    } else {
        phdr = (ElfW(Phdr) *) malloc (maplength);

        if ((ret = _DkStreamRead(handle, header->e_phoff, maplength, phdr,
                                 NULL, 0)) < 0) {
            errstring = "cannot read file data";
    75f0:	48 8d 35 d7 17 01 00 	lea    0x117d7(%rip),%rsi        # 18dce <handle_sizes.1924+0x64e>
    75f7:	8d 48 ff             	lea    -0x1(%rax),%ecx
    75fa:	e9 06 fd ff ff       	jmpq   7305 <map_elf_object_by_handle+0x6c5>

    if (l->l_phdr == NULL) {
        /* The program header is not contained in any of the segments.
           We have to allocate memory ourself and copy it over from out
           temporary place.  */
        ElfW(Phdr) * newp = (ElfW(Phdr) *) malloc (header->e_phnum
    75ff:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    7603:	0f b7 78 38          	movzwl 0x38(%rax),%edi
    7607:	6b ff 38             	imul   $0x38,%edi,%edi
    760a:	e8 f1 13 00 00       	callq  8a00 <malloc>
                                                   * sizeof (ElfW(Phdr)));
        if (!newp) {
    760f:	48 85 c0             	test   %rax,%rax
    7612:	0f 84 fa 00 00 00    	je     7712 <map_elf_object_by_handle+0xad2>
            errstring = "cannot allocate memory for program header";
            goto call_lose;
        }

        l->l_phdr = memcpy(newp, phdr,
    7618:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
    761c:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
    7620:	48 89 c7             	mov    %rax,%rdi
    7623:	0f b7 52 38          	movzwl 0x38(%rdx),%edx
    7627:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
    762e:	00 
    762f:	48 c1 e2 06          	shl    $0x6,%rdx
    7633:	48 29 ca             	sub    %rcx,%rdx
    7636:	e8 45 ec 00 00       	callq  16280 <memcpy>
    763b:	48 8b 13             	mov    (%rbx),%rdx
    763e:	48 89 83 a8 02 00 00 	mov    %rax,0x2a8(%rbx)
    7645:	e9 d4 fb ff ff       	jmpq   721e <map_elf_object_by_handle+0x5de>
            if (zerosec > zero) {
                /* Zero the final part of the last section of the segment.  */
                if (__builtin_expect ((c->prot & PROT_WRITE) == 0, 0))
                {
                    /* Dag nab it.  */
                    if (_DkVirtualMemoryProtect((void *) ALLOC_ALIGNDOWN(zero),
    764a:	44 89 da             	mov    %r11d,%edx
    764d:	4c 89 ff             	mov    %r15,%rdi
    7650:	83 ca 02             	or     $0x2,%edx
    7653:	48 85 f6             	test   %rsi,%rsi
    7656:	74 0a                	je     7662 <map_elf_object_by_handle+0xa22>
    7658:	48 8b 05 99 c4 21 00 	mov    0x21c499(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    765f:	48 23 38             	and    (%rax),%rdi
    7662:	48 89 8d 78 ff ff ff 	mov    %rcx,-0x88(%rbp)
    7669:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    766d:	44 89 5d a0          	mov    %r11d,-0x60(%rbp)
    7671:	e8 aa 8d 00 00       	callq  10420 <_DkVirtualMemoryProtect>
    7676:	85 c0                	test   %eax,%eax
    7678:	44 8b 5d a0          	mov    -0x60(%rbp),%r11d
    767c:	4c 8b 45 80          	mov    -0x80(%rbp),%r8
    7680:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
    7687:	78 75                	js     76fe <map_elf_object_by_handle+0xabe>
                                                c->prot|PAL_PROT_WRITE) < 0) {
                        errstring = "cannot change memory protections";
                        goto call_lose;
                    }
                }
                memset ((void *) zero, '\0', zerosec - zero);
    7689:	48 89 ca             	mov    %rcx,%rdx
    768c:	31 f6                	xor    %esi,%esi
    768e:	4c 89 ff             	mov    %r15,%rdi
    7691:	4c 29 fa             	sub    %r15,%rdx
    7694:	4c 89 85 78 ff ff ff 	mov    %r8,-0x88(%rbp)
    769b:	44 89 5d 80          	mov    %r11d,-0x80(%rbp)
    769f:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    76a3:	e8 f8 ea 00 00       	callq  161a0 <memset>
                if (__builtin_expect ((c->prot & PROT_WRITE) == 0, 0))
                    _DkVirtualMemoryProtect((void *) ALLOC_ALIGNDOWN(zero),
    76a8:	48 8b 05 e1 c2 21 00 	mov    0x21c2e1(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
    76af:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
    76b3:	44 8b 5d 80          	mov    -0x80(%rbp),%r11d
    76b7:	4c 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%r8
    76be:	48 8b 30             	mov    (%rax),%rsi
    76c1:	48 85 f6             	test   %rsi,%rsi
    76c4:	74 0a                	je     76d0 <map_elf_object_by_handle+0xa90>
    76c6:	48 8b 05 2b c4 21 00 	mov    0x21c42b(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    76cd:	4c 23 38             	and    (%rax),%r15
    76d0:	44 89 da             	mov    %r11d,%edx
    76d3:	4c 89 ff             	mov    %r15,%rdi
    76d6:	48 89 8d 78 ff ff ff 	mov    %rcx,-0x88(%rbp)
    76dd:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    76e1:	44 89 5d a0          	mov    %r11d,-0x60(%rbp)
    76e5:	e8 36 8d 00 00       	callq  10420 <_DkVirtualMemoryProtect>
    76ea:	48 8b 8d 78 ff ff ff 	mov    -0x88(%rbp),%rcx
    76f1:	4c 8b 45 80          	mov    -0x80(%rbp),%r8
    76f5:	44 8b 5d a0          	mov    -0x60(%rbp),%r11d
    76f9:	e9 17 f9 ff ff       	jmpq   7015 <map_elf_object_by_handle+0x3d5>
    76fe:	8b 45 b8             	mov    -0x48(%rbp),%eax
                {
                    /* Dag nab it.  */
                    if (_DkVirtualMemoryProtect((void *) ALLOC_ALIGNDOWN(zero),
                                                allocsize,
                                                c->prot|PAL_PROT_WRITE) < 0) {
                        errstring = "cannot change memory protections";
    7701:	48 8d 35 50 18 01 00 	lea    0x11850(%rip),%rsi        # 18f58 <handle_sizes.1924+0x7d8>
    7708:	f7 d8                	neg    %eax
    770a:	8d 48 ff             	lea    -0x1(%rax),%ecx
    770d:	e9 ef fb ff ff       	jmpq   7301 <map_elf_object_by_handle+0x6c1>
    7712:	8b 45 b8             	mov    -0x48(%rbp),%eax
           We have to allocate memory ourself and copy it over from out
           temporary place.  */
        ElfW(Phdr) * newp = (ElfW(Phdr) *) malloc (header->e_phnum
                                                   * sizeof (ElfW(Phdr)));
        if (!newp) {
            errstring = "cannot allocate memory for program header";
    7715:	48 8d 35 ac 18 01 00 	lea    0x118ac(%rip),%rsi        # 18fc8 <handle_sizes.1924+0x848>
    771c:	f7 d8                	neg    %eax
    771e:	8d 48 ff             	lea    -0x1(%rax),%ecx
    7721:	e9 db fb ff ff       	jmpq   7301 <map_elf_object_by_handle+0x6c1>
    7726:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    772d:	00 00 00 

0000000000007730 <check_elf_object>:

    return l;
}

int check_elf_object (PAL_HANDLE handle)
{
    7730:	55                   	push   %rbp
#define ELF_MAGIC_SIZE EI_CLASS
    unsigned char buffer[ELF_MAGIC_SIZE];

    int len = _DkStreamRead(handle, 0, ELF_MAGIC_SIZE, buffer, NULL, 0);
    7731:	45 31 c9             	xor    %r9d,%r9d
    7734:	45 31 c0             	xor    %r8d,%r8d
    7737:	31 f6                	xor    %esi,%esi
    7739:	ba 04 00 00 00       	mov    $0x4,%edx

    return l;
}

int check_elf_object (PAL_HANDLE handle)
{
    773e:	48 89 e5             	mov    %rsp,%rbp
    7741:	53                   	push   %rbx
#define ELF_MAGIC_SIZE EI_CLASS
    unsigned char buffer[ELF_MAGIC_SIZE];

    int len = _DkStreamRead(handle, 0, ELF_MAGIC_SIZE, buffer, NULL, 0);
    7742:	48 8d 5d e0          	lea    -0x20(%rbp),%rbx

    return l;
}

int check_elf_object (PAL_HANDLE handle)
{
    7746:	48 83 ec 18          	sub    $0x18,%rsp
#define ELF_MAGIC_SIZE EI_CLASS
    unsigned char buffer[ELF_MAGIC_SIZE];

    int len = _DkStreamRead(handle, 0, ELF_MAGIC_SIZE, buffer, NULL, 0);
    774a:	48 89 d9             	mov    %rbx,%rcx
    774d:	e8 3e c5 ff ff       	callq  3c90 <_DkStreamRead>

    if (__builtin_expect (len < 0, 0))
    7752:	85 c0                	test   %eax,%eax
    7754:	78 3a                	js     7790 <check_elf_object+0x60>
        return -len;

    if (__builtin_expect (len < ELF_MAGIC_SIZE, 0))
    7756:	83 f8 03             	cmp    $0x3,%eax
    7759:	7e 25                	jle    7780 <check_elf_object+0x50>
        [EI_MAG2] = ELFMAG2,
        [EI_MAG3] = ELFMAG3,
    };

    /* See whether the ELF header is what we expect.  */
    if (__builtin_expect(memcmp(ehdr->e_ident, expected, ELF_MAGIC_SIZE) !=
    775b:	48 8d 35 1e 1b 01 00 	lea    0x11b1e(%rip),%rsi        # 19280 <expected.3450>
    7762:	ba 04 00 00 00       	mov    $0x4,%edx
    7767:	48 89 df             	mov    %rbx,%rdi
    776a:	e8 a1 eb 00 00       	callq  16310 <memcmp>
    776f:	85 c0                	test   %eax,%eax
    7771:	75 0d                	jne    7780 <check_elf_object+0x50>
                         0, 0))
        return -PAL_ERROR_INVAL;

    return 0;
}
    7773:	48 83 c4 18          	add    $0x18,%rsp
    7777:	5b                   	pop    %rbx
    7778:	5d                   	pop    %rbp
    7779:	c3                   	retq   
    777a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    7780:	48 83 c4 18          	add    $0x18,%rsp

    if (__builtin_expect (len < 0, 0))
        return -len;

    if (__builtin_expect (len < ELF_MAGIC_SIZE, 0))
        return -PAL_ERROR_INVAL;
    7784:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    if (__builtin_expect(memcmp(ehdr->e_ident, expected, ELF_MAGIC_SIZE) !=
                         0, 0))
        return -PAL_ERROR_INVAL;

    return 0;
}
    7789:	5b                   	pop    %rbx
    778a:	5d                   	pop    %rbp
    778b:	c3                   	retq   
    778c:	0f 1f 40 00          	nopl   0x0(%rax)
    7790:	48 83 c4 18          	add    $0x18,%rsp
    unsigned char buffer[ELF_MAGIC_SIZE];

    int len = _DkStreamRead(handle, 0, ELF_MAGIC_SIZE, buffer, NULL, 0);

    if (__builtin_expect (len < 0, 0))
        return -len;
    7794:	f7 d8                	neg    %eax
    if (__builtin_expect(memcmp(ehdr->e_ident, expected, ELF_MAGIC_SIZE) !=
                         0, 0))
        return -PAL_ERROR_INVAL;

    return 0;
}
    7796:	5b                   	pop    %rbx
    7797:	5d                   	pop    %rbp
    7798:	c3                   	retq   
    7799:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000077a0 <free_elf_object>:

void free_elf_object (struct link_map * map)
{
    77a0:	55                   	push   %rbp
    77a1:	48 89 e5             	mov    %rsp,%rbp
    77a4:	41 54                	push   %r12
    77a6:	53                   	push   %rbx
    77a7:	48 89 fb             	mov    %rdi,%rbx
    /* unmap the exec_map */
    _DkVirtualMemoryFree((void *) map->l_map_start,
                         map->l_map_end - map->l_map_start);
    77aa:	48 8b bf e0 02 00 00 	mov    0x2e0(%rdi),%rdi
}

void free_elf_object (struct link_map * map)
{
    /* unmap the exec_map */
    _DkVirtualMemoryFree((void *) map->l_map_start,
    77b1:	48 8b b3 e8 02 00 00 	mov    0x2e8(%rbx),%rsi
    77b8:	48 29 fe             	sub    %rdi,%rsi
    77bb:	e8 50 8b 00 00       	callq  10310 <_DkVirtualMemoryFree>
                         map->l_map_end - map->l_map_start);

    pal_sec_info._r_debug->r_state = RT_DELETE;
    77c0:	4c 8b 25 e1 c2 21 00 	mov    0x21c2e1(%rip),%r12        # 223aa8 <_DYNAMIC+0x2c0>
    77c7:	49 8b 44 24 30       	mov    0x30(%r12),%rax
    77cc:	c7 40 18 02 00 00 00 	movl   $0x2,0x18(%rax)
    pal_sec_info._dl_debug_state();
    77d3:	41 ff 54 24 28       	callq  *0x28(%r12)

    if (map->l_prev)
    77d8:	48 8b 43 20          	mov    0x20(%rbx),%rax
    77dc:	48 85 c0             	test   %rax,%rax
    77df:	74 08                	je     77e9 <free_elf_object+0x49>
        map->l_prev->l_next = map->l_next;
    77e1:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    77e5:	48 89 50 18          	mov    %rdx,0x18(%rax)
    if (map->l_next)
    77e9:	48 8b 53 18          	mov    0x18(%rbx),%rdx
    77ed:	48 85 d2             	test   %rdx,%rdx
    77f0:	74 04                	je     77f6 <free_elf_object+0x56>
        map->l_next->l_prev = map->l_prev;
    77f2:	48 89 42 20          	mov    %rax,0x20(%rdx)

    pal_sec_info._r_debug->r_state = RT_CONSISTENT;
    77f6:	49 8b 44 24 30       	mov    0x30(%r12),%rax
    77fb:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
    pal_sec_info._dl_debug_state();
    7802:	41 ff 54 24 28       	callq  *0x28(%r12)

    if (loaded_libraries == map)
    7807:	48 8b 05 1a c3 21 00 	mov    0x21c31a(%rip),%rax        # 223b28 <_DYNAMIC+0x340>
    780e:	48 39 18             	cmp    %rbx,(%rax)
    7811:	74 0d                	je     7820 <free_elf_object+0x80>
        loaded_libraries = map->l_next;

    free(map);
    7813:	48 89 df             	mov    %rbx,%rdi
}
    7816:	5b                   	pop    %rbx
    7817:	41 5c                	pop    %r12
    7819:	5d                   	pop    %rbp
    pal_sec_info._dl_debug_state();

    if (loaded_libraries == map)
        loaded_libraries = map->l_next;

    free(map);
    781a:	e9 71 14 00 00       	jmpq   8c90 <free>
    781f:	90                   	nop    

    pal_sec_info._r_debug->r_state = RT_CONSISTENT;
    pal_sec_info._dl_debug_state();

    if (loaded_libraries == map)
        loaded_libraries = map->l_next;
    7820:	48 8b 53 18          	mov    0x18(%rbx),%rdx

    free(map);
    7824:	48 89 df             	mov    %rbx,%rdi

    pal_sec_info._r_debug->r_state = RT_CONSISTENT;
    pal_sec_info._dl_debug_state();

    if (loaded_libraries == map)
        loaded_libraries = map->l_next;
    7827:	48 89 10             	mov    %rdx,(%rax)

    free(map);
}
    782a:	5b                   	pop    %rbx
    782b:	41 5c                	pop    %r12
    782d:	5d                   	pop    %rbp
    pal_sec_info._dl_debug_state();

    if (loaded_libraries == map)
        loaded_libraries = map->l_next;

    free(map);
    782e:	e9 5d 14 00 00       	jmpq   8c90 <free>
    7833:	66 66 66 66 2e 0f 1f 	nopw   %cs:0x0(%rax,%rax,1)
    783a:	84 00 00 00 00 00 

0000000000007840 <elf_hash>:

/* This is the hashing function specified by the ELF ABI.  In the
   first five operations no overflow is possible so we optimized it a
   bit.  */
unsigned long int elf_hash (const char *name_arg)
{
    7840:	0f b6 17             	movzbl (%rdi),%edx
    7843:	55                   	push   %rbp
    const unsigned char *name = (const unsigned char *) name_arg;
    unsigned long int hash = 0;

    if (*name == '\0')
        return hash;
    7844:	31 c0                	xor    %eax,%eax

/* This is the hashing function specified by the ELF ABI.  In the
   first five operations no overflow is possible so we optimized it a
   bit.  */
unsigned long int elf_hash (const char *name_arg)
{
    7846:	48 89 e5             	mov    %rsp,%rbp
    const unsigned char *name = (const unsigned char *) name_arg;
    unsigned long int hash = 0;

    if (*name == '\0')
    7849:	84 d2                	test   %dl,%dl
    784b:	0f 84 8f 00 00 00    	je     78e0 <elf_hash+0xa0>
        return hash;

    hash = *name++;
    if (*name == '\0')
    7851:	0f b6 4f 01          	movzbl 0x1(%rdi),%ecx
        return hash;
    7855:	48 89 d0             	mov    %rdx,%rax

    if (*name == '\0')
        return hash;

    hash = *name++;
    if (*name == '\0')
    7858:	84 c9                	test   %cl,%cl
    785a:	0f 84 80 00 00 00    	je     78e0 <elf_hash+0xa0>
        return hash;

    hash = (hash << 4) + *name++;
    7860:	48 c1 e2 04          	shl    $0x4,%rdx
    7864:	48 01 ca             	add    %rcx,%rdx
    if (*name == '\0')
    7867:	0f b6 4f 02          	movzbl 0x2(%rdi),%ecx
        return hash;
    786b:	48 89 d0             	mov    %rdx,%rax
    hash = *name++;
    if (*name == '\0')
        return hash;

    hash = (hash << 4) + *name++;
    if (*name == '\0')
    786e:	84 c9                	test   %cl,%cl
    7870:	74 6e                	je     78e0 <elf_hash+0xa0>
        return hash;

    hash = (hash << 4) + *name++;
    7872:	48 c1 e2 04          	shl    $0x4,%rdx
    7876:	48 01 ca             	add    %rcx,%rdx
    if (*name == '\0')
    7879:	0f b6 4f 03          	movzbl 0x3(%rdi),%ecx
        return hash;
    787d:	48 89 d0             	mov    %rdx,%rax
    hash = (hash << 4) + *name++;
    if (*name == '\0')
        return hash;

    hash = (hash << 4) + *name++;
    if (*name == '\0')
    7880:	84 c9                	test   %cl,%cl
    7882:	74 5c                	je     78e0 <elf_hash+0xa0>
        return hash;

    hash = (hash << 4) + *name++;
    7884:	48 c1 e2 04          	shl    $0x4,%rdx
    7888:	48 01 ca             	add    %rcx,%rdx
    if (*name == '\0')
    788b:	0f b6 4f 04          	movzbl 0x4(%rdi),%ecx
        return hash;
    788f:	48 89 d0             	mov    %rdx,%rax
    hash = (hash << 4) + *name++;
    if (*name == '\0')
        return hash;

    hash = (hash << 4) + *name++;
    if (*name == '\0')
    7892:	84 c9                	test   %cl,%cl
    7894:	74 4a                	je     78e0 <elf_hash+0xa0>
        return hash;

    hash = (hash << 4) + *name++;
    7896:	0f b6 c1             	movzbl %cl,%eax
    while (*name != '\0') {
    7899:	0f b6 4f 05          	movzbl 0x5(%rdi),%ecx

    hash = (hash << 4) + *name++;
    if (*name == '\0')
        return hash;

    hash = (hash << 4) + *name++;
    789d:	48 c1 e2 04          	shl    $0x4,%rdx
    78a1:	48 01 c2             	add    %rax,%rdx
    78a4:	48 8d 77 05          	lea    0x5(%rdi),%rsi
    while (*name != '\0') {
    78a8:	84 c9                	test   %cl,%cl
    78aa:	74 2c                	je     78d8 <elf_hash+0x98>
    78ac:	0f 1f 40 00          	nopl   0x0(%rax)
        unsigned long int hi;
        hash = (hash << 4) + *name++;
    78b0:	48 89 d0             	mov    %rdx,%rax
    78b3:	48 83 c6 01          	add    $0x1,%rsi
    78b7:	48 c1 e0 04          	shl    $0x4,%rax
    78bb:	48 01 c8             	add    %rcx,%rax
    hash = (hash << 4) + *name++;
    if (*name == '\0')
        return hash;

    hash = (hash << 4) + *name++;
    while (*name != '\0') {
    78be:	0f b6 0e             	movzbl (%rsi),%ecx
        unsigned long int hi;
        hash = (hash << 4) + *name++;
        hi = hash & 0xf0000000;
    78c1:	48 89 c2             	mov    %rax,%rdx
    78c4:	81 e2 00 00 00 f0    	and    $0xf0000000,%edx
         * hash &= ~hi;
         * But the following is equivalent and a lot faster, especially on
         *  modern processors.
         */

        hash ^= hi;
    78ca:	48 31 d0             	xor    %rdx,%rax
        hash ^= hi >> 24;
    78cd:	48 c1 ea 18          	shr    $0x18,%rdx
    78d1:	48 31 c2             	xor    %rax,%rdx
    hash = (hash << 4) + *name++;
    if (*name == '\0')
        return hash;

    hash = (hash << 4) + *name++;
    while (*name != '\0') {
    78d4:	84 c9                	test   %cl,%cl
    78d6:	75 d8                	jne    78b0 <elf_hash+0x70>
         */

        hash ^= hi;
        hash ^= hi >> 24;
    }
    return hash;
    78d8:	48 89 d0             	mov    %rdx,%rax
    78db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
}
    78e0:	5d                   	pop    %rbp
    78e1:	c3                   	retq   
    78e2:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
    78e9:	1f 84 00 00 00 00 00 

00000000000078f0 <do_lookup_map>:

ElfW(Sym) *
do_lookup_map (ElfW(Sym) * ref, const char * undef_name,
               const uint_fast32_t hash, unsigned long int elf_hash,
               const struct link_map * map)
{
    78f0:	55                   	push   %rbp
    78f1:	48 89 e5             	mov    %rsp,%rbp
    78f4:	41 57                	push   %r15
    78f6:	41 56                	push   %r14
    78f8:	41 55                	push   %r13
    78fa:	41 54                	push   %r12
    78fc:	49 89 f7             	mov    %rsi,%r15
    78ff:	53                   	push   %rbx
    7900:	49 89 fe             	mov    %rdi,%r14
    7903:	4c 89 c3             	mov    %r8,%rbx
    7906:	48 83 ec 28          	sub    $0x28,%rsp
    /* These variables are used in the nested function.  */
    Elf_Symndx symidx;
    ElfW(Sym) * sym;
    /* The tables for this map.  */
    ElfW(Sym) * symtab = (void *) D_PTR (map->l_info[DT_SYMTAB]);
    790a:	49 8b 70 78          	mov    0x78(%r8),%rsi
    790e:	4c 8b 66 08          	mov    0x8(%rsi),%r12
    const char * strtab = (const void *) D_PTR (map->l_info[DT_STRTAB]);
    7912:	49 8b 70 70          	mov    0x70(%r8),%rsi
    7916:	48 8b 46 08          	mov    0x8(%rsi),%rax

    const ElfW(Addr) * bitmask = map->l_gnu_bitmask;
    791a:	49 8b b0 20 03 00 00 	mov    0x320(%r8),%rsi

    if (__builtin_expect (bitmask != NULL, 1)) {
    7921:	48 85 f6             	test   %rsi,%rsi
    /* These variables are used in the nested function.  */
    Elf_Symndx symidx;
    ElfW(Sym) * sym;
    /* The tables for this map.  */
    ElfW(Sym) * symtab = (void *) D_PTR (map->l_info[DT_SYMTAB]);
    const char * strtab = (const void *) D_PTR (map->l_info[DT_STRTAB]);
    7924:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    const ElfW(Addr) * bitmask = map->l_gnu_bitmask;

    if (__builtin_expect (bitmask != NULL, 1)) {
    7928:	0f 84 d2 00 00 00    	je     7a00 <do_lookup_map+0x110>
        ElfW(Addr) bitmask_word = bitmask[(hash / __ELF_NATIVE_CLASS)
    792e:	89 d0                	mov    %edx,%eax
                                          & map->l_gnu_bitmask_idxbits];

        unsigned int hashbit1 = hash & (__ELF_NATIVE_CLASS - 1);
        unsigned int hashbit2 = (hash >> map->l_gnu_shift)
    7930:	41 8b 88 1c 03 00 00 	mov    0x31c(%r8),%ecx
    7937:	41 89 d1             	mov    %edx,%r9d
    const char * strtab = (const void *) D_PTR (map->l_info[DT_STRTAB]);

    const ElfW(Addr) * bitmask = map->l_gnu_bitmask;

    if (__builtin_expect (bitmask != NULL, 1)) {
        ElfW(Addr) bitmask_word = bitmask[(hash / __ELF_NATIVE_CLASS)
    793a:	c1 e8 06             	shr    $0x6,%eax
                                          & map->l_gnu_bitmask_idxbits];
    793d:	41 23 80 18 03 00 00 	and    0x318(%r8),%eax

        unsigned int hashbit1 = hash & (__ELF_NATIVE_CLASS - 1);
        unsigned int hashbit2 = (hash >> map->l_gnu_shift)
    7944:	d3 ea                	shr    %cl,%edx
    7946:	89 d1                	mov    %edx,%ecx
    const char * strtab = (const void *) D_PTR (map->l_info[DT_STRTAB]);

    const ElfW(Addr) * bitmask = map->l_gnu_bitmask;

    if (__builtin_expect (bitmask != NULL, 1)) {
        ElfW(Addr) bitmask_word = bitmask[(hash / __ELF_NATIVE_CLASS)
    7948:	48 8b 04 c6          	mov    (%rsi,%rax,8),%rax
        unsigned int hashbit1 = hash & (__ELF_NATIVE_CLASS - 1);
        unsigned int hashbit2 = (hash >> map->l_gnu_shift)
                                & (__ELF_NATIVE_CLASS - 1);

        if (__builtin_expect ((bitmask_word >> hashbit1)
                            & (bitmask_word >> hashbit2) & 1, 0)) {
    794c:	48 89 c2             	mov    %rax,%rdx
    794f:	48 d3 ea             	shr    %cl,%rdx

        unsigned int hashbit1 = hash & (__ELF_NATIVE_CLASS - 1);
        unsigned int hashbit2 = (hash >> map->l_gnu_shift)
                                & (__ELF_NATIVE_CLASS - 1);

        if (__builtin_expect ((bitmask_word >> hashbit1)
    7952:	44 89 c9             	mov    %r9d,%ecx
    7955:	48 d3 e8             	shr    %cl,%rax
                            & (bitmask_word >> hashbit2) & 1, 0)) {
    7958:	48 21 d0             	and    %rdx,%rax

        unsigned int hashbit1 = hash & (__ELF_NATIVE_CLASS - 1);
        unsigned int hashbit2 = (hash >> map->l_gnu_shift)
                                & (__ELF_NATIVE_CLASS - 1);

        if (__builtin_expect ((bitmask_word >> hashbit1)
    795b:	a8 01                	test   $0x1,%al
    795d:	75 11                	jne    7970 <do_lookup_map+0x80>
            if (sym != NULL)
                return sym;
        }
    }

    return NULL;
    795f:	31 c0                	xor    %eax,%eax
}
    7961:	48 83 c4 28          	add    $0x28,%rsp
    7965:	5b                   	pop    %rbx
    7966:	41 5c                	pop    %r12
    7968:	41 5d                	pop    %r13
    796a:	41 5e                	pop    %r14
    796c:	41 5f                	pop    %r15
    796e:	5d                   	pop    %rbp
    796f:	c3                   	retq   
                                & (__ELF_NATIVE_CLASS - 1);

        if (__builtin_expect ((bitmask_word >> hashbit1)
                            & (bitmask_word >> hashbit2) & 1, 0)) {
            Elf32_Word bucket = map->l_gnu_buckets
                                    [hash % map->l_nbuckets];
    7970:	31 d2                	xor    %edx,%edx
    7972:	44 89 c8             	mov    %r9d,%eax
    7975:	41 f7 b0 00 03 00 00 	divl   0x300(%r8)
        unsigned int hashbit2 = (hash >> map->l_gnu_shift)
                                & (__ELF_NATIVE_CLASS - 1);

        if (__builtin_expect ((bitmask_word >> hashbit1)
                            & (bitmask_word >> hashbit2) & 1, 0)) {
            Elf32_Word bucket = map->l_gnu_buckets
    797c:	49 8b 80 28 03 00 00 	mov    0x328(%r8),%rax
                                    [hash % map->l_nbuckets];
    7983:	89 d2                	mov    %edx,%edx
        unsigned int hashbit2 = (hash >> map->l_gnu_shift)
                                & (__ELF_NATIVE_CLASS - 1);

        if (__builtin_expect ((bitmask_word >> hashbit1)
                            & (bitmask_word >> hashbit2) & 1, 0)) {
            Elf32_Word bucket = map->l_gnu_buckets
    7985:	8b 04 90             	mov    (%rax,%rdx,4),%eax
                                    [hash % map->l_nbuckets];

            if (bucket != 0) {
    7988:	85 c0                	test   %eax,%eax
    798a:	74 d3                	je     795f <do_lookup_map+0x6f>
                const Elf32_Word *hasharr = &map->l_gnu_chain_zero[bucket];
    798c:	49 8b 90 30 03 00 00 	mov    0x330(%r8),%rdx
    7993:	4c 8d 04 82          	lea    (%rdx,%rax,4),%r8
    7997:	eb 10                	jmp    79a9 <do_lookup_map+0xb9>
    7999:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                        symidx = hasharr - map->l_gnu_chain_zero;
                        sym = check_match (&symtab[symidx], strtab, undef_name, ref);
                        if (sym != NULL)
                            return sym;
                    }
                while ((*hasharr++ & 1u) == 0);
    79a0:	49 83 c0 04          	add    $0x4,%r8
    79a4:	83 e6 01             	and    $0x1,%esi
    79a7:	75 b6                	jne    795f <do_lookup_map+0x6f>

            if (bucket != 0) {
                const Elf32_Word *hasharr = &map->l_gnu_chain_zero[bucket];

                do
                    if (((*hasharr ^ hash) >> 1) == 0) {
    79a9:	41 8b 30             	mov    (%r8),%esi
    79ac:	89 f0                	mov    %esi,%eax
    79ae:	44 31 c8             	xor    %r9d,%eax
    79b1:	d1 e8                	shr    %eax
    79b3:	75 eb                	jne    79a0 <do_lookup_map+0xb0>
                        symidx = hasharr - map->l_gnu_chain_zero;
    79b5:	4c 89 c0             	mov    %r8,%rax
    79b8:	48 2b 83 30 03 00 00 	sub    0x330(%rbx),%rax
                        sym = check_match (&symtab[symidx], strtab, undef_name, ref);
    79bf:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    79c3:	4c 89 f1             	mov    %r14,%rcx
    79c6:	4c 89 fa             	mov    %r15,%rdx
    79c9:	44 89 4d bc          	mov    %r9d,-0x44(%rbp)
            if (bucket != 0) {
                const Elf32_Word *hasharr = &map->l_gnu_chain_zero[bucket];

                do
                    if (((*hasharr ^ hash) >> 1) == 0) {
                        symidx = hasharr - map->l_gnu_chain_zero;
    79cd:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
    79d1:	48 c1 f8 02          	sar    $0x2,%rax
    79d5:	89 c0                	mov    %eax,%eax
                        sym = check_match (&symtab[symidx], strtab, undef_name, ref);
    79d7:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
    79db:	49 8d 3c c4          	lea    (%r12,%rax,8),%rdi
    79df:	e8 dc ef ff ff       	callq  69c0 <check_match>
                        if (sym != NULL)
    79e4:	48 85 c0             	test   %rax,%rax
    79e7:	0f 85 74 ff ff ff    	jne    7961 <do_lookup_map+0x71>
    79ed:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
    79f1:	44 8b 4d bc          	mov    -0x44(%rbp),%r9d
    79f5:	41 8b 30             	mov    (%r8),%esi
    79f8:	eb a6                	jmp    79a0 <do_lookup_map+0xb0>
    79fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        symidx = SHN_UNDEF;
    } else {
        /* Use the old SysV-style hash table.  Search the appropriate
           hash bucket in this object's symbol table for a definition
           for the same symbol name.  */
        for (symidx = map->l_buckets[elf_hash % map->l_nbuckets];
    7a00:	41 8b b0 00 03 00 00 	mov    0x300(%r8),%esi
    7a07:	31 d2                	xor    %edx,%edx
    7a09:	48 89 c8             	mov    %rcx,%rax
    7a0c:	48 f7 f6             	div    %rsi
    7a0f:	49 8b b0 08 03 00 00 	mov    0x308(%r8),%rsi
    7a16:	44 8b 04 96          	mov    (%rsi,%rdx,4),%r8d
    7a1a:	45 85 c0             	test   %r8d,%r8d
    7a1d:	0f 84 3c ff ff ff    	je     795f <do_lookup_map+0x6f>
             symidx != STN_UNDEF;
             symidx = map->l_chain[symidx]) {
            sym = check_match (&symtab[symidx], strtab, undef_name, ref);
    7a23:	45 89 c5             	mov    %r8d,%r13d
    7a26:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
    7a2a:	4c 89 f1             	mov    %r14,%rcx
    7a2d:	4b 8d 44 6d 00       	lea    0x0(%r13,%r13,2),%rax
    7a32:	4c 89 fa             	mov    %r15,%rdx
    7a35:	49 8d 3c c4          	lea    (%r12,%rax,8),%rdi
    7a39:	e8 82 ef ff ff       	callq  69c0 <check_match>
            if (sym != NULL)
    7a3e:	48 85 c0             	test   %rax,%rax
    7a41:	0f 85 1a ff ff ff    	jne    7961 <do_lookup_map+0x71>
        /* Use the old SysV-style hash table.  Search the appropriate
           hash bucket in this object's symbol table for a definition
           for the same symbol name.  */
        for (symidx = map->l_buckets[elf_hash % map->l_nbuckets];
             symidx != STN_UNDEF;
             symidx = map->l_chain[symidx]) {
    7a47:	48 8b 83 10 03 00 00 	mov    0x310(%rbx),%rax
    7a4e:	46 8b 04 a8          	mov    (%rax,%r13,4),%r8d
        symidx = SHN_UNDEF;
    } else {
        /* Use the old SysV-style hash table.  Search the appropriate
           hash bucket in this object's symbol table for a definition
           for the same symbol name.  */
        for (symidx = map->l_buckets[elf_hash % map->l_nbuckets];
    7a52:	45 85 c0             	test   %r8d,%r8d
    7a55:	75 cc                	jne    7a23 <do_lookup_map+0x133>
    7a57:	e9 03 ff ff ff       	jmpq   795f <do_lookup_map+0x6f>
    7a5c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000007a60 <lookup_symbol>:

   We must never have calls to the audit functions inside this function
   or in any function which gets called.  If this would happen the audit
   code might create a thread which can throw off all the scope locking.  */
struct link_map * lookup_symbol (const char * undef_name, ElfW(Sym) ** ref)
{
    7a60:	55                   	push   %rbp
    7a61:	48 89 e5             	mov    %rsp,%rbp
    7a64:	41 57                	push   %r15
    7a66:	41 56                	push   %r14
    7a68:	41 55                	push   %r13
    7a6a:	41 54                	push   %r12
    7a6c:	49 89 f6             	mov    %rsi,%r14
    7a6f:	53                   	push   %rbx
    7a70:	48 89 fb             	mov    %rdi,%rbx
    7a73:	48 83 ec 28          	sub    $0x28,%rsp
void free_elf_object (struct link_map * map);

static inline uint_fast32_t elf_fast_hash (const char *s)
{
  uint_fast32_t h = 5381;
  for (unsigned char c = *s; c != '\0'; c = *++s)
    7a77:	0f b6 07             	movzbl (%rdi),%eax
    struct sym_val current_value = { NULL, NULL };

    do_lookup(undef_name, *ref, &current_value);
    7a7a:	4c 8b 2e             	mov    (%rsi),%r13
    7a7d:	84 c0                	test   %al,%al
    7a7f:	0f 84 f2 00 00 00    	je     7b77 <lookup_symbol+0x117>
    7a85:	48 89 fe             	mov    %rdi,%rsi
    7a88:	41 bc 05 15 00 00    	mov    $0x1505,%r12d
    7a8e:	66 90                	xchg   %ax,%ax
    h = h * 33 + c;
    7a90:	44 89 e1             	mov    %r12d,%ecx
void free_elf_object (struct link_map * map);

static inline uint_fast32_t elf_fast_hash (const char *s)
{
  uint_fast32_t h = 5381;
  for (unsigned char c = *s; c != '\0'; c = *++s)
    7a93:	48 83 c6 01          	add    $0x1,%rsi
    h = h * 33 + c;
    7a97:	c1 e1 05             	shl    $0x5,%ecx
    7a9a:	42 8d 14 21          	lea    (%rcx,%r12,1),%edx
    7a9e:	44 8d 24 10          	lea    (%rax,%rdx,1),%r12d
void free_elf_object (struct link_map * map);

static inline uint_fast32_t elf_fast_hash (const char *s)
{
  uint_fast32_t h = 5381;
  for (unsigned char c = *s; c != '\0'; c = *++s)
    7aa2:	0f b6 06             	movzbl (%rsi),%eax
    7aa5:	84 c0                	test   %al,%al
    7aa7:	75 e7                	jne    7a90 <lookup_symbol+0x30>
   something bad happened.  */
static int do_lookup (const char * undef_name, ElfW(Sym) * ref,
                      struct sym_val * result)
{
    const uint_fast32_t fast_hash = elf_fast_hash(undef_name);
    const long int hash = elf_hash(undef_name);
    7aa9:	48 89 df             	mov    %rbx,%rdi
    7aac:	e8 8f fd ff ff       	callq  7840 <elf_hash>
    7ab1:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    ElfW(Sym) * sym;
    struct link_map * map = loaded_libraries;
    7ab5:	48 8b 05 6c c0 21 00 	mov    0x21c06c(%rip),%rax        # 223b28 <_DYNAMIC+0x340>

    while (map) {
    7abc:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    7ac3:	00 
    7ac4:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    7acb:	00 
                      struct sym_val * result)
{
    const uint_fast32_t fast_hash = elf_fast_hash(undef_name);
    const long int hash = elf_hash(undef_name);
    ElfW(Sym) * sym;
    struct link_map * map = loaded_libraries;
    7acc:	4c 8b 38             	mov    (%rax),%r15

    while (map) {
    7acf:	4d 85 ff             	test   %r15,%r15
    7ad2:	75 15                	jne    7ae9 <lookup_symbol+0x89>
    7ad4:	e9 86 00 00 00       	jmpq   7b5f <lookup_symbol+0xff>
    7ad9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            default:
                /* Local symbols are ignored.  */
                break;
        }

        map = map->l_next;
    7ae0:	4d 8b 7f 18          	mov    0x18(%r15),%r15
    const uint_fast32_t fast_hash = elf_fast_hash(undef_name);
    const long int hash = elf_hash(undef_name);
    ElfW(Sym) * sym;
    struct link_map * map = loaded_libraries;

    while (map) {
    7ae4:	4d 85 ff             	test   %r15,%r15
    7ae7:	74 67                	je     7b50 <lookup_symbol+0xf0>
        if (!map->l_lookup_symbol) {
    7ae9:	41 80 7f 41 00       	cmpb   $0x0,0x41(%r15)
    7aee:	74 f0                	je     7ae0 <lookup_symbol+0x80>
            map = map->l_next;
            continue;
        }

        sym = do_lookup_map (ref, undef_name, fast_hash, hash, map);
    7af0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    7af4:	4d 89 f8             	mov    %r15,%r8
    7af7:	44 89 e2             	mov    %r12d,%edx
    7afa:	48 89 de             	mov    %rbx,%rsi
    7afd:	4c 89 ef             	mov    %r13,%rdi
    7b00:	e8 eb fd ff ff       	callq  78f0 <do_lookup_map>

        if (sym == NULL)
    7b05:	48 85 c0             	test   %rax,%rax
    7b08:	74 46                	je     7b50 <lookup_symbol+0xf0>
            return 0;

        switch (__builtin_expect (ELFW(ST_BIND) (sym->st_info), STB_GLOBAL)) {
    7b0a:	0f b6 50 04          	movzbl 0x4(%rax),%edx
    7b0e:	c0 ea 04             	shr    $0x4,%dl
    7b11:	80 fa 02             	cmp    $0x2,%dl
    7b14:	74 1f                	je     7b35 <lookup_symbol+0xd5>
    7b16:	80 fa 0a             	cmp    $0xa,%dl
    7b19:	74 05                	je     7b20 <lookup_symbol+0xc0>
    7b1b:	80 fa 01             	cmp    $0x1,%dl
    7b1e:	75 c0                	jne    7ae0 <lookup_symbol+0x80>
    if (__builtin_expect (current_value.s == NULL, 0)) {
        *ref = NULL;
        return NULL;
    }

    *ref = current_value.s;
    7b20:	49 89 06             	mov    %rax,(%r14)
    return current_value.m;
}
    7b23:	48 83 c4 28          	add    $0x28,%rsp
        *ref = NULL;
        return NULL;
    }

    *ref = current_value.s;
    return current_value.m;
    7b27:	4c 89 f8             	mov    %r15,%rax
}
    7b2a:	5b                   	pop    %rbx
    7b2b:	41 5c                	pop    %r12
    7b2d:	41 5d                	pop    %r13
    7b2f:	41 5e                	pop    %r14
    7b31:	41 5f                	pop    %r15
    7b33:	5d                   	pop    %rbp
    7b34:	c3                   	retq   
            return 0;

        switch (__builtin_expect (ELFW(ST_BIND) (sym->st_info), STB_GLOBAL)) {
            case STB_WEAK:
                /* Weak definition.  Use this value if we don't find another. */
                if (!result->s) {
    7b35:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
    7b3a:	75 a4                	jne    7ae0 <lookup_symbol+0x80>
    7b3c:	4c 89 7d b8          	mov    %r15,-0x48(%rbp)
            default:
                /* Local symbols are ignored.  */
                break;
        }

        map = map->l_next;
    7b40:	4d 8b 7f 18          	mov    0x18(%r15),%r15
            return 0;

        switch (__builtin_expect (ELFW(ST_BIND) (sym->st_info), STB_GLOBAL)) {
            case STB_WEAK:
                /* Weak definition.  Use this value if we don't find another. */
                if (!result->s) {
    7b44:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    const uint_fast32_t fast_hash = elf_fast_hash(undef_name);
    const long int hash = elf_hash(undef_name);
    ElfW(Sym) * sym;
    struct link_map * map = loaded_libraries;

    while (map) {
    7b48:	4d 85 ff             	test   %r15,%r15
    7b4b:	75 9c                	jne    7ae9 <lookup_symbol+0x89>
    7b4d:	0f 1f 00             	nopl   (%rax)
{
    struct sym_val current_value = { NULL, NULL };

    do_lookup(undef_name, *ref, &current_value);

    if (__builtin_expect (current_value.s == NULL, 0)) {
    7b50:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    7b54:	48 85 c0             	test   %rax,%rax
    7b57:	74 06                	je     7b5f <lookup_symbol+0xff>
    7b59:	4c 8b 7d b8          	mov    -0x48(%rbp),%r15
    7b5d:	eb c1                	jmp    7b20 <lookup_symbol+0xc0>
        *ref = NULL;
    7b5f:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
        return NULL;
    }

    *ref = current_value.s;
    return current_value.m;
}
    7b66:	48 83 c4 28          	add    $0x28,%rsp

    do_lookup(undef_name, *ref, &current_value);

    if (__builtin_expect (current_value.s == NULL, 0)) {
        *ref = NULL;
        return NULL;
    7b6a:	31 c0                	xor    %eax,%eax
    }

    *ref = current_value.s;
    return current_value.m;
}
    7b6c:	5b                   	pop    %rbx
    7b6d:	41 5c                	pop    %r12
    7b6f:	41 5d                	pop    %r13
    7b71:	41 5e                	pop    %r14
    7b73:	41 5f                	pop    %r15
    7b75:	5d                   	pop    %rbp
    7b76:	c3                   	retq   
new_elf_object (const char * realname, enum object_type type);
void free_elf_object (struct link_map * map);

static inline uint_fast32_t elf_fast_hash (const char *s)
{
  uint_fast32_t h = 5381;
    7b77:	41 bc 05 15 00 00    	mov    $0x1505,%r12d
    7b7d:	e9 27 ff ff ff       	jmpq   7aa9 <lookup_symbol+0x49>
    7b82:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
    7b89:	1f 84 00 00 00 00 00 

0000000000007b90 <elf_dynamic_do_rela>:

static void __attribute__((unused))
elf_dynamic_do_rel (ElfW(Dyn) **l_info, ElfW(Addr) l_addr,
                    ElfW(Addr) reladdr, ElfW(Addr) relsize,
                    bool do_rel, bool do_rel_relative)
{
    7b90:	55                   	push   %rbp
    ElfW(Rel) *r = (void *) reladdr;
    ElfW(Rel) *end = (void *) (reladdr + relsize);
    7b91:	48 8d 04 0a          	lea    (%rdx,%rcx,1),%rax

static void __attribute__((unused))
elf_dynamic_do_rel (ElfW(Dyn) **l_info, ElfW(Addr) l_addr,
                    ElfW(Addr) reladdr, ElfW(Addr) relsize,
                    bool do_rel, bool do_rel_relative)
{
    7b95:	48 89 e5             	mov    %rsp,%rbp
    7b98:	41 57                	push   %r15
    7b9a:	41 56                	push   %r14
    7b9c:	41 55                	push   %r13
    7b9e:	41 54                	push   %r12
    7ba0:	49 89 f6             	mov    %rsi,%r14
    7ba3:	53                   	push   %rbx
    7ba4:	49 89 fd             	mov    %rdi,%r13
    7ba7:	48 89 d6             	mov    %rdx,%rsi
    7baa:	48 83 ec 48          	sub    $0x48,%rsp
    ElfW(Rel) *r = (void *) reladdr;
    ElfW(Rel) *end = (void *) (reladdr + relsize);
    7bae:	48 89 45 a0          	mov    %rax,-0x60(%rbp)

    if (!l_info[DT_SYMTAB])
    7bb2:	48 8b 47 30          	mov    0x30(%rdi),%rax

static void __attribute__((unused))
elf_dynamic_do_rel (ElfW(Dyn) **l_info, ElfW(Addr) l_addr,
                    ElfW(Addr) reladdr, ElfW(Addr) relsize,
                    bool do_rel, bool do_rel_relative)
{
    7bb6:	44 88 45 af          	mov    %r8b,-0x51(%rbp)
    7bba:	44 88 4d ae          	mov    %r9b,-0x52(%rbp)
    ElfW(Rel) *r = (void *) reladdr;
    ElfW(Rel) *end = (void *) (reladdr + relsize);

    if (!l_info[DT_SYMTAB])
    7bbe:	48 85 c0             	test   %rax,%rax
    7bc1:	0f 84 88 01 00 00    	je     7d4f <elf_dynamic_do_rela+0x1bf>
        return;

    {
        ElfW(Sym) *symtab = (void *) D_PTR (l_info[DT_SYMTAB]);
        ElfW(Word) nrelative = (l_info[RELCOUNT_IDX] == NULL
    7bc7:	48 8b bf 40 01 00 00 	mov    0x140(%rdi),%rdi

    if (!l_info[DT_SYMTAB])
        return;

    {
        ElfW(Sym) *symtab = (void *) D_PTR (l_info[DT_SYMTAB]);
    7bce:	48 8b 40 08          	mov    0x8(%rax),%rax
    7bd2:	48 89 d3             	mov    %rdx,%rbx
        ElfW(Word) nrelative = (l_info[RELCOUNT_IDX] == NULL
    7bd5:	48 85 ff             	test   %rdi,%rdi

    if (!l_info[DT_SYMTAB])
        return;

    {
        ElfW(Sym) *symtab = (void *) D_PTR (l_info[DT_SYMTAB]);
    7bd8:	48 89 45 98          	mov    %rax,-0x68(%rbp)
        ElfW(Word) nrelative = (l_info[RELCOUNT_IDX] == NULL
    7bdc:	0f 84 5e 03 00 00    	je     7f40 <elf_dynamic_do_rela+0x3b0>
    7be2:	48 89 c8             	mov    %rcx,%rax
    7be5:	48 ba ab aa aa aa aa 	mov    $0xaaaaaaaaaaaaaaab,%rdx
    7bec:	aa aa aa 
    7bef:	48 f7 e2             	mul    %rdx
    7bf2:	8b 47 08             	mov    0x8(%rdi),%eax
    7bf5:	48 c1 ea 04          	shr    $0x4,%rdx
    7bf9:	48 39 c2             	cmp    %rax,%rdx
    7bfc:	48 0f 46 c2          	cmovbe %rdx,%rax
    7c00:	4c 8d 04 40          	lea    (%rax,%rax,2),%r8
    7c04:	49 c1 e0 03          	shl    $0x3,%r8
                                ? 0 : l_info[RELCOUNT_IDX]->d_un.d_val);
        ElfW(Rel) *relative = r;
        r = r + MIN (nrelative, relsize / sizeof (ElfW(Rel)));

        if (do_rel_relative)
    7c08:	45 84 c9             	test   %r9b,%r9b
    {
        ElfW(Sym) *symtab = (void *) D_PTR (l_info[DT_SYMTAB]);
        ElfW(Word) nrelative = (l_info[RELCOUNT_IDX] == NULL
                                ? 0 : l_info[RELCOUNT_IDX]->d_un.d_val);
        ElfW(Rel) *relative = r;
        r = r + MIN (nrelative, relsize / sizeof (ElfW(Rel)));
    7c0b:	4e 8d 3c 06          	lea    (%rsi,%r8,1),%r15

        if (do_rel_relative)
    7c0f:	0f 85 4b 02 00 00    	jne    7e60 <elf_dynamic_do_rela+0x2d0>
#endif
                for (; relative < r; ++relative) {
		    //printf("relocate: %08x\n", relative);
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
                }
        for (; r < end; ++r) {
    7c15:	4c 39 7d a0          	cmp    %r15,-0x60(%rbp)
    7c19:	0f 86 30 01 00 00    	jbe    7d4f <elf_dynamic_do_rela+0x1bf>

/* This macro is used as a callback from the ELF_DYNAMIC_RELOCATE code.  */
static ElfW(Addr) resolve_map (const char **strtab, ElfW(Sym) ** ref)
{
    if (ELFW(ST_BIND) ((*ref)->st_info) != STB_LOCAL) {
        struct link_map * l = lookup_symbol((*strtab) + (*ref)->st_name, ref);
    7c1f:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
    7c23:	4d 89 fc             	mov    %r15,%r12
    7c26:	4c 89 75 b0          	mov    %r14,-0x50(%rbp)
    7c2a:	4d 89 ef             	mov    %r13,%r15
    7c2d:	48 89 45 90          	mov    %rax,-0x70(%rbp)
	    //printf("relocate: %08x\n", r);
            elf_machine_rel (l_info, l_addr, r,
                             &symtab[ELFW(R_SYM) (r->r_info)],
                             (void *) (l_addr + r->r_offset),
    7c31:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    7c35:	49 03 04 24          	add    (%r12),%rax
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
                }
        for (; r < end; ++r) {
	    //printf("relocate: %08x\n", r);
            elf_machine_rel (l_info, l_addr, r,
                             &symtab[ELFW(R_SYM) (r->r_info)],
    7c39:	49 8b 54 24 08       	mov    0x8(%r12),%rdx
		    //printf("relocate: %08x\n", relative);
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
                }
        for (; r < end; ++r) {
	    //printf("relocate: %08x\n", r);
            elf_machine_rel (l_info, l_addr, r,
    7c3e:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi
                             &symtab[ELFW(R_SYM) (r->r_info)],
                             (void *) (l_addr + r->r_offset),
    7c42:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
                }
        for (; r < end; ++r) {
	    //printf("relocate: %08x\n", r);
            elf_machine_rel (l_info, l_addr, r,
                             &symtab[ELFW(R_SYM) (r->r_info)],
    7c46:	48 89 d0             	mov    %rdx,%rax
elf_machine_rela (Elf64_Dyn **l_info, Elf64_Addr l_addr,
                  Elf64_Rela *reloc, Elf64_Sym *sym, void *const reloc_addr_arg,
                  bool rel, bool rel_relative)
{
    Elf64_Addr *const reloc_addr = reloc_addr_arg;
    const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
    7c49:	41 89 d6             	mov    %edx,%r14d
    7c4c:	48 c1 e8 20          	shr    $0x20,%rax
    })
#else
#define elf_machine_rela_debug(...) ({})
#endif

    if (__builtin_expect (r_type == R_X86_64_RELATIVE, 0))
    7c50:	49 83 fe 08          	cmp    $0x8,%r14
    7c54:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
		    //printf("relocate: %08x\n", relative);
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
                }
        for (; r < end; ++r) {
	    //printf("relocate: %08x\n", r);
            elf_machine_rel (l_info, l_addr, r,
    7c58:	48 8d 1c c7          	lea    (%rdi,%rax,8),%rbx
{
    Elf64_Addr *const reloc_addr = reloc_addr_arg;
    const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);

    const char * __attribute__ ((unused)) strtab =
                            (const void *) D_PTR (l_info[DT_STRTAB]);
    7c5c:	49 8b 47 28          	mov    0x28(%r15),%rax
    7c60:	48 89 5d c8          	mov    %rbx,-0x38(%rbp)
    7c64:	4c 8b 68 08          	mov    0x8(%rax),%r13
    })
#else
#define elf_machine_rela_debug(...) ({})
#endif

    if (__builtin_expect (r_type == R_X86_64_RELATIVE, 0))
    7c68:	0f 84 86 01 00 00    	je     7df4 <elf_dynamic_do_rela+0x264>
#endif
        }
        return;
    }

    if (__builtin_expect (r_type == R_X86_64_NONE, 0))
    7c6e:	4d 85 f6             	test   %r14,%r14
    7c71:	0f 84 ca 00 00 00    	je     7d41 <elf_dynamic_do_rela+0x1b1>
#else
    Elf64_Sym *refsym = sym;
    Elf64_Addr value;
    Elf64_Addr sym_map = 0;

    value = RESOLVE_MAP_IN_RTLD(sym);
    7c77:	48 89 df             	mov    %rbx,%rdi
    7c7a:	e8 41 c4 00 00       	callq  140c0 <resolve_map_in_rtld>

    if (value) {
    7c7f:	48 85 c0             	test   %rax,%rax
    7c82:	0f 84 48 01 00 00    	je     7dd0 <elf_dynamic_do_rela+0x240>
        /* We can't handle a IRELEATIVE symbol if it's found in RTLD,
           they should never exist */
        if (r_type == R_X86_64_IRELATIVE)
    7c88:	49 83 fe 25          	cmp    $0x25,%r14
    7c8c:	0f 84 af 00 00 00    	je     7d41 <elf_dynamic_do_rela+0x1b1>
    7c92:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    Elf64_Addr value = (sym == NULL ? 0 : l_addr + sym->st_value);
#define SYM (sym)
#else
    Elf64_Sym *refsym = sym;
    Elf64_Addr value;
    Elf64_Addr sym_map = 0;
    7c96:	45 31 ed             	xor    %r13d,%r13d
    }

#define SYM (sym ? : refsym)

    /* We do a very special relocation for loaded libraries */
    if (!rel) {
    7c99:	80 7d af 00          	cmpb   $0x0,-0x51(%rbp)
    7c9d:	75 4c                	jne    7ceb <elf_dynamic_do_rela+0x15b>
        if (sym && refsym && refsym != sym) {
    7c9f:	48 85 c9             	test   %rcx,%rcx
    7ca2:	40 0f 95 c7          	setne  %dil
    7ca6:	48 39 cb             	cmp    %rcx,%rbx
    7ca9:	40 0f 95 c6          	setne  %sil
    7cad:	40 84 f7             	test   %sil,%dil
    7cb0:	0f 84 8b 00 00 00    	je     7d41 <elf_dynamic_do_rela+0x1b1>
    7cb6:	48 85 db             	test   %rbx,%rbx
    7cb9:	0f 84 82 00 00 00    	je     7d41 <elf_dynamic_do_rela+0x1b1>
            refsym->st_info = sym->st_info;
    7cbf:	0f b6 71 04          	movzbl 0x4(%rcx),%esi
    7cc3:	40 88 73 04          	mov    %sil,0x4(%rbx)
            refsym->st_size = sym->st_size;
    7cc7:	48 8b 71 10          	mov    0x10(%rcx),%rsi
    7ccb:	48 89 73 10          	mov    %rsi,0x10(%rbx)

            if (__builtin_expect (ELFW(ST_TYPE) (sym->st_info)
    7ccf:	0f b6 71 04          	movzbl 0x4(%rcx),%esi
    7cd3:	83 e6 0f             	and    $0xf,%esi
    7cd6:	40 80 fe 0a          	cmp    $0xa,%sil
    7cda:	0f 84 30 02 00 00    	je     7f10 <elf_dynamic_do_rela+0x380>

                refsym->st_info ^= ELFW(ST_TYPE)(sym->st_info);
                refsym->st_info |= STT_FUNC;
            }

            refsym->st_value = value - l_addr;
    7ce0:	48 89 c6             	mov    %rax,%rsi
    7ce3:	48 2b 75 b0          	sub    -0x50(%rbp),%rsi
    7ce7:	48 89 73 08          	mov    %rsi,0x8(%rbx)
            return;
        }
    }
#endif

    if (sym != NULL
    7ceb:	48 85 c9             	test   %rcx,%rcx
    7cee:	0f 84 4d 01 00 00    	je     7e41 <elf_dynamic_do_rela+0x2b1>
        && __builtin_expect (ELFW(ST_TYPE) (sym->st_info)
    7cf4:	0f b6 71 04          	movzbl 0x4(%rcx),%esi
    7cf8:	83 e6 0f             	and    $0xf,%esi
    7cfb:	40 80 fe 0a          	cmp    $0xa,%sil
    7cff:	0f 84 d0 01 00 00    	je     7ed5 <elf_dynamic_do_rela+0x345>

    /* In the libc loader, they guaranteed that only R_ARCH_RELATIVE,
       R_ARCH_GLOB_DAT, R_ARCH_JUMP_SLOT appear in ld.so. We observed
       the same thing in libpal.so, so we are gonna to make the same
       assumption */
    switch (r_type)
    7d05:	49 83 fe 25          	cmp    $0x25,%r14
    7d09:	77 36                	ja     7d41 <elf_dynamic_do_rela+0x1b1>
    7d0b:	48 8d 35 8e 13 01 00 	lea    0x1138e(%rip),%rsi        # 190a0 <handle_sizes.1924+0x920>
    7d12:	4a 63 14 b6          	movslq (%rsi,%r14,4),%rdx
    7d16:	48 01 f2             	add    %rsi,%rdx
    7d19:	ff e2                	jmpq   *%rdx
    7d1b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
            *reloc_addr = value + reloc->r_addend;
            break;

        case R_X86_64_32:
            elf_machine_rela_debug (R_X86_64_32, SYM, value);
            value += reloc->r_addend;
    7d20:	49 03 44 24 10       	add    0x10(%r12),%rax
            *(Elf64_Addr *) reloc_addr = value;
    7d25:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
    7d29:	48 89 03             	mov    %rax,(%rbx)
#endif
        default:
            return;
    }

    if (!rel)
    7d2c:	80 7d af 00          	cmpb   $0x0,-0x51(%rbp)
    7d30:	75 0f                	jne    7d41 <elf_dynamic_do_rela+0x1b1>
        /* We have relocated the symbol, we don't want the
           interpreter to relocate it again. */
        reloc->r_info ^= ELF64_R_TYPE (reloc->r_info);
    7d32:	48 b8 00 00 00 00 ff 	mov    $0xffffffff00000000,%rax
    7d39:	ff ff ff 
    7d3c:	49 21 44 24 08       	and    %rax,0x8(%r12)
#endif
                for (; relative < r; ++relative) {
		    //printf("relocate: %08x\n", relative);
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
                }
        for (; r < end; ++r) {
    7d41:	49 83 c4 18          	add    $0x18,%r12
    7d45:	4c 39 65 a0          	cmp    %r12,-0x60(%rbp)
    7d49:	0f 87 e2 fe ff ff    	ja     7c31 <elf_dynamic_do_rela+0xa1>
                             &symtab[ELFW(R_SYM) (r->r_info)],
                             (void *) (l_addr + r->r_offset),
                             do_rel, do_rel_relative);
	}
    }
}
    7d4f:	48 83 c4 48          	add    $0x48,%rsp
    7d53:	5b                   	pop    %rbx
    7d54:	41 5c                	pop    %r12
    7d56:	41 5d                	pop    %r13
    7d58:	41 5e                	pop    %r14
    7d5a:	41 5f                	pop    %r15
    7d5c:	5d                   	pop    %rbp
    7d5d:	c3                   	retq   
    7d5e:	66 90                	xchg   %ax,%ax
            break;

#ifndef RTLD_BOOTSTRAP
        case R_X86_64_64:
            elf_machine_rela_debug (R_X86_64_64, SYM, value);
            *reloc_addr = value + reloc->r_addend;
    7d60:	49 03 44 24 10       	add    0x10(%r12),%rax
    7d65:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    7d69:	48 89 01             	mov    %rax,(%rcx)
    7d6c:	eb be                	jmp    7d2c <elf_dynamic_do_rela+0x19c>
    7d6e:	66 90                	xchg   %ax,%ax
                    ref_size));
            break;

        case R_X86_64_IRELATIVE:
            elf_machine_rela_debug (R_X86_64_IRELATIVE, SYM, value);
            value = sym_map + reloc->r_addend;
    7d70:	4d 03 6c 24 10       	add    0x10(%r12),%r13
            value = ((Elf64_Addr (*) (void)) value) ();
    7d75:	41 ff d5             	callq  *%r13
            *reloc_addr = value;
    7d78:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    7d7c:	48 89 01             	mov    %rax,(%rcx)
    7d7f:	eb ab                	jmp    7d2c <elf_dynamic_do_rela+0x19c>
            break;

        /* Not needed for dl-conflict.c.  */
        case R_X86_64_PC32:
            elf_machine_rela_debug (R_X86_64_PC32, SYM, value);
            value += reloc->r_addend - (Elf64_Addr) reloc_addr;
    7d81:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    7d85:	48 29 c8             	sub    %rcx,%rax
    7d88:	49 03 44 24 10       	add    0x10(%r12),%rax
    7d8d:	48 89 01             	mov    %rax,(%rcx)
    7d90:	eb 9a                	jmp    7d2c <elf_dynamic_do_rela+0x19c>
            *(Elf64_Addr *) reloc_addr = value;
            break;
	
        case R_X86_64_COPY:
            elf_machine_rela_debug (R_X86_64_COPY, SYM, value);
            size_t sym_size = sym ? sym->st_size : 0;
    7d92:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    7d96:	48 85 c9             	test   %rcx,%rcx
    7d99:	0f 84 61 01 00 00    	je     7f00 <elf_dynamic_do_rela+0x370>
    7d9f:	48 8b 51 10          	mov    0x10(%rcx),%rdx
            size_t ref_size = refsym ? refsym->st_size : 0;
    7da3:	48 85 db             	test   %rbx,%rbx
    7da6:	0f 84 9c 01 00 00    	je     7f48 <elf_dynamic_do_rela+0x3b8>
    7dac:	48 8b 4b 10          	mov    0x10(%rbx),%rcx
    7db0:	48 39 ca             	cmp    %rcx,%rdx
    7db3:	48 0f 47 d1          	cmova  %rcx,%rdx
            memcpy (reloc_addr_arg, (void *) value, MIN (sym_size,
    7db7:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    7dbb:	48 89 c6             	mov    %rax,%rsi
    7dbe:	e8 bd e4 00 00       	callq  16280 <memcpy>
    7dc3:	e9 64 ff ff ff       	jmpq   7d2c <elf_dynamic_do_rela+0x19c>
    7dc8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    7dcf:	00 
}

/* This macro is used as a callback from the ELF_DYNAMIC_RELOCATE code.  */
static ElfW(Addr) resolve_map (const char **strtab, ElfW(Sym) ** ref)
{
    if (ELFW(ST_BIND) ((*ref)->st_info) != STB_LOCAL) {
    7dd0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    7dd4:	0f b6 41 04          	movzbl 0x4(%rcx),%eax
    7dd8:	c0 e8 04             	shr    $0x4,%al
    7ddb:	84 c0                	test   %al,%al
    7ddd:	75 34                	jne    7e13 <elf_dynamic_do_rela+0x283>
           they should never exist */
        if (r_type == R_X86_64_IRELATIVE)
            return;
    } else {
        sym_map = RESOLVE_MAP(&strtab, &sym) ? : l_addr;
        value = sym_map + (sym ? sym->st_value : refsym->st_value);
    7ddf:	48 85 c9             	test   %rcx,%rcx
    7de2:	4c 8b 6d b0          	mov    -0x50(%rbp),%r13
    7de6:	74 53                	je     7e3b <elf_dynamic_do_rela+0x2ab>
    7de8:	48 8b 41 08          	mov    0x8(%rcx),%rax
    7dec:	4c 01 e8             	add    %r13,%rax
    7def:	e9 a5 fe ff ff       	jmpq   7c99 <elf_dynamic_do_rela+0x109>
           This declaration cannot be done when compiling rtld.c
           (i.e. #ifdef RTLD_BOOTSTRAP) because rtld.c contains the
           common defn for _dl_rtld_map, which is incompatible with a
           weak decl in the same file.  */

        if (rel_relative)
    7df4:	80 7d ae 00          	cmpb   $0x0,-0x52(%rbp)
    7df8:	0f 84 43 ff ff ff    	je     7d41 <elf_dynamic_do_rela+0x1b1>
        {
#ifndef RTLD_BOOTSTRAP
            elf_machine_rela_debug (R_X86_64_RELATIVE, sym, 0);
            *reloc_addr = l_addr + reloc->r_addend;
    7dfe:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    7e02:	49 03 44 24 10       	add    0x10(%r12),%rax
    7e07:	48 8b 5d b8          	mov    -0x48(%rbp),%rbx
    7e0b:	48 89 03             	mov    %rax,(%rbx)
    7e0e:	e9 2e ff ff ff       	jmpq   7d41 <elf_dynamic_do_rela+0x1b1>
        struct link_map * l = lookup_symbol((*strtab) + (*ref)->st_name, ref);
    7e13:	8b 39                	mov    (%rcx),%edi
    7e15:	48 8b 75 90          	mov    -0x70(%rbp),%rsi
    7e19:	4c 01 ef             	add    %r13,%rdi
    7e1c:	e8 3f fc ff ff       	callq  7a60 <lookup_symbol>
        if (l) {
    7e21:	48 85 c0             	test   %rax,%rax
    7e24:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    7e28:	74 b5                	je     7ddf <elf_dynamic_do_rela+0x24f>
            *strtab = (const void *) D_PTR (l->l_info[DT_STRTAB]);
            return l->l_addr;
    7e2a:	4c 8b 28             	mov    (%rax),%r13
    7e2d:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
        /* We can't handle a IRELEATIVE symbol if it's found in RTLD,
           they should never exist */
        if (r_type == R_X86_64_IRELATIVE)
            return;
    } else {
        sym_map = RESOLVE_MAP(&strtab, &sym) ? : l_addr;
    7e31:	4d 85 ed             	test   %r13,%r13
    7e34:	74 a9                	je     7ddf <elf_dynamic_do_rela+0x24f>
        value = sym_map + (sym ? sym->st_value : refsym->st_value);
    7e36:	48 85 c9             	test   %rcx,%rcx
    7e39:	75 ad                	jne    7de8 <elf_dynamic_do_rela+0x258>
    7e3b:	48 8b 43 08          	mov    0x8(%rbx),%rax
    7e3f:	eb ab                	jmp    7dec <elf_dynamic_do_rela+0x25c>

    /* In the libc loader, they guaranteed that only R_ARCH_RELATIVE,
       R_ARCH_GLOB_DAT, R_ARCH_JUMP_SLOT appear in ld.so. We observed
       the same thing in libpal.so, so we are gonna to make the same
       assumption */
    switch (r_type)
    7e41:	49 83 fe 25          	cmp    $0x25,%r14
    7e45:	0f 87 f6 fe ff ff    	ja     7d41 <elf_dynamic_do_rela+0x1b1>
    7e4b:	48 8d 0d e6 12 01 00 	lea    0x112e6(%rip),%rcx        # 19138 <handle_sizes.1924+0x9b8>
    7e52:	4a 63 14 b1          	movslq (%rcx,%r14,4),%rdx
    7e56:	48 01 ca             	add    %rcx,%rdx
    7e59:	ff e2                	jmpq   *%rdx
    7e5b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
               relocations or rela relocations if they are computed as
               memory_loc += l_addr...  */
            if (l_addr != 0)
# else
            /* ...or we know the object has been prelinked.  */
            if (l_addr != 0 || !l_info[VALIDX(DT_GNU_PRELINKED)])
    7e60:	4d 85 f6             	test   %r14,%r14
    7e63:	75 0e                	jne    7e73 <elf_dynamic_do_rela+0x2e3>
    7e65:	49 83 bd f8 01 00 00 	cmpq   $0x0,0x1f8(%r13)
    7e6c:	00 
    7e6d:	0f 85 a2 fd ff ff    	jne    7c15 <elf_dynamic_do_rela+0x85>
# endif
#endif
                for (; relative < r; ++relative) {
    7e73:	4c 39 fe             	cmp    %r15,%rsi
    7e76:	0f 83 99 fd ff ff    	jae    7c15 <elf_dynamic_do_rela+0x85>
    7e7c:	0f 1f 40 00          	nopl   0x0(%rax)
		    //printf("relocate: %08x\n", relative);
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
    7e80:	4d 89 f4             	mov    %r14,%r12
    7e83:	4c 03 23             	add    (%rbx),%r12
#endif
elf_machine_rela_relative (Elf64_Addr l_addr, const Elf64_Rela *reloc,
                           void *const reloc_addr_arg)
{
    Elf64_Addr *const reloc_addr = reloc_addr_arg;
    assert (ELF64_R_TYPE (reloc->r_info) == R_X86_64_RELATIVE);
    7e86:	83 7b 08 08          	cmpl   $0x8,0x8(%rbx)
    7e8a:	74 30                	je     7ebc <elf_dynamic_do_rela+0x32c>
    7e8c:	48 8d 3d a5 08 01 00 	lea    0x108a5(%rip),%rdi        # 18738 <write_config+0x188>
    7e93:	48 8d 15 ec 6b 01 00 	lea    0x16bec(%rip),%rdx        # 1ea86 <slab_levels+0x57e6>
    7e9a:	48 8d 35 bf 11 01 00 	lea    0x111bf(%rip),%rsi        # 19060 <handle_sizes.1924+0x8e0>
    7ea1:	b9 da 00 00 00       	mov    $0xda,%ecx
    7ea6:	31 c0                	xor    %eax,%eax
    7ea8:	e8 73 0f 00 00       	callq  8e20 <pal_printf>
    7ead:	e8 be eb ff ff       	callq  6a70 <__assert>
    7eb2:	bf 01 00 00 00       	mov    $0x1,%edi
    7eb7:	e8 c4 a6 00 00       	callq  12580 <_DkProcessExit>
    *reloc_addr = l_addr + reloc->r_addend;
    7ebc:	4c 89 f0             	mov    %r14,%rax
    7ebf:	48 03 43 10          	add    0x10(%rbx),%rax
# else
            /* ...or we know the object has been prelinked.  */
            if (l_addr != 0 || !l_info[VALIDX(DT_GNU_PRELINKED)])
# endif
#endif
                for (; relative < r; ++relative) {
    7ec3:	48 83 c3 18          	add    $0x18,%rbx
    7ec7:	49 39 df             	cmp    %rbx,%r15
    7eca:	49 89 04 24          	mov    %rax,(%r12)
    7ece:	77 b0                	ja     7e80 <elf_dynamic_do_rela+0x2f0>
    7ed0:	e9 40 fd ff ff       	jmpq   7c15 <elf_dynamic_do_rela+0x85>
#endif

    if (sym != NULL
        && __builtin_expect (ELFW(ST_TYPE) (sym->st_info)
                             == STT_GNU_IFUNC, 0)
        && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1))
    7ed5:	66 83 79 06 00       	cmpw   $0x0,0x6(%rcx)
    7eda:	0f 84 25 fe ff ff    	je     7d05 <elf_dynamic_do_rela+0x175>
        value = ((Elf64_Addr (*) (void)) value) ();
    7ee0:	ff d0                	callq  *%rax

    /* In the libc loader, they guaranteed that only R_ARCH_RELATIVE,
       R_ARCH_GLOB_DAT, R_ARCH_JUMP_SLOT appear in ld.so. We observed
       the same thing in libpal.so, so we are gonna to make the same
       assumption */
    switch (r_type)
    7ee2:	49 83 fe 25          	cmp    $0x25,%r14
    7ee6:	0f 87 55 fe ff ff    	ja     7d41 <elf_dynamic_do_rela+0x1b1>
    7eec:	48 8d 0d dd 12 01 00 	lea    0x112dd(%rip),%rcx        # 191d0 <handle_sizes.1924+0xa50>
    7ef3:	4a 63 14 b1          	movslq (%rcx,%r14,4),%rdx
    7ef7:	48 01 d1             	add    %rdx,%rcx
    7efa:	ff e1                	jmpq   *%rcx
    7efc:	0f 1f 40 00          	nopl   0x0(%rax)
            *(Elf64_Addr *) reloc_addr = value;
            break;
	
        case R_X86_64_COPY:
            elf_machine_rela_debug (R_X86_64_COPY, SYM, value);
            size_t sym_size = sym ? sym->st_size : 0;
    7f00:	31 d2                	xor    %edx,%edx
    7f02:	e9 9c fe ff ff       	jmpq   7da3 <elf_dynamic_do_rela+0x213>
    7f07:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    7f0e:	00 00 
            refsym->st_info = sym->st_info;
            refsym->st_size = sym->st_size;

            if (__builtin_expect (ELFW(ST_TYPE) (sym->st_info)
                                  == STT_GNU_IFUNC, 0)
                && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1))
    7f10:	66 83 79 06 00       	cmpw   $0x0,0x6(%rcx)
    7f15:	0f 84 c5 fd ff ff    	je     7ce0 <elf_dynamic_do_rela+0x150>
            {
                value = ((Elf64_Addr (*) (void)) value) ();
    7f1b:	ff d0                	callq  *%rax

                refsym->st_info ^= ELFW(ST_TYPE)(sym->st_info);
    7f1d:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
    7f21:	0f b6 71 04          	movzbl 0x4(%rcx),%esi
    7f25:	83 e6 0f             	and    $0xf,%esi
    7f28:	40 32 73 04          	xor    0x4(%rbx),%sil
                refsym->st_info |= STT_FUNC;
    7f2c:	83 ce 02             	or     $0x2,%esi
    7f2f:	40 88 73 04          	mov    %sil,0x4(%rbx)
    7f33:	e9 a8 fd ff ff       	jmpq   7ce0 <elf_dynamic_do_rela+0x150>
    7f38:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    7f3f:	00 
    7f40:	45 31 c0             	xor    %r8d,%r8d
    7f43:	e9 c0 fc ff ff       	jmpq   7c08 <elf_dynamic_do_rela+0x78>
            break;
	
        case R_X86_64_COPY:
            elf_machine_rela_debug (R_X86_64_COPY, SYM, value);
            size_t sym_size = sym ? sym->st_size : 0;
            size_t ref_size = refsym ? refsym->st_size : 0;
    7f48:	31 d2                	xor    %edx,%edx
    7f4a:	e9 68 fe ff ff       	jmpq   7db7 <elf_dynamic_do_rela+0x227>
    7f4f:	90                   	nop    

0000000000007f50 <_elf_dynamic_do_reloc.constprop.2>:
}
#else
/* Now this part is for our x86s machines */

static void __attribute__((unused))
_elf_dynamic_do_reloc(int dt_reloc, int dt_reloc_sz,
    7f50:	55                   	push   %rbp
    7f51:	48 89 e5             	mov    %rsp,%rbp
    7f54:	41 56                	push   %r14
    7f56:	41 55                	push   %r13
    7f58:	41 54                	push   %r12
    7f5a:	53                   	push   %rbx
    7f5b:	49 89 f6             	mov    %rsi,%r14
    7f5e:	48 89 fb             	mov    %rdi,%rbx
    7f61:	41 89 d4             	mov    %edx,%r12d
    7f64:	41 89 cd             	mov    %ecx,%r13d
    7f67:	48 83 ec 20          	sub    $0x20,%rsp
{
    struct { ElfW(Addr) start, size; } ranges[2];
    ranges[0].size = ranges[1].size = 0;
    ranges[0].start = ranges[1].start = 0;

    if (l_info[dt_reloc]) {
    7f6b:	48 8b 47 38          	mov    0x38(%rdi),%rax
                                        bool, bool),
                      ElfW(Dyn) **l_info, ElfW(Addr) l_addr,
                      bool rel, bool rel_relative)
{
    struct { ElfW(Addr) start, size; } ranges[2];
    ranges[0].size = ranges[1].size = 0;
    7f6f:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    7f76:	00 
    ranges[0].start = ranges[1].start = 0;
    7f77:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    7f7e:	00 

    if (l_info[dt_reloc]) {
    7f7f:	48 85 c0             	test   %rax,%rax
    7f82:	0f 84 98 00 00 00    	je     8020 <_elf_dynamic_do_reloc.constprop.2+0xd0>
        ranges[0].start = D_PTR (l_info[dt_reloc]);
    7f88:	48 8b 50 08          	mov    0x8(%rax),%rdx
        ranges[0].size = l_info[dt_reloc_sz]->d_un.d_val;
    7f8c:	48 8b 47 40          	mov    0x40(%rdi),%rax
    7f90:	48 8b 48 08          	mov    0x8(%rax),%rcx
    }

    if (l_info[DT_PLTREL]
    7f94:	48 8b 83 a0 00 00 00 	mov    0xa0(%rbx),%rax
    7f9b:	48 85 c0             	test   %rax,%rax
    7f9e:	74 07                	je     7fa7 <_elf_dynamic_do_reloc.constprop.2+0x57>
        && l_info[DT_PLTREL]->d_un.d_val == dt_reloc) {
    7fa0:	48 83 78 08 07       	cmpq   $0x7,0x8(%rax)
    7fa5:	74 3e                	je     7fe5 <_elf_dynamic_do_reloc.constprop.2+0x95>
    7fa7:	45 0f b6 ed          	movzbl %r13b,%r13d
    7fab:	45 0f b6 e4          	movzbl %r12b,%r12d
                     rel, rel_relative);
    } else {
        int ranges_index;
        for (ranges_index = 0; ranges_index < 2; ++ranges_index) {
           // printf("relocate: %08x-%08x\n", ranges[ranges_index].start, ranges[ranges_index].start + ranges[ranges_index].size);
   	    (*do_reloc) (l_info, l_addr,
    7faf:	4c 89 f6             	mov    %r14,%rsi
    7fb2:	45 89 e9             	mov    %r13d,%r9d
    7fb5:	45 89 e0             	mov    %r12d,%r8d
    7fb8:	48 89 df             	mov    %rbx,%rdi
    7fbb:	e8 d0 fb ff ff       	callq  7b90 <elf_dynamic_do_rela>
    7fc0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
    7fc4:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
                         ranges[ranges_index].start,
                         ranges[ranges_index].size,
                         rel, rel_relative);
	}
    }
}
    7fc8:	48 83 c4 20          	add    $0x20,%rsp
                     rel, rel_relative);
    } else {
        int ranges_index;
        for (ranges_index = 0; ranges_index < 2; ++ranges_index) {
           // printf("relocate: %08x-%08x\n", ranges[ranges_index].start, ranges[ranges_index].start + ranges[ranges_index].size);
   	    (*do_reloc) (l_info, l_addr,
    7fcc:	45 89 e9             	mov    %r13d,%r9d
    7fcf:	45 89 e0             	mov    %r12d,%r8d
    7fd2:	4c 89 f6             	mov    %r14,%rsi
    7fd5:	48 89 df             	mov    %rbx,%rdi
                         ranges[ranges_index].start,
                         ranges[ranges_index].size,
                         rel, rel_relative);
	}
    }
}
    7fd8:	5b                   	pop    %rbx
    7fd9:	41 5c                	pop    %r12
    7fdb:	41 5d                	pop    %r13
    7fdd:	41 5e                	pop    %r14
    7fdf:	5d                   	pop    %rbp
                     rel, rel_relative);
    } else {
        int ranges_index;
        for (ranges_index = 0; ranges_index < 2; ++ranges_index) {
           // printf("relocate: %08x-%08x\n", ranges[ranges_index].start, ranges[ranges_index].start + ranges[ranges_index].size);
   	    (*do_reloc) (l_info, l_addr,
    7fe0:	e9 ab fb ff ff       	jmpq   7b90 <elf_dynamic_do_rela>
        ranges[0].size = l_info[dt_reloc_sz]->d_un.d_val;
    }

    if (l_info[DT_PLTREL]
        && l_info[DT_PLTREL]->d_un.d_val == dt_reloc) {
        ElfW(Addr) start = D_PTR (l_info[DT_JMPREL]);
    7fe5:	48 8b 83 b8 00 00 00 	mov    0xb8(%rbx),%rax

        if (!ELF_DURING_STARTUP &&
        /* This test does not only detect whether the relocation
           sections are in the right order, it also checks whether
           there is a DT_REL/DT_RELA section.  */
            ranges[0].start + ranges[0].size != start) {
    7fec:	48 8d 34 11          	lea    (%rcx,%rdx,1),%rsi
        ranges[0].size = l_info[dt_reloc_sz]->d_un.d_val;
    }

    if (l_info[DT_PLTREL]
        && l_info[DT_PLTREL]->d_un.d_val == dt_reloc) {
        ElfW(Addr) start = D_PTR (l_info[DT_JMPREL]);
    7ff0:	48 8b 40 08          	mov    0x8(%rax),%rax

        if (!ELF_DURING_STARTUP &&
    7ff4:	48 39 f0             	cmp    %rsi,%rax
    7ff7:	74 17                	je     8010 <_elf_dynamic_do_reloc.constprop.2+0xc0>
        /* This test does not only detect whether the relocation
           sections are in the right order, it also checks whether
           there is a DT_REL/DT_RELA section.  */
            ranges[0].start + ranges[0].size != start) {
            ranges[1].start = start;
    7ff9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
            ranges[1].size = l_info[DT_PLTRELSZ]->d_un.d_val;
    7ffd:	48 8b 43 10          	mov    0x10(%rbx),%rax
    8001:	48 8b 40 08          	mov    0x8(%rax),%rax
    8005:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    8009:	eb 9c                	jmp    7fa7 <_elf_dynamic_do_reloc.constprop.2+0x57>
    800b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        } else {
            /* Combine processing the sections.  */
            assert (ranges[0].start + ranges[0].size == start);
            ranges[0].size += l_info[DT_PLTRELSZ]->d_un.d_val;
    8010:	48 8b 43 10          	mov    0x10(%rbx),%rax
    8014:	48 03 48 08          	add    0x8(%rax),%rcx
    8018:	eb 8d                	jmp    7fa7 <_elf_dynamic_do_reloc.constprop.2+0x57>
    801a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    struct { ElfW(Addr) start, size; } ranges[2];
    ranges[0].size = ranges[1].size = 0;
    ranges[0].start = ranges[1].start = 0;

    if (l_info[dt_reloc]) {
    8020:	31 c9                	xor    %ecx,%ecx
    8022:	31 d2                	xor    %edx,%edx
    8024:	e9 6b ff ff ff       	jmpq   7f94 <_elf_dynamic_do_reloc.constprop.2+0x44>
    8029:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000008030 <load_elf_object_by_handle>:
}

static int relocate_elf_object (struct link_map *l);

int load_elf_object_by_handle (PAL_HANDLE handle, enum object_type type)
{
    8030:	55                   	push   %rbp
       is borrow from open_verify() */
    ElfW(Ehdr) * ehdr = (ElfW(Ehdr) *) &fb;
    ElfW(Phdr) * phdr = NULL;
    int phdr_malloced = 0;

    int len = _DkStreamRead(handle, 0, FILEBUF_SIZE, &fb, NULL, 0);
    8031:	45 31 c9             	xor    %r9d,%r9d
    8034:	45 31 c0             	xor    %r8d,%r8d
    8037:	ba 40 03 00 00       	mov    $0x340,%edx
}

static int relocate_elf_object (struct link_map *l);

int load_elf_object_by_handle (PAL_HANDLE handle, enum object_type type)
{
    803c:	48 89 e5             	mov    %rsp,%rbp
    803f:	41 57                	push   %r15
    8041:	41 56                	push   %r14
    8043:	41 55                	push   %r13
    8045:	41 54                	push   %r12
    8047:	49 89 fd             	mov    %rdi,%r13
    804a:	53                   	push   %rbx
       is borrow from open_verify() */
    ElfW(Ehdr) * ehdr = (ElfW(Ehdr) *) &fb;
    ElfW(Phdr) * phdr = NULL;
    int phdr_malloced = 0;

    int len = _DkStreamRead(handle, 0, FILEBUF_SIZE, &fb, NULL, 0);
    804b:	48 8d 9d 90 fc ff ff 	lea    -0x370(%rbp),%rbx
}

static int relocate_elf_object (struct link_map *l);

int load_elf_object_by_handle (PAL_HANDLE handle, enum object_type type)
{
    8052:	48 81 ec 68 03 00 00 	sub    $0x368,%rsp
       is borrow from open_verify() */
    ElfW(Ehdr) * ehdr = (ElfW(Ehdr) *) &fb;
    ElfW(Phdr) * phdr = NULL;
    int phdr_malloced = 0;

    int len = _DkStreamRead(handle, 0, FILEBUF_SIZE, &fb, NULL, 0);
    8059:	48 89 d9             	mov    %rbx,%rcx
}

static int relocate_elf_object (struct link_map *l);

int load_elf_object_by_handle (PAL_HANDLE handle, enum object_type type)
{
    805c:	89 b5 88 fc ff ff    	mov    %esi,-0x378(%rbp)
       is borrow from open_verify() */
    ElfW(Ehdr) * ehdr = (ElfW(Ehdr) *) &fb;
    ElfW(Phdr) * phdr = NULL;
    int phdr_malloced = 0;

    int len = _DkStreamRead(handle, 0, FILEBUF_SIZE, &fb, NULL, 0);
    8062:	31 f6                	xor    %esi,%esi
    8064:	e8 27 bc ff ff       	callq  3c90 <_DkStreamRead>

    if (__builtin_expect (len < sizeof(ElfW(Ehdr)), 0)) {
    8069:	83 f8 3f             	cmp    $0x3f,%eax
       is borrow from open_verify() */
    ElfW(Ehdr) * ehdr = (ElfW(Ehdr) *) &fb;
    ElfW(Phdr) * phdr = NULL;
    int phdr_malloced = 0;

    int len = _DkStreamRead(handle, 0, FILEBUF_SIZE, &fb, NULL, 0);
    806c:	41 89 c7             	mov    %eax,%r15d

    if (__builtin_expect (len < sizeof(ElfW(Ehdr)), 0)) {
    806f:	0f 86 fc 03 00 00    	jbe    8471 <load_elf_object_by_handle+0x441>
			            memcmp(ehdr->e_ident, expected, EI_OSABI) != 0 || (
					            ehdr->e_ident[EI_OSABI] != ELFOSABI_SYSV &&
						            ehdr->e_ident[EI_OSABI] != ELFOSABI_FREEBSD), 0)); */
    /* See whether the ELF header is what we expect.  */
    if (__builtin_expect(
        memcmp(ehdr->e_ident, expected, EI_OSABI) != 0 || (
    8075:	48 8d 35 f4 11 01 00 	lea    0x111f4(%rip),%rsi        # 19270 <expected.3479>
    807c:	ba 07 00 00 00       	mov    $0x7,%edx
    8081:	48 89 df             	mov    %rbx,%rdi
    8084:	e8 87 e2 00 00       	callq  16310 <memcmp>
    /*printf(" Raj -- %x %x -%x %x\n\n",ehdr->e_ident[EI_OSABI],ELFOSABI_LINUX,ELFOSABI_FREEBSD,__builtin_expect(
			            memcmp(ehdr->e_ident, expected, EI_OSABI) != 0 || (
					            ehdr->e_ident[EI_OSABI] != ELFOSABI_SYSV &&
						            ehdr->e_ident[EI_OSABI] != ELFOSABI_FREEBSD), 0)); */
    /* See whether the ELF header is what we expect.  */
    if (__builtin_expect(
    8089:	85 c0                	test   %eax,%eax
        memcmp(ehdr->e_ident, expected, EI_OSABI) != 0 || (
    808b:	41 89 c4             	mov    %eax,%r12d
    /*printf(" Raj -- %x %x -%x %x\n\n",ehdr->e_ident[EI_OSABI],ELFOSABI_LINUX,ELFOSABI_FREEBSD,__builtin_expect(
			            memcmp(ehdr->e_ident, expected, EI_OSABI) != 0 || (
					            ehdr->e_ident[EI_OSABI] != ELFOSABI_SYSV &&
						            ehdr->e_ident[EI_OSABI] != ELFOSABI_FREEBSD), 0)); */
    /* See whether the ELF header is what we expect.  */
    if (__builtin_expect(
    808e:	0f 85 7c 03 00 00    	jne    8410 <load_elf_object_by_handle+0x3e0>
        memcmp(ehdr->e_ident, expected, EI_OSABI) != 0 || (
        ehdr->e_ident[EI_OSABI] != ELFOSABI_SYSV &&
    8094:	0f b6 85 97 fc ff ff 	movzbl -0x369(%rbp),%eax
    /*printf(" Raj -- %x %x -%x %x\n\n",ehdr->e_ident[EI_OSABI],ELFOSABI_LINUX,ELFOSABI_FREEBSD,__builtin_expect(
			            memcmp(ehdr->e_ident, expected, EI_OSABI) != 0 || (
					            ehdr->e_ident[EI_OSABI] != ELFOSABI_SYSV &&
						            ehdr->e_ident[EI_OSABI] != ELFOSABI_FREEBSD), 0)); */
    /* See whether the ELF header is what we expect.  */
    if (__builtin_expect(
    809b:	3c 03                	cmp    $0x3,%al
    809d:	74 08                	je     80a7 <load_elf_object_by_handle+0x77>
    809f:	84 c0                	test   %al,%al
    80a1:	0f 85 69 03 00 00    	jne    8410 <load_elf_object_by_handle+0x3e0>
    }

    /* Chia-Che 11/23/13: Removing other checks, comparing the header
       should be enough */

    maplength = ehdr->e_phnum * sizeof (ElfW(Phdr));
    80a7:	44 0f b7 b5 c8 fc ff 	movzwl -0x338(%rbp),%r14d
    80ae:	ff 
    /* if e_phoff + maplength is smaller than the data read */
    if (ehdr->e_phoff + maplength <= (size_t) len) {
    80af:	48 8b 95 b0 fc ff ff 	mov    -0x350(%rbp),%rdx
    80b6:	4d 63 d7             	movslq %r15d,%r10
    }

    /* Chia-Che 11/23/13: Removing other checks, comparing the header
       should be enough */

    maplength = ehdr->e_phnum * sizeof (ElfW(Phdr));
    80b9:	41 6b c6 38          	imul   $0x38,%r14d,%eax
    80bd:	49 89 c6             	mov    %rax,%r14
    /* if e_phoff + maplength is smaller than the data read */
    if (ehdr->e_phoff + maplength <= (size_t) len) {
    80c0:	48 01 d0             	add    %rdx,%rax
    80c3:	4c 39 d0             	cmp    %r10,%rax
    80c6:	0f 87 76 02 00 00    	ja     8342 <load_elf_object_by_handle+0x312>
        phdr = (void *) (&fb + ehdr->e_phoff);
    80cc:	48 8d 04 52          	lea    (%rdx,%rdx,2),%rax

    /* Now we will start verify the file as a ELF header. This part of code
       is borrow from open_verify() */
    ElfW(Ehdr) * ehdr = (ElfW(Ehdr) *) &fb;
    ElfW(Phdr) * phdr = NULL;
    int phdr_malloced = 0;
    80d0:	45 31 f6             	xor    %r14d,%r14d

int load_elf_object_by_handle (PAL_HANDLE handle, enum object_type type)
{
    char fb[FILEBUF_SIZE];
    char * errstring;
    int ret = 0;
    80d3:	45 31 ff             	xor    %r15d,%r15d
       should be enough */

    maplength = ehdr->e_phnum * sizeof (ElfW(Phdr));
    /* if e_phoff + maplength is smaller than the data read */
    if (ehdr->e_phoff + maplength <= (size_t) len) {
        phdr = (void *) (&fb + ehdr->e_phoff);
    80d6:	48 8d 04 82          	lea    (%rdx,%rax,4),%rax
    80da:	48 c1 e0 06          	shl    $0x6,%rax
    80de:	48 01 d8             	add    %rbx,%rax
    80e1:	48 89 85 78 fc ff ff 	mov    %rax,-0x388(%rbp)
            errstring = "cannot read file data";
            goto verify_failed;
        }
    }

    pal_sec_info._r_debug->r_state = RT_ADD;
    80e8:	48 8b 05 b9 b9 21 00 	mov    0x21b9b9(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
    80ef:	4c 89 95 80 fc ff ff 	mov    %r10,-0x380(%rbp)
    80f6:	48 8b 40 30          	mov    0x30(%rax),%rax
    80fa:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
    pal_sec_info._dl_debug_state();
    8101:	48 8b 05 a0 b9 21 00 	mov    0x21b9a0(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
    8108:	ff 50 28             	callq  *0x28(%rax)

    struct link_map * map;

    if (!(map = map_elf_object_by_handle(handle, type, &fb, len, true))) {
    810b:	4c 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%r10
    8112:	8b b5 88 fc ff ff    	mov    -0x378(%rbp),%esi
    8118:	48 89 da             	mov    %rbx,%rdx
    811b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
    8121:	4c 89 ef             	mov    %r13,%rdi
    8124:	4c 89 d1             	mov    %r10,%rcx
    8127:	e8 14 eb ff ff       	callq  6c40 <map_elf_object_by_handle>
    812c:	48 85 c0             	test   %rax,%rax
    812f:	48 89 c3             	mov    %rax,%rbx
    8132:	0f 84 5a 02 00 00    	je     8392 <load_elf_object_by_handle+0x362>
        struct textrels * next;
    } * textrels = NULL;
    int ret;
    const ElfW(Phdr) * ph;

    for (ph = l->l_phdr ; ph < &l->l_phdr[l->l_phnum] ; ph++)
    8138:	0f b7 90 b8 02 00 00 	movzwl 0x2b8(%rax),%edx
    813f:	48 8b b0 a8 02 00 00 	mov    0x2a8(%rax),%rsi
    8146:	45 31 ff             	xor    %r15d,%r15d
    8149:	49 89 f5             	mov    %rsi,%r13
    814c:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
    8153:	00 
    8154:	48 89 d0             	mov    %rdx,%rax
    8157:	48 c1 e0 06          	shl    $0x6,%rax
    815b:	48 29 c8             	sub    %rcx,%rax
    815e:	48 01 f0             	add    %rsi,%rax
    8161:	48 39 c6             	cmp    %rax,%rsi
    8164:	0f 83 06 01 00 00    	jae    8270 <load_elf_object_by_handle+0x240>
        if (ph->p_type == PT_LOAD && (ph->p_flags & PF_W) == 0) {
    816a:	49 be ff ff ff ff 02 	mov    $0x2ffffffff,%r14
    8171:	00 00 00 
    8174:	eb 2c                	jmp    81a2 <load_elf_object_by_handle+0x172>
    8176:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    817d:	00 00 00 
        struct textrels * next;
    } * textrels = NULL;
    int ret;
    const ElfW(Phdr) * ph;

    for (ph = l->l_phdr ; ph < &l->l_phdr[l->l_phnum] ; ph++)
    8180:	48 8d 0c d5 00 00 00 	lea    0x0(,%rdx,8),%rcx
    8187:	00 
    8188:	48 89 d0             	mov    %rdx,%rax
    818b:	49 83 c5 38          	add    $0x38,%r13
    818f:	48 c1 e0 06          	shl    $0x6,%rax
    8193:	48 29 c8             	sub    %rcx,%rax
    8196:	48 01 f0             	add    %rsi,%rax
    8199:	49 39 c5             	cmp    %rax,%r13
    819c:	0f 83 ce 00 00 00    	jae    8270 <load_elf_object_by_handle+0x240>
        if (ph->p_type == PT_LOAD && (ph->p_flags & PF_W) == 0) {
    81a2:	4c 89 f0             	mov    %r14,%rax
    81a5:	49 23 45 00          	and    0x0(%r13),%rax
    81a9:	48 83 f8 01          	cmp    $0x1,%rax
    81ad:	75 d1                	jne    8180 <load_elf_object_by_handle+0x150>
            struct textrels * r = malloc(sizeof(struct textrels));
    81af:	bf 20 00 00 00       	mov    $0x20,%edi
    81b4:	e8 47 08 00 00       	callq  8a00 <malloc>
    81b9:	49 89 c1             	mov    %rax,%r9
            r->start = ALLOC_ALIGNDOWN(ph->p_vaddr) + l->l_addr;
    81bc:	48 8b 05 cd b7 21 00 	mov    0x21b7cd(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
    81c3:	48 83 38 00          	cmpq   $0x0,(%rax)
    81c7:	0f 84 87 00 00 00    	je     8254 <load_elf_object_by_handle+0x224>
    81cd:	48 8b 05 24 b9 21 00 	mov    0x21b924(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
    81d4:	49 8b 75 10          	mov    0x10(%r13),%rsi
            r->len = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_memsz)
    81d8:	48 8b 0d 69 b9 21 00 	mov    0x21b969(%rip),%rcx        # 223b48 <_DYNAMIC+0x360>
    const ElfW(Phdr) * ph;

    for (ph = l->l_phdr ; ph < &l->l_phdr[l->l_phnum] ; ph++)
        if (ph->p_type == PT_LOAD && (ph->p_flags & PF_W) == 0) {
            struct textrels * r = malloc(sizeof(struct textrels));
            r->start = ALLOC_ALIGNDOWN(ph->p_vaddr) + l->l_addr;
    81df:	48 8b 00             	mov    (%rax),%rax
    81e2:	48 89 f2             	mov    %rsi,%rdx
    81e5:	48 21 c2             	and    %rax,%rdx
    81e8:	48 89 d7             	mov    %rdx,%rdi
    81eb:	48 03 3b             	add    (%rbx),%rdi
    81ee:	49 89 39             	mov    %rdi,(%r9)
            r->len = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_memsz)
    81f1:	49 03 75 28          	add    0x28(%r13),%rsi
    81f5:	48 03 31             	add    (%rcx),%rsi
    81f8:	48 21 c6             	and    %rax,%rsi
                     - ALLOC_ALIGNDOWN(ph->p_vaddr);
    81fb:	48 29 d6             	sub    %rdx,%rsi

            ret = _DkVirtualMemoryProtect((void *) r->start, r->len,
    81fe:	ba 03 00 00 00       	mov    $0x3,%edx

    for (ph = l->l_phdr ; ph < &l->l_phdr[l->l_phnum] ; ph++)
        if (ph->p_type == PT_LOAD && (ph->p_flags & PF_W) == 0) {
            struct textrels * r = malloc(sizeof(struct textrels));
            r->start = ALLOC_ALIGNDOWN(ph->p_vaddr) + l->l_addr;
            r->len = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_memsz)
    8203:	4c 89 8d 88 fc ff ff 	mov    %r9,-0x378(%rbp)
    820a:	49 89 71 08          	mov    %rsi,0x8(%r9)
                     - ALLOC_ALIGNDOWN(ph->p_vaddr);

            ret = _DkVirtualMemoryProtect((void *) r->start, r->len,
    820e:	e8 0d 82 00 00       	callq  10420 <_DkVirtualMemoryProtect>
                                          PAL_PROT_READ|PAL_PROT_WRITE);
            if (ret < 0)
    8213:	85 c0                	test   %eax,%eax
    8215:	4c 8b 8d 88 fc ff ff 	mov    -0x378(%rbp),%r9
    821c:	0f 88 aa 00 00 00    	js     82cc <load_elf_object_by_handle+0x29c>
                return ret;

#if (PF_R | PF_W | PF_X) == 7 && (PROT_READ | PROT_WRITE | PROT_EXEC) == 7
            r->prot = (PF_TO_PROT
                      >> ((ph->p_flags & (PF_R | PF_W | PF_X)) * 4)) & 0xf;
    8222:	41 8b 4d 04          	mov    0x4(%r13),%ecx
    8226:	b8 40 62 51 73       	mov    $0x73516240,%eax
            if (ph->p_flags & PF_W)
                r->prot |= PROT_WRITE;
            if (ph->p_flags & PF_X)
                r->prot |= PROT_EXEC;
#endif
            r->next = textrels;
    822b:	4d 89 79 18          	mov    %r15,0x18(%r9)
    822f:	48 8b b3 a8 02 00 00 	mov    0x2a8(%rbx),%rsi
    8236:	4d 89 cf             	mov    %r9,%r15
    8239:	0f b7 93 b8 02 00 00 	movzwl 0x2b8(%rbx),%edx
            if (ret < 0)
                return ret;

#if (PF_R | PF_W | PF_X) == 7 && (PROT_READ | PROT_WRITE | PROT_EXEC) == 7
            r->prot = (PF_TO_PROT
                      >> ((ph->p_flags & (PF_R | PF_W | PF_X)) * 4)) & 0xf;
    8240:	83 e1 07             	and    $0x7,%ecx
    8243:	c1 e1 02             	shl    $0x2,%ecx
    8246:	d3 f8                	sar    %cl,%eax
    8248:	83 e0 0f             	and    $0xf,%eax
    824b:	41 89 41 10          	mov    %eax,0x10(%r9)
    824f:	e9 2c ff ff ff       	jmpq   8180 <load_elf_object_by_handle+0x150>
    const ElfW(Phdr) * ph;

    for (ph = l->l_phdr ; ph < &l->l_phdr[l->l_phnum] ; ph++)
        if (ph->p_type == PT_LOAD && (ph->p_flags & PF_W) == 0) {
            struct textrels * r = malloc(sizeof(struct textrels));
            r->start = ALLOC_ALIGNDOWN(ph->p_vaddr) + l->l_addr;
    8254:	49 8b 55 10          	mov    0x10(%r13),%rdx
    8258:	48 89 d7             	mov    %rdx,%rdi
    825b:	48 03 3b             	add    (%rbx),%rdi
            r->len = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_memsz)
    825e:	48 89 d6             	mov    %rdx,%rsi
    const ElfW(Phdr) * ph;

    for (ph = l->l_phdr ; ph < &l->l_phdr[l->l_phnum] ; ph++)
        if (ph->p_type == PT_LOAD && (ph->p_flags & PF_W) == 0) {
            struct textrels * r = malloc(sizeof(struct textrels));
            r->start = ALLOC_ALIGNDOWN(ph->p_vaddr) + l->l_addr;
    8261:	49 89 39             	mov    %rdi,(%r9)
            r->len = ALLOC_ALIGNUP(ph->p_vaddr + ph->p_memsz)
    8264:	49 03 75 28          	add    0x28(%r13),%rsi
    8268:	eb 91                	jmp    81fb <load_elf_object_by_handle+0x1cb>
    826a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            r->next = textrels;
            textrels = r;
        }

    /* Do the actual relocation of the object's GOT and other data.  */
    if (l->l_type == OBJECT_EXEC)
    8270:	83 7b 28 01          	cmpl   $0x1,0x28(%rbx)
        ELF_DYNAMIC_SCAN(l->l_info, l->l_addr);
    8274:	48 8d 7b 48          	lea    0x48(%rbx),%rdi
            r->next = textrels;
            textrels = r;
        }

    /* Do the actual relocation of the object's GOT and other data.  */
    if (l->l_type == OBJECT_EXEC)
    8278:	0f 84 e2 01 00 00    	je     8460 <load_elf_object_by_handle+0x430>
        ELF_DYNAMIC_SCAN(l->l_info, l->l_addr);
    else
        ELF_DYNAMIC_RELOCATE(l->l_info, l->l_addr);
    827e:	48 8b 33             	mov    (%rbx),%rsi
    8281:	b9 01 00 00 00       	mov    $0x1,%ecx
    8286:	ba 01 00 00 00       	mov    $0x1,%edx
    828b:	e8 c0 fc ff ff       	callq  7f50 <_elf_dynamic_do_reloc.constprop.2>

    while (textrels) {
    8290:	4d 85 ff             	test   %r15,%r15
    8293:	75 23                	jne    82b8 <load_elf_object_by_handle+0x288>
    8295:	e9 86 01 00 00       	jmpq   8420 <load_elf_object_by_handle+0x3f0>
    829a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
       ret = _DkVirtualMemoryProtect((void *) textrels->start, textrels->len,
                                     textrels->prot);
        if (ret < 0)
            return ret;

        struct textrels * next = textrels->next;
    82a0:	4d 8b 6f 18          	mov    0x18(%r15),%r13
        free(textrels);
    82a4:	4c 89 ff             	mov    %r15,%rdi
    82a7:	e8 e4 09 00 00       	callq  8c90 <free>
    if (l->l_type == OBJECT_EXEC)
        ELF_DYNAMIC_SCAN(l->l_info, l->l_addr);
    else
        ELF_DYNAMIC_RELOCATE(l->l_info, l->l_addr);

    while (textrels) {
    82ac:	4d 85 ed             	test   %r13,%r13
    82af:	0f 84 6b 01 00 00    	je     8420 <load_elf_object_by_handle+0x3f0>
    82b5:	4d 89 ef             	mov    %r13,%r15
       ret = _DkVirtualMemoryProtect((void *) textrels->start, textrels->len,
    82b8:	41 8b 57 10          	mov    0x10(%r15),%edx
    82bc:	49 8b 77 08          	mov    0x8(%r15),%rsi
    82c0:	49 8b 3f             	mov    (%r15),%rdi
    82c3:	e8 58 81 00 00       	callq  10420 <_DkVirtualMemoryProtect>
                                     textrels->prot);
        if (ret < 0)
    82c8:	85 c0                	test   %eax,%eax
    82ca:	79 d4                	jns    82a0 <load_elf_object_by_handle+0x270>
    82cc:	8b 43 28             	mov    0x28(%rbx),%eax
        goto verify_failed;
    }

    relocate_elf_object(map);

    if (map->l_type == OBJECT_EXEC)
    82cf:	83 f8 01             	cmp    $0x1,%eax
    82d2:	0f 84 72 01 00 00    	je     844a <load_elf_object_by_handle+0x41a>
        exec_map = map;

    if (map->l_type == OBJECT_PRELOAD && map->l_entry)
    82d8:	83 f8 02             	cmp    $0x2,%eax
    82db:	0f 84 ff 00 00 00    	je     83e0 <load_elf_object_by_handle+0x3b0>
        run_preload = true;

    struct link_map * prev = NULL, ** pprev = &loaded_libraries,
                    * next = loaded_libraries;
    82e1:	48 8b 05 40 b8 21 00 	mov    0x21b840(%rip),%rax        # 223b28 <_DYNAMIC+0x340>
    82e8:	48 8b 10             	mov    (%rax),%rdx

    while (next) {
    82eb:	48 85 d2             	test   %rdx,%rdx
    82ee:	75 05                	jne    82f5 <load_elf_object_by_handle+0x2c5>
    82f0:	eb 10                	jmp    8302 <load_elf_object_by_handle+0x2d2>
    82f2:	48 89 c2             	mov    %rax,%rdx
        prev = next;
        pprev = &next->l_next;
        next = next->l_next;
    82f5:	48 8b 42 18          	mov    0x18(%rdx),%rax
        run_preload = true;

    struct link_map * prev = NULL, ** pprev = &loaded_libraries,
                    * next = loaded_libraries;

    while (next) {
    82f9:	48 85 c0             	test   %rax,%rax
    82fc:	75 f4                	jne    82f2 <load_elf_object_by_handle+0x2c2>
        prev = next;
        pprev = &next->l_next;
    82fe:	48 8d 42 18          	lea    0x18(%rdx),%rax
        next = next->l_next;
    }

    *pprev = map;
    8302:	48 89 18             	mov    %rbx,(%rax)
    map->l_prev = prev;
    map->l_next = NULL;

    pal_sec_info._r_debug->r_state = RT_CONSISTENT;
    8305:	48 8b 05 9c b7 21 00 	mov    0x21b79c(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
        pprev = &next->l_next;
        next = next->l_next;
    }

    *pprev = map;
    map->l_prev = prev;
    830c:	48 89 53 20          	mov    %rdx,0x20(%rbx)
    map->l_next = NULL;
    8310:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
    8317:	00 

    pal_sec_info._r_debug->r_state = RT_CONSISTENT;
    8318:	48 8b 40 30          	mov    0x30(%rax),%rax
    831c:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
    pal_sec_info._dl_debug_state();
    8323:	48 8b 05 7e b7 21 00 	mov    0x21b77e(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
    832a:	ff 50 28             	callq  *0x28(%rax)
    if (phdr && phdr_malloced)
        free(phdr);

    printf("%s\n", errstring);
    return ret;
}
    832d:	48 81 c4 68 03 00 00 	add    $0x368,%rsp
    8334:	44 89 e0             	mov    %r12d,%eax
    8337:	5b                   	pop    %rbx
    8338:	41 5c                	pop    %r12
    833a:	41 5d                	pop    %r13
    833c:	41 5e                	pop    %r14
    833e:	41 5f                	pop    %r15
    8340:	5d                   	pop    %rbp
    8341:	c3                   	retq   
    /* if e_phoff + maplength is smaller than the data read */
    if (ehdr->e_phoff + maplength <= (size_t) len) {
        phdr = (void *) (&fb + ehdr->e_phoff);
    } else {
        /* ...otherwise, we have to read again */
        phdr = malloc (maplength);
    8342:	44 89 f7             	mov    %r14d,%edi
    8345:	4c 89 95 80 fc ff ff 	mov    %r10,-0x380(%rbp)
    834c:	e8 af 06 00 00       	callq  8a00 <malloc>
        phdr_malloced = 1;

        ret = _DkStreamRead(handle, ehdr->e_phoff, maplength, phdr, NULL, 0);
    8351:	8b b5 b0 fc ff ff    	mov    -0x350(%rbp),%esi
    8357:	45 31 c9             	xor    %r9d,%r9d
    835a:	45 31 c0             	xor    %r8d,%r8d
    835d:	44 89 f2             	mov    %r14d,%edx
    8360:	48 89 c1             	mov    %rax,%rcx
    8363:	4c 89 ef             	mov    %r13,%rdi
    /* if e_phoff + maplength is smaller than the data read */
    if (ehdr->e_phoff + maplength <= (size_t) len) {
        phdr = (void *) (&fb + ehdr->e_phoff);
    } else {
        /* ...otherwise, we have to read again */
        phdr = malloc (maplength);
    8366:	48 89 85 78 fc ff ff 	mov    %rax,-0x388(%rbp)
        phdr_malloced = 1;

        ret = _DkStreamRead(handle, ehdr->e_phoff, maplength, phdr, NULL, 0);
    836d:	e8 1e b9 ff ff       	callq  3c90 <_DkStreamRead>

        if (ret < 0 || ret != maplength) {
    8372:	44 39 f0             	cmp    %r14d,%eax
    } else {
        /* ...otherwise, we have to read again */
        phdr = malloc (maplength);
        phdr_malloced = 1;

        ret = _DkStreamRead(handle, ehdr->e_phoff, maplength, phdr, NULL, 0);
    8375:	41 89 c7             	mov    %eax,%r15d

        if (ret < 0 || ret != maplength) {
    8378:	4c 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%r10
    837f:	0f 95 c2             	setne  %dl
    8382:	c1 e8 1f             	shr    $0x1f,%eax
    8385:	08 d0                	or     %dl,%al
    8387:	74 77                	je     8400 <load_elf_object_by_handle+0x3d0>
            errstring = "cannot read file data";
    8389:	48 8d 35 3e 0a 01 00 	lea    0x10a3e(%rip),%rsi        # 18dce <handle_sizes.1924+0x64e>
    8390:	eb 0d                	jmp    839f <load_elf_object_by_handle+0x36f>
    8392:	44 89 f0             	mov    %r14d,%eax
    pal_sec_info._dl_debug_state();

    struct link_map * map;

    if (!(map = map_elf_object_by_handle(handle, type, &fb, len, true))) {
        errstring = "unexpected failure";
    8395:	48 8d 35 6b 0a 01 00 	lea    0x10a6b(%rip),%rsi        # 18e07 <handle_sizes.1924+0x687>
    839c:	83 e0 01             	and    $0x1,%eax

    return 0;

verify_failed:

    if (phdr && phdr_malloced)
    839f:	48 8b 9d 78 fc ff ff 	mov    -0x388(%rbp),%rbx
    83a6:	48 85 db             	test   %rbx,%rbx
    83a9:	74 1a                	je     83c5 <load_elf_object_by_handle+0x395>
    83ab:	84 c0                	test   %al,%al
    83ad:	74 16                	je     83c5 <load_elf_object_by_handle+0x395>
        free(phdr);
    83af:	48 89 df             	mov    %rbx,%rdi
    83b2:	48 89 b5 88 fc ff ff 	mov    %rsi,-0x378(%rbp)
    83b9:	e8 d2 08 00 00       	callq  8c90 <free>
    83be:	48 8b b5 88 fc ff ff 	mov    -0x378(%rbp),%rsi

    printf("%s\n", errstring);
    83c5:	48 8d 3d 21 67 01 00 	lea    0x16721(%rip),%rdi        # 1eaed <slab_levels+0x584d>
    83cc:	31 c0                	xor    %eax,%eax
    return ret;
    83ce:	45 89 fc             	mov    %r15d,%r12d
verify_failed:

    if (phdr && phdr_malloced)
        free(phdr);

    printf("%s\n", errstring);
    83d1:	e8 4a 0a 00 00       	callq  8e20 <pal_printf>
    return ret;
    83d6:	e9 52 ff ff ff       	jmpq   832d <load_elf_object_by_handle+0x2fd>
    83db:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    relocate_elf_object(map);

    if (map->l_type == OBJECT_EXEC)
        exec_map = map;

    if (map->l_type == OBJECT_PRELOAD && map->l_entry)
    83e0:	48 83 bb b0 02 00 00 	cmpq   $0x0,0x2b0(%rbx)
    83e7:	00 
    83e8:	0f 84 f3 fe ff ff    	je     82e1 <load_elf_object_by_handle+0x2b1>
        run_preload = true;
    83ee:	48 8b 05 93 b7 21 00 	mov    0x21b793(%rip),%rax        # 223b88 <_DYNAMIC+0x3a0>
    83f5:	c6 00 01             	movb   $0x1,(%rax)
    83f8:	e9 e4 fe ff ff       	jmpq   82e1 <load_elf_object_by_handle+0x2b1>
    83fd:	0f 1f 00             	nopl   (%rax)
    if (ehdr->e_phoff + maplength <= (size_t) len) {
        phdr = (void *) (&fb + ehdr->e_phoff);
    } else {
        /* ...otherwise, we have to read again */
        phdr = malloc (maplength);
        phdr_malloced = 1;
    8400:	41 be 01 00 00 00    	mov    $0x1,%r14d
    8406:	e9 dd fc ff ff       	jmpq   80e8 <load_elf_object_by_handle+0xb8>
    840b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    if (__builtin_expect(
        memcmp(ehdr->e_ident, expected, EI_OSABI) != 0 || (
        ehdr->e_ident[EI_OSABI] != ELFOSABI_SYSV &&
        // ehdr->e_ident[EI_OSABI] != ELFOSABI_FREEBSD), 0)) {
        ehdr->e_ident[EI_OSABI] != ELFOSABI_LINUX), 0)) {
        errstring = "ELF file with invalid header";
    8410:	48 8d 35 03 0a 01 00 	lea    0x10a03(%rip),%rsi        # 18e1a <handle_sizes.1924+0x69a>
    pal_sec_info._dl_debug_state();

    struct link_map * map;

    if (!(map = map_elf_object_by_handle(handle, type, &fb, len, true))) {
        errstring = "unexpected failure";
    8417:	45 31 ff             	xor    %r15d,%r15d
    841a:	eb a9                	jmp    83c5 <load_elf_object_by_handle+0x395>
    841c:	0f 1f 40 00          	nopl   0x0(%rax)
        textrels = next;
    }

    /* In case we can protect the data now that the relocations are
       done, do it.  */
    if (l->l_type != OBJECT_EXEC && l->l_relro_size != 0)
    8420:	8b 43 28             	mov    0x28(%rbx),%eax
    8423:	83 f8 01             	cmp    $0x1,%eax
    8426:	74 15                	je     843d <load_elf_object_by_handle+0x40d>
    8428:	48 8b 93 f8 02 00 00 	mov    0x2f8(%rbx),%rdx
    842f:	48 85 d2             	test   %rdx,%rdx
    8432:	0f 85 b9 00 00 00    	jne    84f1 <load_elf_object_by_handle+0x4c1>
        if ((ret = protect_relro(l)) < 0)
            return ret;

    if (l->l_type == OBJECT_PRELOAD && pal_config.syscall_sym_name) {
    8438:	83 f8 02             	cmp    $0x2,%eax
    843b:	74 3d                	je     847a <load_elf_object_by_handle+0x44a>
        goto verify_failed;
    }

    relocate_elf_object(map);

    if (map->l_type == OBJECT_EXEC)
    843d:	83 f8 01             	cmp    $0x1,%eax
            pal_config.syscall_sym_addr =
                    (void *) (l->l_addr + sym->st_value);
        }
    }

    l->l_relocated = true;
    8440:	c6 43 40 01          	movb   $0x1,0x40(%rbx)
        goto verify_failed;
    }

    relocate_elf_object(map);

    if (map->l_type == OBJECT_EXEC)
    8444:	0f 85 8e fe ff ff    	jne    82d8 <load_elf_object_by_handle+0x2a8>
        exec_map = map;
    844a:	48 8b 05 17 b5 21 00 	mov    0x21b517(%rip),%rax        # 223968 <_DYNAMIC+0x180>
    8451:	48 89 18             	mov    %rbx,(%rax)
    8454:	e9 88 fe ff ff       	jmpq   82e1 <load_elf_object_by_handle+0x2b1>
    8459:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            textrels = r;
        }

    /* Do the actual relocation of the object's GOT and other data.  */
    if (l->l_type == OBJECT_EXEC)
        ELF_DYNAMIC_SCAN(l->l_info, l->l_addr);
    8460:	48 8b 33             	mov    (%rbx),%rsi
    8463:	31 c9                	xor    %ecx,%ecx
    8465:	31 d2                	xor    %edx,%edx
    8467:	e8 e4 fa ff ff       	callq  7f50 <_elf_dynamic_do_reloc.constprop.2>
    846c:	e9 1f fe ff ff       	jmpq   8290 <load_elf_object_by_handle+0x260>
    int phdr_malloced = 0;

    int len = _DkStreamRead(handle, 0, FILEBUF_SIZE, &fb, NULL, 0);

    if (__builtin_expect (len < sizeof(ElfW(Ehdr)), 0)) {
        errstring = "ELF file with a strange size";
    8471:	48 8d 35 bf 09 01 00 	lea    0x109bf(%rip),%rsi        # 18e37 <handle_sizes.1924+0x6b7>
    8478:	eb 9d                	jmp    8417 <load_elf_object_by_handle+0x3e7>
       done, do it.  */
    if (l->l_type != OBJECT_EXEC && l->l_relro_size != 0)
        if ((ret = protect_relro(l)) < 0)
            return ret;

    if (l->l_type == OBJECT_PRELOAD && pal_config.syscall_sym_name) {
    847a:	4c 8b 2d 9f b5 21 00 	mov    0x21b59f(%rip),%r13        # 223a20 <_DYNAMIC+0x238>
    8481:	49 8b bd 80 00 00 00 	mov    0x80(%r13),%rdi
    8488:	48 85 ff             	test   %rdi,%rdi
    848b:	74 b0                	je     843d <load_elf_object_by_handle+0x40d>
  for (unsigned char c = *s; c != '\0'; c = *++s)
    848d:	0f b6 07             	movzbl (%rdi),%eax
    8490:	84 c0                	test   %al,%al
    8492:	0f 84 c1 00 00 00    	je     8559 <load_elf_object_by_handle+0x529>
    8498:	48 89 fe             	mov    %rdi,%rsi
    849b:	41 bf 05 15 00 00    	mov    $0x1505,%r15d
    h = h * 33 + c;
    84a1:	44 89 f9             	mov    %r15d,%ecx
void free_elf_object (struct link_map * map);

static inline uint_fast32_t elf_fast_hash (const char *s)
{
  uint_fast32_t h = 5381;
  for (unsigned char c = *s; c != '\0'; c = *++s)
    84a4:	48 83 c6 01          	add    $0x1,%rsi
    h = h * 33 + c;
    84a8:	c1 e1 05             	shl    $0x5,%ecx
    84ab:	42 8d 14 39          	lea    (%rcx,%r15,1),%edx
    84af:	44 8d 3c 10          	lea    (%rax,%rdx,1),%r15d
void free_elf_object (struct link_map * map);

static inline uint_fast32_t elf_fast_hash (const char *s)
{
  uint_fast32_t h = 5381;
  for (unsigned char c = *s; c != '\0'; c = *++s)
    84b3:	0f b6 06             	movzbl (%rsi),%eax
    84b6:	84 c0                	test   %al,%al
    84b8:	75 e7                	jne    84a1 <load_elf_object_by_handle+0x471>
        uint_fast32_t fast_hash = elf_fast_hash(pal_config.syscall_sym_name);
        long int hash = elf_hash(pal_config.syscall_sym_name);
    84ba:	e8 81 f3 ff ff       	callq  7840 <elf_hash>
        ElfW(Sym) * sym = NULL;

        sym = do_lookup_map(NULL, pal_config.syscall_sym_name, fast_hash,
    84bf:	49 8b b5 80 00 00 00 	mov    0x80(%r13),%rsi
    84c6:	31 ff                	xor    %edi,%edi
    84c8:	49 89 d8             	mov    %rbx,%r8
    84cb:	48 89 c1             	mov    %rax,%rcx
    84ce:	44 89 fa             	mov    %r15d,%edx
    84d1:	e8 1a f4 ff ff       	callq  78f0 <do_lookup_map>
                            hash, l);

        if (sym) {
    84d6:	48 85 c0             	test   %rax,%rax
    84d9:	74 0e                	je     84e9 <load_elf_object_by_handle+0x4b9>
            pal_config.syscall_sym_addr =
                    (void *) (l->l_addr + sym->st_value);
    84db:	48 8b 13             	mov    (%rbx),%rdx
    84de:	48 03 50 08          	add    0x8(%rax),%rdx

        sym = do_lookup_map(NULL, pal_config.syscall_sym_name, fast_hash,
                            hash, l);

        if (sym) {
            pal_config.syscall_sym_addr =
    84e2:	49 89 95 88 00 00 00 	mov    %rdx,0x88(%r13)
    84e9:	8b 43 28             	mov    0x28(%rbx),%eax
    84ec:	e9 4c ff ff ff       	jmpq   843d <load_elf_object_by_handle+0x40d>
    return current_value.m;
}

static int protect_relro (struct link_map * l)
{
    ElfW(Addr) start = ALLOC_ALIGNDOWN(l->l_addr + l->l_relro_addr);
    84f1:	48 8b 0d 98 b4 21 00 	mov    0x21b498(%rip),%rcx        # 223990 <_DYNAMIC+0x1a8>
    84f8:	48 83 39 00          	cmpq   $0x0,(%rcx)
    84fc:	74 4c                	je     854a <load_elf_object_by_handle+0x51a>
    84fe:	48 8b 0d f3 b5 21 00 	mov    0x21b5f3(%rip),%rcx        # 223af8 <_DYNAMIC+0x310>
    8505:	48 8b 33             	mov    (%rbx),%rsi
    8508:	48 03 b3 f0 02 00 00 	add    0x2f0(%rbx),%rsi
    850f:	4c 8b 01             	mov    (%rcx),%r8
    8512:	48 8b 0d 2f b6 21 00 	mov    0x21b62f(%rip),%rcx        # 223b48 <_DYNAMIC+0x360>
    8519:	48 89 f7             	mov    %rsi,%rdi
    851c:	48 03 11             	add    (%rcx),%rdx
    851f:	4c 21 c7             	and    %r8,%rdi
    ElfW(Addr) end = ALLOC_ALIGNUP(l->l_addr + l->l_relro_addr +
    8522:	48 8d 14 32          	lea    (%rdx,%rsi,1),%rdx
    8526:	4c 21 c2             	and    %r8,%rdx
                                   l->l_relro_size);

    if (start != end)
    8529:	48 39 d7             	cmp    %rdx,%rdi
    852c:	0f 84 06 ff ff ff    	je     8438 <load_elf_object_by_handle+0x408>
        _DkVirtualMemoryProtect((void *) start, end - start, PAL_PROT_READ);
    8532:	48 89 d6             	mov    %rdx,%rsi
    8535:	ba 01 00 00 00       	mov    $0x1,%edx
    853a:	48 29 fe             	sub    %rdi,%rsi
    853d:	e8 de 7e 00 00       	callq  10420 <_DkVirtualMemoryProtect>
    8542:	8b 43 28             	mov    0x28(%rbx),%eax
    8545:	e9 ee fe ff ff       	jmpq   8438 <load_elf_object_by_handle+0x408>
    return current_value.m;
}

static int protect_relro (struct link_map * l)
{
    ElfW(Addr) start = ALLOC_ALIGNDOWN(l->l_addr + l->l_relro_addr);
    854a:	48 8b 3b             	mov    (%rbx),%rdi
    854d:	48 03 bb f0 02 00 00 	add    0x2f0(%rbx),%rdi
    ElfW(Addr) end = ALLOC_ALIGNUP(l->l_addr + l->l_relro_addr +
    8554:	48 01 fa             	add    %rdi,%rdx
    8557:	eb d0                	jmp    8529 <load_elf_object_by_handle+0x4f9>
new_elf_object (const char * realname, enum object_type type);
void free_elf_object (struct link_map * map);

static inline uint_fast32_t elf_fast_hash (const char *s)
{
  uint_fast32_t h = 5381;
    8559:	41 bf 05 15 00 00    	mov    $0x1505,%r15d
    855f:	e9 56 ff ff ff       	jmpq   84ba <load_elf_object_by_handle+0x48a>
    8564:	66 66 66 2e 0f 1f 84 	nopw   %cs:0x0(%rax,%rax,1)
    856b:	00 00 00 00 00 

0000000000008570 <load_elf_object>:
    free(map);
}

/* Map in the shared object file loaded from URI.  */
int load_elf_object (const char * uri, enum object_type type)
{
    8570:	55                   	push   %rbp
    8571:	48 89 f8             	mov    %rdi,%rax
    PAL_HANDLE handle;
    /* First we open the file by uri, as the regular file handles */
    int ret = _DkStreamOpen(&handle, uri, PAL_ACCESS_RDONLY,
    8574:	45 31 c9             	xor    %r9d,%r9d
    8577:	45 31 c0             	xor    %r8d,%r8d
    857a:	31 c9                	xor    %ecx,%ecx
    857c:	31 d2                	xor    %edx,%edx
    free(map);
}

/* Map in the shared object file loaded from URI.  */
int load_elf_object (const char * uri, enum object_type type)
{
    857e:	48 89 e5             	mov    %rsp,%rbp
    8581:	41 54                	push   %r12
    8583:	53                   	push   %rbx
    PAL_HANDLE handle;
    /* First we open the file by uri, as the regular file handles */
    int ret = _DkStreamOpen(&handle, uri, PAL_ACCESS_RDONLY,
    8584:	48 8d 7d e8          	lea    -0x18(%rbp),%rdi
    free(map);
}

/* Map in the shared object file loaded from URI.  */
int load_elf_object (const char * uri, enum object_type type)
{
    8588:	41 89 f4             	mov    %esi,%r12d
    PAL_HANDLE handle;
    /* First we open the file by uri, as the regular file handles */
    int ret = _DkStreamOpen(&handle, uri, PAL_ACCESS_RDONLY,
    858b:	48 89 c6             	mov    %rax,%rsi
    free(map);
}

/* Map in the shared object file loaded from URI.  */
int load_elf_object (const char * uri, enum object_type type)
{
    858e:	48 83 ec 10          	sub    $0x10,%rsp
    PAL_HANDLE handle;
    /* First we open the file by uri, as the regular file handles */
    int ret = _DkStreamOpen(&handle, uri, PAL_ACCESS_RDONLY,
    8592:	e8 99 b3 ff ff       	callq  3930 <_DkStreamOpen>
                            0, 0, 0);
    if (ret < 0)
    8597:	85 c0                	test   %eax,%eax
    8599:	78 1f                	js     85ba <load_elf_object+0x4a>
        return ret;

    if (type == OBJECT_EXEC) {
    859b:	41 83 fc 01          	cmp    $0x1,%r12d
    859f:	74 22                	je     85c3 <load_elf_object+0x53>
                free_elf_object(map);
            map = next;
        }
    }

    ret = load_elf_object_by_handle(handle, type);
    85a1:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
    85a5:	44 89 e6             	mov    %r12d,%esi
    85a8:	e8 83 fa ff ff       	callq  8030 <load_elf_object_by_handle>

    _DkObjectClose(handle);
    85ad:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
                free_elf_object(map);
            map = next;
        }
    }

    ret = load_elf_object_by_handle(handle, type);
    85b1:	89 c3                	mov    %eax,%ebx

    _DkObjectClose(handle);
    85b3:	e8 88 d2 ff ff       	callq  5840 <_DkObjectClose>
    return ret;
    85b8:	89 d8                	mov    %ebx,%eax
}
    85ba:	48 83 c4 10          	add    $0x10,%rsp
    85be:	5b                   	pop    %rbx
    85bf:	41 5c                	pop    %r12
    85c1:	5d                   	pop    %rbp
    85c2:	c3                   	retq   
                            0, 0, 0);
    if (ret < 0)
        return ret;

    if (type == OBJECT_EXEC) {
        struct link_map *map = loaded_libraries, *next;
    85c3:	48 8b 05 5e b5 21 00 	mov    0x21b55e(%rip),%rax        # 223b28 <_DYNAMIC+0x340>
    85ca:	48 8b 38             	mov    (%rax),%rdi
        while (map) {
    85cd:	48 85 ff             	test   %rdi,%rdi
    85d0:	75 0a                	jne    85dc <load_elf_object+0x6c>
    85d2:	eb cd                	jmp    85a1 <load_elf_object+0x31>
    85d4:	48 85 db             	test   %rbx,%rbx
    85d7:	48 89 df             	mov    %rbx,%rdi
    85da:	74 c5                	je     85a1 <load_elf_object+0x31>
            next = map->l_next;
            if (map->l_type == type)
    85dc:	83 7f 28 01          	cmpl   $0x1,0x28(%rdi)
        return ret;

    if (type == OBJECT_EXEC) {
        struct link_map *map = loaded_libraries, *next;
        while (map) {
            next = map->l_next;
    85e0:	48 8b 5f 18          	mov    0x18(%rdi),%rbx
            if (map->l_type == type)
    85e4:	75 ee                	jne    85d4 <load_elf_object+0x64>
                free_elf_object(map);
    85e6:	e8 b5 f1 ff ff       	callq  77a0 <free_elf_object>
    85eb:	eb e7                	jmp    85d4 <load_elf_object+0x64>
    85ed:	0f 1f 00             	nopl   (%rax)

00000000000085f0 <start_execution>:
    l->l_relocated = true;
    return 0;
}

void start_execution (int argc, const char ** argv)
{
    85f0:	55                   	push   %rbp
    85f1:	48 89 e5             	mov    %rsp,%rbp
    85f4:	41 57                	push   %r15
    85f6:	41 56                	push   %r14
    85f8:	41 55                	push   %r13
    85fa:	41 54                	push   %r12
    85fc:	41 89 ff             	mov    %edi,%r15d
    85ff:	53                   	push   %rbx
    8600:	49 89 f5             	mov    %rsi,%r13
    8603:	48 83 ec 18          	sub    $0x18,%rsp
    /* First we will try to run all the preloaded libraries which come with
       entry points */
    if (exec_map) {
    8607:	4c 8b 35 5a b3 21 00 	mov    0x21b35a(%rip),%r14        # 223968 <_DYNAMIC+0x180>
    860e:	49 8b 3e             	mov    (%r14),%rdi
    8611:	48 85 ff             	test   %rdi,%rdi
    8614:	0f 84 96 00 00 00    	je     86b0 <start_execution+0xc0>
        __pal_control.executable_begin = (void *) exec_map->l_map_start;
    861a:	4c 8b 0d 57 b5 21 00 	mov    0x21b557(%rip),%r9        # 223b78 <_DYNAMIC+0x390>
    8621:	48 8b 87 e0 02 00 00 	mov    0x2e0(%rdi),%rax
    8628:	49 89 41 10          	mov    %rax,0x10(%r9)
        __pal_control.executable_end = (void *) exec_map->l_map_end;
    862c:	48 8b 87 e8 02 00 00 	mov    0x2e8(%rdi),%rax
    8633:	49 89 41 18          	mov    %rax,0x18(%r9)
    }

    int ret = 0;

    if (!run_preload)
    8637:	48 8b 05 4a b5 21 00 	mov    0x21b54a(%rip),%rax        # 223b88 <_DYNAMIC+0x3a0>
    863e:	80 38 00             	cmpb   $0x0,(%rax)
    8641:	0f 85 89 00 00 00    	jne    86d0 <start_execution+0xe0>
    if (exec_map) {
        __pal_control.executable_begin = (void *) exec_map->l_map_start;
        __pal_control.executable_end = (void *) exec_map->l_map_end;
    }

    int ret = 0;
    8647:	31 c0                	xor    %eax,%eax
        if (ret < 0)
            _DkThreadExit(ret);
    }

NO_PRELOAD:
    if (exec_map && exec_map->l_entry) {
    8649:	48 8b 8f b0 02 00 00 	mov    0x2b0(%rdi),%rcx
    8650:	48 85 c9             	test   %rcx,%rcx
    8653:	74 13                	je     8668 <start_execution+0x78>
        /* This part is awesome. Don't risk changing it!! */
#if defined(__x86_64__)
        ret = ((int (*) (int, const char **, const char **))
    8655:	48 8b 05 c4 b3 21 00 	mov    0x21b3c4(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
    865c:	4c 89 ee             	mov    %r13,%rsi
    865f:	44 89 ff             	mov    %r15d,%edi
    8662:	48 8b 50 30          	mov    0x30(%rax),%rdx
    8666:	ff d1                	callq  *%rcx
# error "architecture not supported"
#endif
    }

    /* If they ever return here, we will be exiting */
    _DkProcessExit(ret);
    8668:	89 c7                	mov    %eax,%edi
    866a:	e8 11 9f 00 00       	callq  12580 <_DkProcessExit>

    /* Control should not get here */
    assert(0);
    866f:	48 8d 15 4e 07 01 00 	lea    0x1074e(%rip),%rdx        # 18dc4 <handle_sizes.1924+0x644>
    8676:	48 8d 35 d7 07 01 00 	lea    0x107d7(%rip),%rsi        # 18e54 <handle_sizes.1924+0x6d4>
    867d:	48 8d 3d b4 00 01 00 	lea    0x100b4(%rip),%rdi        # 18738 <write_config+0x188>
    8684:	b9 83 04 00 00       	mov    $0x483,%ecx
    8689:	31 c0                	xor    %eax,%eax
    868b:	e8 90 07 00 00       	callq  8e20 <pal_printf>
    8690:	e8 db e3 ff ff       	callq  6a70 <__assert>
    8695:	bf 01 00 00 00       	mov    $0x1,%edi
    869a:	e8 e1 9e 00 00       	callq  12580 <_DkProcessExit>
}
    869f:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    86a3:	5b                   	pop    %rbx
    86a4:	41 5c                	pop    %r12
    86a6:	41 5d                	pop    %r13
    86a8:	41 5e                	pop    %r14
    86aa:	41 5f                	pop    %r15
    86ac:	5d                   	pop    %rbp
    86ad:	c3                   	retq   
    86ae:	66 90                	xchg   %ax,%ax
        __pal_control.executable_end = (void *) exec_map->l_map_end;
    }

    int ret = 0;

    if (!run_preload)
    86b0:	48 8b 05 d1 b4 21 00 	mov    0x21b4d1(%rip),%rax        # 223b88 <_DYNAMIC+0x3a0>
    86b7:	80 38 00             	cmpb   $0x0,(%rax)
    86ba:	0f 84 f0 01 00 00    	je     88b0 <start_execution+0x2c0>
    86c0:	4c 8b 0d b1 b4 21 00 	mov    0x21b4b1(%rip),%r9        # 223b78 <_DYNAMIC+0x390>
    86c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    86ce:	00 00 

    /* Let's count the number of cookies, first we will have argc & argv */
    size_t ncookies = argc + 2; /* 1 for argc, argc + 1 for argv */

    /* Then we count envp */
    for (const char ** e = pal_config.environments; *e; e++)
    86d0:	48 8b 05 49 b3 21 00 	mov    0x21b349(%rip),%rax        # 223a20 <_DYNAMIC+0x238>

    if (!run_preload)
        goto NO_PRELOAD;

    /* Let's count the number of cookies, first we will have argc & argv */
    size_t ncookies = argc + 2; /* 1 for argc, argc + 1 for argv */
    86d7:	41 8d 57 02          	lea    0x2(%r15),%edx
    86db:	48 63 d2             	movslq %edx,%rdx

    /* Then we count envp */
    for (const char ** e = pal_config.environments; *e; e++)
    86de:	4c 8b 50 30          	mov    0x30(%rax),%r10
    86e2:	49 8b 0a             	mov    (%r10),%rcx
    86e5:	48 85 c9             	test   %rcx,%rcx
    86e8:	0f 84 c9 01 00 00    	je     88b7 <start_execution+0x2c7>
    86ee:	4c 89 d0             	mov    %r10,%rax
    86f1:	48 89 d6             	mov    %rdx,%rsi
    86f4:	48 83 c0 08          	add    $0x8,%rax
        ncookies++;
    86f8:	48 83 c6 01          	add    $0x1,%rsi

    /* Let's count the number of cookies, first we will have argc & argv */
    size_t ncookies = argc + 2; /* 1 for argc, argc + 1 for argv */

    /* Then we count envp */
    for (const char ** e = pal_config.environments; *e; e++)
    86fc:	48 83 38 00          	cmpq   $0x0,(%rax)
    8700:	75 f2                	jne    86f4 <start_execution+0x104>

    size_t cookiesz = sizeof(unsigned long int) * ncookies
                      + sizeof(ElfW(auxv_t)) * 6
                      + sizeof(void *) * 3 + 16;

    unsigned long int * cookies = __alloca(cookiesz);
    8702:	48 8d 04 f5 ae 00 00 	lea    0xae(,%rsi,8),%rax
    8709:	00 

    /* Let's copy the cookies */
    cookies[0] = (unsigned long int) argc;
    870a:	4d 63 c7             	movslq %r15d,%r8

    size_t cookiesz = sizeof(unsigned long int) * ncookies
                      + sizeof(ElfW(auxv_t)) * 6
                      + sizeof(void *) * 3 + 16;

    unsigned long int * cookies = __alloca(cookiesz);
    870d:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    8711:	48 29 c4             	sub    %rax,%rsp

    /* Let's copy the cookies */
    cookies[0] = (unsigned long int) argc;
    size_t i;

    for (i = 0 ; i <= argc ; i++)
    8714:	31 c0                	xor    %eax,%eax

    size_t cookiesz = sizeof(unsigned long int) * ncookies
                      + sizeof(ElfW(auxv_t)) * 6
                      + sizeof(void *) * 3 + 16;

    unsigned long int * cookies = __alloca(cookiesz);
    8716:	48 8d 5c 24 0f       	lea    0xf(%rsp),%rbx
    871b:	48 83 e3 f0          	and    $0xfffffffffffffff0,%rbx

    /* Let's copy the cookies */
    cookies[0] = (unsigned long int) argc;
    871f:	4c 89 03             	mov    %r8,(%rbx)
    size_t i;

    for (i = 0 ; i <= argc ; i++)
        cookies[i + 1] = (unsigned long int) argv[i];
    8722:	48 83 c0 01          	add    $0x1,%rax
    8726:	49 8b 74 c5 f8       	mov    -0x8(%r13,%rax,8),%rsi

    /* Let's copy the cookies */
    cookies[0] = (unsigned long int) argc;
    size_t i;

    for (i = 0 ; i <= argc ; i++)
    872b:	49 39 c0             	cmp    %rax,%r8
        cookies[i + 1] = (unsigned long int) argv[i];
    872e:	48 89 34 c3          	mov    %rsi,(%rbx,%rax,8)

    /* Let's copy the cookies */
    cookies[0] = (unsigned long int) argc;
    size_t i;

    for (i = 0 ; i <= argc ; i++)
    8732:	73 ee                	jae    8722 <start_execution+0x132>
        cookies[i + 1] = (unsigned long int) argv[i];

    size_t cnt = argc + 2;

    if (pal_config.environments)
        for (i = 0 ; pal_config.environments[i]; i++)
    8734:	48 85 c9             	test   %rcx,%rcx
    8737:	74 1c                	je     8755 <start_execution+0x165>
    8739:	48 89 d0             	mov    %rdx,%rax
    873c:	48 f7 d8             	neg    %rax
    873f:	49 8d 04 c2          	lea    (%r10,%rax,8),%rax
            cookies[cnt++] = (unsigned long int) pal_config.environments[i];
    8743:	48 83 c2 01          	add    $0x1,%rdx
    8747:	48 89 4c d3 f8       	mov    %rcx,-0x8(%rbx,%rdx,8)
        cookies[i + 1] = (unsigned long int) argv[i];

    size_t cnt = argc + 2;

    if (pal_config.environments)
        for (i = 0 ; pal_config.environments[i]; i++)
    874c:	48 8b 0c d0          	mov    (%rax,%rdx,8),%rcx
    8750:	48 85 c9             	test   %rcx,%rcx
    8753:	75 ee                	jne    8743 <start_execution+0x153>
            cookies[cnt++] = (unsigned long int) pal_config.environments[i];

    cookies[cnt++] = 0;

    ElfW(auxv_t) * auxv = (ElfW(auxv_t) *) &cookies[cnt];
    8755:	48 8d 44 d3 08       	lea    0x8(%rbx,%rdx,8),%rax

    auxv[0].a_type = AT_PHDR;
    auxv[0].a_un.a_val = exec_map ?
                         (__typeof(auxv[1].a_un.a_val)) exec_map->l_phdr : 0;
    875a:	48 85 ff             	test   %rdi,%rdi

    if (pal_config.environments)
        for (i = 0 ; pal_config.environments[i]; i++)
            cookies[cnt++] = (unsigned long int) pal_config.environments[i];

    cookies[cnt++] = 0;
    875d:	48 c7 04 d3 00 00 00 	movq   $0x0,(%rbx,%rdx,8)
    8764:	00 

    ElfW(auxv_t) * auxv = (ElfW(auxv_t) *) &cookies[cnt];

    auxv[0].a_type = AT_PHDR;
    8765:	48 c7 00 03 00 00 00 	movq   $0x3,(%rax)
    auxv[0].a_un.a_val = exec_map ?
                         (__typeof(auxv[1].a_un.a_val)) exec_map->l_phdr : 0;
    876c:	0f 84 ee 00 00 00    	je     8860 <start_execution+0x270>
    cookies[cnt++] = 0;

    ElfW(auxv_t) * auxv = (ElfW(auxv_t) *) &cookies[cnt];

    auxv[0].a_type = AT_PHDR;
    auxv[0].a_un.a_val = exec_map ?
    8772:	48 8b 97 a8 02 00 00 	mov    0x2a8(%rdi),%rdx
                         (__typeof(auxv[1].a_un.a_val)) exec_map->l_phdr : 0;

    auxv[1].a_type = AT_PHNUM;
    8779:	48 c7 40 10 05 00 00 	movq   $0x5,0x10(%rax)
    8780:	00 
    cookies[cnt++] = 0;

    ElfW(auxv_t) * auxv = (ElfW(auxv_t) *) &cookies[cnt];

    auxv[0].a_type = AT_PHDR;
    auxv[0].a_un.a_val = exec_map ?
    8781:	48 89 50 08          	mov    %rdx,0x8(%rax)
                         (__typeof(auxv[1].a_un.a_val)) exec_map->l_phdr : 0;

    auxv[1].a_type = AT_PHNUM;
    auxv[1].a_un.a_val = exec_map ? exec_map->l_phnum : 0;
    8785:	0f b7 97 b8 02 00 00 	movzwl 0x2b8(%rdi),%edx

    auxv[2].a_type = AT_PAGESZ;
    878c:	48 c7 40 20 06 00 00 	movq   $0x6,0x20(%rax)
    8793:	00 
    auxv[2].a_un.a_val = __pal_control.pagesize;

    auxv[3].a_type = AT_ENTRY;
    8794:	48 c7 40 30 09 00 00 	movq   $0x9,0x30(%rax)
    879b:	00 
    auxv[0].a_type = AT_PHDR;
    auxv[0].a_un.a_val = exec_map ?
                         (__typeof(auxv[1].a_un.a_val)) exec_map->l_phdr : 0;

    auxv[1].a_type = AT_PHNUM;
    auxv[1].a_un.a_val = exec_map ? exec_map->l_phnum : 0;
    879c:	48 89 50 18          	mov    %rdx,0x18(%rax)

    auxv[2].a_type = AT_PAGESZ;
    auxv[2].a_un.a_val = __pal_control.pagesize;
    87a0:	49 8b 51 30          	mov    0x30(%r9),%rdx
    87a4:	48 89 50 28          	mov    %rdx,0x28(%rax)

    auxv[3].a_type = AT_ENTRY;
    auxv[3].a_un.a_val = exec_map ? exec_map->l_entry : 0;
    87a8:	48 8b 97 b0 02 00 00 	mov    0x2b0(%rdi),%rdx

    auxv[4].a_type = AT_BASE;
    87af:	48 c7 40 40 07 00 00 	movq   $0x7,0x40(%rax)
    87b6:	00 

    auxv[2].a_type = AT_PAGESZ;
    auxv[2].a_un.a_val = __pal_control.pagesize;

    auxv[3].a_type = AT_ENTRY;
    auxv[3].a_un.a_val = exec_map ? exec_map->l_entry : 0;
    87b7:	48 89 50 38          	mov    %rdx,0x38(%rax)

    auxv[4].a_type = AT_BASE;
    auxv[4].a_un.a_val = exec_map ? exec_map->l_addr : 0;
    87bb:	48 8b 17             	mov    (%rdi),%rdx
    87be:	48 89 50 48          	mov    %rdx,0x48(%rax)

    auxv[5].a_type = AT_NULL;
    87c2:	48 c7 40 50 00 00 00 	movq   $0x0,0x50(%rax)
    87c9:	00 

    void * stack = (void *) &auxv[6] + sizeof(uint64_t);
    87ca:	48 8d 70 68          	lea    0x68(%rax),%rsi
    ((uint64_t *) stack)[-1] = 0;
    87ce:	48 c7 40 60 00 00 00 	movq   $0x0,0x60(%rax)
    87d5:	00 

    /* the previous cookiesz might be wrong, we have to recalculate it */
    cookiesz = (PAL_PTR) &auxv[6] - (PAL_PTR) cookies;

    for (struct link_map * l = loaded_libraries ; l ; l = l->l_next) {
    87d6:	48 8b 05 4b b3 21 00 	mov    0x21b34b(%rip),%rax        # 223b28 <_DYNAMIC+0x340>
    87dd:	4c 8b 20             	mov    (%rax),%r12
    87e0:	31 c0                	xor    %eax,%eax
    87e2:	4d 85 e4             	test   %r12,%r12
    87e5:	75 13                	jne    87fa <start_execution+0x20a>
    87e7:	eb 5c                	jmp    8845 <start_execution+0x255>
    87e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    87f0:	4d 8b 64 24 18       	mov    0x18(%r12),%r12
    87f5:	4d 85 e4             	test   %r12,%r12
    87f8:	74 4b                	je     8845 <start_execution+0x255>
        if (l->l_type != OBJECT_PRELOAD || !l->l_entry)
    87fa:	41 83 7c 24 28 02    	cmpl   $0x2,0x28(%r12)
    8800:	75 ee                	jne    87f0 <start_execution+0x200>
    8802:	49 8b bc 24 b0 02 00 	mov    0x2b0(%r12),%rdi
    8809:	00 
    880a:	48 85 ff             	test   %rdi,%rdi
    880d:	74 e1                	je     87f0 <start_execution+0x200>
            continue;

#if defined(__x86_64__)
        asm volatile (
    880f:	48 89 f8             	mov    %rdi,%rax
    8812:	48 89 66 10          	mov    %rsp,0x10(%rsi)
    8816:	48 89 dc             	mov    %rbx,%rsp
    8819:	48 8d 1d 09 00 00 00 	lea    0x9(%rip),%rbx        # 8829 <start_execution+0x239>
    8820:	48 89 5e 08          	mov    %rbx,0x8(%rsi)
    8824:	48 89 2e             	mov    %rbp,(%rsi)
    8827:	ff e0                	jmpq   *%rax
    8829:	5c                   	pop    %rsp
              : "rcx", "rdx", "r8", "r9", "r10", "r11", "memory");
#else
# error "architecture not supported"
#endif

        if (ret < 0)
    882a:	85 c0                	test   %eax,%eax
    882c:	79 c2                	jns    87f0 <start_execution+0x200>
            _DkThreadExit(ret);
    882e:	89 c7                	mov    %eax,%edi
    8830:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
    8834:	89 45 cc             	mov    %eax,-0x34(%rbp)
    8837:	e8 74 7e 00 00       	callq  106b0 <_DkThreadExit>
    883c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
    8840:	8b 45 cc             	mov    -0x34(%rbp),%eax
    8843:	eb ab                	jmp    87f0 <start_execution+0x200>
    8845:	49 8b 3e             	mov    (%r14),%rdi
    }

NO_PRELOAD:
    if (exec_map && exec_map->l_entry) {
    8848:	48 85 ff             	test   %rdi,%rdi
    884b:	0f 85 f8 fd ff ff    	jne    8649 <start_execution+0x59>
    8851:	e9 12 fe ff ff       	jmpq   8668 <start_execution+0x78>
    8856:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    885d:	00 00 00 

    auxv[1].a_type = AT_PHNUM;
    auxv[1].a_un.a_val = exec_map ? exec_map->l_phnum : 0;

    auxv[2].a_type = AT_PAGESZ;
    auxv[2].a_un.a_val = __pal_control.pagesize;
    8860:	49 8b 51 30          	mov    0x30(%r9),%rdx
    cookies[cnt++] = 0;

    ElfW(auxv_t) * auxv = (ElfW(auxv_t) *) &cookies[cnt];

    auxv[0].a_type = AT_PHDR;
    auxv[0].a_un.a_val = exec_map ?
    8864:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
    886b:	00 
                         (__typeof(auxv[1].a_un.a_val)) exec_map->l_phdr : 0;

    auxv[1].a_type = AT_PHNUM;
    886c:	48 c7 40 10 05 00 00 	movq   $0x5,0x10(%rax)
    8873:	00 
    auxv[1].a_un.a_val = exec_map ? exec_map->l_phnum : 0;
    8874:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
    887b:	00 

    auxv[2].a_type = AT_PAGESZ;
    887c:	48 c7 40 20 06 00 00 	movq   $0x6,0x20(%rax)
    8883:	00 
    auxv[2].a_un.a_val = __pal_control.pagesize;

    auxv[3].a_type = AT_ENTRY;
    8884:	48 c7 40 30 09 00 00 	movq   $0x9,0x30(%rax)
    888b:	00 

    auxv[1].a_type = AT_PHNUM;
    auxv[1].a_un.a_val = exec_map ? exec_map->l_phnum : 0;

    auxv[2].a_type = AT_PAGESZ;
    auxv[2].a_un.a_val = __pal_control.pagesize;
    888c:	48 89 50 28          	mov    %rdx,0x28(%rax)

    auxv[3].a_type = AT_ENTRY;
    auxv[3].a_un.a_val = exec_map ? exec_map->l_entry : 0;
    8890:	48 c7 40 38 00 00 00 	movq   $0x0,0x38(%rax)
    8897:	00 

    auxv[4].a_type = AT_BASE;
    auxv[4].a_un.a_val = exec_map ? exec_map->l_addr : 0;
    8898:	31 d2                	xor    %edx,%edx
    auxv[2].a_un.a_val = __pal_control.pagesize;

    auxv[3].a_type = AT_ENTRY;
    auxv[3].a_un.a_val = exec_map ? exec_map->l_entry : 0;

    auxv[4].a_type = AT_BASE;
    889a:	48 c7 40 40 07 00 00 	movq   $0x7,0x40(%rax)
    88a1:	00 
    88a2:	e9 17 ff ff ff       	jmpq   87be <start_execution+0x1ce>
    88a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    88ae:	00 00 
    if (exec_map) {
        __pal_control.executable_begin = (void *) exec_map->l_map_start;
        __pal_control.executable_end = (void *) exec_map->l_map_end;
    }

    int ret = 0;
    88b0:	31 c0                	xor    %eax,%eax
    88b2:	e9 b1 fd ff ff       	jmpq   8668 <start_execution+0x78>

    if (!run_preload)
        goto NO_PRELOAD;

    /* Let's count the number of cookies, first we will have argc & argv */
    size_t ncookies = argc + 2; /* 1 for argc, argc + 1 for argv */
    88b7:	48 89 d6             	mov    %rdx,%rsi
    88ba:	e9 43 fe ff ff       	jmpq   8702 <start_execution+0x112>
    88bf:	90                   	nop    

00000000000088c0 <init_slab_mgr>:
#include "slabmgr.h"

static SLAB_MGR slab_mgr = NULL;

void init_slab_mgr (void)
{
    88c0:	55                   	push   %rbp
    88c1:	48 89 e5             	mov    %rsp,%rbp
    88c4:	41 56                	push   %r14
    88c6:	41 55                	push   %r13
    88c8:	41 54                	push   %r12
    88ca:	53                   	push   %rbx
    88cb:	48 83 ec 10          	sub    $0x10,%rsp
    if (!slab_mgr) {
    88cf:	4c 8b 25 52 c1 21 00 	mov    0x21c152(%rip),%r12        # 224a28 <slab_mgr>
    88d6:	4d 85 e4             	test   %r12,%r12
    88d9:	74 15                	je     88f0 <init_slab_mgr+0x30>
        slab_mgr = create_slab_mgr();
    }
}
    88db:	48 83 c4 10          	add    $0x10,%rsp
    88df:	5b                   	pop    %rbx
    88e0:	41 5c                	pop    %r12
    88e2:	41 5d                	pop    %r13
    88e4:	41 5e                	pop    %r14
    88e6:	5d                   	pop    %rbp
    88e7:	c3                   	retq   
    88e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    88ef:	00 
        DkProcessExit(-1);
        return NULL;
    }
#else
    void * addr = NULL;
    _DkVirtualMemoryAlloc(&addr, size, 0, PAL_PROT_READ|PAL_PROT_WRITE);
    88f0:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
    88f4:	31 d2                	xor    %edx,%edx
    88f6:	b9 03 00 00 00       	mov    $0x3,%ecx
    88fb:	be 40 02 01 00       	mov    $0x10240,%esi
        printf("Pal out of internal memory!\n");
        DkProcessExit(-1);
        return NULL;
    }
#else
    void * addr = NULL;
    8900:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    8907:	00 
    _DkVirtualMemoryAlloc(&addr, size, 0, PAL_PROT_READ|PAL_PROT_WRITE);
    8908:	e8 83 78 00 00       	callq  10190 <_DkVirtualMemoryAlloc>
#endif /* STATIC_SLAB != 1 */

    return addr;
    890d:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
    SLAB_AREA area;
    SLAB_MGR mgr;

    mem = (unsigned long) system_malloc(__INIT_MAX_MEM_SIZE(size));

    if (mem <= 0)
    8911:	48 85 db             	test   %rbx,%rbx
    8914:	0f 84 cf 00 00 00    	je     89e9 <init_slab_mgr+0x129>
        return NULL;

    mgr = (SLAB_MGR) mem;

    void * addr = (void *) mgr + sizeof(SLAB_MGR_TYPE);
    891a:	4c 8d 93 20 01 00 00 	lea    0x120(%rbx),%r10
    8921:	48 8d 93 80 00 00 00 	lea    0x80(%rbx),%rdx
    8928:	4c 8d b3 00 01 00 00 	lea    0x100(%rbx),%r14
    892f:	4c 8d 2d 6a 09 01 00 	lea    0x1096a(%rip),%r13        # 192a0 <slab_levels>
    8936:	45 31 db             	xor    %r11d,%r11d
    8939:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    8940:	48 8d 42 80          	lea    -0x80(%rdx),%rax
    int i;
    for (i = 0 ; i < SLAB_LEVEL ; i++) {
        area = (SLAB_AREA) addr;
        area->size = STARTUP_SIZE;
    8944:	41 c7 42 10 10 00 00 	movl   $0x10,0x10(%r10)
    894b:	00 
 */
static inline void __list_add(struct list_head *new,
                              struct list_head *prev,
                              struct list_head *next)
{
        next->prev = new;
    894c:	4c 89 52 88          	mov    %r10,-0x78(%rdx)
        new->next = next;
    8950:	49 89 02             	mov    %rax,(%r10)
        new->prev = prev;
    8953:	49 89 42 08          	mov    %rax,0x8(%r10)
        prev->next = new;
    8957:	4c 89 52 80          	mov    %r10,-0x80(%rdx)
#define LIST_HEAD(name) \
        struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
        list->next = list;
    895b:	48 89 12             	mov    %rdx,(%rdx)
        list->prev = list;
    895e:	48 89 52 08          	mov    %rdx,0x8(%rdx)
        INIT_LIST_HEAD(&area->__list);
        INIT_LIST_HEAD(&mgr->area_list[i]);
        list_add_tail(&area->__list, &mgr->area_list[i]);

        INIT_LIST_HEAD(&mgr->free_list[i]);
        mgr->size[i] = 0;
    8962:	42 c7 84 1b 00 01 00 	movl   $0x0,0x100(%rbx,%r11,1)
    8969:	00 00 00 00 00 
#endif

static inline void __set_free_slab_area (SLAB_AREA area, SLAB_MGR mgr,
                                         unsigned int level)
{
    int i, size = area->size;
    896e:	45 8b 42 10          	mov    0x10(%r10),%r8d
    int slab_size = slab_levels[level] + SLAB_HDR_SIZE;
    8972:	43 8b 44 1d 00       	mov    0x0(%r13,%r11,1),%eax
    void * addr = (void *) area->raw;

    for (i = 0 ; i < size ; i++, addr += slab_size) {
    8977:	45 85 c0             	test   %r8d,%r8d

static inline void __set_free_slab_area (SLAB_AREA area, SLAB_MGR mgr,
                                         unsigned int level)
{
    int i, size = area->size;
    int slab_size = slab_levels[level] + SLAB_HDR_SIZE;
    897a:	8d 78 08             	lea    0x8(%rax),%edi
    void * addr = (void *) area->raw;

    for (i = 0 ; i < size ; i++, addr += slab_size) {
    897d:	7e 39                	jle    89b8 <init_slab_mgr+0xf8>
    897f:	49 8d 42 1c          	lea    0x1c(%r10),%rax
    8983:	45 89 e1             	mov    %r12d,%r9d
    8986:	48 63 ff             	movslq %edi,%rdi
    8989:	31 c9                	xor    %ecx,%ecx
    898b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
#define LIST_HEAD(name) \
        struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
        list->next = list;
    8990:	48 89 00             	mov    %rax,(%rax)
        list->prev = list;
    8993:	48 89 40 08          	mov    %rax,0x8(%rax)
    8997:	83 c1 01             	add    $0x1,%ecx
        SLAB_OBJ obj = (SLAB_OBJ) addr;
        OBJ_LEVEL(obj) = level;
    899a:	44 88 48 f8          	mov    %r9b,-0x8(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
        __list_add(new, head->prev, head);
    899e:	48 8b 72 08          	mov    0x8(%rdx),%rsi
 */
static inline void __list_add(struct list_head *new,
                              struct list_head *prev,
                              struct list_head *next)
{
        next->prev = new;
    89a2:	48 89 42 08          	mov    %rax,0x8(%rdx)
        new->next = next;
    89a6:	48 89 10             	mov    %rdx,(%rax)
        new->prev = prev;
    89a9:	48 89 70 08          	mov    %rsi,0x8(%rax)
        prev->next = new;
    89ad:	48 89 06             	mov    %rax,(%rsi)
    89b0:	48 01 f8             	add    %rdi,%rax
{
    int i, size = area->size;
    int slab_size = slab_levels[level] + SLAB_HDR_SIZE;
    void * addr = (void *) area->raw;

    for (i = 0 ; i < size ; i++, addr += slab_size) {
    89b3:	41 39 c8             	cmp    %ecx,%r8d
    89b6:	75 d8                	jne    8990 <init_slab_mgr+0xd0>

        INIT_LIST_HEAD(&mgr->free_list[i]);
        mgr->size[i] = 0;
        __set_free_slab_area(area, mgr, i);

        addr += __MAX_MEM_SIZE(slab_levels[i], STARTUP_SIZE);
    89b8:	4b 63 44 1d 00       	movslq 0x0(%r13,%r11,1),%rax
    89bd:	48 83 c2 10          	add    $0x10,%rdx
#endif
        INIT_LIST_HEAD(&obj->__list);
        list_add_tail(&obj->__list, &mgr->free_list[level]);
    }

    mgr->size[level] += size;
    89c1:	46 01 84 1b 00 01 00 	add    %r8d,0x100(%rbx,%r11,1)
    89c8:	00 

    mgr = (SLAB_MGR) mem;

    void * addr = (void *) mgr + sizeof(SLAB_MGR_TYPE);
    int i;
    for (i = 0 ; i < SLAB_LEVEL ; i++) {
    89c9:	41 83 c4 01          	add    $0x1,%r12d
    89cd:	49 83 c3 04          	add    $0x4,%r11

        INIT_LIST_HEAD(&mgr->free_list[i]);
        mgr->size[i] = 0;
        __set_free_slab_area(area, mgr, i);

        addr += __MAX_MEM_SIZE(slab_levels[i], STARTUP_SIZE);
    89d1:	48 c1 e0 04          	shl    $0x4,%rax

    mgr = (SLAB_MGR) mem;

    void * addr = (void *) mgr + sizeof(SLAB_MGR_TYPE);
    int i;
    for (i = 0 ; i < SLAB_LEVEL ; i++) {
    89d5:	4c 39 f2             	cmp    %r14,%rdx

        INIT_LIST_HEAD(&mgr->free_list[i]);
        mgr->size[i] = 0;
        __set_free_slab_area(area, mgr, i);

        addr += __MAX_MEM_SIZE(slab_levels[i], STARTUP_SIZE);
    89d8:	4d 8d 94 02 94 00 00 	lea    0x94(%r10,%rax,1),%r10
    89df:	00 

    mgr = (SLAB_MGR) mem;

    void * addr = (void *) mgr + sizeof(SLAB_MGR_TYPE);
    int i;
    for (i = 0 ; i < SLAB_LEVEL ; i++) {
    89e0:	0f 85 5a ff ff ff    	jne    8940 <init_slab_mgr+0x80>
    89e6:	49 89 dc             	mov    %rbx,%r12
static SLAB_MGR slab_mgr = NULL;

void init_slab_mgr (void)
{
    if (!slab_mgr) {
        slab_mgr = create_slab_mgr();
    89e9:	4c 89 25 38 c0 21 00 	mov    %r12,0x21c038(%rip)        # 224a28 <slab_mgr>
    }
}
    89f0:	48 83 c4 10          	add    $0x10,%rsp
    89f4:	5b                   	pop    %rbx
    89f5:	41 5c                	pop    %r12
    89f7:	41 5d                	pop    %r13
    89f9:	41 5e                	pop    %r14
    89fb:	5d                   	pop    %rbp
    89fc:	c3                   	retq   
    89fd:	0f 1f 00             	nopl   (%rax)

0000000000008a00 <malloc>:

void * malloc (int size)
{
    8a00:	55                   	push   %rbp
    8a01:	48 8d 15 98 08 01 00 	lea    0x10898(%rip),%rdx        # 192a0 <slab_levels>
    void * ptr = slab_alloc(slab_mgr, size);
    8a08:	31 c0                	xor    %eax,%eax
        slab_mgr = create_slab_mgr();
    }
}

void * malloc (int size)
{
    8a0a:	48 89 e5             	mov    %rsp,%rbp
    8a0d:	41 57                	push   %r15
    8a0f:	41 56                	push   %r14
    8a11:	41 55                	push   %r13
    8a13:	41 54                	push   %r12
    8a15:	53                   	push   %rbx
    8a16:	48 83 ec 28          	sub    $0x28,%rsp
    void * ptr = slab_alloc(slab_mgr, size);
    8a1a:	4c 8b 2d 07 c0 21 00 	mov    0x21c007(%rip),%r13        # 224a28 <slab_mgr>
    SLAB_OBJ mobj;
    int i;
    int level = -1;

    for (i = 0 ; i < SLAB_LEVEL ; i++)
        if (size < slab_levels[i]) {
    8a21:	3b 3c 82             	cmp    (%rdx,%rax,4),%edi
    8a24:	41 89 c4             	mov    %eax,%r12d
    8a27:	7c 57                	jl     8a80 <malloc+0x80>
    8a29:	48 83 c0 01          	add    $0x1,%rax
{
    SLAB_OBJ mobj;
    int i;
    int level = -1;

    for (i = 0 ; i < SLAB_LEVEL ; i++)
    8a2d:	48 83 f8 08          	cmp    $0x8,%rax
    8a31:	75 ee                	jne    8a21 <malloc+0x21>
            break;
        }

    if (level == -1) {
        LARGE_MEM_OBJ mem = (LARGE_MEM_OBJ)
                            system_malloc(sizeof(LARGE_MEM_OBJ_TYPE) + size);
    8a33:	48 63 df             	movslq %edi,%rbx
        DkProcessExit(-1);
        return NULL;
    }
#else
    void * addr = NULL;
    _DkVirtualMemoryAlloc(&addr, size, 0, PAL_PROT_READ|PAL_PROT_WRITE);
    8a36:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    8a3a:	31 d2                	xor    %edx,%edx
    8a3c:	48 8d 73 10          	lea    0x10(%rbx),%rsi
    8a40:	b9 03 00 00 00       	mov    $0x3,%ecx
        printf("Pal out of internal memory!\n");
        DkProcessExit(-1);
        return NULL;
    }
#else
    void * addr = NULL;
    8a45:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    8a4c:	00 
    _DkVirtualMemoryAlloc(&addr, size, 0, PAL_PROT_READ|PAL_PROT_WRITE);
    8a4d:	e8 3e 77 00 00       	callq  10190 <_DkVirtualMemoryAlloc>
#endif /* STATIC_SLAB != 1 */

    return addr;
    8a52:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
        if (!mem)
    8a56:	48 85 c0             	test   %rax,%rax
    8a59:	74 0f                	je     8a6a <malloc+0x6a>
            return NULL;

        mem->size = size;
    8a5b:	48 89 18             	mov    %rbx,(%rax)
        OBJ_LEVEL(mem) = (unsigned char) -1;
    8a5e:	c6 40 08 ff          	movb   $0xff,0x8(%rax)

        return OBJ_RAW(mem);
    8a62:	48 83 c0 10          	add    $0x10,%rax

    /* the slab manger will always remain at least one byte of padding,
       so we can feel free to assign an offset at the byte prior to
       the pointer */
    if (ptr)
        *(((unsigned char *) ptr) - 1) = 0;
    8a66:	c6 40 ff 00          	movb   $0x0,-0x1(%rax)

    return ptr;
}
    8a6a:	48 83 c4 28          	add    $0x28,%rsp
    8a6e:	5b                   	pop    %rbx
    8a6f:	41 5c                	pop    %r12
    8a71:	41 5d                	pop    %r13
    8a73:	41 5e                	pop    %r14
    8a75:	41 5f                	pop    %r15
    8a77:	5d                   	pop    %rbp
    8a78:	c3                   	retq   
    8a79:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    }

    system_lock();
    8a80:	48 8d 3d 81 b3 21 00 	lea    0x21b381(%rip),%rdi        # 223e08 <slab_mgr_lock>
    8a87:	4d 63 f4             	movslq %r12d,%r14
    8a8a:	e8 c1 81 00 00       	callq  10c50 <_DkMutexLock>
    8a8f:	4d 89 f0             	mov    %r14,%r8
    if (list_empty(&mgr->free_list[level])) {
    8a92:	49 8d 46 08          	lea    0x8(%r14),%rax
    8a96:	49 c1 e0 04          	shl    $0x4,%r8
    8a9a:	4f 8d 7c 05 00       	lea    0x0(%r13,%r8,1),%r15
    8a9f:	48 c1 e0 04          	shl    $0x4,%rax
    8aa3:	4c 01 e8             	add    %r13,%rax
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
        return head->next == head;
    8aa6:	49 8b 9f 80 00 00 00 	mov    0x80(%r15),%rbx
    8aad:	48 39 c3             	cmp    %rax,%rbx
    8ab0:	74 2e                	je     8ae0 <malloc+0xe0>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
        __list_del(entry->prev, entry->next);
    8ab2:	48 8b 13             	mov    (%rbx),%rdx
    8ab5:	48 8b 43 08          	mov    0x8(%rbx),%rax
        system_lock();
    }

    mobj = list_first_entry(&mgr->free_list[level], SLAB_OBJ_TYPE, __list);
    list_del(&mobj->__list);
    system_unlock();
    8ab9:	48 8d 3d 48 b3 21 00 	lea    0x21b348(%rip),%rdi        # 223e08 <slab_mgr_lock>
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
        next->prev = prev;
    8ac0:	48 89 42 08          	mov    %rax,0x8(%rdx)
        prev->next = next;
    8ac4:	48 89 10             	mov    %rdx,(%rax)
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
        __list_del(entry->prev, entry->next);
        entry->next = LIST_POISON1;
    8ac7:	48 c7 03 00 01 10 00 	movq   $0x100100,(%rbx)
        entry->prev = LIST_POISON2;
    8ace:	48 c7 43 08 00 02 20 	movq   $0x200200,0x8(%rbx)
    8ad5:	00 
    8ad6:	e8 e5 83 00 00       	callq  10ec0 <_DkMutexUnlock>
    unsigned long * m =
            (unsigned long *) ((void *) OBJ_RAW(mobj) + slab_levels[level]);
    *m = SLAB_CANARY_STRING;
#endif

    return OBJ_RAW(mobj);
    8adb:	48 89 d8             	mov    %rbx,%rax
    8ade:	eb 86                	jmp    8a66 <malloc+0x66>
        return OBJ_RAW(mem);
    }

    system_lock();
    if (list_empty(&mgr->free_list[level])) {
        system_unlock();
    8ae0:	48 8d 3d 21 b3 21 00 	lea    0x21b321(%rip),%rdi        # 223e08 <slab_mgr_lock>
    8ae7:	e8 d4 83 00 00       	callq  10ec0 <_DkMutexUnlock>
        system_lock();
        goto out;
    }

    size = mgr->size[level];
    area = (SLAB_AREA) system_malloc(__MAX_MEM_SIZE(slab_levels[level], size));
    8aec:	48 8d 05 ad 07 01 00 	lea    0x107ad(%rip),%rax        # 192a0 <slab_levels>
    8af3:	4f 8d 54 b5 00       	lea    0x0(%r13,%r14,4),%r10
    8af8:	45 89 e6             	mov    %r12d,%r14d
        DkProcessExit(-1);
        return NULL;
    }
#else
    void * addr = NULL;
    _DkVirtualMemoryAlloc(&addr, size, 0, PAL_PROT_READ|PAL_PROT_WRITE);
    8afb:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    8aff:	31 d2                	xor    %edx,%edx
    8b01:	b9 03 00 00 00       	mov    $0x3,%ecx
    8b06:	4a 63 04 b0          	movslq (%rax,%r14,4),%rax
    if (level >= SLAB_LEVEL) {
        system_lock();
        goto out;
    }

    size = mgr->size[level];
    8b0a:	49 63 b2 00 01 00 00 	movslq 0x100(%r10),%rsi
    8b11:	4c 89 55 b0          	mov    %r10,-0x50(%rbp)
        printf("Pal out of internal memory!\n");
        DkProcessExit(-1);
        return NULL;
    }
#else
    void * addr = NULL;
    8b15:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    8b1c:	00 
    area = (SLAB_AREA) system_malloc(__MAX_MEM_SIZE(slab_levels[level], size));
    8b1d:	89 45 bc             	mov    %eax,-0x44(%rbp)
    8b20:	48 83 c0 08          	add    $0x8,%rax
    8b24:	89 75 b8             	mov    %esi,-0x48(%rbp)
    8b27:	48 0f af f0          	imul   %rax,%rsi
    8b2b:	48 83 c6 14          	add    $0x14,%rsi
    _DkVirtualMemoryAlloc(&addr, size, 0, PAL_PROT_READ|PAL_PROT_WRITE);
    8b2f:	e8 5c 76 00 00       	callq  10190 <_DkVirtualMemoryAlloc>
#endif /* STATIC_SLAB != 1 */

    return addr;
    8b34:	48 8b 5d c8          	mov    -0x38(%rbp),%rbx
    if (area <= 0)
    8b38:	48 85 db             	test   %rbx,%rbx
    8b3b:	0f 84 a0 00 00 00    	je     8be1 <malloc+0x1e1>
        return NULL;

    system_lock();
    8b41:	48 8d 3d c0 b2 21 00 	lea    0x21b2c0(%rip),%rdi        # 223e08 <slab_mgr_lock>
    8b48:	e8 03 81 00 00       	callq  10c50 <_DkMutexLock>
#define LIST_HEAD(name) \
        struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
        list->next = list;
    8b4d:	48 89 1b             	mov    %rbx,(%rbx)
        list->prev = list;
    8b50:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
    area->size = size;
    INIT_LIST_HEAD(&area->__list);
    list_add(&area->__list, &mgr->area_list[level]);
    8b54:	4c 89 f1             	mov    %r14,%rcx
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
        __list_add(new, head, head->next);
    8b57:	49 8b 07             	mov    (%r15),%rax
    area = (SLAB_AREA) system_malloc(__MAX_MEM_SIZE(slab_levels[level], size));
    if (area <= 0)
        return NULL;

    system_lock();
    area->size = size;
    8b5a:	44 8b 4d b8          	mov    -0x48(%rbp),%r9d
    INIT_LIST_HEAD(&area->__list);
    list_add(&area->__list, &mgr->area_list[level]);
    8b5e:	48 c1 e1 04          	shl    $0x4,%rcx

static inline void __set_free_slab_area (SLAB_AREA area, SLAB_MGR mgr,
                                         unsigned int level)
{
    int i, size = area->size;
    int slab_size = slab_levels[level] + SLAB_HDR_SIZE;
    8b62:	8b 75 bc             	mov    -0x44(%rbp),%esi
    void * addr = (void *) area->raw;

    for (i = 0 ; i < size ; i++, addr += slab_size) {
    8b65:	4c 8b 55 b0          	mov    -0x50(%rbp),%r10
    area = (SLAB_AREA) system_malloc(__MAX_MEM_SIZE(slab_levels[level], size));
    if (area <= 0)
        return NULL;

    system_lock();
    area->size = size;
    8b69:	44 89 4b 10          	mov    %r9d,0x10(%rbx)
 */
static inline void __list_add(struct list_head *new,
                              struct list_head *prev,
                              struct list_head *next)
{
        next->prev = new;
    8b6d:	48 89 58 08          	mov    %rbx,0x8(%rax)
        new->next = next;
    8b71:	48 89 03             	mov    %rax,(%rbx)
    INIT_LIST_HEAD(&area->__list);
    list_add(&area->__list, &mgr->area_list[level]);
    8b74:	48 89 c8             	mov    %rcx,%rax

static inline void __set_free_slab_area (SLAB_AREA area, SLAB_MGR mgr,
                                         unsigned int level)
{
    int i, size = area->size;
    int slab_size = slab_levels[level] + SLAB_HDR_SIZE;
    8b77:	83 c6 08             	add    $0x8,%esi
        return NULL;

    system_lock();
    area->size = size;
    INIT_LIST_HEAD(&area->__list);
    list_add(&area->__list, &mgr->area_list[level]);
    8b7a:	4c 01 e8             	add    %r13,%rax
{
    int i, size = area->size;
    int slab_size = slab_levels[level] + SLAB_HDR_SIZE;
    void * addr = (void *) area->raw;

    for (i = 0 ; i < size ; i++, addr += slab_size) {
    8b7d:	45 85 c9             	test   %r9d,%r9d
        return NULL;

    system_lock();
    area->size = size;
    INIT_LIST_HEAD(&area->__list);
    list_add(&area->__list, &mgr->area_list[level]);
    8b80:	48 89 43 08          	mov    %rax,0x8(%rbx)
        new->prev = prev;
        prev->next = new;
    8b84:	49 89 1f             	mov    %rbx,(%r15)
{
    int i, size = area->size;
    int slab_size = slab_levels[level] + SLAB_HDR_SIZE;
    void * addr = (void *) area->raw;

    for (i = 0 ; i < size ; i++, addr += slab_size) {
    8b87:	7e 45                	jle    8bce <malloc+0x1ce>
    8b89:	49 83 c6 08          	add    $0x8,%r14
    8b8d:	48 8d 43 1c          	lea    0x1c(%rbx),%rax
    8b91:	48 63 f6             	movslq %esi,%rsi
    8b94:	49 c1 e6 04          	shl    $0x4,%r14
    8b98:	31 d2                	xor    %edx,%edx
    8b9a:	4d 01 f5             	add    %r14,%r13
    8b9d:	0f 1f 00             	nopl   (%rax)
#define LIST_HEAD(name) \
        struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
        list->next = list;
    8ba0:	48 89 00             	mov    %rax,(%rax)
        list->prev = list;
    8ba3:	48 89 40 08          	mov    %rax,0x8(%rax)
    8ba7:	83 c2 01             	add    $0x1,%edx
        SLAB_OBJ obj = (SLAB_OBJ) addr;
        OBJ_LEVEL(obj) = level;
    8baa:	44 88 60 f8          	mov    %r12b,-0x8(%rax)
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
        __list_add(new, head->prev, head);
    8bae:	49 8b 8f 88 00 00 00 	mov    0x88(%r15),%rcx
 */
static inline void __list_add(struct list_head *new,
                              struct list_head *prev,
                              struct list_head *next)
{
        next->prev = new;
    8bb5:	49 89 87 88 00 00 00 	mov    %rax,0x88(%r15)
        new->next = next;
    8bbc:	4c 89 28             	mov    %r13,(%rax)
        new->prev = prev;
    8bbf:	48 89 48 08          	mov    %rcx,0x8(%rax)
        prev->next = new;
    8bc3:	48 89 01             	mov    %rax,(%rcx)
    8bc6:	48 01 f0             	add    %rsi,%rax
{
    int i, size = area->size;
    int slab_size = slab_levels[level] + SLAB_HDR_SIZE;
    void * addr = (void *) area->raw;

    for (i = 0 ; i < size ; i++, addr += slab_size) {
    8bc9:	41 39 d1             	cmp    %edx,%r9d
    8bcc:	75 d2                	jne    8ba0 <malloc+0x1a0>
#endif
        INIT_LIST_HEAD(&obj->__list);
        list_add_tail(&obj->__list, &mgr->free_list[level]);
    }

    mgr->size[level] += size;
    8bce:	45 01 8a 00 01 00 00 	add    %r9d,0x100(%r10)
    system_lock();
    area->size = size;
    INIT_LIST_HEAD(&area->__list);
    list_add(&area->__list, &mgr->area_list[level]);
    __set_free_slab_area(area, mgr, level);
    system_unlock();
    8bd5:	48 8d 3d 2c b2 21 00 	lea    0x21b22c(%rip),%rdi        # 223e08 <slab_mgr_lock>
    8bdc:	e8 df 82 00 00       	callq  10ec0 <_DkMutexUnlock>

    system_lock();
    if (list_empty(&mgr->free_list[level])) {
        system_unlock();
        enlarge_slab_mgr(mgr, level);
        system_lock();
    8be1:	48 8d 3d 20 b2 21 00 	lea    0x21b220(%rip),%rdi        # 223e08 <slab_mgr_lock>
    8be8:	e8 63 80 00 00       	callq  10c50 <_DkMutexLock>
    8bed:	49 8b 9f 80 00 00 00 	mov    0x80(%r15),%rbx
    8bf4:	e9 b9 fe ff ff       	jmpq   8ab2 <malloc+0xb2>
    8bf9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000008c00 <remalloc>:

    return ptr;
}

void * remalloc (const void * mem, int size)
{
    8c00:	55                   	push   %rbp
    8c01:	48 89 e5             	mov    %rsp,%rbp
    8c04:	41 55                	push   %r13
    8c06:	41 54                	push   %r12
    8c08:	53                   	push   %rbx
    8c09:	49 89 fd             	mov    %rdi,%r13
    void * nmem = malloc(size);
    8c0c:	89 f7                	mov    %esi,%edi

    return ptr;
}

void * remalloc (const void * mem, int size)
{
    8c0e:	89 f3                	mov    %esi,%ebx
    8c10:	48 83 ec 08          	sub    $0x8,%rsp
    void * nmem = malloc(size);
    8c14:	e8 e7 fd ff ff       	callq  8a00 <malloc>

    if (nmem)
    8c19:	48 85 c0             	test   %rax,%rax
    return ptr;
}

void * remalloc (const void * mem, int size)
{
    void * nmem = malloc(size);
    8c1c:	49 89 c4             	mov    %rax,%r12

    if (nmem)
    8c1f:	74 0e                	je     8c2f <remalloc+0x2f>
        memcpy(nmem, mem, size);
    8c21:	48 63 d3             	movslq %ebx,%rdx
    8c24:	4c 89 ee             	mov    %r13,%rsi
    8c27:	48 89 c7             	mov    %rax,%rdi
    8c2a:	e8 51 d6 00 00       	callq  16280 <memcpy>

    return nmem;
}
    8c2f:	48 83 c4 08          	add    $0x8,%rsp
    8c33:	4c 89 e0             	mov    %r12,%rax
    8c36:	5b                   	pop    %rbx
    8c37:	41 5c                	pop    %r12
    8c39:	41 5d                	pop    %r13
    8c3b:	5d                   	pop    %rbp
    8c3c:	c3                   	retq   
    8c3d:	0f 1f 00             	nopl   (%rax)

0000000000008c40 <calloc>:

void * calloc (int nmem, int size)
{
    8c40:	55                   	push   %rbp
    void * ptr = malloc(nmem * size + size);
    8c41:	83 c7 01             	add    $0x1,%edi
    8c44:	0f af fe             	imul   %esi,%edi

    return nmem;
}

void * calloc (int nmem, int size)
{
    8c47:	48 89 e5             	mov    %rsp,%rbp
    8c4a:	53                   	push   %rbx
    8c4b:	89 f3                	mov    %esi,%ebx
    8c4d:	48 83 ec 08          	sub    $0x8,%rsp
    void * ptr = malloc(nmem * size + size);
    8c51:	e8 aa fd ff ff       	callq  8a00 <malloc>
    void * old_ptr = ptr;

    if (ptr) {
    8c56:	48 85 c0             	test   %rax,%rax
    return nmem;
}

void * calloc (int nmem, int size)
{
    void * ptr = malloc(nmem * size + size);
    8c59:	48 89 c1             	mov    %rax,%rcx
    void * old_ptr = ptr;

    if (ptr) {
    8c5c:	74 1c                	je     8c7a <calloc+0x3a>
        // align ptr to size
        ptr += size - 1 - ((uintptr_t) ptr + size - 1) % size;
    8c5e:	48 63 f3             	movslq %ebx,%rsi
    8c61:	31 d2                	xor    %edx,%edx
    8c63:	83 eb 01             	sub    $0x1,%ebx
    8c66:	48 8d 44 30 ff       	lea    -0x1(%rax,%rsi,1),%rax
    8c6b:	48 63 db             	movslq %ebx,%rbx
    8c6e:	48 f7 f6             	div    %rsi
    8c71:	48 29 d3             	sub    %rdx,%rbx
    8c74:	48 01 d9             	add    %rbx,%rcx
        *(((unsigned char *) ptr) - 1) = ptr - old_ptr;
    8c77:	88 59 ff             	mov    %bl,-0x1(%rcx)
    }

    return ptr;
}
    8c7a:	48 83 c4 08          	add    $0x8,%rsp
    8c7e:	48 89 c8             	mov    %rcx,%rax
    8c81:	5b                   	pop    %rbx
    8c82:	5d                   	pop    %rbp
    8c83:	c3                   	retq   
    8c84:	66 66 66 2e 0f 1f 84 	nopw   %cs:0x0(%rax,%rax,1)
    8c8b:	00 00 00 00 00 

0000000000008c90 <free>:

void free (void * ptr)
{
    8c90:	55                   	push   %rbp
    8c91:	48 89 e5             	mov    %rsp,%rbp
    8c94:	41 55                	push   %r13
    8c96:	41 54                	push   %r12
    8c98:	53                   	push   %rbx
    ptr -= *(((unsigned char *) ptr) - 1);
    8c99:	48 89 fb             	mov    %rdi,%rbx

    return ptr;
}

void free (void * ptr)
{
    8c9c:	48 83 ec 08          	sub    $0x8,%rsp
    ptr -= *(((unsigned char *) ptr) - 1);
    8ca0:	0f b6 47 ff          	movzbl -0x1(%rdi),%eax
    slab_free(slab_mgr, ptr);
    8ca4:	4c 8b 2d 7d bd 21 00 	mov    0x21bd7d(%rip),%r13        # 224a28 <slab_mgr>
    return ptr;
}

void free (void * ptr)
{
    ptr -= *(((unsigned char *) ptr) - 1);
    8cab:	48 29 c3             	sub    %rax,%rbx
}
#endif

static inline void slab_free (SLAB_MGR mgr, void * obj)
{
    unsigned char level = RAW_TO_LEVEL(obj);
    8cae:	44 0f b6 63 f8       	movzbl -0x8(%rbx),%r12d

    if (level == (unsigned char) -1) {
    8cb3:	41 80 fc ff          	cmp    $0xff,%r12b
    8cb7:	74 77                	je     8d30 <free+0xa0>
        LARGE_MEM_OBJ mem = RAW_TO_OBJ(obj, LARGE_MEM_OBJ_TYPE);
        system_free(mem, mem->size + sizeof(LARGE_MEM_OBJ_TYPE));
        return;
    }

    if (level >= SLAB_LEVEL)
    8cb9:	41 80 fc 07          	cmp    $0x7,%r12b
    8cbd:	76 11                	jbe    8cd0 <free+0x40>
    slab_free(slab_mgr, ptr);
}
    8cbf:	48 83 c4 08          	add    $0x8,%rsp
    8cc3:	5b                   	pop    %rbx
    8cc4:	41 5c                	pop    %r12
    8cc6:	41 5d                	pop    %r13
    8cc8:	5d                   	pop    %rbp
    8cc9:	c3                   	retq   
    8cca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    assert((*m) == SLAB_CANARY_STRING);
#endif

    SLAB_OBJ mobj = RAW_TO_OBJ(obj, SLAB_OBJ_TYPE);

    system_lock();
    8cd0:	48 8d 3d 31 b1 21 00 	lea    0x21b131(%rip),%rdi        # 223e08 <slab_mgr_lock>
    8cd7:	e8 74 7f 00 00       	callq  10c50 <_DkMutexLock>
    8cdc:	41 0f b6 c4          	movzbl %r12b,%eax
#define LIST_HEAD(name) \
        struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
        list->next = list;
    8ce0:	48 89 1b             	mov    %rbx,(%rbx)
        list->prev = list;
    8ce3:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
    8ce7:	48 c1 e0 04          	shl    $0x4,%rax
    INIT_LIST_HEAD(&mobj->__list);
    list_add_tail(&mobj->__list, &mgr->free_list[level]);
    8ceb:	49 83 c4 08          	add    $0x8,%r12
    system_unlock();
    8cef:	48 8d 3d 12 b1 21 00 	lea    0x21b112(%rip),%rdi        # 223e08 <slab_mgr_lock>
    8cf6:	4c 01 e8             	add    %r13,%rax

    SLAB_OBJ mobj = RAW_TO_OBJ(obj, SLAB_OBJ_TYPE);

    system_lock();
    INIT_LIST_HEAD(&mobj->__list);
    list_add_tail(&mobj->__list, &mgr->free_list[level]);
    8cf9:	49 c1 e4 04          	shl    $0x4,%r12
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
        __list_add(new, head->prev, head);
    8cfd:	48 8b 90 88 00 00 00 	mov    0x88(%rax),%rdx
    8d04:	4d 01 ec             	add    %r13,%r12
 */
static inline void __list_add(struct list_head *new,
                              struct list_head *prev,
                              struct list_head *next)
{
        next->prev = new;
    8d07:	48 89 98 88 00 00 00 	mov    %rbx,0x88(%rax)
    8d0e:	4c 89 23             	mov    %r12,(%rbx)
        new->next = next;
        new->prev = prev;
    8d11:	48 89 53 08          	mov    %rdx,0x8(%rbx)
        prev->next = new;
    8d15:	48 89 1a             	mov    %rbx,(%rdx)
    8d18:	48 83 c4 08          	add    $0x8,%rsp
    8d1c:	5b                   	pop    %rbx
    8d1d:	41 5c                	pop    %r12
    8d1f:	41 5d                	pop    %r13
    8d21:	5d                   	pop    %rbp
    system_unlock();
    8d22:	e9 99 81 00 00       	jmpq   10ec0 <_DkMutexUnlock>
    8d27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    8d2e:	00 00 
{
    unsigned char level = RAW_TO_LEVEL(obj);

    if (level == (unsigned char) -1) {
        LARGE_MEM_OBJ mem = RAW_TO_OBJ(obj, LARGE_MEM_OBJ_TYPE);
        system_free(mem, mem->size + sizeof(LARGE_MEM_OBJ_TYPE));
    8d30:	48 8b 43 f0          	mov    -0x10(%rbx),%rax
    8d34:	48 83 c4 08          	add    $0x8,%rsp
static inline void slab_free (SLAB_MGR mgr, void * obj)
{
    unsigned char level = RAW_TO_LEVEL(obj);

    if (level == (unsigned char) -1) {
        LARGE_MEM_OBJ mem = RAW_TO_OBJ(obj, LARGE_MEM_OBJ_TYPE);
    8d38:	48 8d 7b f0          	lea    -0x10(%rbx),%rdi
    8d3c:	5b                   	pop    %rbx
    8d3d:	41 5c                	pop    %r12
    8d3f:	41 5d                	pop    %r13
    8d41:	5d                   	pop    %rbp
        system_free(mem, mem->size + sizeof(LARGE_MEM_OBJ_TYPE));
    8d42:	48 8d 70 10          	lea    0x10(%rax),%rsi

#define system_malloc(size) __malloc(size)

static inline void __free (void * addr, size_t size)
{
    _DkVirtualMemoryFree(addr, size);
    8d46:	e9 c5 75 00 00       	jmpq   10310 <_DkVirtualMemoryFree>
    8d4b:	90                   	nop    
    8d4c:	90                   	nop    
    8d4d:	90                   	nop    
    8d4e:	90                   	nop    
    8d4f:	90                   	nop    

0000000000008d50 <sprintputch>:
}
extern_alias(printf);

static void
sprintputch(void * f, int ch, struct sprintbuf * b)
{
    8d50:	83 42 10 01          	addl   $0x1,0x10(%rdx)
    b->cnt++;
    if (b->buf < b->ebuf)
    8d54:	48 8b 02             	mov    (%rdx),%rax
    8d57:	48 3b 42 08          	cmp    0x8(%rdx),%rax
}
extern_alias(printf);

static void
sprintputch(void * f, int ch, struct sprintbuf * b)
{
    8d5b:	55                   	push   %rbp
    8d5c:	48 89 e5             	mov    %rsp,%rbp
    b->cnt++;
    if (b->buf < b->ebuf)
    8d5f:	73 0a                	jae    8d6b <sprintputch+0x1b>
        *b->buf++ = ch;
    8d61:	48 8d 48 01          	lea    0x1(%rax),%rcx
    8d65:	48 89 0a             	mov    %rcx,(%rdx)
    8d68:	40 88 30             	mov    %sil,(%rax)
}
    8d6b:	5d                   	pop    %rbp
    8d6c:	c3                   	retq   
    8d6d:	0f 1f 00             	nopl   (%rax)

0000000000008d70 <vprintf>:
    b->cnt++;
}

static int
vprintf(const char * fmt, va_list ap)
{
    8d70:	55                   	push   %rbp
    8d71:	48 89 f9             	mov    %rdi,%rcx
    struct printbuf b;

    b.idx = 0;
    b.cnt = 0;
    vfprintfmt((void *) &fputch, NULL, &b, fmt, ap);
    8d74:	48 8d 3d 55 00 00 00 	lea    0x55(%rip),%rdi        # 8dd0 <fputch>
    b->cnt++;
}

static int
vprintf(const char * fmt, va_list ap)
{
    8d7b:	49 89 f0             	mov    %rsi,%r8
    struct printbuf b;

    b.idx = 0;
    b.cnt = 0;
    vfprintfmt((void *) &fputch, NULL, &b, fmt, ap);
    8d7e:	31 f6                	xor    %esi,%esi
    b->cnt++;
}

static int
vprintf(const char * fmt, va_list ap)
{
    8d80:	48 89 e5             	mov    %rsp,%rbp
    8d83:	53                   	push   %rbx
    struct printbuf b;

    b.idx = 0;
    b.cnt = 0;
    vfprintfmt((void *) &fputch, NULL, &b, fmt, ap);
    8d84:	48 8d 9d e0 fe ff ff 	lea    -0x120(%rbp),%rbx
    b->cnt++;
}

static int
vprintf(const char * fmt, va_list ap)
{
    8d8b:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
    struct printbuf b;

    b.idx = 0;
    8d92:	c7 85 e0 fe ff ff 00 	movl   $0x0,-0x120(%rbp)
    8d99:	00 00 00 
    b.cnt = 0;
    8d9c:	c7 85 e4 fe ff ff 00 	movl   $0x0,-0x11c(%rbp)
    8da3:	00 00 00 
    vfprintfmt((void *) &fputch, NULL, &b, fmt, ap);
    8da6:	48 89 da             	mov    %rbx,%rdx
    8da9:	e8 72 dd 00 00       	callq  16b20 <vfprintfmt>
    _DkPrintConsole(b.buf, b.idx);
    8dae:	8b b5 e0 fe ff ff    	mov    -0x120(%rbp),%esi
    8db4:	48 8d 7b 08          	lea    0x8(%rbx),%rdi
    8db8:	e8 c3 69 00 00       	callq  f780 <_DkPrintConsole>

    return b.cnt;
}
    8dbd:	8b 85 e4 fe ff ff    	mov    -0x11c(%rbp),%eax
    8dc3:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
    8dca:	5b                   	pop    %rbx
    8dcb:	5d                   	pop    %rbp
    8dcc:	c3                   	retq   
    8dcd:	0f 1f 00             	nopl   (%rax)

0000000000008dd0 <fputch>:
    int cnt;
};

static void
fputch(void * f, int ch, struct printbuf * b)
{
    8dd0:	48 63 02             	movslq (%rdx),%rax
    8dd3:	8d 48 01             	lea    0x1(%rax),%ecx
    b->buf[b->idx++] = ch;
    if (b->idx == PRINTBUF_SIZE-1) {
    8dd6:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
};

static void
fputch(void * f, int ch, struct printbuf * b)
{
    b->buf[b->idx++] = ch;
    8ddc:	89 0a                	mov    %ecx,(%rdx)
    8dde:	40 88 74 02 08       	mov    %sil,0x8(%rdx,%rax,1)
    if (b->idx == PRINTBUF_SIZE-1) {
    8de3:	74 0b                	je     8df0 <fputch+0x20>
        _DkPrintConsole(b->buf, b->idx);
        b->idx = 0;
    }
    b->cnt++;
    8de5:	83 42 04 01          	addl   $0x1,0x4(%rdx)
    8de9:	c3                   	retq   
    8dea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    int cnt;
};

static void
fputch(void * f, int ch, struct printbuf * b)
{
    8df0:	55                   	push   %rbp
    b->buf[b->idx++] = ch;
    if (b->idx == PRINTBUF_SIZE-1) {
        _DkPrintConsole(b->buf, b->idx);
    8df1:	48 8d 7a 08          	lea    0x8(%rdx),%rdi
    8df5:	be ff 00 00 00       	mov    $0xff,%esi
    int cnt;
};

static void
fputch(void * f, int ch, struct printbuf * b)
{
    8dfa:	48 89 e5             	mov    %rsp,%rbp
    8dfd:	48 83 ec 10          	sub    $0x10,%rsp
    b->buf[b->idx++] = ch;
    if (b->idx == PRINTBUF_SIZE-1) {
        _DkPrintConsole(b->buf, b->idx);
    8e01:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
    8e05:	e8 76 69 00 00       	callq  f780 <_DkPrintConsole>
        b->idx = 0;
    8e0a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
    }
    b->cnt++;
    8e0e:	83 42 04 01          	addl   $0x1,0x4(%rdx)
fputch(void * f, int ch, struct printbuf * b)
{
    b->buf[b->idx++] = ch;
    if (b->idx == PRINTBUF_SIZE-1) {
        _DkPrintConsole(b->buf, b->idx);
        b->idx = 0;
    8e12:	c7 02 00 00 00 00    	movl   $0x0,(%rdx)
    }
    b->cnt++;
}
    8e18:	c9                   	leaveq 
    8e19:	c3                   	retq   
    8e1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000008e20 <pal_printf>:
    return b.cnt;
}

int
printf(const char * fmt, ...)
{
    8e20:	55                   	push   %rbp
    8e21:	48 89 e5             	mov    %rsp,%rbp
    8e24:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
    8e2b:	84 c0                	test   %al,%al
    8e2d:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
    8e34:	48 89 95 60 ff ff ff 	mov    %rdx,-0xa0(%rbp)
    8e3b:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
    8e42:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
    8e49:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
    8e50:	74 20                	je     8e72 <pal_printf+0x52>
    8e52:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
    8e56:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
    8e5a:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
    8e5e:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
    8e62:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
    8e66:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
    8e6a:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
    8e6e:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
    va_list ap;
    int cnt;

    va_start(ap, fmt);
    8e72:	48 8d 45 10          	lea    0x10(%rbp),%rax
    cnt = vprintf(fmt, ap);
    8e76:	48 8d b5 38 ff ff ff 	lea    -0xc8(%rbp),%rsi
printf(const char * fmt, ...)
{
    va_list ap;
    int cnt;

    va_start(ap, fmt);
    8e7d:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    8e84:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
    8e8b:	c7 85 38 ff ff ff 08 	movl   $0x8,-0xc8(%rbp)
    8e92:	00 00 00 
    8e95:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
    8e9c:	00 00 00 
    8e9f:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    cnt = vprintf(fmt, ap);
    8ea6:	e8 c5 fe ff ff       	callq  8d70 <vprintf>
    va_end(ap);

    return cnt;
}
    8eab:	c9                   	leaveq 
    8eac:	c3                   	retq   
    8ead:	0f 1f 00             	nopl   (%rax)

0000000000008eb0 <pal_snprintf>:
    return b.cnt;
}

int
snprintf(char * buf, size_t n, const char * fmt, ...)
{
    8eb0:	55                   	push   %rbp
    8eb1:	48 89 e5             	mov    %rsp,%rbp
    8eb4:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
    8ebb:	84 c0                	test   %al,%al
    8ebd:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
    8ec4:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
    8ecb:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
    8ed2:	74 20                	je     8ef4 <pal_snprintf+0x44>
    8ed4:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
    8ed8:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
    8edc:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
    8ee0:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
    8ee4:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
    8ee8:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
    8eec:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
    8ef0:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
    va_list ap;
    int rc;

    va_start(ap, fmt);
    8ef4:	48 8d 45 10          	lea    0x10(%rbp),%rax
static int
vsprintf(char * buf, int n, const char * fmt, va_list ap)
{
    struct sprintbuf b = {buf, buf + n - 1, 0};

    if (buf == NULL || n < 1) {
    8ef8:	85 f6                	test   %esi,%esi
    return b.cnt;
}

int
snprintf(char * buf, size_t n, const char * fmt, ...)
{
    8efa:	48 89 d1             	mov    %rdx,%rcx
    va_list ap;
    int rc;

    va_start(ap, fmt);
    8efd:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    8f04:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
    8f0b:	c7 85 38 ff ff ff 18 	movl   $0x18,-0xc8(%rbp)
    8f12:	00 00 00 
    8f15:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
    8f1c:	00 00 00 
}

static int
vsprintf(char * buf, int n, const char * fmt, va_list ap)
{
    struct sprintbuf b = {buf, buf + n - 1, 0};
    8f1f:	48 89 bd 20 ff ff ff 	mov    %rdi,-0xe0(%rbp)
snprintf(char * buf, size_t n, const char * fmt, ...)
{
    va_list ap;
    int rc;

    va_start(ap, fmt);
    8f26:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
}

static int
vsprintf(char * buf, int n, const char * fmt, va_list ap)
{
    struct sprintbuf b = {buf, buf + n - 1, 0};
    8f2d:	48 63 c6             	movslq %esi,%rax
    8f30:	c7 85 30 ff ff ff 00 	movl   $0x0,-0xd0(%rbp)
    8f37:	00 00 00 
    8f3a:	48 8d 44 07 ff       	lea    -0x1(%rdi,%rax,1),%rax
    8f3f:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)

    if (buf == NULL || n < 1) {
    8f46:	7e 38                	jle    8f80 <pal_snprintf+0xd0>
    8f48:	48 85 ff             	test   %rdi,%rdi
    8f4b:	74 33                	je     8f80 <pal_snprintf+0xd0>
        return -1;
    }

    // print the string to the buffer
    vfprintfmt((void *) sprintputch, (void *) 0, &b, fmt, ap);
    8f4d:	48 8d 95 20 ff ff ff 	lea    -0xe0(%rbp),%rdx
    8f54:	4c 8d 85 38 ff ff ff 	lea    -0xc8(%rbp),%r8
    8f5b:	48 8d 3d ee fd ff ff 	lea    -0x212(%rip),%rdi        # 8d50 <sprintputch>
    8f62:	31 f6                	xor    %esi,%esi
    8f64:	e8 b7 db 00 00       	callq  16b20 <vfprintfmt>

    // null terminate the buffer
    *b.buf = '\0';
    8f69:	48 8b 85 20 ff ff ff 	mov    -0xe0(%rbp),%rax
    8f70:	c6 00 00             	movb   $0x0,(%rax)

    return b.cnt;
    8f73:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
    va_start(ap, fmt);
    rc = vsprintf(buf, n, fmt, ap);
    va_end(ap);

    return rc;
}
    8f79:	c9                   	leaveq 
    8f7a:	c3                   	retq   
    8f7b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
vsprintf(char * buf, int n, const char * fmt, va_list ap)
{
    struct sprintbuf b = {buf, buf + n - 1, 0};

    if (buf == NULL || n < 1) {
        return -1;
    8f80:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    va_start(ap, fmt);
    rc = vsprintf(buf, n, fmt, ap);
    va_end(ap);

    return rc;
}
    8f85:	c9                   	leaveq 
    8f86:	c3                   	retq   
    8f87:	90                   	nop    
    8f88:	90                   	nop    
    8f89:	90                   	nop    
    8f8a:	90                   	nop    
    8f8b:	90                   	nop    
    8f8c:	90                   	nop    
    8f8d:	90                   	nop    
    8f8e:	90                   	nop    
    8f8f:	90                   	nop    

0000000000008f90 <file_write>:
}

/* 'write' operation for file streams. */
static int file_write (PAL_HANDLE handle, int offset, int count,
                       const void * buffer)
{
    8f90:	55                   	push   %rbp
    8f91:	49 89 fa             	mov    %rdi,%r10
    8f94:	48 89 e5             	mov    %rsp,%rbp
    8f97:	41 55                	push   %r13
    8f99:	4c 63 ee             	movslq %esi,%r13
    8f9c:	41 54                	push   %r12
    int fd = handle->file.fd;
    int ret;

    if (handle->file.offset != offset) {
    8f9e:	4d 39 6a 10          	cmp    %r13,0x10(%r10)
}

/* 'write' operation for file streams. */
static int file_write (PAL_HANDLE handle, int offset, int count,
                       const void * buffer)
{
    8fa2:	4d 89 e9             	mov    %r13,%r9
    8fa5:	53                   	push   %rbx
    int fd = handle->file.fd;
    8fa6:	4c 63 47 0c          	movslq 0xc(%rdi),%r8
}

/* 'write' operation for file streams. */
static int file_write (PAL_HANDLE handle, int offset, int count,
                       const void * buffer)
{
    8faa:	41 89 d4             	mov    %edx,%r12d
    8fad:	49 63 f8             	movslq %r8d,%rdi
    int fd = handle->file.fd;
    int ret;

    if (handle->file.offset != offset) {
    8fb0:	74 39                	je     8feb <file_write+0x5b>
        ret = INLINE_SYSCALL(lseek, 3, fd, offset, SEEK_SET);
    8fb2:	bb de 01 00 00       	mov    $0x1de,%ebx
    8fb7:	31 d2                	xor    %edx,%edx
    8fb9:	4c 89 ee             	mov    %r13,%rsi
    8fbc:	4c 89 c7             	mov    %r8,%rdi
    8fbf:	89 d8                	mov    %ebx,%eax
    8fc1:	cd 80                	int    $0x80
    8fc3:	48 89 c2             	mov    %rax,%rdx
    8fc6:	bb 00 00 00 00       	mov    $0x0,%ebx
    8fcb:	83 d3 00             	adc    $0x0,%ebx
    8fce:	31 f6                	xor    %esi,%esi
    8fd0:	85 db                	test   %ebx,%ebx
    8fd2:	40 0f 95 c6          	setne  %sil
    8fd6:	48 89 f0             	mov    %rsi,%rax
    8fd9:	48 f7 d8             	neg    %rax
    8fdc:	48 31 d0             	xor    %rdx,%rax
        if (IS_ERR(ret))
    8fdf:	01 f0                	add    %esi,%eax
    8fe1:	0f 88 19 01 00 00    	js     9100 <file_write+0x170>
            return -PAL_ERROR_DENIED;

        handle->file.offset = offset;
    8fe7:	4d 89 6a 10          	mov    %r13,0x10(%r10)
    }

    ret = INLINE_SYSCALL(write, 3, fd, buffer, count);
    8feb:	bb 04 00 00 00       	mov    $0x4,%ebx
    8ff0:	49 63 d4             	movslq %r12d,%rdx
    8ff3:	48 89 ce             	mov    %rcx,%rsi
    8ff6:	89 d8                	mov    %ebx,%eax
    8ff8:	cd 80                	int    $0x80
    8ffa:	48 89 c1             	mov    %rax,%rcx
    8ffd:	bb 00 00 00 00       	mov    $0x0,%ebx
    9002:	83 d3 00             	adc    $0x0,%ebx
    9005:	31 d2                	xor    %edx,%edx
    9007:	85 db                	test   %ebx,%ebx
    9009:	0f 95 c2             	setne  %dl
    900c:	48 89 d0             	mov    %rdx,%rax
    900f:	48 f7 d8             	neg    %rax
    9012:	48 31 c8             	xor    %rcx,%rax
    9015:	48 01 d0             	add    %rdx,%rax

    if (IS_ERR(ret))
    9018:	85 c0                	test   %eax,%eax
    901a:	78 14                	js     9030 <file_write+0xa0>
        return unix_to_pal_error(ERRNO(ret));

    handle->file.offset = offset + ret;
    901c:	41 01 c1             	add    %eax,%r9d
    901f:	4d 63 c9             	movslq %r9d,%r9
    9022:	4d 89 4a 10          	mov    %r9,0x10(%r10)
    return ret;
}
    9026:	5b                   	pop    %rbx
    9027:	41 5c                	pop    %r12
    9029:	41 5d                	pop    %r13
    902b:	5d                   	pop    %rbp
    902c:	c3                   	retq   
    902d:	0f 1f 00             	nopl   (%rax)
    }

    ret = INLINE_SYSCALL(write, 3, fd, buffer, count);

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));
    9030:	f7 d8                	neg    %eax
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    9032:	83 f8 6e             	cmp    $0x6e,%eax
    9035:	0f 87 c5 00 00 00    	ja     9100 <file_write+0x170>
    903b:	48 8d 15 7e 02 01 00 	lea    0x1027e(%rip),%rdx        # 192c0 <slab_levels+0x20>
    9042:	89 c0                	mov    %eax,%eax
    9044:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    9048:	48 01 c2             	add    %rax,%rdx
    904b:	ff e2                	jmpq   *%rdx
    904d:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    9050:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    9055:	eb cf                	jmp    9026 <file_write+0x96>
    9057:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    905e:	00 00 
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    9060:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    9065:	eb bf                	jmp    9026 <file_write+0x96>
    9067:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    906e:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    9070:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9075:	eb af                	jmp    9026 <file_write+0x96>
    9077:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    907e:	00 00 
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    9080:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    9085:	eb 9f                	jmp    9026 <file_write+0x96>
    9087:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    908e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    9090:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    9095:	eb 8f                	jmp    9026 <file_write+0x96>
    9097:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    909e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    90a0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    90a5:	e9 7c ff ff ff       	jmpq   9026 <file_write+0x96>
    90aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    90b0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    90b5:	e9 6c ff ff ff       	jmpq   9026 <file_write+0x96>
    90ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    90c0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    90c5:	e9 5c ff ff ff       	jmpq   9026 <file_write+0x96>
    90ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    90d0:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    90d5:	e9 4c ff ff ff       	jmpq   9026 <file_write+0x96>
    90da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    90e0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    90e5:	e9 3c ff ff ff       	jmpq   9026 <file_write+0x96>
    90ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    90f0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    90f5:	e9 2c ff ff ff       	jmpq   9026 <file_write+0x96>
    90fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    int ret;

    if (handle->file.offset != offset) {
        ret = INLINE_SYSCALL(lseek, 3, fd, offset, SEEK_SET);
        if (IS_ERR(ret))
            return -PAL_ERROR_DENIED;
    9100:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    9105:	e9 1c ff ff ff       	jmpq   9026 <file_write+0x96>
    910a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000009110 <file_delete>:
}

/* 'delete' operation for file streams. It will actually delete
   the file if we can successfully close it. */
static int file_delete (PAL_HANDLE handle, int access)
{
    9110:	85 f6                	test   %esi,%esi
    9112:	75 1d                	jne    9131 <file_delete+0x21>
    9114:	55                   	push   %rbp
    if (access)
        return -PAL_ERROR_INVAL;

    INLINE_SYSCALL(unlink, 1, handle->file.realpath);
    9115:	b8 0a 00 00 00       	mov    $0xa,%eax
}

/* 'delete' operation for file streams. It will actually delete
   the file if we can successfully close it. */
static int file_delete (PAL_HANDLE handle, int access)
{
    911a:	48 89 e5             	mov    %rsp,%rbp
    911d:	53                   	push   %rbx
    if (access)
        return -PAL_ERROR_INVAL;

    INLINE_SYSCALL(unlink, 1, handle->file.realpath);
    911e:	48 8b 7f 20          	mov    0x20(%rdi),%rdi
    9122:	cd 80                	int    $0x80
    9124:	bb 00 00 00 00       	mov    $0x0,%ebx
    9129:	83 d3 00             	adc    $0x0,%ebx
    return 0;
    912c:	31 c0                	xor    %eax,%eax
}
    912e:	5b                   	pop    %rbx
    912f:	5d                   	pop    %rbp
    9130:	c3                   	retq   
/* 'delete' operation for file streams. It will actually delete
   the file if we can successfully close it. */
static int file_delete (PAL_HANDLE handle, int access)
{
    if (access)
        return -PAL_ERROR_INVAL;
    9131:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9136:	c3                   	retq   
    9137:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    913e:	00 00 

0000000000009140 <file_map>:
}

/* 'map' operation for file stream. */
static int file_map (PAL_HANDLE handle, void ** addr, int prot,
                     int offset, int size)
{
    9140:	55                   	push   %rbp
    9141:	49 89 f2             	mov    %rsi,%r10

static inline int HOST_FLAGS (int alloc_type, int prot)
{
    return ((alloc_type & PAL_ALLOC_32BIT) ? MAP_32BIT : 0) |
           ((alloc_type & PAL_ALLOC_RESERVE) ? MAP_NORESERVE/*|MAP_UNINITIALIZED - not present in BSD*/ : 0) |
           ((prot & PAL_PROT_WRITECOPY) ? MAP_PRIVATE : MAP_SHARED);
    9144:	89 d0                	mov    %edx,%eax
    9146:	83 e0 08             	and    $0x8,%eax
    prot = HOST_PROT(prot);

    /* The memory will always allocated with flag MAP_PRIVATE
       and MAP_FILE */

    mem = (void *) ARCH_MMAP(mem, size, prot, flags, fd, offset);
    9149:	4c 63 c9             	movslq %ecx,%r9
}

/* 'map' operation for file stream. */
static int file_map (PAL_HANDLE handle, void ** addr, int prot,
                     int offset, int size)
{
    914c:	49 63 f0             	movslq %r8d,%rsi
    914f:	48 89 e5             	mov    %rsp,%rbp
    9152:	53                   	push   %rbx
    int fd = handle->file.fd;
    void * mem = *addr;
    9153:	49 8b 1a             	mov    (%r10),%rbx
    9156:	83 f8 01             	cmp    $0x1,%eax
    prot = HOST_PROT(prot);

    /* The memory will always allocated with flag MAP_PRIVATE
       and MAP_FILE */

    mem = (void *) ARCH_MMAP(mem, size, prot, flags, fd, offset);
    9159:	4c 63 47 0c          	movslq 0xc(%rdi),%r8
    915d:	19 c0                	sbb    %eax,%eax
    915f:	83 c0 02             	add    $0x2,%eax
static int file_map (PAL_HANDLE handle, void ** addr, int prot,
                     int offset, int size)
{
    int fd = handle->file.fd;
    void * mem = *addr;
    int flags = MAP_FILE|HOST_FLAGS(0, prot)|(mem ? MAP_FIXED : 0);
    9162:	48 83 fb 01          	cmp    $0x1,%rbx
    prot = HOST_PROT(prot);

    /* The memory will always allocated with flag MAP_PRIVATE
       and MAP_FILE */

    mem = (void *) ARCH_MMAP(mem, size, prot, flags, fd, offset);
    9166:	48 89 df             	mov    %rbx,%rdi
static int file_map (PAL_HANDLE handle, void ** addr, int prot,
                     int offset, int size)
{
    int fd = handle->file.fd;
    void * mem = *addr;
    int flags = MAP_FILE|HOST_FLAGS(0, prot)|(mem ? MAP_FIXED : 0);
    9169:	45 19 db             	sbb    %r11d,%r11d
    prot = HOST_PROT(prot);

    /* The memory will always allocated with flag MAP_PRIVATE
       and MAP_FILE */

    mem = (void *) ARCH_MMAP(mem, size, prot, flags, fd, offset);
    916c:	bb dd 01 00 00       	mov    $0x1dd,%ebx
    9171:	83 e2 07             	and    $0x7,%edx
static int file_map (PAL_HANDLE handle, void ** addr, int prot,
                     int offset, int size)
{
    int fd = handle->file.fd;
    void * mem = *addr;
    int flags = MAP_FILE|HOST_FLAGS(0, prot)|(mem ? MAP_FIXED : 0);
    9174:	41 f7 d3             	not    %r11d
    9177:	41 83 e3 10          	and    $0x10,%r11d
    917b:	44 89 d9             	mov    %r11d,%ecx
    917e:	09 c1                	or     %eax,%ecx
    prot = HOST_PROT(prot);

    /* The memory will always allocated with flag MAP_PRIVATE
       and MAP_FILE */

    mem = (void *) ARCH_MMAP(mem, size, prot, flags, fd, offset);
    9180:	89 d8                	mov    %ebx,%eax
    9182:	48 63 c9             	movslq %ecx,%rcx
    9185:	cd 80                	int    $0x80
    9187:	48 89 c2             	mov    %rax,%rdx
    918a:	bb 00 00 00 00       	mov    $0x0,%ebx
    918f:	83 d3 00             	adc    $0x0,%ebx
    9192:	31 c9                	xor    %ecx,%ecx
    9194:	85 db                	test   %ebx,%ebx
    9196:	0f 95 c1             	setne  %cl
    9199:	48 89 c8             	mov    %rcx,%rax
    919c:	48 f7 d8             	neg    %rax
    919f:	48 31 d0             	xor    %rdx,%rax
    91a2:	48 01 c8             	add    %rcx,%rax

    if (IS_ERR_P(mem))
    91a5:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
    91ab:	77 08                	ja     91b5 <file_map+0x75>
        return -PAL_ERROR_DENIED;

    *addr = mem;
    91ad:	49 89 02             	mov    %rax,(%r10)
    return 0;
    91b0:	31 c0                	xor    %eax,%eax
}
    91b2:	5b                   	pop    %rbx
    91b3:	5d                   	pop    %rbp
    91b4:	c3                   	retq   
       and MAP_FILE */

    mem = (void *) ARCH_MMAP(mem, size, prot, flags, fd, offset);

    if (IS_ERR_P(mem))
        return -PAL_ERROR_DENIED;
    91b5:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    91ba:	eb f6                	jmp    91b2 <file_map+0x72>
    91bc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000091c0 <file_setlength>:
    return 0;
}

/* 'setlength' operation for file stream. */
static int file_setlength (PAL_HANDLE handle, int length)
{
    91c0:	55                   	push   %rbp
    91c1:	48 63 f6             	movslq %esi,%rsi
    91c4:	48 89 e5             	mov    %rsp,%rbp
    91c7:	53                   	push   %rbx
    int ret = INLINE_SYSCALL(ftruncate, 2, handle->file.fd, length);
    91c8:	bb e0 01 00 00       	mov    $0x1e0,%ebx
    91cd:	8b 7f 0c             	mov    0xc(%rdi),%edi
    91d0:	89 d8                	mov    %ebx,%eax
    91d2:	cd 80                	int    $0x80
    91d4:	48 89 c2             	mov    %rax,%rdx
    91d7:	bb 00 00 00 00       	mov    $0x0,%ebx
    91dc:	83 d3 00             	adc    $0x0,%ebx
    91df:	31 c9                	xor    %ecx,%ecx
    91e1:	85 db                	test   %ebx,%ebx
    91e3:	0f 95 c1             	setne  %cl
    91e6:	48 89 c8             	mov    %rcx,%rax
    91e9:	48 f7 d8             	neg    %rax
    91ec:	48 31 c2             	xor    %rax,%rdx

    if (IS_ERR(ret))
        return (ERRNO(ret) == EINVAL || ERRNO(ret) == EBADF) ?
               -PAL_ERROR_BADHANDLE : -PAL_ERROR_DENIED;

    return length;
    91ef:	89 f0                	mov    %esi,%eax
    91f1:	48 01 ca             	add    %rcx,%rdx
/* 'setlength' operation for file stream. */
static int file_setlength (PAL_HANDLE handle, int length)
{
    int ret = INLINE_SYSCALL(ftruncate, 2, handle->file.fd, length);

    if (IS_ERR(ret))
    91f4:	85 d2                	test   %edx,%edx
    91f6:	78 08                	js     9200 <file_setlength+0x40>
        return (ERRNO(ret) == EINVAL || ERRNO(ret) == EBADF) ?
               -PAL_ERROR_BADHANDLE : -PAL_ERROR_DENIED;

    return length;
}
    91f8:	5b                   	pop    %rbx
    91f9:	5d                   	pop    %rbp
    91fa:	c3                   	retq   
    91fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{
    int ret = INLINE_SYSCALL(ftruncate, 2, handle->file.fd, length);

    if (IS_ERR(ret))
        return (ERRNO(ret) == EINVAL || ERRNO(ret) == EBADF) ?
               -PAL_ERROR_BADHANDLE : -PAL_ERROR_DENIED;
    9200:	83 fa f7             	cmp    $0xfffffffffffffff7,%edx
    9203:	74 0a                	je     920f <file_setlength+0x4f>
    9205:	83 fa ea             	cmp    $0xffffffffffffffea,%edx
    9208:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    920d:	75 e9                	jne    91f8 <file_setlength+0x38>
    920f:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

    return length;
}
    9214:	5b                   	pop    %rbx
    9215:	5d                   	pop    %rbp
    9216:	c3                   	retq   
    9217:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    921e:	00 00 

0000000000009220 <file_flush>:

/* 'flush' operation for file stream. */
static int file_flush (PAL_HANDLE handle)
{
    9220:	55                   	push   %rbp
    int ret = INLINE_SYSCALL(fsync, 1, handle->file.fd);
    9221:	be 5f 00 00 00       	mov    $0x5f,%esi
    9226:	89 f0                	mov    %esi,%eax
    return length;
}

/* 'flush' operation for file stream. */
static int file_flush (PAL_HANDLE handle)
{
    9228:	48 89 e5             	mov    %rsp,%rbp
    922b:	53                   	push   %rbx
    int ret = INLINE_SYSCALL(fsync, 1, handle->file.fd);
    922c:	8b 7f 0c             	mov    0xc(%rdi),%edi
    922f:	cd 80                	int    $0x80
    9231:	48 89 c2             	mov    %rax,%rdx
    9234:	bb 00 00 00 00       	mov    $0x0,%ebx
    9239:	83 d3 00             	adc    $0x0,%ebx
    923c:	31 c9                	xor    %ecx,%ecx
    923e:	85 db                	test   %ebx,%ebx
    9240:	0f 95 c1             	setne  %cl
    9243:	48 89 c8             	mov    %rcx,%rax
    9246:	48 f7 d8             	neg    %rax
    9249:	48 31 c2             	xor    %rax,%rdx

    if (IS_ERR(ret))
        return (ERRNO(ret) == EINVAL || ERRNO(ret) == EBADF) ?
               -PAL_ERROR_BADHANDLE : -PAL_ERROR_DENIED;

    return 0;
    924c:	31 c0                	xor    %eax,%eax
    924e:	48 01 ca             	add    %rcx,%rdx
/* 'flush' operation for file stream. */
static int file_flush (PAL_HANDLE handle)
{
    int ret = INLINE_SYSCALL(fsync, 1, handle->file.fd);

    if (IS_ERR(ret))
    9251:	85 d2                	test   %edx,%edx
    9253:	78 0b                	js     9260 <file_flush+0x40>
        return (ERRNO(ret) == EINVAL || ERRNO(ret) == EBADF) ?
               -PAL_ERROR_BADHANDLE : -PAL_ERROR_DENIED;

    return 0;
}
    9255:	5b                   	pop    %rbx
    9256:	5d                   	pop    %rbp
    9257:	c3                   	retq   
    9258:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    925f:	00 
{
    int ret = INLINE_SYSCALL(fsync, 1, handle->file.fd);

    if (IS_ERR(ret))
        return (ERRNO(ret) == EINVAL || ERRNO(ret) == EBADF) ?
               -PAL_ERROR_BADHANDLE : -PAL_ERROR_DENIED;
    9260:	83 fa f7             	cmp    $0xfffffffffffffff7,%edx
    9263:	74 0a                	je     926f <file_flush+0x4f>
    9265:	83 fa ea             	cmp    $0xffffffffffffffea,%edx
    9268:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    926d:	75 e6                	jne    9255 <file_flush+0x35>
    926f:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

    return 0;
}
    9274:	5b                   	pop    %rbx
    9275:	5d                   	pop    %rbp
    9276:	c3                   	retq   
    9277:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    927e:	00 00 

0000000000009280 <file_getrealpath>:
    memcpy(buffer + 5, handle->file.realpath, len + 1);
    return len + 5;
}

const char * file_getrealpath (PAL_HANDLE handle)
{
    9280:	55                   	push   %rbp
    return handle->file.realpath;
    9281:	48 8b 47 20          	mov    0x20(%rdi),%rax
    memcpy(buffer + 5, handle->file.realpath, len + 1);
    return len + 5;
}

const char * file_getrealpath (PAL_HANDLE handle)
{
    9285:	48 89 e5             	mov    %rsp,%rbp
    return handle->file.realpath;
}
    9288:	5d                   	pop    %rbp
    9289:	c3                   	retq   
    928a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000009290 <dir_getrealpath>:
    buffer[len + 6] = 0;
    return len + 6;
}

static const char * dir_getrealpath (PAL_HANDLE handle)
{
    9290:	55                   	push   %rbp
    return handle->dir.realpath;
    9291:	48 8b 47 10          	mov    0x10(%rdi),%rax
    buffer[len + 6] = 0;
    return len + 6;
}

static const char * dir_getrealpath (PAL_HANDLE handle)
{
    9295:	48 89 e5             	mov    %rsp,%rbp
    return handle->dir.realpath;
}
    9298:	5d                   	pop    %rbp
    9299:	c3                   	retq   
    929a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000092a0 <dir_close>:
    return bytes ? : -PAL_ERROR_ENDOFSTREAM;
}

/* 'close' operation of directory streams */
static int dir_close (PAL_HANDLE handle)
{
    92a0:	55                   	push   %rbp
    int fd = handle->dir.fd;

    int ret = INLINE_SYSCALL(close, 1, fd);
    92a1:	be 06 00 00 00       	mov    $0x6,%esi
    92a6:	89 f0                	mov    %esi,%eax
    return bytes ? : -PAL_ERROR_ENDOFSTREAM;
}

/* 'close' operation of directory streams */
static int dir_close (PAL_HANDLE handle)
{
    92a8:	48 89 e5             	mov    %rsp,%rbp
    92ab:	41 54                	push   %r12
    92ad:	49 89 fc             	mov    %rdi,%r12
    92b0:	53                   	push   %rbx
    int fd = handle->dir.fd;

    int ret = INLINE_SYSCALL(close, 1, fd);
    92b1:	48 63 7f 0c          	movslq 0xc(%rdi),%rdi
    92b5:	cd 80                	int    $0x80
    92b7:	48 89 c1             	mov    %rax,%rcx
    92ba:	bb 00 00 00 00       	mov    $0x0,%ebx
    92bf:	83 d3 00             	adc    $0x0,%ebx
    92c2:	31 d2                	xor    %edx,%edx
    92c4:	85 db                	test   %ebx,%ebx

    if (handle->dir.buf) {
    92c6:	49 8b 7c 24 18       	mov    0x18(%r12),%rdi
    92cb:	0f 95 c2             	setne  %dl
    92ce:	48 89 d3             	mov    %rdx,%rbx
    92d1:	48 f7 db             	neg    %rbx
    92d4:	48 31 d9             	xor    %rbx,%rcx
    92d7:	48 85 ff             	test   %rdi,%rdi
    92da:	48 8d 1c 11          	lea    (%rcx,%rdx,1),%rbx
    92de:	74 20                	je     9300 <dir_close+0x60>
        free(handle->dir.buf);
    92e0:	e8 ab f9 ff ff       	callq  8c90 <free>
        handle->dir.buf = handle->dir.ptr = handle->dir.end = NULL;
    92e5:	49 c7 44 24 28 00 00 	movq   $0x0,0x28(%r12)
    92ec:	00 00 
    92ee:	49 c7 44 24 20 00 00 	movq   $0x0,0x20(%r12)
    92f5:	00 00 
    92f7:	49 c7 44 24 18 00 00 	movq   $0x0,0x18(%r12)
    92fe:	00 00 
    }

    if (handle->dir.realpath &&
    9300:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
    9305:	48 85 ff             	test   %rdi,%rdi
    9308:	74 0e                	je     9318 <dir_close+0x78>
        handle->dir.realpath != (void *) handle + HANDLE_SIZE(dir))
    930a:	49 83 c4 38          	add    $0x38,%r12
    if (handle->dir.buf) {
        free(handle->dir.buf);
        handle->dir.buf = handle->dir.ptr = handle->dir.end = NULL;
    }

    if (handle->dir.realpath &&
    930e:	4c 39 e7             	cmp    %r12,%rdi
    9311:	74 05                	je     9318 <dir_close+0x78>
        handle->dir.realpath != (void *) handle + HANDLE_SIZE(dir))
        free((void *) handle->dir.realpath);
    9313:	e8 78 f9 ff ff       	callq  8c90 <free>

    if (IS_ERR(ret))
        return -PAL_ERROR_BADHANDLE;

    return 0;
    9318:	89 d8                	mov    %ebx,%eax
    931a:	c1 f8 1f             	sar    $0x1f,%eax
}
    931d:	5b                   	pop    %rbx
        free((void *) handle->dir.realpath);

    if (IS_ERR(ret))
        return -PAL_ERROR_BADHANDLE;

    return 0;
    931e:	83 e0 f9             	and    $0xfffffffffffffff9,%eax
}
    9321:	41 5c                	pop    %r12
    9323:	5d                   	pop    %rbp
    9324:	c3                   	retq   
    9325:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
    932c:	00 00 00 00 

0000000000009330 <dir_delete>:

/* 'delete' operation of directoy streams */
static int dir_delete (PAL_HANDLE handle, int access)
{
    9330:	85 f6                	test   %esi,%esi
    if (access)
        return -PAL_ERROR_INVAL;
    9332:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}

/* 'delete' operation of directoy streams */
static int dir_delete (PAL_HANDLE handle, int access)
{
    if (access)
    9337:	75 57                	jne    9390 <dir_delete+0x60>
    return 0;
}

/* 'delete' operation of directoy streams */
static int dir_delete (PAL_HANDLE handle, int access)
{
    9339:	55                   	push   %rbp
    933a:	48 89 e5             	mov    %rsp,%rbp
    933d:	53                   	push   %rbx
    933e:	48 89 fb             	mov    %rdi,%rbx
    9341:	48 83 ec 08          	sub    $0x8,%rsp
    if (access)
        return -PAL_ERROR_INVAL;

    int ret = dir_close(handle);
    9345:	e8 56 ff ff ff       	callq  92a0 <dir_close>

    if (ret < 0)
    934a:	85 c0                	test   %eax,%eax
    934c:	78 3c                	js     938a <dir_delete+0x5a>
        return ret;

    ret = INLINE_SYSCALL(rmdir, 1, handle->dir.realpath);
    934e:	b9 89 00 00 00       	mov    $0x89,%ecx
    9353:	48 8b 7b 10          	mov    0x10(%rbx),%rdi
    9357:	89 c8                	mov    %ecx,%eax
    9359:	cd 80                	int    $0x80
    935b:	48 89 c1             	mov    %rax,%rcx
    935e:	bb 00 00 00 00       	mov    $0x0,%ebx
    9363:	83 d3 00             	adc    $0x0,%ebx
    9366:	31 d2                	xor    %edx,%edx
    9368:	85 db                	test   %ebx,%ebx
    936a:	0f 95 c2             	setne  %dl
    936d:	48 89 d0             	mov    %rdx,%rax
    9370:	48 f7 d8             	neg    %rax
    9373:	48 31 c1             	xor    %rax,%rcx
    9376:	48 01 ca             	add    %rcx,%rdx

    return (IS_ERR(ret) && ERRNO(ret) != ENOENT) ?
           -PAL_ERROR_DENIED : 0;
    9379:	83 fa fe             	cmp    $0xfffffffffffffffe,%edx
    937c:	74 14                	je     9392 <dir_delete+0x62>
    if (ret < 0)
        return ret;

    ret = INLINE_SYSCALL(rmdir, 1, handle->dir.realpath);

    return (IS_ERR(ret) && ERRNO(ret) != ENOENT) ?
    937e:	c1 ea 1f             	shr    $0x1f,%edx
           -PAL_ERROR_DENIED : 0;
    9381:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    9386:	84 d2                	test   %dl,%dl
    9388:	74 08                	je     9392 <dir_delete+0x62>
}
    938a:	48 83 c4 08          	add    $0x8,%rsp
    938e:	5b                   	pop    %rbx
    938f:	5d                   	pop    %rbp
    9390:	f3 c3                	repz retq 
    9392:	48 83 c4 08          	add    $0x8,%rsp
        return ret;

    ret = INLINE_SYSCALL(rmdir, 1, handle->dir.realpath);

    return (IS_ERR(ret) && ERRNO(ret) != ENOENT) ?
           -PAL_ERROR_DENIED : 0;
    9396:	31 c0                	xor    %eax,%eax
}
    9398:	5b                   	pop    %rbx
    9399:	5d                   	pop    %rbp
    939a:	eb f4                	jmp    9390 <dir_delete+0x60>
    939c:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000093a0 <file_getname>:
    handle->file.realpath = remalloc(uri, strlen(uri));
    return 0;
}

static int file_getname (PAL_HANDLE handle, char * buffer, int count)
{
    93a0:	55                   	push   %rbp
    93a1:	48 89 e5             	mov    %rsp,%rbp
    93a4:	41 57                	push   %r15
    93a6:	41 56                	push   %r14
    93a8:	41 55                	push   %r13
    93aa:	41 54                	push   %r12
    if (!handle->file.realpath)
        return 0;
    93ac:	45 31 f6             	xor    %r14d,%r14d
    handle->file.realpath = remalloc(uri, strlen(uri));
    return 0;
}

static int file_getname (PAL_HANDLE handle, char * buffer, int count)
{
    93af:	53                   	push   %rbx
    93b0:	48 83 ec 08          	sub    $0x8,%rsp
    if (!handle->file.realpath)
    93b4:	48 8b 47 20          	mov    0x20(%rdi),%rax
    93b8:	48 85 c0             	test   %rax,%rax
    93bb:	74 46                	je     9403 <file_getname+0x63>
    93bd:	49 89 fd             	mov    %rdi,%r13
        return 0;

    int len = strlen(handle->file.realpath);
    93c0:	48 89 c7             	mov    %rax,%rdi
    93c3:	41 89 d7             	mov    %edx,%r15d
    93c6:	48 89 f3             	mov    %rsi,%rbx
    93c9:	e8 d2 d3 00 00       	callq  167a0 <strlen>

    if (len + 5 >= count)
    93ce:	44 8d 70 05          	lea    0x5(%rax),%r14d
static int file_getname (PAL_HANDLE handle, char * buffer, int count)
{
    if (!handle->file.realpath)
        return 0;

    int len = strlen(handle->file.realpath);
    93d2:	49 89 c4             	mov    %rax,%r12

    if (len + 5 >= count)
    93d5:	45 39 fe             	cmp    %r15d,%r14d
    93d8:	7d 3b                	jge    9415 <file_getname+0x75>
        return -PAL_ERROR_TOOLONG;

    memcpy(buffer, "file:", 5);
    93da:	48 8d 35 dd f9 00 00 	lea    0xf9dd(%rip),%rsi        # 18dbe <handle_sizes.1924+0x63e>
    93e1:	ba 05 00 00 00       	mov    $0x5,%edx
    93e6:	48 89 df             	mov    %rbx,%rdi
    93e9:	e8 92 ce 00 00       	callq  16280 <memcpy>
    memcpy(buffer + 5, handle->file.realpath, len + 1);
    93ee:	41 8d 54 24 01       	lea    0x1(%r12),%edx
    93f3:	49 8b 75 20          	mov    0x20(%r13),%rsi
    93f7:	48 8d 7b 05          	lea    0x5(%rbx),%rdi
    93fb:	48 63 d2             	movslq %edx,%rdx
    93fe:	e8 7d ce 00 00       	callq  16280 <memcpy>
    return len + 5;
}
    9403:	48 83 c4 08          	add    $0x8,%rsp
    9407:	44 89 f0             	mov    %r14d,%eax
    940a:	5b                   	pop    %rbx
    940b:	41 5c                	pop    %r12
    940d:	41 5d                	pop    %r13
    940f:	41 5e                	pop    %r14
    9411:	41 5f                	pop    %r15
    9413:	5d                   	pop    %rbp
    9414:	c3                   	retq   
        return 0;

    int len = strlen(handle->file.realpath);

    if (len + 5 >= count)
        return -PAL_ERROR_TOOLONG;
    9415:	41 be fb ff ff ff    	mov    $0xfffffffb,%r14d
    941b:	eb e6                	jmp    9403 <file_getname+0x63>
    941d:	0f 1f 00             	nopl   (%rax)

0000000000009420 <dir_getname>:
    handle->dir.realpath = remalloc(uri, strlen(uri));
    return 0;
}

static int dir_getname (PAL_HANDLE handle, char * buffer, int count)
{
    9420:	55                   	push   %rbp
    9421:	48 89 e5             	mov    %rsp,%rbp
    9424:	41 57                	push   %r15
    9426:	41 56                	push   %r14
    9428:	41 55                	push   %r13
    942a:	41 54                	push   %r12
    if (!handle->dir.realpath)
        return 0;
    942c:	45 31 f6             	xor    %r14d,%r14d
    handle->dir.realpath = remalloc(uri, strlen(uri));
    return 0;
}

static int dir_getname (PAL_HANDLE handle, char * buffer, int count)
{
    942f:	53                   	push   %rbx
    9430:	48 83 ec 08          	sub    $0x8,%rsp
    if (!handle->dir.realpath)
    9434:	48 8b 47 10          	mov    0x10(%rdi),%rax
    9438:	48 85 c0             	test   %rax,%rax
    943b:	74 50                	je     948d <dir_getname+0x6d>
    943d:	49 89 fd             	mov    %rdi,%r13
        return 0;

    int len = strlen(handle->dir.realpath);
    9440:	48 89 c7             	mov    %rax,%rdi
    9443:	41 89 d7             	mov    %edx,%r15d
    9446:	48 89 f3             	mov    %rsi,%rbx
    9449:	e8 52 d3 00 00       	callq  167a0 <strlen>

    if (len + 6 >= count)
    944e:	44 8d 70 06          	lea    0x6(%rax),%r14d
static int dir_getname (PAL_HANDLE handle, char * buffer, int count)
{
    if (!handle->dir.realpath)
        return 0;

    int len = strlen(handle->dir.realpath);
    9452:	49 89 c4             	mov    %rax,%r12

    if (len + 6 >= count)
    9455:	45 39 fe             	cmp    %r15d,%r14d
    9458:	7d 46                	jge    94a0 <dir_getname+0x80>
        return -PAL_ERROR_TOOLONG;

    memcpy(buffer, "file:", 5);
    945a:	48 8d 35 5d f9 00 00 	lea    0xf95d(%rip),%rsi        # 18dbe <handle_sizes.1924+0x63e>
    9461:	ba 05 00 00 00       	mov    $0x5,%edx
    9466:	48 89 df             	mov    %rbx,%rdi
    memcpy(buffer + 5, handle->dir.realpath, len);
    9469:	4d 63 e4             	movslq %r12d,%r12
    int len = strlen(handle->dir.realpath);

    if (len + 6 >= count)
        return -PAL_ERROR_TOOLONG;

    memcpy(buffer, "file:", 5);
    946c:	e8 0f ce 00 00       	callq  16280 <memcpy>
    memcpy(buffer + 5, handle->dir.realpath, len);
    9471:	49 8b 75 10          	mov    0x10(%r13),%rsi
    9475:	48 8d 7b 05          	lea    0x5(%rbx),%rdi
    9479:	4c 89 e2             	mov    %r12,%rdx
    947c:	e8 ff cd 00 00       	callq  16280 <memcpy>
    buffer[len + 5] = '/';
    9481:	42 c6 44 23 05 2f    	movb   $0x2f,0x5(%rbx,%r12,1)
    buffer[len + 6] = 0;
    9487:	42 c6 44 23 06 00    	movb   $0x0,0x6(%rbx,%r12,1)
    return len + 6;
}
    948d:	48 83 c4 08          	add    $0x8,%rsp
    9491:	44 89 f0             	mov    %r14d,%eax
    9494:	5b                   	pop    %rbx
    9495:	41 5c                	pop    %r12
    9497:	41 5d                	pop    %r13
    9499:	41 5e                	pop    %r14
    949b:	41 5f                	pop    %r15
    949d:	5d                   	pop    %rbp
    949e:	c3                   	retq   
    949f:	90                   	nop    
        return 0;

    int len = strlen(handle->dir.realpath);

    if (len + 6 >= count)
        return -PAL_ERROR_TOOLONG;
    94a0:	41 be fb ff ff ff    	mov    $0xfffffffb,%r14d
    94a6:	eb e5                	jmp    948d <dir_getname+0x6d>
    94a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    94af:	00 

00000000000094b0 <dir_read>:
#define DIRBUF_SIZE     1024

/* 'read' operation for directory stream. Directory stream will not
   need a 'write' operat4on. */
int dir_read (PAL_HANDLE handle, int offset, int count, void * buf)
{
    94b0:	55                   	push   %rbp
    94b1:	48 89 e5             	mov    %rsp,%rbp
    94b4:	41 57                	push   %r15
    94b6:	41 56                	push   %r14
    94b8:	41 55                	push   %r13
    94ba:	41 54                	push   %r12
    94bc:	41 89 d5             	mov    %edx,%r13d
    94bf:	53                   	push   %rbx
    94c0:	49 89 cf             	mov    %rcx,%r15
    94c3:	48 83 ec 38          	sub    $0x38,%rsp
    94c7:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
    void * dent_buf = handle->dir.buf ? : __alloca(DIRBUF_SIZE);
    94cb:	48 8b 7f 18          	mov    0x18(%rdi),%rdi
    94cf:	48 85 ff             	test   %rdi,%rdi
    94d2:	48 89 7d b0          	mov    %rdi,-0x50(%rbp)
    94d6:	0f 84 24 02 00 00    	je     9700 <dir_read+0x250>
    void * ptr = handle->dir.ptr;
    94dc:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    94e0:	4c 8b 70 20          	mov    0x20(%rax),%r14
    void * end = handle->dir.end;
    94e4:	48 8b 40 28          	mov    0x28(%rax),%rax
    int bytes = 0;

    if (ptr && ptr < end)
    94e8:	49 39 c6             	cmp    %rax,%r14
   need a 'write' operat4on. */
int dir_read (PAL_HANDLE handle, int offset, int count, void * buf)
{
    void * dent_buf = handle->dir.buf ? : __alloca(DIRBUF_SIZE);
    void * ptr = handle->dir.ptr;
    void * end = handle->dir.end;
    94eb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    int bytes = 0;

    if (ptr && ptr < end)
    94ef:	0f 92 c0             	setb   %al
    94f2:	0f 83 f9 00 00 00    	jae    95f1 <dir_read+0x141>
int dir_read (PAL_HANDLE handle, int offset, int count, void * buf)
{
    void * dent_buf = handle->dir.buf ? : __alloca(DIRBUF_SIZE);
    void * ptr = handle->dir.ptr;
    void * end = handle->dir.end;
    int bytes = 0;
    94f8:	45 31 e4             	xor    %r12d,%r12d

    if (ptr && ptr < end)
    94fb:	4d 85 f6             	test   %r14,%r14
    94fe:	0f 84 ed 00 00 00    	je     95f1 <dir_read+0x141>

        ptr = dent_buf;
        end = dent_buf + size;

output:
        while (ptr < end) {
    9504:	4c 39 75 c8          	cmp    %r14,-0x38(%rbp)
    9508:	0f 86 9a 00 00 00    	jbe    95a8 <dir_read+0xf8>
    950e:	66 90                	xchg   %ax,%ax
            struct linux_dirent64 * d = (struct linux_dirent64 *) ptr;

            if (d->d_name[0] == '.' &&
    9510:	41 80 7e 13 2e       	cmpb   $0x2e,0x13(%r14)
    9515:	75 0d                	jne    9524 <dir_read+0x74>
                (!d->d_name[1] || d->d_name[1] == '.'))
    9517:	41 0f b6 46 14       	movzbl 0x14(%r14),%eax

output:
        while (ptr < end) {
            struct linux_dirent64 * d = (struct linux_dirent64 *) ptr;

            if (d->d_name[0] == '.' &&
    951c:	3c 2e                	cmp    $0x2e,%al
    951e:	74 76                	je     9596 <dir_read+0xe6>
    9520:	84 c0                	test   %al,%al
    9522:	74 72                	je     9596 <dir_read+0xe6>
                (!d->d_name[1] || d->d_name[1] == '.'))
                goto next;

            bool isdir = (d->d_type == DT_DIR);
    9524:	41 0f b6 46 12       	movzbl 0x12(%r14),%eax
            int len = strlen(d->d_name);
    9529:	49 8d 5e 13          	lea    0x13(%r14),%rbx
    952d:	48 89 df             	mov    %rbx,%rdi

            if (d->d_name[0] == '.' &&
                (!d->d_name[1] || d->d_name[1] == '.'))
                goto next;

            bool isdir = (d->d_type == DT_DIR);
    9530:	88 45 c0             	mov    %al,-0x40(%rbp)
            int len = strlen(d->d_name);
    9533:	e8 68 d2 00 00       	callq  167a0 <strlen>
            if (len + (isdir ? 2 : 1) > count)
    9538:	80 7d c0 04          	cmpb   $0x4,-0x40(%rbp)
            if (d->d_name[0] == '.' &&
                (!d->d_name[1] || d->d_name[1] == '.'))
                goto next;

            bool isdir = (d->d_type == DT_DIR);
            int len = strlen(d->d_name);
    953c:	49 89 c3             	mov    %rax,%r11
    953f:	41 89 c2             	mov    %eax,%r10d
            if (len + (isdir ? 2 : 1) > count)
    9542:	0f 85 88 00 00 00    	jne    95d0 <dir_read+0x120>
    9548:	8d 40 02             	lea    0x2(%rax),%eax
    954b:	44 39 e8             	cmp    %r13d,%eax
    954e:	0f 8f 4c 01 00 00    	jg     96a0 <dir_read+0x1f0>
                break;

            memcpy(buf, d->d_name, len);
    9554:	49 63 cb             	movslq %r11d,%rcx
    9557:	48 89 de             	mov    %rbx,%rsi
    955a:	4c 89 ff             	mov    %r15,%rdi
    955d:	48 89 ca             	mov    %rcx,%rdx
    9560:	4c 89 5d a8          	mov    %r11,-0x58(%rbp)
    9564:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    9568:	e8 13 cd 00 00       	callq  16280 <memcpy>
            if (isdir)
                ((char *) buf)[len++] = '/';
    956d:	4c 8b 5d a8          	mov    -0x58(%rbp),%r11
    9571:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
    9575:	45 8d 53 01          	lea    0x1(%r11),%r10d
    9579:	41 c6 04 0f 2f       	movb   $0x2f,(%r15,%rcx,1)
            ((char *) buf)[len++] = '\0';
    957e:	41 8d 42 01          	lea    0x1(%r10),%eax
    9582:	4d 63 d2             	movslq %r10d,%r10
    9585:	43 c6 04 17 00       	movb   $0x0,(%r15,%r10,1)

            bytes += len;
            buf += len;
    958a:	48 63 d0             	movslq %eax,%rdx
            memcpy(buf, d->d_name, len);
            if (isdir)
                ((char *) buf)[len++] = '/';
            ((char *) buf)[len++] = '\0';

            bytes += len;
    958d:	41 01 c4             	add    %eax,%r12d
            buf += len;
            count -= len;
    9590:	41 29 c5             	sub    %eax,%r13d
            if (isdir)
                ((char *) buf)[len++] = '/';
            ((char *) buf)[len++] = '\0';

            bytes += len;
            buf += len;
    9593:	49 01 d7             	add    %rdx,%r15
            count -= len;
next:
            ptr += d->d_reclen;
    9596:	41 0f b7 46 10       	movzwl 0x10(%r14),%eax
    959b:	49 01 c6             	add    %rax,%r14

        ptr = dent_buf;
        end = dent_buf + size;

output:
        while (ptr < end) {
    959e:	4c 3b 75 c8          	cmp    -0x38(%rbp),%r14
    95a2:	0f 82 68 ff ff ff    	jb     9510 <dir_read+0x60>
            buf += len;
            count -= len;
next:
            ptr += d->d_reclen;
        }
    } while (ptr == end);
    95a8:	4c 3b 75 c8          	cmp    -0x38(%rbp),%r14
    95ac:	0f 84 f4 00 00 00    	je     96a6 <dir_read+0x1f6>

        if (!bytes)
            return -PAL_ERROR_OVERFLOW;
    }

    return bytes ? : -PAL_ERROR_ENDOFSTREAM;
    95b2:	45 85 e4             	test   %r12d,%r12d
    95b5:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
    95ba:	41 0f 45 c4          	cmovne %r12d,%eax
}
    95be:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    95c2:	5b                   	pop    %rbx
    95c3:	41 5c                	pop    %r12
    95c5:	41 5d                	pop    %r13
    95c7:	41 5e                	pop    %r14
    95c9:	41 5f                	pop    %r15
    95cb:	5d                   	pop    %rbp
    95cc:	c3                   	retq   
    95cd:	0f 1f 00             	nopl   (%rax)
                (!d->d_name[1] || d->d_name[1] == '.'))
                goto next;

            bool isdir = (d->d_type == DT_DIR);
            int len = strlen(d->d_name);
            if (len + (isdir ? 2 : 1) > count)
    95d0:	44 39 e8             	cmp    %r13d,%eax
    95d3:	0f 8d c7 00 00 00    	jge    96a0 <dir_read+0x1f0>
                break;

            memcpy(buf, d->d_name, len);
    95d9:	49 63 d3             	movslq %r11d,%rdx
    95dc:	48 89 de             	mov    %rbx,%rsi
    95df:	4c 89 ff             	mov    %r15,%rdi
    95e2:	44 89 55 c0          	mov    %r10d,-0x40(%rbp)
    95e6:	e8 95 cc 00 00       	callq  16280 <memcpy>
    95eb:	44 8b 55 c0          	mov    -0x40(%rbp),%r10d
    95ef:	eb 8d                	jmp    957e <dir_read+0xce>

    if (ptr && ptr < end)
        goto output;

    do {
        if (handle->dir.endofstream)
    95f1:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
    95f5:	80 79 30 00          	cmpb   $0x0,0x30(%rcx)
    95f9:	0f 85 c1 00 00 00    	jne    96c0 <dir_read+0x210>
int dir_read (PAL_HANDLE handle, int offset, int count, void * buf)
{
    void * dent_buf = handle->dir.buf ? : __alloca(DIRBUF_SIZE);
    void * ptr = handle->dir.ptr;
    void * end = handle->dir.end;
    int bytes = 0;
    95ff:	45 31 e4             	xor    %r12d,%r12d

    do {
        if (handle->dir.endofstream)
            break;

        int size = INLINE_SYSCALL(getdents, 3, handle->dir.fd, dent_buf,
    9602:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    9606:	b9 10 01 00 00       	mov    $0x110,%ecx
    960b:	ba 00 04 00 00       	mov    $0x400,%edx
    9610:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
    9614:	8b 78 0c             	mov    0xc(%rax),%edi
    9617:	89 c8                	mov    %ecx,%eax
    9619:	cd 80                	int    $0x80
    961b:	48 89 c6             	mov    %rax,%rsi
    961e:	bb 00 00 00 00       	mov    $0x0,%ebx
    9623:	83 d3 00             	adc    $0x0,%ebx
    9626:	31 d2                	xor    %edx,%edx
    9628:	85 db                	test   %ebx,%ebx
    962a:	0f 95 c2             	setne  %dl
    962d:	48 89 d0             	mov    %rdx,%rax
    9630:	48 f7 d8             	neg    %rax
    9633:	48 31 f0             	xor    %rsi,%rax
    9636:	48 01 c2             	add    %rax,%rdx
                                  DIRBUF_SIZE); //No getdents64 in BSD

        if (IS_ERR(size))
    9639:	85 d2                	test   %edx,%edx
    963b:	0f 88 f1 00 00 00    	js     9732 <dir_read+0x282>
            return -PAL_ERROR_DENIED;

        if (size == 0) {
    9641:	0f 85 9d 00 00 00    	jne    96e4 <dir_read+0x234>
            handle->dir.endofstream = PAL_TRUE;
    9647:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    964b:	c6 40 30 01          	movb   $0x1,0x30(%rax)
next:
            ptr += d->d_reclen;
        }
    } while (ptr == end);

    if (ptr < end) {
    964f:	4c 3b 75 c8          	cmp    -0x38(%rbp),%r14
    9653:	0f 83 59 ff ff ff    	jae    95b2 <dir_read+0x102>
    9659:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    965d:	48 8b 78 18          	mov    0x18(%rax),%rdi
        if (!handle->dir.buf)
    9661:	48 85 ff             	test   %rdi,%rdi
    9664:	0f 84 af 00 00 00    	je     9719 <dir_read+0x269>
            handle->dir.buf = malloc(DIRBUF_SIZE);

        if (handle->dir.buf != ptr) {
    966a:	4c 39 f7             	cmp    %r14,%rdi
    966d:	74 0f                	je     967e <dir_read+0x1ce>
            memmove(handle->dir.buf, ptr, end - ptr);
    966f:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    9673:	4c 89 f6             	mov    %r14,%rsi
    9676:	4c 29 f2             	sub    %r14,%rdx
    9679:	e8 32 cc 00 00       	callq  162b0 <memmove>
            end = handle->dir.buf + (end - ptr);
            ptr = handle->dir.buf;
        }

        if (!bytes)
            return -PAL_ERROR_OVERFLOW;
    967e:	45 85 e4             	test   %r12d,%r12d
    9681:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
    9686:	41 0f 45 c4          	cmovne %r12d,%eax
    }

    return bytes ? : -PAL_ERROR_ENDOFSTREAM;
}
    968a:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    968e:	5b                   	pop    %rbx
    968f:	41 5c                	pop    %r12
    9691:	41 5d                	pop    %r13
    9693:	41 5e                	pop    %r14
    9695:	41 5f                	pop    %r15
    9697:	5d                   	pop    %rbp
    9698:	c3                   	retq   
    9699:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            buf += len;
            count -= len;
next:
            ptr += d->d_reclen;
        }
    } while (ptr == end);
    96a0:	4c 3b 75 c8          	cmp    -0x38(%rbp),%r14
    96a4:	75 a9                	jne    964f <dir_read+0x19f>

    if (ptr && ptr < end)
        goto output;

    do {
        if (handle->dir.endofstream)
    96a6:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    96aa:	80 78 30 00          	cmpb   $0x0,0x30(%rax)
    96ae:	0f 85 fe fe ff ff    	jne    95b2 <dir_read+0x102>
    96b4:	4c 89 75 c8          	mov    %r14,-0x38(%rbp)
    96b8:	e9 45 ff ff ff       	jmpq   9602 <dir_read+0x152>
    96bd:	0f 1f 00             	nopl   (%rax)
next:
            ptr += d->d_reclen;
        }
    } while (ptr == end);

    if (ptr < end) {
    96c0:	84 c0                	test   %al,%al
    96c2:	74 0c                	je     96d0 <dir_read+0x220>
int dir_read (PAL_HANDLE handle, int offset, int count, void * buf)
{
    void * dent_buf = handle->dir.buf ? : __alloca(DIRBUF_SIZE);
    void * ptr = handle->dir.ptr;
    void * end = handle->dir.end;
    int bytes = 0;
    96c4:	45 31 e4             	xor    %r12d,%r12d
    96c7:	eb 98                	jmp    9661 <dir_read+0x1b1>
    96c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        if (!bytes)
            return -PAL_ERROR_OVERFLOW;
    }

    return bytes ? : -PAL_ERROR_ENDOFSTREAM;
}
    96d0:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp

        if (!bytes)
            return -PAL_ERROR_OVERFLOW;
    }

    return bytes ? : -PAL_ERROR_ENDOFSTREAM;
    96d4:	b8 ec ff ff ff       	mov    $0xffffffec,%eax
}
    96d9:	5b                   	pop    %rbx
    96da:	41 5c                	pop    %r12
    96dc:	41 5d                	pop    %r13
    96de:	41 5e                	pop    %r14
    96e0:	41 5f                	pop    %r15
    96e2:	5d                   	pop    %rbp
    96e3:	c3                   	retq   
            handle->dir.endofstream = PAL_TRUE;
            break;
        }

        ptr = dent_buf;
        end = dent_buf + size;
    96e4:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
    96e8:	48 63 d2             	movslq %edx,%rdx
    96eb:	48 01 c2             	add    %rax,%rdx
        if (size == 0) {
            handle->dir.endofstream = PAL_TRUE;
            break;
        }

        ptr = dent_buf;
    96ee:	49 89 c6             	mov    %rax,%r14
        end = dent_buf + size;
    96f1:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    96f5:	e9 0a fe ff ff       	jmpq   9504 <dir_read+0x54>
    96fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

/* 'read' operation for directory stream. Directory stream will not
   need a 'write' operat4on. */
int dir_read (PAL_HANDLE handle, int offset, int count, void * buf)
{
    void * dent_buf = handle->dir.buf ? : __alloca(DIRBUF_SIZE);
    9700:	48 81 ec 10 04 00 00 	sub    $0x410,%rsp
    9707:	48 8d 44 24 0f       	lea    0xf(%rsp),%rax
    970c:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    9710:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    9714:	e9 c3 fd ff ff       	jmpq   94dc <dir_read+0x2c>
        }
    } while (ptr == end);

    if (ptr < end) {
        if (!handle->dir.buf)
            handle->dir.buf = malloc(DIRBUF_SIZE);
    9719:	66 bf 00 04          	mov    $0x400,%di
    971d:	e8 de f2 ff ff       	callq  8a00 <malloc>
    9722:	48 89 c7             	mov    %rax,%rdi
    9725:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    9729:	48 89 78 18          	mov    %rdi,0x18(%rax)
    972d:	e9 38 ff ff ff       	jmpq   966a <dir_read+0x1ba>

        int size = INLINE_SYSCALL(getdents, 3, handle->dir.fd, dent_buf,
                                  DIRBUF_SIZE); //No getdents64 in BSD

        if (IS_ERR(size))
            return -PAL_ERROR_DENIED;
    9732:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    9737:	e9 4e ff ff ff       	jmpq   968a <dir_read+0x1da>
    973c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000009740 <file_attrsetbyhdl>:
    return 0;
}

static int file_attrsetbyhdl (PAL_HANDLE handle,
                              PAL_STREAM_ATTR * attr)
{
    9740:	55                   	push   %rbp
    9741:	48 89 e5             	mov    %rsp,%rbp
    9744:	53                   	push   %rbx
    int fd = handle->__in.fds[0], ret;

    ret = INLINE_SYSCALL(fchmod, 2, fd, attr->share_flags);
    9745:	bb 7c 00 00 00       	mov    $0x7c,%ebx
    974a:	48 63 7f 0c          	movslq 0xc(%rdi),%rdi
    974e:	8b 76 34             	mov    0x34(%rsi),%esi
    9751:	89 d8                	mov    %ebx,%eax
    9753:	cd 80                	int    $0x80
    9755:	48 89 c1             	mov    %rax,%rcx
    9758:	bb 00 00 00 00       	mov    $0x0,%ebx
    975d:	83 d3 00             	adc    $0x0,%ebx
    9760:	31 d2                	xor    %edx,%edx
    9762:	85 db                	test   %ebx,%ebx
    9764:	0f 95 c2             	setne  %dl
    9767:	48 89 d0             	mov    %rdx,%rax
    976a:	48 f7 d8             	neg    %rax
    976d:	48 31 c1             	xor    %rax,%rcx
    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));

    return 0;
    9770:	31 c0                	xor    %eax,%eax
    9772:	48 01 ca             	add    %rcx,%rdx
                              PAL_STREAM_ATTR * attr)
{
    int fd = handle->__in.fds[0], ret;

    ret = INLINE_SYSCALL(fchmod, 2, fd, attr->share_flags);
    if (IS_ERR(ret))
    9775:	85 d2                	test   %edx,%edx
    9777:	78 07                	js     9780 <file_attrsetbyhdl+0x40>
        return unix_to_pal_error(ERRNO(ret));

    return 0;
}
    9779:	5b                   	pop    %rbx
    977a:	5d                   	pop    %rbp
    977b:	c3                   	retq   
    977c:	0f 1f 40 00          	nopl   0x0(%rax)
{
    int fd = handle->__in.fds[0], ret;

    ret = INLINE_SYSCALL(fchmod, 2, fd, attr->share_flags);
    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));
    9780:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    9782:	83 fa 6e             	cmp    $0x6e,%edx
    9785:	0f 87 c5 00 00 00    	ja     9850 <file_attrsetbyhdl+0x110>
    978b:	48 8d 05 ea fc 00 00 	lea    0xfcea(%rip),%rax        # 1947c <slab_levels+0x1dc>
    9792:	89 d2                	mov    %edx,%edx
    9794:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    9798:	48 01 d0             	add    %rdx,%rax
    979b:	ff e0                	jmpq   *%rax
    979d:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    97a0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    97a5:	eb d2                	jmp    9779 <file_attrsetbyhdl+0x39>
    97a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    97ae:	00 00 
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    97b0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    97b5:	eb c2                	jmp    9779 <file_attrsetbyhdl+0x39>
    97b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    97be:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    97c0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    97c5:	eb b2                	jmp    9779 <file_attrsetbyhdl+0x39>
    97c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    97ce:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    97d0:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    97d5:	eb a2                	jmp    9779 <file_attrsetbyhdl+0x39>
    97d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    97de:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    97e0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    97e5:	eb 92                	jmp    9779 <file_attrsetbyhdl+0x39>
    97e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    97ee:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    97f0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    97f5:	eb 82                	jmp    9779 <file_attrsetbyhdl+0x39>
    97f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    97fe:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    9800:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    9805:	e9 6f ff ff ff       	jmpq   9779 <file_attrsetbyhdl+0x39>
    980a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    9810:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    9815:	e9 5f ff ff ff       	jmpq   9779 <file_attrsetbyhdl+0x39>
    981a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    9820:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    9825:	e9 4f ff ff ff       	jmpq   9779 <file_attrsetbyhdl+0x39>
    982a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    9830:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9835:	e9 3f ff ff ff       	jmpq   9779 <file_attrsetbyhdl+0x39>
    983a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    9840:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    9845:	e9 2f ff ff ff       	jmpq   9779 <file_attrsetbyhdl+0x39>
    984a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    9850:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    9855:	e9 1f ff ff ff       	jmpq   9779 <file_attrsetbyhdl+0x39>
    985a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000009860 <file_close>:
}

/* 'close' operation for file streams. In this case, it will only
   close the file withou deleting it. */
static int file_close (PAL_HANDLE handle)
{
    9860:	55                   	push   %rbp
    int fd = handle->file.fd;

    int ret = INLINE_SYSCALL(close, 1, fd);
    9861:	b9 06 00 00 00       	mov    $0x6,%ecx
}

/* 'close' operation for file streams. In this case, it will only
   close the file withou deleting it. */
static int file_close (PAL_HANDLE handle)
{
    9866:	48 89 fe             	mov    %rdi,%rsi
    int fd = handle->file.fd;

    int ret = INLINE_SYSCALL(close, 1, fd);
    9869:	89 c8                	mov    %ecx,%eax
}

/* 'close' operation for file streams. In this case, it will only
   close the file withou deleting it. */
static int file_close (PAL_HANDLE handle)
{
    986b:	48 89 e5             	mov    %rsp,%rbp
    986e:	53                   	push   %rbx
    986f:	48 83 ec 08          	sub    $0x8,%rsp
    int fd = handle->file.fd;

    int ret = INLINE_SYSCALL(close, 1, fd);
    9873:	48 63 7f 0c          	movslq 0xc(%rdi),%rdi
    9877:	cd 80                	int    $0x80
    9879:	48 89 c1             	mov    %rax,%rcx
    987c:	bb 00 00 00 00       	mov    $0x0,%ebx
    9881:	83 d3 00             	adc    $0x0,%ebx
    9884:	31 d2                	xor    %edx,%edx
    9886:	85 db                	test   %ebx,%ebx

    if (handle->file.realpath &&
    9888:	48 8b 7e 20          	mov    0x20(%rsi),%rdi
    988c:	0f 95 c2             	setne  %dl
    988f:	48 89 d3             	mov    %rdx,%rbx
    9892:	48 f7 db             	neg    %rbx
    9895:	48 31 d9             	xor    %rbx,%rcx
    9898:	48 85 ff             	test   %rdi,%rdi
    989b:	48 8d 1c 11          	lea    (%rcx,%rdx,1),%rbx
    989f:	74 0e                	je     98af <file_close+0x4f>
        handle->file.realpath != (void *) handle + HANDLE_SIZE(file))
    98a1:	48 83 c6 28          	add    $0x28,%rsi
{
    int fd = handle->file.fd;

    int ret = INLINE_SYSCALL(close, 1, fd);

    if (handle->file.realpath &&
    98a5:	48 39 f7             	cmp    %rsi,%rdi
    98a8:	74 05                	je     98af <file_close+0x4f>
        handle->file.realpath != (void *) handle + HANDLE_SIZE(file))
        free((void *) handle->file.realpath);
    98aa:	e8 e1 f3 ff ff       	callq  8c90 <free>

    return IS_ERR(ret) ? unix_to_pal_error(ERRNO(ret)) : 0;
    98af:	31 c0                	xor    %eax,%eax
    98b1:	85 db                	test   %ebx,%ebx
    98b3:	78 0b                	js     98c0 <file_close+0x60>
}
    98b5:	48 83 c4 08          	add    $0x8,%rsp
    98b9:	5b                   	pop    %rbx
    98ba:	5d                   	pop    %rbp
    98bb:	c3                   	retq   
    98bc:	0f 1f 40 00          	nopl   0x0(%rax)

    if (handle->file.realpath &&
        handle->file.realpath != (void *) handle + HANDLE_SIZE(file))
        free((void *) handle->file.realpath);

    return IS_ERR(ret) ? unix_to_pal_error(ERRNO(ret)) : 0;
    98c0:	89 da                	mov    %ebx,%edx
    98c2:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    98c4:	83 fa 6e             	cmp    $0x6e,%edx
    98c7:	0f 87 c3 00 00 00    	ja     9990 <file_close+0x130>
    98cd:	48 8d 05 64 fd 00 00 	lea    0xfd64(%rip),%rax        # 19638 <slab_levels+0x398>
    98d4:	89 d2                	mov    %edx,%edx
    98d6:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    98da:	48 01 d0             	add    %rdx,%rax
    98dd:	ff e0                	jmpq   *%rax
    98df:	90                   	nop    
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    98e0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    98e5:	eb ce                	jmp    98b5 <file_close+0x55>
    98e7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    98ee:	00 00 
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    98f0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    98f5:	eb be                	jmp    98b5 <file_close+0x55>
    98f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    98fe:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    9900:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    9905:	eb ae                	jmp    98b5 <file_close+0x55>
    9907:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    990e:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    9910:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    9915:	eb 9e                	jmp    98b5 <file_close+0x55>
    9917:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    991e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    9920:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    9925:	eb 8e                	jmp    98b5 <file_close+0x55>
    9927:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    992e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    9930:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    9935:	e9 7b ff ff ff       	jmpq   98b5 <file_close+0x55>
    993a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    9940:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    9945:	e9 6b ff ff ff       	jmpq   98b5 <file_close+0x55>
    994a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    9950:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    9955:	e9 5b ff ff ff       	jmpq   98b5 <file_close+0x55>
    995a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    9960:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    9965:	e9 4b ff ff ff       	jmpq   98b5 <file_close+0x55>
    996a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    9970:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9975:	e9 3b ff ff ff       	jmpq   98b5 <file_close+0x55>
    997a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    9980:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    9985:	e9 2b ff ff ff       	jmpq   98b5 <file_close+0x55>
    998a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    9990:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    9995:	e9 1b ff ff ff       	jmpq   98b5 <file_close+0x55>
    999a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000099a0 <file_rename>:
    return 0;
}

static int file_rename (PAL_HANDLE handle, const char * type,
                        const char * uri)
{
    99a0:	55                   	push   %rbp
    99a1:	49 89 f9             	mov    %rdi,%r9
    int ret = INLINE_SYSCALL(rename, 2, handle->file.realpath, uri);
    99a4:	48 89 d6             	mov    %rdx,%rsi
    return 0;
}

static int file_rename (PAL_HANDLE handle, const char * type,
                        const char * uri)
{
    99a7:	48 89 e5             	mov    %rsp,%rbp
    99aa:	41 54                	push   %r12
    99ac:	53                   	push   %rbx
    int ret = INLINE_SYSCALL(rename, 2, handle->file.realpath, uri);
    99ad:	bb 80 00 00 00       	mov    $0x80,%ebx
    99b2:	48 8b 7f 20          	mov    0x20(%rdi),%rdi
    99b6:	89 d8                	mov    %ebx,%eax
    99b8:	cd 80                	int    $0x80
    99ba:	49 89 c0             	mov    %rax,%r8
    99bd:	bb 00 00 00 00       	mov    $0x0,%ebx
    99c2:	83 d3 00             	adc    $0x0,%ebx
    99c5:	31 c9                	xor    %ecx,%ecx
    99c7:	85 db                	test   %ebx,%ebx
    99c9:	0f 95 c1             	setne  %cl
    99cc:	48 89 c8             	mov    %rcx,%rax
    99cf:	48 f7 d8             	neg    %rax
    99d2:	49 31 c0             	xor    %rax,%r8
    99d5:	4c 01 c1             	add    %r8,%rcx

    if (IS_ERR(ret))
    99d8:	85 c9                	test   %ecx,%ecx
    99da:	78 24                	js     9a00 <file_rename+0x60>
    99dc:	48 89 d3             	mov    %rdx,%rbx
        return unix_to_pal_error(ERRNO(ret));

    handle->file.realpath = remalloc(uri, strlen(uri));
    99df:	48 89 d7             	mov    %rdx,%rdi
    99e2:	4d 89 cc             	mov    %r9,%r12
    99e5:	e8 b6 cd 00 00       	callq  167a0 <strlen>
    99ea:	48 89 df             	mov    %rbx,%rdi
    99ed:	89 c6                	mov    %eax,%esi
    99ef:	e8 0c f2 ff ff       	callq  8c00 <remalloc>
    99f4:	49 89 44 24 20       	mov    %rax,0x20(%r12)
    99f9:	31 c0                	xor    %eax,%eax
    return 0;
}
    99fb:	5b                   	pop    %rbx
    99fc:	41 5c                	pop    %r12
    99fe:	5d                   	pop    %rbp
    99ff:	c3                   	retq   
                        const char * uri)
{
    int ret = INLINE_SYSCALL(rename, 2, handle->file.realpath, uri);

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));
    9a00:	f7 d9                	neg    %ecx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    9a02:	83 f9 6e             	cmp    $0x6e,%ecx
    9a05:	0f 87 c5 00 00 00    	ja     9ad0 <file_rename+0x130>
    9a0b:	48 8d 05 e2 fd 00 00 	lea    0xfde2(%rip),%rax        # 197f4 <slab_levels+0x554>
    9a12:	89 c9                	mov    %ecx,%ecx
    9a14:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    9a18:	48 01 d0             	add    %rdx,%rax
    9a1b:	ff e0                	jmpq   *%rax
    9a1d:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    9a20:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    9a25:	eb d4                	jmp    99fb <file_rename+0x5b>
    9a27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9a2e:	00 00 
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    9a30:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    9a35:	eb c4                	jmp    99fb <file_rename+0x5b>
    9a37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9a3e:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    9a40:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    9a45:	eb b4                	jmp    99fb <file_rename+0x5b>
    9a47:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9a4e:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    9a50:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    9a55:	eb a4                	jmp    99fb <file_rename+0x5b>
    9a57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9a5e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    9a60:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    9a65:	eb 94                	jmp    99fb <file_rename+0x5b>
    9a67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9a6e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    9a70:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    9a75:	eb 84                	jmp    99fb <file_rename+0x5b>
    9a77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9a7e:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    9a80:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    9a85:	e9 71 ff ff ff       	jmpq   99fb <file_rename+0x5b>
    9a8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    9a90:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    9a95:	e9 61 ff ff ff       	jmpq   99fb <file_rename+0x5b>
    9a9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    9aa0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    9aa5:	e9 51 ff ff ff       	jmpq   99fb <file_rename+0x5b>
    9aaa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    9ab0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9ab5:	e9 41 ff ff ff       	jmpq   99fb <file_rename+0x5b>
    9aba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    9ac0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    9ac5:	e9 31 ff ff ff       	jmpq   99fb <file_rename+0x5b>
    9aca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    9ad0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    9ad5:	e9 21 ff ff ff       	jmpq   99fb <file_rename+0x5b>
    9ada:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000009ae0 <dir_rename>:
           -PAL_ERROR_DENIED : 0;
}

static int dir_rename (PAL_HANDLE handle, const char * type,
                       const char * uri)
{
    9ae0:	55                   	push   %rbp
    9ae1:	49 89 f9             	mov    %rdi,%r9
    int ret = INLINE_SYSCALL(rename, 2, handle->dir.realpath, uri);
    9ae4:	48 89 d6             	mov    %rdx,%rsi
           -PAL_ERROR_DENIED : 0;
}

static int dir_rename (PAL_HANDLE handle, const char * type,
                       const char * uri)
{
    9ae7:	48 89 e5             	mov    %rsp,%rbp
    9aea:	41 54                	push   %r12
    9aec:	53                   	push   %rbx
    int ret = INLINE_SYSCALL(rename, 2, handle->dir.realpath, uri);
    9aed:	bb 80 00 00 00       	mov    $0x80,%ebx
    9af2:	48 8b 7f 10          	mov    0x10(%rdi),%rdi
    9af6:	89 d8                	mov    %ebx,%eax
    9af8:	cd 80                	int    $0x80
    9afa:	49 89 c0             	mov    %rax,%r8
    9afd:	bb 00 00 00 00       	mov    $0x0,%ebx
    9b02:	83 d3 00             	adc    $0x0,%ebx
    9b05:	31 c9                	xor    %ecx,%ecx
    9b07:	85 db                	test   %ebx,%ebx
    9b09:	0f 95 c1             	setne  %cl
    9b0c:	48 89 c8             	mov    %rcx,%rax
    9b0f:	48 f7 d8             	neg    %rax
    9b12:	49 31 c0             	xor    %rax,%r8
    9b15:	4c 01 c1             	add    %r8,%rcx

    if (IS_ERR(ret))
    9b18:	85 c9                	test   %ecx,%ecx
    9b1a:	78 24                	js     9b40 <dir_rename+0x60>
    9b1c:	48 89 d3             	mov    %rdx,%rbx
        return unix_to_pal_error(ERRNO(ret));

    handle->dir.realpath = remalloc(uri, strlen(uri));
    9b1f:	48 89 d7             	mov    %rdx,%rdi
    9b22:	4d 89 cc             	mov    %r9,%r12
    9b25:	e8 76 cc 00 00       	callq  167a0 <strlen>
    9b2a:	48 89 df             	mov    %rbx,%rdi
    9b2d:	89 c6                	mov    %eax,%esi
    9b2f:	e8 cc f0 ff ff       	callq  8c00 <remalloc>
    9b34:	49 89 44 24 10       	mov    %rax,0x10(%r12)
    9b39:	31 c0                	xor    %eax,%eax
    return 0;
}
    9b3b:	5b                   	pop    %rbx
    9b3c:	41 5c                	pop    %r12
    9b3e:	5d                   	pop    %rbp
    9b3f:	c3                   	retq   
                       const char * uri)
{
    int ret = INLINE_SYSCALL(rename, 2, handle->dir.realpath, uri);

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));
    9b40:	f7 d9                	neg    %ecx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    9b42:	83 f9 6e             	cmp    $0x6e,%ecx
    9b45:	0f 87 c5 00 00 00    	ja     9c10 <dir_rename+0x130>
    9b4b:	48 8d 05 5e fe 00 00 	lea    0xfe5e(%rip),%rax        # 199b0 <slab_levels+0x710>
    9b52:	89 c9                	mov    %ecx,%ecx
    9b54:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    9b58:	48 01 d0             	add    %rdx,%rax
    9b5b:	ff e0                	jmpq   *%rax
    9b5d:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    9b60:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    9b65:	eb d4                	jmp    9b3b <dir_rename+0x5b>
    9b67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9b6e:	00 00 
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    9b70:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    9b75:	eb c4                	jmp    9b3b <dir_rename+0x5b>
    9b77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9b7e:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    9b80:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    9b85:	eb b4                	jmp    9b3b <dir_rename+0x5b>
    9b87:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9b8e:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    9b90:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    9b95:	eb a4                	jmp    9b3b <dir_rename+0x5b>
    9b97:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9b9e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    9ba0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    9ba5:	eb 94                	jmp    9b3b <dir_rename+0x5b>
    9ba7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9bae:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    9bb0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    9bb5:	eb 84                	jmp    9b3b <dir_rename+0x5b>
    9bb7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9bbe:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    9bc0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    9bc5:	e9 71 ff ff ff       	jmpq   9b3b <dir_rename+0x5b>
    9bca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    9bd0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    9bd5:	e9 61 ff ff ff       	jmpq   9b3b <dir_rename+0x5b>
    9bda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    9be0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    9be5:	e9 51 ff ff ff       	jmpq   9b3b <dir_rename+0x5b>
    9bea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    9bf0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9bf5:	e9 41 ff ff ff       	jmpq   9b3b <dir_rename+0x5b>
    9bfa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    9c00:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    9c05:	e9 31 ff ff ff       	jmpq   9b3b <dir_rename+0x5b>
    9c0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    9c10:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    9c15:	e9 21 ff ff ff       	jmpq   9b3b <dir_rename+0x5b>
    9c1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000009c20 <file_open>:
#include <sys/types.h>
typedef __kernel_pid_t pid_t;
/* 'open' operation for file streams */
static int file_open (PAL_HANDLE * handle, const char * type, const char * uri,
                      int access, int share, int create, int options)
{
    9c20:	55                   	push   %rbp
    9c21:	49 89 d2             	mov    %rdx,%r10
    /* try to do the real open */
    int ret = INLINE_SYSCALL(open, 3, uri,
    9c24:	49 63 d0             	movslq %r8d,%rdx
#include <sys/types.h>
typedef __kernel_pid_t pid_t;
/* 'open' operation for file streams */
static int file_open (PAL_HANDLE * handle, const char * type, const char * uri,
                      int access, int share, int create, int options)
{
    9c27:	48 89 e5             	mov    %rsp,%rbp
    9c2a:	41 57                	push   %r15
    9c2c:	41 56                	push   %r14
    9c2e:	41 55                	push   %r13
    9c30:	41 54                	push   %r12
    9c32:	49 89 fc             	mov    %rdi,%r12
    9c35:	53                   	push   %rbx
    /* try to do the real open */
    int ret = INLINE_SYSCALL(open, 3, uri,
    9c36:	bb 05 00 00 00       	mov    $0x5,%ebx
    9c3b:	4c 89 d7             	mov    %r10,%rdi
    9c3e:	89 d8                	mov    %ebx,%eax
#include <sys/types.h>
typedef __kernel_pid_t pid_t;
/* 'open' operation for file streams */
static int file_open (PAL_HANDLE * handle, const char * type, const char * uri,
                      int access, int share, int create, int options)
{
    9c40:	48 83 ec 08          	sub    $0x8,%rsp
    9c44:	44 0b 4d 10          	or     0x10(%rbp),%r9d
    9c48:	41 81 c9 00 00 10 00 	or     $0x100000,%r9d
    /* try to do the real open */
    int ret = INLINE_SYSCALL(open, 3, uri,
    9c4f:	44 89 ce             	mov    %r9d,%esi
    9c52:	09 ce                	or     %ecx,%esi
    9c54:	48 63 f6             	movslq %esi,%rsi
    9c57:	cd 80                	int    $0x80
    9c59:	48 89 c2             	mov    %rax,%rdx
    9c5c:	bb 00 00 00 00       	mov    $0x0,%ebx
    9c61:	83 d3 00             	adc    $0x0,%ebx
    9c64:	31 c9                	xor    %ecx,%ecx
    9c66:	85 db                	test   %ebx,%ebx
    9c68:	0f 95 c1             	setne  %cl
    9c6b:	48 89 c8             	mov    %rcx,%rax
    9c6e:	48 f7 d8             	neg    %rax
    9c71:	48 31 d0             	xor    %rdx,%rax
    9c74:	48 8d 1c 08          	lea    (%rax,%rcx,1),%rbx
                             access|create|options|O_CLOEXEC,
                             share);

    if (IS_ERR(ret))
    9c78:	85 db                	test   %ebx,%ebx
    9c7a:	78 74                	js     9cf0 <file_open+0xd0>
        return unix_to_pal_error(ERRNO(ret));

    /* if try_create_path succeeded, prepare for the file handle */
    int len = strlen(uri);
    9c7c:	4c 89 d7             	mov    %r10,%rdi
    9c7f:	4d 89 d5             	mov    %r10,%r13
    9c82:	4d 89 e7             	mov    %r12,%r15
    9c85:	e8 16 cb 00 00       	callq  167a0 <strlen>
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + len + 1);
    9c8a:	8d 78 29             	lea    0x29(%rax),%edi

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));

    /* if try_create_path succeeded, prepare for the file handle */
    int len = strlen(uri);
    9c8d:	49 89 c6             	mov    %rax,%r14
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + len + 1);
    9c90:	e8 6b ed ff ff       	callq  8a00 <malloc>
    hdl->file.fd = ret;
    hdl->file.offset = 0;
    hdl->file.append = 0;
    hdl->file.pass = 0;
    char * path = (void *) hdl + HANDLE_SIZE(file);
    memcpy(path, uri, len + 1);
    9c95:	41 8d 56 01          	lea    0x1(%r14),%edx
    /* if try_create_path succeeded, prepare for the file handle */
    int len = strlen(uri);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + len + 1);
    SET_HANDLE_TYPE(hdl, file);
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    hdl->file.fd = ret;
    9c99:	89 58 0c             	mov    %ebx,0xc(%rax)
    hdl->file.offset = 0;
    hdl->file.append = 0;
    hdl->file.pass = 0;
    char * path = (void *) hdl + HANDLE_SIZE(file);
    9c9c:	48 8d 58 28          	lea    0x28(%rax),%rbx
    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));

    /* if try_create_path succeeded, prepare for the file handle */
    int len = strlen(uri);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + len + 1);
    9ca0:	49 89 c4             	mov    %rax,%r12
    SET_HANDLE_TYPE(hdl, file);
    9ca3:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    9ca9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    9cb0:	c7 40 08 49 00 00 00 	movl   $0x49,0x8(%rax)
    hdl->file.fd = ret;
    hdl->file.offset = 0;
    9cb7:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
    9cbe:	00 
    hdl->file.append = 0;
    hdl->file.pass = 0;
    char * path = (void *) hdl + HANDLE_SIZE(file);
    memcpy(path, uri, len + 1);
    9cbf:	48 63 d2             	movslq %edx,%rdx
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + len + 1);
    SET_HANDLE_TYPE(hdl, file);
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    hdl->file.fd = ret;
    hdl->file.offset = 0;
    hdl->file.append = 0;
    9cc2:	c6 40 18 00          	movb   $0x0,0x18(%rax)
    hdl->file.pass = 0;
    9cc6:	c6 40 19 00          	movb   $0x0,0x19(%rax)
    char * path = (void *) hdl + HANDLE_SIZE(file);
    memcpy(path, uri, len + 1);
    9cca:	4c 89 ee             	mov    %r13,%rsi
    9ccd:	48 89 df             	mov    %rbx,%rdi
    9cd0:	e8 ab c5 00 00       	callq  16280 <memcpy>
    hdl->file.realpath = path;
    9cd5:	49 89 5c 24 20       	mov    %rbx,0x20(%r12)
    *handle = hdl;
    return 0;
    9cda:	31 c0                	xor    %eax,%eax
    hdl->file.append = 0;
    hdl->file.pass = 0;
    char * path = (void *) hdl + HANDLE_SIZE(file);
    memcpy(path, uri, len + 1);
    hdl->file.realpath = path;
    *handle = hdl;
    9cdc:	4d 89 27             	mov    %r12,(%r15)
    return 0;
}
    9cdf:	48 83 c4 08          	add    $0x8,%rsp
    9ce3:	5b                   	pop    %rbx
    9ce4:	41 5c                	pop    %r12
    9ce6:	41 5d                	pop    %r13
    9ce8:	41 5e                	pop    %r14
    9cea:	41 5f                	pop    %r15
    9cec:	5d                   	pop    %rbp
    9ced:	c3                   	retq   
    9cee:	66 90                	xchg   %ax,%ax
    int ret = INLINE_SYSCALL(open, 3, uri,
                             access|create|options|O_CLOEXEC,
                             share);

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));
    9cf0:	89 d9                	mov    %ebx,%ecx
    9cf2:	f7 d9                	neg    %ecx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    9cf4:	83 f9 6e             	cmp    $0x6e,%ecx
    9cf7:	0f 87 c3 00 00 00    	ja     9dc0 <file_open+0x1a0>
    9cfd:	48 8d 05 68 fe 00 00 	lea    0xfe68(%rip),%rax        # 19b6c <slab_levels+0x8cc>
    9d04:	89 c9                	mov    %ecx,%ecx
    9d06:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    9d0a:	48 01 d0             	add    %rdx,%rax
    9d0d:	ff e0                	jmpq   *%rax
    9d0f:	90                   	nop    
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    9d10:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    9d15:	eb c8                	jmp    9cdf <file_open+0xbf>
    9d17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9d1e:	00 00 
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    9d20:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    9d25:	eb b8                	jmp    9cdf <file_open+0xbf>
    9d27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9d2e:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    9d30:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    9d35:	eb a8                	jmp    9cdf <file_open+0xbf>
    9d37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9d3e:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    9d40:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    9d45:	eb 98                	jmp    9cdf <file_open+0xbf>
    9d47:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9d4e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    9d50:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    9d55:	eb 88                	jmp    9cdf <file_open+0xbf>
    9d57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9d5e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    9d60:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    9d65:	e9 75 ff ff ff       	jmpq   9cdf <file_open+0xbf>
    9d6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    9d70:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    9d75:	e9 65 ff ff ff       	jmpq   9cdf <file_open+0xbf>
    9d7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    9d80:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    9d85:	e9 55 ff ff ff       	jmpq   9cdf <file_open+0xbf>
    9d8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    9d90:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    9d95:	e9 45 ff ff ff       	jmpq   9cdf <file_open+0xbf>
    9d9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    9da0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9da5:	e9 35 ff ff ff       	jmpq   9cdf <file_open+0xbf>
    9daa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    9db0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    9db5:	e9 25 ff ff ff       	jmpq   9cdf <file_open+0xbf>
    9dba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    9dc0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    9dc5:	e9 15 ff ff ff       	jmpq   9cdf <file_open+0xbf>
    9dca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000009dd0 <dir_open>:
/* 'open' operation for directory stream. Directory stream does not have a
   specific type prefix, its URI looks the same file streams, plus it
   ended with slashes. dir_open will be called by file_open. */
static int dir_open (PAL_HANDLE * handle, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    9dd0:	55                   	push   %rbp
    9dd1:	49 89 d2             	mov    %rdx,%r10
    9dd4:	48 89 e5             	mov    %rsp,%rbp
    9dd7:	41 57                	push   %r15
    9dd9:	41 56                	push   %r14
    9ddb:	41 55                	push   %r13
    9ddd:	41 54                	push   %r12
    9ddf:	49 89 fc             	mov    %rdi,%r12
    9de2:	53                   	push   %rbx
    9de3:	48 83 ec 08          	sub    $0x8,%rsp
    int ret;

    if (create & PAL_CREAT_TRY) {
    9de7:	41 f7 c1 00 02 00 00 	test   $0x200,%r9d
    9dee:	74 36                	je     9e26 <dir_open+0x56>
        ret = INLINE_SYSCALL(mkdir, 2, uri, share);
    9df0:	bb 88 00 00 00       	mov    $0x88,%ebx
    9df5:	49 63 f0             	movslq %r8d,%rsi
    9df8:	48 89 d7             	mov    %rdx,%rdi
    9dfb:	89 d8                	mov    %ebx,%eax
    9dfd:	cd 80                	int    $0x80
    9dff:	48 89 c2             	mov    %rax,%rdx
    9e02:	bb 00 00 00 00       	mov    $0x0,%ebx
    9e07:	83 d3 00             	adc    $0x0,%ebx
    9e0a:	31 c9                	xor    %ecx,%ecx
    9e0c:	85 db                	test   %ebx,%ebx
    9e0e:	0f 95 c1             	setne  %cl
    9e11:	48 89 c8             	mov    %rcx,%rax
    9e14:	48 f7 d8             	neg    %rax
    9e17:	48 31 c2             	xor    %rax,%rdx
    9e1a:	48 01 ca             	add    %rcx,%rdx

        if (IS_ERR(ret) && ERRNO(ret) == EEXIST &&
    9e1d:	83 fa ef             	cmp    $0xffffffffffffffef,%edx
    9e20:	0f 84 ea 00 00 00    	je     9f10 <dir_open+0x140>
            create & PAL_CREAT_ALWAYS)
            return -PAL_ERROR_STREAMEXIST;
    }

    ret = INLINE_SYSCALL(open, 3, uri, O_DIRECTORY|options|O_CLOEXEC, 0);
    9e26:	8b 75 10             	mov    0x10(%rbp),%esi
    9e29:	b9 05 00 00 00       	mov    $0x5,%ecx
    9e2e:	31 d2                	xor    %edx,%edx
    9e30:	4c 89 d7             	mov    %r10,%rdi
    9e33:	89 c8                	mov    %ecx,%eax
    9e35:	81 ce 00 00 12 00    	or     $0x120000,%esi
    9e3b:	48 63 f6             	movslq %esi,%rsi
    9e3e:	cd 80                	int    $0x80
    9e40:	49 89 c0             	mov    %rax,%r8
    9e43:	bb 00 00 00 00       	mov    $0x0,%ebx
    9e48:	83 d3 00             	adc    $0x0,%ebx
    9e4b:	31 c9                	xor    %ecx,%ecx
    9e4d:	85 db                	test   %ebx,%ebx
    9e4f:	0f 95 c1             	setne  %cl
    9e52:	48 89 c8             	mov    %rcx,%rax
    9e55:	48 f7 d8             	neg    %rax
    9e58:	4c 31 c0             	xor    %r8,%rax
    9e5b:	48 8d 1c 08          	lea    (%rax,%rcx,1),%rbx

    if (IS_ERR(ret))
    9e5f:	85 db                	test   %ebx,%ebx
    9e61:	0f 88 89 00 00 00    	js     9ef0 <dir_open+0x120>
        return unix_to_pal_error(ERRNO(ret));

    int len = strlen(uri);
    9e67:	4c 89 d7             	mov    %r10,%rdi
    9e6a:	4d 89 d5             	mov    %r10,%r13
    9e6d:	4d 89 e7             	mov    %r12,%r15
    9e70:	e8 2b c9 00 00       	callq  167a0 <strlen>
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(dir) + len + 1);
    9e75:	8d 78 39             	lea    0x39(%rax),%edi
    ret = INLINE_SYSCALL(open, 3, uri, O_DIRECTORY|options|O_CLOEXEC, 0);

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));

    int len = strlen(uri);
    9e78:	49 89 c6             	mov    %rax,%r14
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(dir) + len + 1);
    9e7b:	e8 80 eb ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, dir);
    hdl->__in.flags |= RFD(0);
    hdl->dir.fd = ret;
    char * path = (void *) hdl + HANDLE_SIZE(dir);
    memcpy(path, uri, len + 1);
    9e80:	41 8d 56 01          	lea    0x1(%r14),%edx

    int len = strlen(uri);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(dir) + len + 1);
    SET_HANDLE_TYPE(hdl, dir);
    hdl->__in.flags |= RFD(0);
    hdl->dir.fd = ret;
    9e84:	89 58 0c             	mov    %ebx,0xc(%rax)
    char * path = (void *) hdl + HANDLE_SIZE(dir);
    9e87:	48 8d 58 38          	lea    0x38(%rax),%rbx

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));

    int len = strlen(uri);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(dir) + len + 1);
    9e8b:	49 89 c4             	mov    %rax,%r12
    SET_HANDLE_TYPE(hdl, dir);
    9e8e:	c7 00 07 00 00 00    	movl   $0x7,(%rax)
    9e94:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    hdl->__in.flags |= RFD(0);
    9e9b:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)
    hdl->dir.fd = ret;
    char * path = (void *) hdl + HANDLE_SIZE(dir);
    memcpy(path, uri, len + 1);
    9ea2:	48 63 d2             	movslq %edx,%rdx
    9ea5:	4c 89 ee             	mov    %r13,%rsi
    9ea8:	48 89 df             	mov    %rbx,%rdi
    9eab:	e8 d0 c3 00 00       	callq  16280 <memcpy>
    hdl->dir.realpath = path;
    9eb0:	49 89 5c 24 10       	mov    %rbx,0x10(%r12)
    hdl->dir.buf = NULL;
    9eb5:	49 c7 44 24 18 00 00 	movq   $0x0,0x18(%r12)
    9ebc:	00 00 
    hdl->dir.ptr = NULL;
    hdl->dir.end = NULL;
    hdl->dir.endofstream = false;
    *handle = hdl;
    return 0;
    9ebe:	31 c0                	xor    %eax,%eax
    hdl->dir.fd = ret;
    char * path = (void *) hdl + HANDLE_SIZE(dir);
    memcpy(path, uri, len + 1);
    hdl->dir.realpath = path;
    hdl->dir.buf = NULL;
    hdl->dir.ptr = NULL;
    9ec0:	49 c7 44 24 20 00 00 	movq   $0x0,0x20(%r12)
    9ec7:	00 00 
    hdl->dir.end = NULL;
    9ec9:	49 c7 44 24 28 00 00 	movq   $0x0,0x28(%r12)
    9ed0:	00 00 
    hdl->dir.endofstream = false;
    9ed2:	41 c6 44 24 30 00    	movb   $0x0,0x30(%r12)
    *handle = hdl;
    9ed8:	4d 89 27             	mov    %r12,(%r15)
    return 0;
}
    9edb:	48 83 c4 08          	add    $0x8,%rsp
    9edf:	5b                   	pop    %rbx
    9ee0:	41 5c                	pop    %r12
    9ee2:	41 5d                	pop    %r13
    9ee4:	41 5e                	pop    %r14
    9ee6:	41 5f                	pop    %r15
    9ee8:	5d                   	pop    %rbp
    9ee9:	c3                   	retq   
    9eea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    }

    ret = INLINE_SYSCALL(open, 3, uri, O_DIRECTORY|options|O_CLOEXEC, 0);

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));
    9ef0:	89 d9                	mov    %ebx,%ecx
    9ef2:	f7 d9                	neg    %ecx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    9ef4:	83 f9 6e             	cmp    $0x6e,%ecx
    9ef7:	0f 87 d3 00 00 00    	ja     9fd0 <dir_open+0x200>
    9efd:	48 8d 05 24 fe 00 00 	lea    0xfe24(%rip),%rax        # 19d28 <slab_levels+0xa88>
    9f04:	89 c9                	mov    %ecx,%ecx
    9f06:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    9f0a:	48 01 d0             	add    %rdx,%rax
    9f0d:	ff e0                	jmpq   *%rax
    9f0f:	90                   	nop    
    int ret;

    if (create & PAL_CREAT_TRY) {
        ret = INLINE_SYSCALL(mkdir, 2, uri, share);

        if (IS_ERR(ret) && ERRNO(ret) == EEXIST &&
    9f10:	41 81 e1 00 08 00 00 	and    $0x800,%r9d
    9f17:	0f 84 09 ff ff ff    	je     9e26 <dir_open+0x56>
    9f1d:	0f 1f 00             	nopl   (%rax)
            create & PAL_CREAT_ALWAYS)
            return -PAL_ERROR_STREAMEXIST;
    9f20:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    9f25:	eb b4                	jmp    9edb <dir_open+0x10b>
    9f27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9f2e:	00 00 
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    9f30:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    9f35:	eb a4                	jmp    9edb <dir_open+0x10b>
    9f37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9f3e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    9f40:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    9f45:	eb 94                	jmp    9edb <dir_open+0x10b>
    9f47:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9f4e:	00 00 
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    9f50:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    9f55:	eb 84                	jmp    9edb <dir_open+0x10b>
    9f57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    9f5e:	00 00 
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    9f60:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    9f65:	e9 71 ff ff ff       	jmpq   9edb <dir_open+0x10b>
    9f6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    9f70:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    9f75:	e9 61 ff ff ff       	jmpq   9edb <dir_open+0x10b>
    9f7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    9f80:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    9f85:	e9 51 ff ff ff       	jmpq   9edb <dir_open+0x10b>
    9f8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    9f90:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    9f95:	e9 41 ff ff ff       	jmpq   9edb <dir_open+0x10b>
    9f9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    9fa0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    9fa5:	e9 31 ff ff ff       	jmpq   9edb <dir_open+0x10b>
    9faa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    9fb0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    9fb5:	e9 21 ff ff ff       	jmpq   9edb <dir_open+0x10b>
    9fba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    9fc0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    9fc5:	e9 11 ff ff ff       	jmpq   9edb <dir_open+0x10b>
    9fca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    9fd0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    9fd5:	e9 01 ff ff ff       	jmpq   9edb <dir_open+0x10b>
    9fda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000009fe0 <file_attrquery>:
}

/* 'attrquery' operation for file streams */
static int file_attrquery (const char * type, const char * uri,
                           PAL_STREAM_ATTR * attr)
{
    9fe0:	55                   	push   %rbp
    struct stat stat_buf;
    /* try to do the real open */
    int ret = INLINE_SYSCALL(stat, 2, uri, &stat_buf);
    9fe1:	b9 bc 00 00 00       	mov    $0xbc,%ecx
}

/* 'attrquery' operation for file streams */
static int file_attrquery (const char * type, const char * uri,
                           PAL_STREAM_ATTR * attr)
{
    9fe6:	48 89 f7             	mov    %rsi,%rdi
    struct stat stat_buf;
    /* try to do the real open */
    int ret = INLINE_SYSCALL(stat, 2, uri, &stat_buf);
    9fe9:	89 c8                	mov    %ecx,%eax
}

/* 'attrquery' operation for file streams */
static int file_attrquery (const char * type, const char * uri,
                           PAL_STREAM_ATTR * attr)
{
    9feb:	48 89 e5             	mov    %rsp,%rbp
    9fee:	41 54                	push   %r12
    9ff0:	53                   	push   %rbx
    struct stat stat_buf;
    /* try to do the real open */
    int ret = INLINE_SYSCALL(stat, 2, uri, &stat_buf);
    9ff1:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
}

/* 'attrquery' operation for file streams */
static int file_attrquery (const char * type, const char * uri,
                           PAL_STREAM_ATTR * attr)
{
    9ff8:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
    struct stat stat_buf;
    /* try to do the real open */
    int ret = INLINE_SYSCALL(stat, 2, uri, &stat_buf);
    9ffc:	cd 80                	int    $0x80
    9ffe:	48 89 c6             	mov    %rax,%rsi
    a001:	bb 00 00 00 00       	mov    $0x0,%ebx
    a006:	83 d3 00             	adc    $0x0,%ebx
    a009:	31 c9                	xor    %ecx,%ecx
    a00b:	85 db                	test   %ebx,%ebx
    a00d:	0f 95 c1             	setne  %cl
    a010:	48 89 c8             	mov    %rcx,%rax
    a013:	48 f7 d8             	neg    %rax
    a016:	48 31 c6             	xor    %rax,%rsi
    a019:	48 01 f1             	add    %rsi,%rcx

    /* if it failed, return the right error code */
    if (IS_ERR(ret))
    a01c:	85 c9                	test   %ecx,%ecx
    a01e:	0f 88 ce 00 00 00    	js     a0f2 <file_attrquery+0x112>
    a024:	48 89 d3             	mov    %rdx,%rbx

/* copy attr content from POSIX stat struct to PAL_STREAM_ATTR */
static inline void
file_attrcopy (PAL_STREAM_ATTR * attr, struct stat * stat)
{
    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
    a027:	31 f6                	xor    %esi,%esi
    a029:	ba 70 00 00 00       	mov    $0x70,%edx
    a02e:	48 89 df             	mov    %rbx,%rdi
    a031:	e8 6a c1 00 00       	callq  161a0 <memset>
    return 0;
}

static inline int file_stat_type (struct stat * stat)
{
    if (S_ISREG(stat->st_mode))
    a036:	0f b7 85 78 ff ff ff 	movzwl -0x88(%rbp),%eax
    a03d:	66 25 00 f0          	and    $0xf000,%ax
    a041:	66 3d 00 80          	cmp    $0x8000,%ax
    a045:	0f 84 d5 00 00 00    	je     a120 <file_attrquery+0x140>
        return pal_type_file;
    if (S_ISDIR(stat->st_mode))
    a04b:	66 3d 00 40          	cmp    $0x4000,%ax
    a04f:	0f 84 bb 00 00 00    	je     a110 <file_attrquery+0x130>
        return pal_type_dir;
    if (S_ISCHR(stat->st_mode))
    a055:	66 3d 00 20          	cmp    $0x2000,%ax
    a059:	0f 84 d1 00 00 00    	je     a130 <file_attrquery+0x150>
        return pal_type_dev;
    if (S_ISFIFO(stat->st_mode))
    a05f:	66 3d 00 10          	cmp    $0x1000,%ax
    a063:	0f 84 d7 00 00 00    	je     a140 <file_attrquery+0x160>
        return pal_type_pipe;
    if (S_ISSOCK(stat->st_mode))
    a069:	66 3d 00 c0          	cmp    $0xc000,%ax
    a06d:	ba 00 00 00 00       	mov    $0x0,%edx
    a072:	b8 06 00 00 00       	mov    $0x6,%eax
    a077:	0f 45 c2             	cmovne %edx,%eax
static inline void
file_attrcopy (PAL_STREAM_ATTR * attr, struct stat * stat)
{
    memset(attr, 0, sizeof(PAL_STREAM_ATTR));

    attr->type = file_stat_type(stat);
    a07a:	89 03                	mov    %eax,(%rbx)
    attr->file_id = stat->st_ino;
    a07c:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax

    attr->access_time = stat->st_atime;
    attr->change_time = stat->st_mtime;
    attr->create_time = stat->st_ctime;

    attr->readable  = stataccess(stat, ACCESS_R);
    a082:	4c 8d a5 70 ff ff ff 	lea    -0x90(%rbp),%r12
    a089:	be 04 00 00 00       	mov    $0x4,%esi
    a08e:	4c 89 e7             	mov    %r12,%rdi
file_attrcopy (PAL_STREAM_ATTR * attr, struct stat * stat)
{
    memset(attr, 0, sizeof(PAL_STREAM_ATTR));

    attr->type = file_stat_type(stat);
    attr->file_id = stat->st_ino;
    a091:	48 89 43 08          	mov    %rax,0x8(%rbx)
    attr->size = stat->st_size;
    a095:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    a099:	48 89 43 10          	mov    %rax,0x10(%rbx)

    attr->access_time = stat->st_atime;
    a09d:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    a0a1:	48 89 43 18          	mov    %rax,0x18(%rbx)
    attr->change_time = stat->st_mtime;
    a0a5:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    a0a9:	48 89 43 20          	mov    %rax,0x20(%rbx)
    attr->create_time = stat->st_ctime;
    a0ad:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    a0b1:	48 89 43 28          	mov    %rax,0x28(%rbx)

    attr->readable  = stataccess(stat, ACCESS_R);
    a0b5:	e8 f6 56 00 00       	callq  f7b0 <stataccess>
    attr->writeable = stataccess(stat, ACCESS_W);
    a0ba:	be 02 00 00 00       	mov    $0x2,%esi
    a0bf:	4c 89 e7             	mov    %r12,%rdi

    attr->access_time = stat->st_atime;
    attr->change_time = stat->st_mtime;
    attr->create_time = stat->st_ctime;

    attr->readable  = stataccess(stat, ACCESS_R);
    a0c2:	88 43 31             	mov    %al,0x31(%rbx)
    attr->writeable = stataccess(stat, ACCESS_W);
    a0c5:	e8 e6 56 00 00       	callq  f7b0 <stataccess>
    attr->runnable  = stataccess(stat, ACCESS_X);
    a0ca:	be 01 00 00 00       	mov    $0x1,%esi
    attr->access_time = stat->st_atime;
    attr->change_time = stat->st_mtime;
    attr->create_time = stat->st_ctime;

    attr->readable  = stataccess(stat, ACCESS_R);
    attr->writeable = stataccess(stat, ACCESS_W);
    a0cf:	88 43 32             	mov    %al,0x32(%rbx)
    attr->runnable  = stataccess(stat, ACCESS_X);
    a0d2:	4c 89 e7             	mov    %r12,%rdi
    a0d5:	e8 d6 56 00 00       	callq  f7b0 <stataccess>
    a0da:	88 43 33             	mov    %al,0x33(%rbx)
    attr->share_flags = stat->st_mode;
    a0dd:	0f b7 85 78 ff ff ff 	movzwl -0x88(%rbp),%eax
    a0e4:	89 43 34             	mov    %eax,0x34(%rbx)
    /* if it failed, return the right error code */
    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));

    file_attrcopy(attr, &stat_buf);
    return 0;
    a0e7:	31 c0                	xor    %eax,%eax
}
    a0e9:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp
    a0ed:	5b                   	pop    %rbx
    a0ee:	41 5c                	pop    %r12
    a0f0:	5d                   	pop    %rbp
    a0f1:	c3                   	retq   
    /* try to do the real open */
    int ret = INLINE_SYSCALL(stat, 2, uri, &stat_buf);

    /* if it failed, return the right error code */
    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));
    a0f2:	f7 d9                	neg    %ecx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    a0f4:	83 f9 6e             	cmp    $0x6e,%ecx
    a0f7:	0f 87 03 01 00 00    	ja     a200 <file_attrquery+0x220>
    a0fd:	48 8d 05 e0 fd 00 00 	lea    0xfde0(%rip),%rax        # 19ee4 <slab_levels+0xc44>
    a104:	89 c9                	mov    %ecx,%ecx
    a106:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    a10a:	48 01 d0             	add    %rdx,%rax
    a10d:	ff e0                	jmpq   *%rax
    a10f:	90                   	nop    

static inline int file_stat_type (struct stat * stat)
{
    if (S_ISREG(stat->st_mode))
        return pal_type_file;
    if (S_ISDIR(stat->st_mode))
    a110:	b8 07 00 00 00       	mov    $0x7,%eax
    a115:	e9 60 ff ff ff       	jmpq   a07a <file_attrquery+0x9a>
    a11a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    return 0;
}

static inline int file_stat_type (struct stat * stat)
{
    if (S_ISREG(stat->st_mode))
    a120:	b8 01 00 00 00       	mov    $0x1,%eax
    a125:	e9 50 ff ff ff       	jmpq   a07a <file_attrquery+0x9a>
    a12a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        return pal_type_file;
    if (S_ISDIR(stat->st_mode))
        return pal_type_dir;
    if (S_ISCHR(stat->st_mode))
    a130:	b8 06 00 00 00       	mov    $0x6,%eax
    a135:	e9 40 ff ff ff       	jmpq   a07a <file_attrquery+0x9a>
    a13a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        return pal_type_dev;
    if (S_ISFIFO(stat->st_mode))
    a140:	b8 02 00 00 00       	mov    $0x2,%eax
    a145:	e9 30 ff ff ff       	jmpq   a07a <file_attrquery+0x9a>
    a14a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    a150:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    a155:	eb 92                	jmp    a0e9 <file_attrquery+0x109>
    a157:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    a15e:	00 00 
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    a160:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    a165:	e9 7f ff ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a16a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    a170:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    a175:	e9 6f ff ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a17a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    a180:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    a185:	e9 5f ff ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a18a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    a190:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    a195:	e9 4f ff ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a19a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    a1a0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    a1a5:	e9 3f ff ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a1aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    a1b0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    a1b5:	e9 2f ff ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a1ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    a1c0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    a1c5:	e9 1f ff ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a1ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    a1d0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    a1d5:	e9 0f ff ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a1da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    a1e0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    a1e5:	e9 ff fe ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a1ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    a1f0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    a1f5:	e9 ef fe ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a1fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    a200:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    a205:	e9 df fe ff ff       	jmpq   a0e9 <file_attrquery+0x109>
    a20a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000a210 <file_attrquerybyhdl>:
}

/* 'attrquerybyhdl' operation for file streams */
static int file_attrquerybyhdl (PAL_HANDLE handle,
                                PAL_STREAM_ATTR * attr)
{
    a210:	55                   	push   %rbp
    int fd = handle->__in.fds[0];
    struct stat stat_buf;

    int ret = INLINE_SYSCALL(fstat, 2, fd, &stat_buf);
    a211:	b9 bd 00 00 00       	mov    $0xbd,%ecx
}

/* 'attrquerybyhdl' operation for file streams */
static int file_attrquerybyhdl (PAL_HANDLE handle,
                                PAL_STREAM_ATTR * attr)
{
    a216:	48 89 f2             	mov    %rsi,%rdx
    int fd = handle->__in.fds[0];
    struct stat stat_buf;

    int ret = INLINE_SYSCALL(fstat, 2, fd, &stat_buf);
    a219:	89 c8                	mov    %ecx,%eax
}

/* 'attrquerybyhdl' operation for file streams */
static int file_attrquerybyhdl (PAL_HANDLE handle,
                                PAL_STREAM_ATTR * attr)
{
    a21b:	48 89 e5             	mov    %rsp,%rbp
    a21e:	41 54                	push   %r12
    a220:	53                   	push   %rbx
    int fd = handle->__in.fds[0];
    struct stat stat_buf;

    int ret = INLINE_SYSCALL(fstat, 2, fd, &stat_buf);
    a221:	48 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%rsi
}

/* 'attrquerybyhdl' operation for file streams */
static int file_attrquerybyhdl (PAL_HANDLE handle,
                                PAL_STREAM_ATTR * attr)
{
    a228:	48 83 c4 80          	add    $0xffffffffffffff80,%rsp
    int fd = handle->__in.fds[0];
    struct stat stat_buf;

    int ret = INLINE_SYSCALL(fstat, 2, fd, &stat_buf);
    a22c:	48 63 7f 0c          	movslq 0xc(%rdi),%rdi
    a230:	cd 80                	int    $0x80
    a232:	48 89 c6             	mov    %rax,%rsi
    a235:	bb 00 00 00 00       	mov    $0x0,%ebx
    a23a:	83 d3 00             	adc    $0x0,%ebx
    a23d:	31 c9                	xor    %ecx,%ecx
    a23f:	85 db                	test   %ebx,%ebx
    a241:	0f 95 c1             	setne  %cl
    a244:	48 89 c8             	mov    %rcx,%rax
    a247:	48 f7 d8             	neg    %rax
    a24a:	48 31 c6             	xor    %rax,%rsi
    a24d:	48 01 f1             	add    %rsi,%rcx

    if (IS_ERR(ret))
    a250:	85 c9                	test   %ecx,%ecx
    a252:	0f 88 d8 00 00 00    	js     a330 <file_attrquerybyhdl+0x120>
    a258:	48 89 d3             	mov    %rdx,%rbx

/* copy attr content from POSIX stat struct to PAL_STREAM_ATTR */
static inline void
file_attrcopy (PAL_STREAM_ATTR * attr, struct stat * stat)
{
    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
    a25b:	31 f6                	xor    %esi,%esi
    a25d:	ba 70 00 00 00       	mov    $0x70,%edx
    a262:	48 89 df             	mov    %rbx,%rdi
    a265:	e8 36 bf 00 00       	callq  161a0 <memset>
    return 0;
}

static inline int file_stat_type (struct stat * stat)
{
    if (S_ISREG(stat->st_mode))
    a26a:	0f b7 85 78 ff ff ff 	movzwl -0x88(%rbp),%eax
    a271:	66 25 00 f0          	and    $0xf000,%ax
    a275:	66 3d 00 80          	cmp    $0x8000,%ax
    a279:	0f 84 e1 00 00 00    	je     a360 <file_attrquerybyhdl+0x150>
        return pal_type_file;
    if (S_ISDIR(stat->st_mode))
    a27f:	66 3d 00 40          	cmp    $0x4000,%ax
    a283:	0f 84 c7 00 00 00    	je     a350 <file_attrquerybyhdl+0x140>
        return pal_type_dir;
    if (S_ISCHR(stat->st_mode))
    a289:	66 3d 00 20          	cmp    $0x2000,%ax
    a28d:	0f 84 dd 00 00 00    	je     a370 <file_attrquerybyhdl+0x160>
        return pal_type_dev;
    if (S_ISFIFO(stat->st_mode))
    a293:	66 3d 00 10          	cmp    $0x1000,%ax
    a297:	0f 84 e3 00 00 00    	je     a380 <file_attrquerybyhdl+0x170>
        return pal_type_pipe;
    if (S_ISSOCK(stat->st_mode))
    a29d:	66 3d 00 c0          	cmp    $0xc000,%ax
    a2a1:	ba 00 00 00 00       	mov    $0x0,%edx
    a2a6:	b8 06 00 00 00       	mov    $0x6,%eax
    a2ab:	0f 45 c2             	cmovne %edx,%eax
static inline void
file_attrcopy (PAL_STREAM_ATTR * attr, struct stat * stat)
{
    memset(attr, 0, sizeof(PAL_STREAM_ATTR));

    attr->type = file_stat_type(stat);
    a2ae:	89 03                	mov    %eax,(%rbx)
    attr->file_id = stat->st_ino;
    a2b0:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax

    attr->access_time = stat->st_atime;
    attr->change_time = stat->st_mtime;
    attr->create_time = stat->st_ctime;

    attr->readable  = stataccess(stat, ACCESS_R);
    a2b6:	4c 8d a5 70 ff ff ff 	lea    -0x90(%rbp),%r12
    a2bd:	be 04 00 00 00       	mov    $0x4,%esi
    a2c2:	4c 89 e7             	mov    %r12,%rdi
file_attrcopy (PAL_STREAM_ATTR * attr, struct stat * stat)
{
    memset(attr, 0, sizeof(PAL_STREAM_ATTR));

    attr->type = file_stat_type(stat);
    attr->file_id = stat->st_ino;
    a2c5:	48 89 43 08          	mov    %rax,0x8(%rbx)
    attr->size = stat->st_size;
    a2c9:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
    a2cd:	48 89 43 10          	mov    %rax,0x10(%rbx)

    attr->access_time = stat->st_atime;
    a2d1:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    a2d5:	48 89 43 18          	mov    %rax,0x18(%rbx)
    attr->change_time = stat->st_mtime;
    a2d9:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    a2dd:	48 89 43 20          	mov    %rax,0x20(%rbx)
    attr->create_time = stat->st_ctime;
    a2e1:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    a2e5:	48 89 43 28          	mov    %rax,0x28(%rbx)

    attr->readable  = stataccess(stat, ACCESS_R);
    a2e9:	e8 c2 54 00 00       	callq  f7b0 <stataccess>
    attr->writeable = stataccess(stat, ACCESS_W);
    a2ee:	be 02 00 00 00       	mov    $0x2,%esi
    a2f3:	4c 89 e7             	mov    %r12,%rdi

    attr->access_time = stat->st_atime;
    attr->change_time = stat->st_mtime;
    attr->create_time = stat->st_ctime;

    attr->readable  = stataccess(stat, ACCESS_R);
    a2f6:	88 43 31             	mov    %al,0x31(%rbx)
    attr->writeable = stataccess(stat, ACCESS_W);
    a2f9:	e8 b2 54 00 00       	callq  f7b0 <stataccess>
    attr->runnable  = stataccess(stat, ACCESS_X);
    a2fe:	be 01 00 00 00       	mov    $0x1,%esi
    attr->access_time = stat->st_atime;
    attr->change_time = stat->st_mtime;
    attr->create_time = stat->st_ctime;

    attr->readable  = stataccess(stat, ACCESS_R);
    attr->writeable = stataccess(stat, ACCESS_W);
    a303:	88 43 32             	mov    %al,0x32(%rbx)
    attr->runnable  = stataccess(stat, ACCESS_X);
    a306:	4c 89 e7             	mov    %r12,%rdi
    a309:	e8 a2 54 00 00       	callq  f7b0 <stataccess>
    a30e:	88 43 33             	mov    %al,0x33(%rbx)
    attr->share_flags = stat->st_mode;
    a311:	0f b7 85 78 ff ff ff 	movzwl -0x88(%rbp),%eax
    a318:	89 43 34             	mov    %eax,0x34(%rbx)

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));

    file_attrcopy(attr, &stat_buf);
    return 0;
    a31b:	31 c0                	xor    %eax,%eax
}
    a31d:	48 83 ec 80          	sub    $0xffffffffffffff80,%rsp
    a321:	5b                   	pop    %rbx
    a322:	41 5c                	pop    %r12
    a324:	5d                   	pop    %rbp
    a325:	c3                   	retq   
    a326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    a32d:	00 00 00 
    struct stat stat_buf;

    int ret = INLINE_SYSCALL(fstat, 2, fd, &stat_buf);

    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));
    a330:	f7 d9                	neg    %ecx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    a332:	83 f9 6e             	cmp    $0x6e,%ecx
    a335:	0f 87 05 01 00 00    	ja     a440 <file_attrquerybyhdl+0x230>
    a33b:	48 8d 05 5e fd 00 00 	lea    0xfd5e(%rip),%rax        # 1a0a0 <slab_levels+0xe00>
    a342:	89 c9                	mov    %ecx,%ecx
    a344:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    a348:	48 01 d0             	add    %rdx,%rax
    a34b:	ff e0                	jmpq   *%rax
    a34d:	0f 1f 00             	nopl   (%rax)

static inline int file_stat_type (struct stat * stat)
{
    if (S_ISREG(stat->st_mode))
        return pal_type_file;
    if (S_ISDIR(stat->st_mode))
    a350:	b8 07 00 00 00       	mov    $0x7,%eax
    a355:	e9 54 ff ff ff       	jmpq   a2ae <file_attrquerybyhdl+0x9e>
    a35a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    return 0;
}

static inline int file_stat_type (struct stat * stat)
{
    if (S_ISREG(stat->st_mode))
    a360:	b8 01 00 00 00       	mov    $0x1,%eax
    a365:	e9 44 ff ff ff       	jmpq   a2ae <file_attrquerybyhdl+0x9e>
    a36a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        return pal_type_file;
    if (S_ISDIR(stat->st_mode))
        return pal_type_dir;
    if (S_ISCHR(stat->st_mode))
    a370:	b8 06 00 00 00       	mov    $0x6,%eax
    a375:	e9 34 ff ff ff       	jmpq   a2ae <file_attrquerybyhdl+0x9e>
    a37a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        return pal_type_dev;
    if (S_ISFIFO(stat->st_mode))
    a380:	b8 02 00 00 00       	mov    $0x2,%eax
    a385:	e9 24 ff ff ff       	jmpq   a2ae <file_attrquerybyhdl+0x9e>
    a38a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    a390:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    a395:	eb 86                	jmp    a31d <file_attrquerybyhdl+0x10d>
    a397:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    a39e:	00 00 
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    a3a0:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    a3a5:	e9 73 ff ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a3aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    a3b0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    a3b5:	e9 63 ff ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a3ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    a3c0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    a3c5:	e9 53 ff ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a3ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    a3d0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    a3d5:	e9 43 ff ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a3da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    a3e0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    a3e5:	e9 33 ff ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a3ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    a3f0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    a3f5:	e9 23 ff ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a3fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    a400:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    a405:	e9 13 ff ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a40a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    a410:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    a415:	e9 03 ff ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a41a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    a420:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    a425:	e9 f3 fe ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a42a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    a430:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    a435:	e9 e3 fe ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a43a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    a440:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    a445:	e9 d3 fe ff ff       	jmpq   a31d <file_attrquerybyhdl+0x10d>
    a44a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000a450 <file_read>:
#endif

/* 'read' operation for file streams. */
static int file_read (PAL_HANDLE handle, int offset, int count,
                      void * buffer)
{
    a450:	55                   	push   %rbp
    a451:	49 89 fa             	mov    %rdi,%r10
    a454:	48 89 e5             	mov    %rsp,%rbp
    a457:	41 55                	push   %r13
    a459:	4c 63 ee             	movslq %esi,%r13
    a45c:	41 54                	push   %r12
    int fd = handle->file.fd;
    int ret;
//    pal_printf("file_read: 1 Handle Offset: %d Offset from call: %d\n",handle->file.offset, offset);
    if (handle->file.offset != offset) {
    a45e:	4d 39 6a 10          	cmp    %r13,0x10(%r10)
#endif

/* 'read' operation for file streams. */
static int file_read (PAL_HANDLE handle, int offset, int count,
                      void * buffer)
{
    a462:	4d 89 e9             	mov    %r13,%r9
    a465:	53                   	push   %rbx
    int fd = handle->file.fd;
    a466:	4c 63 47 0c          	movslq 0xc(%rdi),%r8
#endif

/* 'read' operation for file streams. */
static int file_read (PAL_HANDLE handle, int offset, int count,
                      void * buffer)
{
    a46a:	41 89 d4             	mov    %edx,%r12d
    a46d:	49 63 f8             	movslq %r8d,%rdi
    int fd = handle->file.fd;
    int ret;
//    pal_printf("file_read: 1 Handle Offset: %d Offset from call: %d\n",handle->file.offset, offset);
    if (handle->file.offset != offset) {
    a470:	74 39                	je     a4ab <file_read+0x5b>
        ret = INLINE_SYSCALL(lseek, 3, fd, offset, SEEK_SET);
    a472:	bb de 01 00 00       	mov    $0x1de,%ebx
    a477:	31 d2                	xor    %edx,%edx
    a479:	4c 89 ee             	mov    %r13,%rsi
    a47c:	4c 89 c7             	mov    %r8,%rdi
    a47f:	89 d8                	mov    %ebx,%eax
    a481:	cd 80                	int    $0x80
    a483:	48 89 c2             	mov    %rax,%rdx
    a486:	bb 00 00 00 00       	mov    $0x0,%ebx
    a48b:	83 d3 00             	adc    $0x0,%ebx
    a48e:	31 f6                	xor    %esi,%esi
    a490:	85 db                	test   %ebx,%ebx
    a492:	40 0f 95 c6          	setne  %sil
    a496:	48 89 f0             	mov    %rsi,%rax
    a499:	48 f7 d8             	neg    %rax
    a49c:	48 31 d0             	xor    %rdx,%rax

        // pal_printf("file_read: 1 Handle Offset: %d Offset from call: %d Return of seek: %d FD: %d Offset: %d\n",handle->file.offset, offset, ret, fd, offset);
        if (IS_ERR(ret))
    a49f:	01 f0                	add    %esi,%eax
    a4a1:	0f 88 19 01 00 00    	js     a5c0 <file_read+0x170>
            return -PAL_ERROR_DENIED;

        handle->file.offset = offset;
    a4a7:	4d 89 6a 10          	mov    %r13,0x10(%r10)
    }

    // pal_printf("file_read: 2\n");
    ret = INLINE_SYSCALL(read, 3, fd, buffer, count);
    a4ab:	bb 03 00 00 00       	mov    $0x3,%ebx
    a4b0:	49 63 d4             	movslq %r12d,%rdx
    a4b3:	48 89 ce             	mov    %rcx,%rsi
    a4b6:	89 d8                	mov    %ebx,%eax
    a4b8:	cd 80                	int    $0x80
    a4ba:	48 89 c1             	mov    %rax,%rcx
    a4bd:	bb 00 00 00 00       	mov    $0x0,%ebx
    a4c2:	83 d3 00             	adc    $0x0,%ebx
    a4c5:	31 d2                	xor    %edx,%edx
    a4c7:	85 db                	test   %ebx,%ebx
    a4c9:	0f 95 c2             	setne  %dl
    a4cc:	48 89 d0             	mov    %rdx,%rax
    a4cf:	48 f7 d8             	neg    %rax
    a4d2:	48 31 c8             	xor    %rcx,%rax
    a4d5:	48 01 d0             	add    %rdx,%rax

    // pal_printf("file_read: 3\n");
    if (IS_ERR(ret))
    a4d8:	85 c0                	test   %eax,%eax
    a4da:	78 14                	js     a4f0 <file_read+0xa0>
        return unix_to_pal_error(ERRNO(ret));

    // pal_printf("file_read: 4\n");
    handle->file.offset = offset + ret;
    a4dc:	41 01 c1             	add    %eax,%r9d
    a4df:	4d 63 c9             	movslq %r9d,%r9
    a4e2:	4d 89 4a 10          	mov    %r9,0x10(%r10)
    // pal_printf("file_read: 5\n");
    return ret;
}
    a4e6:	5b                   	pop    %rbx
    a4e7:	41 5c                	pop    %r12
    a4e9:	41 5d                	pop    %r13
    a4eb:	5d                   	pop    %rbp
    a4ec:	c3                   	retq   
    a4ed:	0f 1f 00             	nopl   (%rax)
    // pal_printf("file_read: 2\n");
    ret = INLINE_SYSCALL(read, 3, fd, buffer, count);

    // pal_printf("file_read: 3\n");
    if (IS_ERR(ret))
        return unix_to_pal_error(ERRNO(ret));
    a4f0:	f7 d8                	neg    %eax
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    a4f2:	83 f8 6e             	cmp    $0x6e,%eax
    a4f5:	0f 87 c5 00 00 00    	ja     a5c0 <file_read+0x170>
    a4fb:	48 8d 15 5a fd 00 00 	lea    0xfd5a(%rip),%rdx        # 1a25c <slab_levels+0xfbc>
    a502:	89 c0                	mov    %eax,%eax
    a504:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    a508:	48 01 c2             	add    %rax,%rdx
    a50b:	ff e2                	jmpq   *%rdx
    a50d:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    a510:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    a515:	eb cf                	jmp    a4e6 <file_read+0x96>
    a517:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    a51e:	00 00 
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    a520:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    a525:	eb bf                	jmp    a4e6 <file_read+0x96>
    a527:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    a52e:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    a530:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    a535:	eb af                	jmp    a4e6 <file_read+0x96>
    a537:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    a53e:	00 00 
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    a540:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    a545:	eb 9f                	jmp    a4e6 <file_read+0x96>
    a547:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    a54e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    a550:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    a555:	eb 8f                	jmp    a4e6 <file_read+0x96>
    a557:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    a55e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    a560:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    a565:	e9 7c ff ff ff       	jmpq   a4e6 <file_read+0x96>
    a56a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    a570:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    a575:	e9 6c ff ff ff       	jmpq   a4e6 <file_read+0x96>
    a57a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    a580:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    a585:	e9 5c ff ff ff       	jmpq   a4e6 <file_read+0x96>
    a58a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    a590:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    a595:	e9 4c ff ff ff       	jmpq   a4e6 <file_read+0x96>
    a59a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    a5a0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    a5a5:	e9 3c ff ff ff       	jmpq   a4e6 <file_read+0x96>
    a5aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    a5b0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    a5b5:	e9 2c ff ff ff       	jmpq   a4e6 <file_read+0x96>
    a5ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    if (handle->file.offset != offset) {
        ret = INLINE_SYSCALL(lseek, 3, fd, offset, SEEK_SET);

        // pal_printf("file_read: 1 Handle Offset: %d Offset from call: %d Return of seek: %d FD: %d Offset: %d\n",handle->file.offset, offset, ret, fd, offset);
        if (IS_ERR(ret))
            return -PAL_ERROR_DENIED;
    a5c0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    a5c5:	e9 1c ff ff ff       	jmpq   a4e6 <file_read+0x96>
    a5ca:	90                   	nop    
    a5cb:	90                   	nop    
    a5cc:	90                   	nop    
    a5cd:	90                   	nop    
    a5ce:	90                   	nop    
    a5cf:	90                   	nop    

000000000000a5d0 <term_close>:

    return open_standard_term(handle, param, access);
}

static int term_close (PAL_HANDLE handle)
{
    a5d0:	55                   	push   %rbp
    return 0;
}
    a5d1:	31 c0                	xor    %eax,%eax

    return open_standard_term(handle, param, access);
}

static int term_close (PAL_HANDLE handle)
{
    a5d3:	48 89 e5             	mov    %rsp,%rbp
    return 0;
}
    a5d6:	5d                   	pop    %rbp
    a5d7:	c3                   	retq   
    a5d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    a5df:	00 

000000000000a5e0 <term_attrquery>:

/* 'attrquery' operation for terminal stream */
static int term_attrquery (const char * type, const char * uri,
                           PAL_STREAM_ATTR * attr)
{
    a5e0:	55                   	push   %rbp
    attr->access_time = 0;
    attr->change_time = 0;
    attr->create_time = 0;

    return 0;
}
    a5e1:	31 c0                	xor    %eax,%eax

/* 'attrquery' operation for terminal stream */
static int term_attrquery (const char * type, const char * uri,
                           PAL_STREAM_ATTR * attr)
{
    attr->type = pal_type_dev;
    a5e3:	c7 02 06 00 00 00    	movl   $0x6,(%rdx)
    attr->file_id = 0;
    a5e9:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
    a5f0:	00 
    attr->size = 0;
    a5f1:	48 c7 42 10 00 00 00 	movq   $0x0,0x10(%rdx)
    a5f8:	00 
}

/* 'attrquery' operation for terminal stream */
static int term_attrquery (const char * type, const char * uri,
                           PAL_STREAM_ATTR * attr)
{
    a5f9:	48 89 e5             	mov    %rsp,%rbp
    attr->type = pal_type_dev;
    attr->file_id = 0;
    attr->size = 0;
    attr->readable  = PAL_TRUE;
    a5fc:	c6 42 31 01          	movb   $0x1,0x31(%rdx)
    attr->writeable = PAL_TRUE;
    a600:	c6 42 32 01          	movb   $0x1,0x32(%rdx)
    attr->runnable  = PAL_FALSE;
    a604:	c6 42 33 00          	movb   $0x0,0x33(%rdx)
    attr->access_time = 0;
    a608:	48 c7 42 18 00 00 00 	movq   $0x0,0x18(%rdx)
    a60f:	00 
    attr->change_time = 0;
    a610:	48 c7 42 20 00 00 00 	movq   $0x0,0x20(%rdx)
    a617:	00 
    attr->create_time = 0;
    a618:	48 c7 42 28 00 00 00 	movq   $0x0,0x28(%rdx)
    a61f:	00 

    return 0;
}
    a620:	5d                   	pop    %rbp
    a621:	c3                   	retq   
    a622:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
    a629:	1f 84 00 00 00 00 00 

000000000000a630 <term_attrquerybyhdl>:

/* 'attrquery' operation for terminal stream */
static int term_attrquerybyhdl (PAL_HANDLE hdl,
                                PAL_STREAM_ATTR * attr)
{
    a630:	c7 06 06 00 00 00    	movl   $0x6,(%rsi)
    attr->type = pal_type_dev;
    attr->file_id = 0;
    a636:	48 c7 46 08 00 00 00 	movq   $0x0,0x8(%rsi)
    a63d:	00 
    attr->size = 0;
    a63e:	48 c7 46 10 00 00 00 	movq   $0x0,0x10(%rsi)
    a645:	00 
    attr->readable  = (hdl->dev.fd_in  != PAL_IDX_POISON);
    a646:	83 7f 0c ff          	cmpl   $0xffffffffffffffff,0xc(%rdi)
}

/* 'attrquery' operation for terminal stream */
static int term_attrquerybyhdl (PAL_HANDLE hdl,
                                PAL_STREAM_ATTR * attr)
{
    a64a:	55                   	push   %rbp
    a64b:	48 89 e5             	mov    %rsp,%rbp
    attr->type = pal_type_dev;
    attr->file_id = 0;
    attr->size = 0;
    attr->readable  = (hdl->dev.fd_in  != PAL_IDX_POISON);
    a64e:	0f 95 46 31          	setne  0x31(%rsi)
    attr->writeable = (hdl->dev.fd_out != PAL_IDX_POISON);
    a652:	83 7f 10 ff          	cmpl   $0xffffffffffffffff,0x10(%rdi)
    attr->access_time = 0;
    attr->change_time = 0;
    attr->create_time = 0;

    return 0;
}
    a656:	5d                   	pop    %rbp
    attr->type = pal_type_dev;
    attr->file_id = 0;
    attr->size = 0;
    attr->readable  = (hdl->dev.fd_in  != PAL_IDX_POISON);
    attr->writeable = (hdl->dev.fd_out != PAL_IDX_POISON);
    attr->runnable  = PAL_FALSE;
    a657:	c6 46 33 00          	movb   $0x0,0x33(%rsi)
    attr->access_time = 0;
    a65b:	48 c7 46 18 00 00 00 	movq   $0x0,0x18(%rsi)
    a662:	00 
    attr->change_time = 0;
    a663:	48 c7 46 20 00 00 00 	movq   $0x0,0x20(%rsi)
    a66a:	00 
    attr->create_time = 0;
    a66b:	48 c7 46 28 00 00 00 	movq   $0x0,0x28(%rsi)
    a672:	00 
{
    attr->type = pal_type_dev;
    attr->file_id = 0;
    attr->size = 0;
    attr->readable  = (hdl->dev.fd_in  != PAL_IDX_POISON);
    attr->writeable = (hdl->dev.fd_out != PAL_IDX_POISON);
    a673:	0f 95 46 32          	setne  0x32(%rsi)
    attr->access_time = 0;
    attr->change_time = 0;
    attr->create_time = 0;

    return 0;
}
    a677:	31 c0                	xor    %eax,%eax
    a679:	c3                   	retq   
    a67a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000a680 <dev_read>:
                     access, share, create, options);
}

/* 'read' operation for device stream */
static int dev_read (PAL_HANDLE handle, int offset, int size, void * buffer)
{
    a680:	83 7f 14 01          	cmpl   $0x1,0x14(%rdi)
    a684:	55                   	push   %rbp
    a685:	48 89 e5             	mov    %rsp,%rbp
    const struct handle_ops * ops = DEVICE_OPS(handle);
    a688:	74 07                	je     a691 <dev_read+0x11>

    if (!ops || !ops->read)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->read(handle, offset, size, buffer);
}
    a68a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    a68f:	5d                   	pop    %rbp
    a690:	c3                   	retq   
/* 'read' operation for device stream */
static int dev_read (PAL_HANDLE handle, int offset, int size, void * buffer)
{
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (!ops || !ops->read)
    a691:	48 8b 05 00 9a 21 00 	mov    0x219a00(%rip),%rax        # 224098 <term_ops+0x18>
    a698:	48 85 c0             	test   %rax,%rax
    a69b:	74 ed                	je     a68a <dev_read+0xa>
        return -PAL_ERROR_NOTSUPPORT;

    return ops->read(handle, offset, size, buffer);
}
    a69d:	5d                   	pop    %rbp
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (!ops || !ops->read)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->read(handle, offset, size, buffer);
    a69e:	ff e0                	jmpq   *%rax

000000000000a6a0 <dev_write>:
}

/* 'write' operation for device stream */
static int dev_write (PAL_HANDLE handle, int offset, int size,
                      const void * buffer)
{
    a6a0:	83 7f 14 01          	cmpl   $0x1,0x14(%rdi)
    a6a4:	55                   	push   %rbp
    a6a5:	48 89 e5             	mov    %rsp,%rbp
    const struct handle_ops * ops = DEVICE_OPS(handle);
    a6a8:	74 07                	je     a6b1 <dev_write+0x11>

    if (!ops || !ops->write)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->write(handle, offset, size, buffer);
}
    a6aa:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    a6af:	5d                   	pop    %rbp
    a6b0:	c3                   	retq   
static int dev_write (PAL_HANDLE handle, int offset, int size,
                      const void * buffer)
{
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (!ops || !ops->write)
    a6b1:	48 8b 05 e8 99 21 00 	mov    0x2199e8(%rip),%rax        # 2240a0 <term_ops+0x20>
    a6b8:	48 85 c0             	test   %rax,%rax
    a6bb:	74 ed                	je     a6aa <dev_write+0xa>
        return -PAL_ERROR_NOTSUPPORT;

    return ops->write(handle, offset, size, buffer);
}
    a6bd:	5d                   	pop    %rbp
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (!ops || !ops->write)
        return -PAL_ERROR_NOTSUPPORT;

    return ops->write(handle, offset, size, buffer);
    a6be:	ff e0                	jmpq   *%rax

000000000000a6c0 <dev_getrealpath>:

    return 0;
}

static const char * dev_getrealpath (PAL_HANDLE handle)
{
    a6c0:	55                   	push   %rbp
    return handle->dev.realpath;
    a6c1:	48 8b 47 20          	mov    0x20(%rdi),%rax

    return 0;
}

static const char * dev_getrealpath (PAL_HANDLE handle)
{
    a6c5:	48 89 e5             	mov    %rsp,%rbp
    return handle->dev.realpath;
}
    a6c8:	5d                   	pop    %rbp
    a6c9:	c3                   	retq   
    a6ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000a6d0 <term_open>:
}

/* 'open' operation for terminal stream */
static int term_open (PAL_HANDLE *handle, const char * type, const char * uri,
                      int access, int share, int create, int options)
{
    a6d0:	55                   	push   %rbp
    a6d1:	48 89 e5             	mov    %rsp,%rbp
    a6d4:	41 54                	push   %r12
    a6d6:	53                   	push   %rbx
    const char * term = NULL;
    const char * param = NULL;

    const char * tmp = uri;
    while (*tmp) {
    a6d7:	0f b6 02             	movzbl (%rdx),%eax
    a6da:	84 c0                	test   %al,%al
    a6dc:	74 4c                	je     a72a <term_open+0x5a>
    a6de:	48 83 c2 01          	add    $0x1,%rdx
    a6e2:	31 f6                	xor    %esi,%esi
    a6e4:	eb 1d                	jmp    a703 <term_open+0x33>
    a6e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    a6ed:	00 00 00 
        if (!term && *tmp == '/')
            term = tmp + 1;
        if (*tmp == ',') {
    a6f0:	3c 2c                	cmp    $0x2c,%al
    a6f2:	0f 84 8a 00 00 00    	je     a782 <term_open+0xb2>
{
    const char * term = NULL;
    const char * param = NULL;

    const char * tmp = uri;
    while (*tmp) {
    a6f8:	0f b6 02             	movzbl (%rdx),%eax
    a6fb:	48 83 c2 01          	add    $0x1,%rdx
    a6ff:	84 c0                	test   %al,%al
    a701:	74 1d                	je     a720 <term_open+0x50>
        if (!term && *tmp == '/')
    a703:	48 85 f6             	test   %rsi,%rsi
    a706:	75 e8                	jne    a6f0 <term_open+0x20>
    a708:	3c 2f                	cmp    $0x2f,%al
    a70a:	75 e4                	jne    a6f0 <term_open+0x20>
{
    const char * term = NULL;
    const char * param = NULL;

    const char * tmp = uri;
    while (*tmp) {
    a70c:	0f b6 02             	movzbl (%rdx),%eax
        if (!term && *tmp == '/')
            term = tmp + 1;
    a70f:	48 89 d6             	mov    %rdx,%rsi
    a712:	48 83 c2 01          	add    $0x1,%rdx
{
    const char * term = NULL;
    const char * param = NULL;

    const char * tmp = uri;
    while (*tmp) {
    a716:	84 c0                	test   %al,%al
    a718:	75 e9                	jne    a703 <term_open+0x33>
    a71a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            break;
        }
        tmp++;
    }

    if (term)
    a720:	48 85 f6             	test   %rsi,%rsi
        return -PAL_ERROR_NOTIMPLEMENTED;
    a723:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
            break;
        }
        tmp++;
    }

    if (term)
    a728:	75 5d                	jne    a787 <term_open+0xb7>
    a72a:	89 cb                	mov    %ecx,%ebx
    a72c:	49 89 fc             	mov    %rdi,%r12
                               int access)
{
    if (param)
        return -PAL_ERROR_NOTIMPLEMENTED;

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(dev));
    a72f:	bf 28 00 00 00       	mov    $0x28,%edi
    a734:	e8 c7 e2 ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, dev);
    hdl->dev.dev_type = device_type_term;

    if (!(access & PAL_ACCESS_WRONLY)) {
    a739:	f6 c3 01             	test   $0x1,%bl
{
    if (param)
        return -PAL_ERROR_NOTIMPLEMENTED;

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(dev));
    SET_HANDLE_TYPE(hdl, dev);
    a73c:	c7 00 06 00 00 00    	movl   $0x6,(%rax)
    a742:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    a749:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    hdl->dev.dev_type = device_type_term;
    a750:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%rax)

    if (!(access & PAL_ACCESS_WRONLY)) {
    a757:	75 0e                	jne    a767 <term_open+0x97>
        hdl->__in.flags |= RFD(0);
    a759:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)
        hdl->dev.fd_in = 0;
    a760:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%rax)
    }

    if (access & (PAL_ACCESS_WRONLY|PAL_ACCESS_RDWR)) {
    a767:	83 e3 03             	and    $0x3,%ebx
    a76a:	74 0b                	je     a777 <term_open+0xa7>
        hdl->__in.flags |= WFD(1);
    a76c:	83 48 08 10          	orl    $0x10,0x8(%rax)
        hdl->dev.fd_out = 1;
    a770:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%rax)
    }

    *handle = hdl;
    a777:	49 89 04 24          	mov    %rax,(%r12)
    return 0;
    a77b:	31 c0                	xor    %eax,%eax

    if (term)
        return -PAL_ERROR_NOTIMPLEMENTED;

    return open_standard_term(handle, param, access);
}
    a77d:	5b                   	pop    %rbx
    a77e:	41 5c                	pop    %r12
    a780:	5d                   	pop    %rbp
    a781:	c3                   	retq   
        }
        tmp++;
    }

    if (term)
        return -PAL_ERROR_NOTIMPLEMENTED;
    a782:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

    return open_standard_term(handle, param, access);
}
    a787:	5b                   	pop    %rbx
    a788:	41 5c                	pop    %r12
    a78a:	5d                   	pop    %rbp
    a78b:	c3                   	retq   
    a78c:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000a790 <dev_attrquerybyhdl>:
}

/* 'attrquerybyhdl' operation for device stream */
static int dev_attrquerybyhdl (PAL_HANDLE handle,
                               PAL_STREAM_ATTR * attr)
{
    a790:	55                   	push   %rbp
    a791:	48 89 e5             	mov    %rsp,%rbp
    a794:	41 55                	push   %r13
    a796:	41 54                	push   %r12
    a798:	53                   	push   %rbx
    a799:	49 89 fd             	mov    %rdi,%r13
    a79c:	49 89 f4             	mov    %rsi,%r12
    a79f:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    const struct handle_ops * ops = DEVICE_OPS(handle);
    a7a6:	83 7f 14 01          	cmpl   $0x1,0x14(%rdi)
    a7aa:	0f 84 11 01 00 00    	je     a8c1 <dev_attrquerybyhdl+0x131>
        return ops->attrquerybyhdl(handle, attr);

    struct stat stat_buf, * stat_in = NULL, * stat_out = NULL;
    int ret;

    attr->type = pal_type_dev;
    a7b0:	41 c7 04 24 06 00 00 	movl   $0x6,(%r12)
    a7b7:	00 
    attr->file_id = 0;
    a7b8:	49 c7 44 24 08 00 00 	movq   $0x0,0x8(%r12)
    a7bf:	00 00 

    if (handle->dev.fd_in != PAL_IDX_POISON) {
    a7c1:	41 8b 7d 0c          	mov    0xc(%r13),%edi
    a7c5:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    a7c8:	0f 84 42 01 00 00    	je     a910 <dev_attrquerybyhdl+0x180>
        ret = INLINE_SYSCALL(fstat, 2, handle->dev.fd_in, &stat_buf);
    a7ce:	b9 bd 00 00 00       	mov    $0xbd,%ecx
    a7d3:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
    a7da:	89 c8                	mov    %ecx,%eax
    a7dc:	cd 80                	int    $0x80
    a7de:	48 89 c2             	mov    %rax,%rdx
    a7e1:	bb 00 00 00 00       	mov    $0x0,%ebx
    a7e6:	83 d3 00             	adc    $0x0,%ebx
    a7e9:	31 c9                	xor    %ecx,%ecx
    a7eb:	85 db                	test   %ebx,%ebx
    a7ed:	0f 95 c1             	setne  %cl
    a7f0:	48 89 c8             	mov    %rcx,%rax
    a7f3:	48 f7 d8             	neg    %rax
    a7f6:	48 31 c2             	xor    %rax,%rdx

        if (!IS_ERR(ret))
    a7f9:	89 d0                	mov    %edx,%eax
    a7fb:	01 c8                	add    %ecx,%eax
    a7fd:	0f 88 4d 01 00 00    	js     a950 <dev_attrquerybyhdl+0x1c0>
            stat_in = &stat_buf;
    }

    attr->readable = (stat_in && stataccess(stat_in, ACCESS_R));
    a803:	48 8d 9d 60 ff ff ff 	lea    -0xa0(%rbp),%rbx
    a80a:	be 04 00 00 00       	mov    $0x4,%esi
    a80f:	48 89 df             	mov    %rbx,%rdi
    a812:	e8 99 4f 00 00       	callq  f7b0 <stataccess>
    attr->runnable = (stat_in && stataccess(stat_in, ACCESS_X));
    a817:	48 89 df             	mov    %rbx,%rdi

        if (!IS_ERR(ret))
            stat_in = &stat_buf;
    }

    attr->readable = (stat_in && stataccess(stat_in, ACCESS_R));
    a81a:	41 88 44 24 31       	mov    %al,0x31(%r12)
    attr->runnable = (stat_in && stataccess(stat_in, ACCESS_X));
    a81f:	be 01 00 00 00       	mov    $0x1,%esi
    a824:	e8 87 4f 00 00       	callq  f7b0 <stataccess>
    a829:	41 88 44 24 33       	mov    %al,0x33(%r12)

    if (stat_in) {
        attr->size = stat_in->st_size;
    a82e:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    a832:	49 89 44 24 10       	mov    %rax,0x10(%r12)
        attr->access_time = stat_in->st_atime;
    a837:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    a83e:	49 89 44 24 18       	mov    %rax,0x18(%r12)
        attr->change_time = stat_in->st_mtime;
    a843:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    a847:	49 89 44 24 20       	mov    %rax,0x20(%r12)
        attr->create_time = stat_in->st_ctime;
    a84c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    a850:	49 89 44 24 28       	mov    %rax,0x28(%r12)
    a855:	41 8b 7d 0c          	mov    0xc(%r13),%edi

    if (handle->dev.fd_in != PAL_IDX_POISON) {
        ret = INLINE_SYSCALL(fstat, 2, handle->dev.fd_in, &stat_buf);

        if (!IS_ERR(ret))
            stat_in = &stat_buf;
    a859:	49 89 dd             	mov    %rbx,%r13
        attr->access_time = stat_in->st_atime;
        attr->change_time = stat_in->st_mtime;
        attr->create_time = stat_in->st_ctime;
    }

    if (handle->dev.fd_in != PAL_IDX_POISON) {
    a85c:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    a85f:	0f 84 08 01 00 00    	je     a96d <dev_attrquerybyhdl+0x1dd>
        ret = INLINE_SYSCALL(fstat, 2, handle->dev.fd_in, &stat_buf);
    a865:	bb bd 00 00 00       	mov    $0xbd,%ebx
    a86a:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
    a871:	89 d8                	mov    %ebx,%eax
    a873:	cd 80                	int    $0x80
    a875:	48 89 c2             	mov    %rax,%rdx
    a878:	bb 00 00 00 00       	mov    $0x0,%ebx
    a87d:	83 d3 00             	adc    $0x0,%ebx
    a880:	31 c9                	xor    %ecx,%ecx
    a882:	85 db                	test   %ebx,%ebx
    a884:	0f 95 c1             	setne  %cl
    a887:	48 89 c8             	mov    %rcx,%rax
    a88a:	48 f7 d8             	neg    %rax
    a88d:	48 31 c2             	xor    %rax,%rdx

        if (!IS_ERR(ret))
    a890:	89 d0                	mov    %edx,%eax
    a892:	01 c8                	add    %ecx,%eax
    a894:	78 4b                	js     a8e1 <dev_attrquerybyhdl+0x151>
            stat_out = &stat_buf;
    }

    attr->writeable = (stat_out && stataccess(stat_out, ACCESS_W));
    a896:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
    a89d:	be 02 00 00 00       	mov    $0x2,%esi
    a8a2:	e8 09 4f 00 00       	callq  f7b0 <stataccess>

    if (!stat_in) {
    a8a7:	4d 85 ed             	test   %r13,%r13

        if (!IS_ERR(ret))
            stat_out = &stat_buf;
    }

    attr->writeable = (stat_out && stataccess(stat_out, ACCESS_W));
    a8aa:	41 88 44 24 32       	mov    %al,0x32(%r12)

    if (!stat_in) {
    a8af:	74 73                	je     a924 <dev_attrquerybyhdl+0x194>
        attr->change_time = stat_out ? stat_out->st_mtime : 0;
        attr->create_time = stat_out ? stat_out->st_ctime : 0;
    }

    return 0;
}
    a8b1:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    a8b8:	31 c0                	xor    %eax,%eax
    a8ba:	5b                   	pop    %rbx
    a8bb:	41 5c                	pop    %r12
    a8bd:	41 5d                	pop    %r13
    a8bf:	5d                   	pop    %rbp
    a8c0:	c3                   	retq   
static int dev_attrquerybyhdl (PAL_HANDLE handle,
                               PAL_STREAM_ATTR * attr)
{
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (ops && ops->attrquerybyhdl)
    a8c1:	48 8b 05 28 98 21 00 	mov    0x219828(%rip),%rax        # 2240f0 <term_ops+0x70>
    a8c8:	48 85 c0             	test   %rax,%rax
    a8cb:	0f 84 df fe ff ff    	je     a7b0 <dev_attrquerybyhdl+0x20>
        return ops->attrquerybyhdl(handle, attr);
    a8d1:	ff d0                	callq  *%rax
        attr->change_time = stat_out ? stat_out->st_mtime : 0;
        attr->create_time = stat_out ? stat_out->st_ctime : 0;
    }

    return 0;
}
    a8d3:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    a8da:	5b                   	pop    %rbx
    a8db:	41 5c                	pop    %r12
    a8dd:	41 5d                	pop    %r13
    a8df:	5d                   	pop    %rbp
    a8e0:	c3                   	retq   
            stat_out = &stat_buf;
    }

    attr->writeable = (stat_out && stataccess(stat_out, ACCESS_W));

    if (!stat_in) {
    a8e1:	4d 85 ed             	test   %r13,%r13

        if (!IS_ERR(ret))
            stat_out = &stat_buf;
    }

    attr->writeable = (stat_out && stataccess(stat_out, ACCESS_W));
    a8e4:	41 c6 44 24 32 00    	movb   $0x0,0x32(%r12)

    if (!stat_in) {
    a8ea:	75 c5                	jne    a8b1 <dev_attrquerybyhdl+0x121>
        attr->size = stat_out ? stat_out->st_size : 0;
    a8ec:	49 c7 44 24 10 00 00 	movq   $0x0,0x10(%r12)
    a8f3:	00 00 
        attr->access_time = stat_out ? stat_out->st_atime : 0;
    a8f5:	49 c7 44 24 18 00 00 	movq   $0x0,0x18(%r12)
    a8fc:	00 00 
        attr->change_time = stat_out ? stat_out->st_mtime : 0;
        attr->create_time = stat_out ? stat_out->st_ctime : 0;
    a8fe:	31 c0                	xor    %eax,%eax
    attr->writeable = (stat_out && stataccess(stat_out, ACCESS_W));

    if (!stat_in) {
        attr->size = stat_out ? stat_out->st_size : 0;
        attr->access_time = stat_out ? stat_out->st_atime : 0;
        attr->change_time = stat_out ? stat_out->st_mtime : 0;
    a900:	49 c7 44 24 20 00 00 	movq   $0x0,0x20(%r12)
    a907:	00 00 
    a909:	eb 3b                	jmp    a946 <dev_attrquerybyhdl+0x1b6>
    a90b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

        if (!IS_ERR(ret))
            stat_in = &stat_buf;
    }

    attr->readable = (stat_in && stataccess(stat_in, ACCESS_R));
    a910:	41 c6 44 24 31 00    	movb   $0x0,0x31(%r12)
    attr->runnable = (stat_in && stataccess(stat_in, ACCESS_X));
    a916:	41 c6 44 24 33 00    	movb   $0x0,0x33(%r12)

        if (!IS_ERR(ret))
            stat_out = &stat_buf;
    }

    attr->writeable = (stat_out && stataccess(stat_out, ACCESS_W));
    a91c:	41 c6 44 24 32 00    	movb   $0x0,0x32(%r12)
    a922:	eb c8                	jmp    a8ec <dev_attrquerybyhdl+0x15c>

    if (!stat_in) {
        attr->size = stat_out ? stat_out->st_size : 0;
    a924:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    a928:	49 89 44 24 10       	mov    %rax,0x10(%r12)
        attr->access_time = stat_out ? stat_out->st_atime : 0;
    a92d:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
    a934:	49 89 44 24 18       	mov    %rax,0x18(%r12)
        attr->change_time = stat_out ? stat_out->st_mtime : 0;
    a939:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    a93d:	49 89 44 24 20       	mov    %rax,0x20(%r12)
        attr->create_time = stat_out ? stat_out->st_ctime : 0;
    a942:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    a946:	49 89 44 24 28       	mov    %rax,0x28(%r12)
    a94b:	e9 61 ff ff ff       	jmpq   a8b1 <dev_attrquerybyhdl+0x121>
    a950:	41 8b 7d 0c          	mov    0xc(%r13),%edi

        if (!IS_ERR(ret))
            stat_in = &stat_buf;
    }

    attr->readable = (stat_in && stataccess(stat_in, ACCESS_R));
    a954:	41 c6 44 24 31 00    	movb   $0x0,0x31(%r12)
    attr->runnable = (stat_in && stataccess(stat_in, ACCESS_X));
    a95a:	41 c6 44 24 33 00    	movb   $0x0,0x33(%r12)
        attr->access_time = stat_in->st_atime;
        attr->change_time = stat_in->st_mtime;
        attr->create_time = stat_in->st_ctime;
    }

    if (handle->dev.fd_in != PAL_IDX_POISON) {
    a960:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    a963:	74 b7                	je     a91c <dev_attrquerybyhdl+0x18c>
    a965:	45 31 ed             	xor    %r13d,%r13d
    a968:	e9 f8 fe ff ff       	jmpq   a865 <dev_attrquerybyhdl+0xd5>

        if (!IS_ERR(ret))
            stat_out = &stat_buf;
    }

    attr->writeable = (stat_out && stataccess(stat_out, ACCESS_W));
    a96d:	41 c6 44 24 32 00    	movb   $0x0,0x32(%r12)
    a973:	e9 39 ff ff ff       	jmpq   a8b1 <dev_attrquerybyhdl+0x121>
    a978:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    a97f:	00 

000000000000a980 <parse_device_uri.constprop.3>:
            &term_ops,
        };

/* parse-device_uri scan the uri, parse the prefix of the uri and search
   for stream handler wich will open or access the device */
static int parse_device_uri (const char ** uri, const char ** type,
    a980:	55                   	push   %rbp
    a981:	48 89 e5             	mov    %rsp,%rbp
    a984:	41 57                	push   %r15
    a986:	41 56                	push   %r14
    a988:	41 55                	push   %r13
    a98a:	41 54                	push   %r12
    a98c:	53                   	push   %rbx
    a98d:	48 83 ec 08          	sub    $0x8,%rsp
                             struct handle_ops ** ops)
{
    struct handle_ops * dops = NULL;
    const char * p, * u = (*uri);
    a991:	4c 8b 27             	mov    (%rdi),%r12

    for (p = u ; (*p) && (*p) != ',' && (*p) != '/' ; p++);
    a994:	41 0f b6 04 24       	movzbl (%r12),%eax
    a999:	3c 2c                	cmp    $0x2c,%al
    a99b:	41 0f 95 c0          	setne  %r8b
    a99f:	84 c0                	test   %al,%al
    a9a1:	0f 95 c1             	setne  %cl
    a9a4:	41 84 c8             	test   %cl,%r8b
    a9a7:	74 30                	je     a9d9 <parse_device_uri.constprop.3+0x59>
    a9a9:	3c 2f                	cmp    $0x2f,%al
    a9ab:	74 2c                	je     a9d9 <parse_device_uri.constprop.3+0x59>
    a9ad:	4c 89 e3             	mov    %r12,%rbx
    a9b0:	eb 04                	jmp    a9b6 <parse_device_uri.constprop.3+0x36>
    a9b2:	3c 2f                	cmp    $0x2f,%al
    a9b4:	74 17                	je     a9cd <parse_device_uri.constprop.3+0x4d>
    a9b6:	48 83 c3 01          	add    $0x1,%rbx
    a9ba:	0f b6 03             	movzbl (%rbx),%eax
    a9bd:	3c 2c                	cmp    $0x2c,%al
    a9bf:	41 0f 95 c0          	setne  %r8b
    a9c3:	84 c0                	test   %al,%al
    a9c5:	0f 95 c1             	setne  %cl
    a9c8:	41 84 c8             	test   %cl,%r8b
    a9cb:	75 e5                	jne    a9b2 <parse_device_uri.constprop.3+0x32>
    a9cd:	48 89 d8             	mov    %rbx,%rax
    a9d0:	4c 29 e0             	sub    %r12,%rax

    switch (p - u) {
    a9d3:	48 83 f8 03          	cmp    $0x3,%rax
    a9d7:	74 17                	je     a9f0 <parse_device_uri.constprop.3+0x70>
        default:
            break;
    }

    if (!dops)
        return -PAL_ERROR_NOTSUPPORT;
    a9d9:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    if (type)
        *type = u;
    if (ops)
        *ops = dops;
    return 0;
}
    a9de:	48 83 c4 08          	add    $0x8,%rsp
    a9e2:	5b                   	pop    %rbx
    a9e3:	41 5c                	pop    %r12
    a9e5:	41 5d                	pop    %r13
    a9e7:	41 5e                	pop    %r14
    a9e9:	41 5f                	pop    %r15
    a9eb:	5d                   	pop    %rbp
    a9ec:	c3                   	retq   
    a9ed:	0f 1f 00             	nopl   (%rax)
    a9f0:	49 89 f7             	mov    %rsi,%r15

    for (p = u ; (*p) && (*p) != ',' && (*p) != '/' ; p++);

    switch (p - u) {
        case 3:
            if (!memcmp(u, "tty", 3))
    a9f3:	48 8d 35 2e e0 00 00 	lea    0xe02e(%rip),%rsi        # 18a28 <handle_sizes.1924+0x2a8>
    a9fa:	49 89 d5             	mov    %rdx,%r13
    a9fd:	49 89 fe             	mov    %rdi,%r14
    aa00:	ba 03 00 00 00       	mov    $0x3,%edx
    aa05:	4c 89 e7             	mov    %r12,%rdi
    aa08:	e8 03 b9 00 00       	callq  16310 <memcmp>
    aa0d:	85 c0                	test   %eax,%eax
    aa0f:	75 c8                	jne    a9d9 <parse_device_uri.constprop.3+0x59>
    }

    if (!dops)
        return -PAL_ERROR_NOTSUPPORT;

    *uri = (*p) ? p + 1 : p;
    aa11:	80 3b 00             	cmpb   $0x0,(%rbx)
    aa14:	48 8d 53 01          	lea    0x1(%rbx),%rdx
    aa18:	48 0f 45 da          	cmovne %rdx,%rbx
    if (type)
    aa1c:	4d 85 ff             	test   %r15,%r15
    }

    if (!dops)
        return -PAL_ERROR_NOTSUPPORT;

    *uri = (*p) ? p + 1 : p;
    aa1f:	49 89 1e             	mov    %rbx,(%r14)
    if (type)
    aa22:	74 03                	je     aa27 <parse_device_uri.constprop.3+0xa7>
        *type = u;
    aa24:	4d 89 27             	mov    %r12,(%r15)
    if (ops)
    aa27:	4d 85 ed             	test   %r13,%r13
    aa2a:	74 b2                	je     a9de <parse_device_uri.constprop.3+0x5e>
        *ops = dops;
    aa2c:	48 8d 35 4d 96 21 00 	lea    0x21964d(%rip),%rsi        # 224080 <term_ops>
    aa33:	49 89 75 00          	mov    %rsi,0x0(%r13)
    return 0;
}
    aa37:	48 83 c4 08          	add    $0x8,%rsp
    aa3b:	5b                   	pop    %rbx
    aa3c:	41 5c                	pop    %r12
    aa3e:	41 5d                	pop    %r13
    aa40:	41 5e                	pop    %r14
    aa42:	41 5f                	pop    %r15
    aa44:	5d                   	pop    %rbp
    aa45:	c3                   	retq   
    aa46:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    aa4d:	00 00 00 

000000000000aa50 <dev_open>:
}

/* 'open' operation for device streams */
static int dev_open (PAL_HANDLE * handle, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    aa50:	55                   	push   %rbp
    aa51:	48 89 e5             	mov    %rsp,%rbp
    aa54:	41 56                	push   %r14
    aa56:	41 55                	push   %r13
    aa58:	41 54                	push   %r12
    aa5a:	53                   	push   %rbx
    struct handle_ops * ops = NULL;
    const char * dev_type = NULL;
    int ret = 0;

    ret = parse_device_uri(&uri, &dev_type, &ops);
    aa5b:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
}

/* 'open' operation for device streams */
static int dev_open (PAL_HANDLE * handle, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    aa5f:	48 89 fb             	mov    %rdi,%rbx
    struct handle_ops * ops = NULL;
    const char * dev_type = NULL;
    int ret = 0;

    ret = parse_device_uri(&uri, &dev_type, &ops);
    aa62:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
}

/* 'open' operation for device streams */
static int dev_open (PAL_HANDLE * handle, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    aa66:	41 89 cc             	mov    %ecx,%r12d
    aa69:	48 83 ec 20          	sub    $0x20,%rsp
    aa6d:	48 89 55 c8          	mov    %rdx,-0x38(%rbp)
    struct handle_ops * ops = NULL;
    const char * dev_type = NULL;
    int ret = 0;

    ret = parse_device_uri(&uri, &dev_type, &ops);
    aa71:	48 8d 55 d0          	lea    -0x30(%rbp),%rdx
}

/* 'open' operation for device streams */
static int dev_open (PAL_HANDLE * handle, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    aa75:	45 89 c5             	mov    %r8d,%r13d
    aa78:	45 89 ce             	mov    %r9d,%r14d
    struct handle_ops * ops = NULL;
    aa7b:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    aa82:	00 
    const char * dev_type = NULL;
    aa83:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
    aa8a:	00 
    int ret = 0;

    ret = parse_device_uri(&uri, &dev_type, &ops);
    aa8b:	e8 f0 fe ff ff       	callq  a980 <parse_device_uri.constprop.3>

    if (ret < 0)
    aa90:	85 c0                	test   %eax,%eax
    aa92:	78 4b                	js     aadf <dev_open+0x8f>
        return ret;

    if (!ops->open)
    aa94:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    aa98:	48 83 78 10 00       	cmpq   $0x0,0x10(%rax)
    aa9d:	74 51                	je     aaf0 <dev_open+0xa0>
            return -PAL_ERROR_NOTSUPPORT;

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(dev));
    aa9f:	bf 28 00 00 00       	mov    $0x28,%edi
    aaa4:	e8 57 df ff ff       	callq  8a00 <malloc>
    hdl->dev.fd_in  = PAL_IDX_POISON;
    aaa9:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rax)
    hdl->dev.fd_out = PAL_IDX_POISON;
    aab0:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rax)
    *handle = hdl;

    return ops->open(handle, dev_type, uri,
    aab7:	48 83 ec 08          	sub    $0x8,%rsp
            return -PAL_ERROR_NOTSUPPORT;

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(dev));
    hdl->dev.fd_in  = PAL_IDX_POISON;
    hdl->dev.fd_out = PAL_IDX_POISON;
    *handle = hdl;
    aabb:	48 89 03             	mov    %rax,(%rbx)

    return ops->open(handle, dev_type, uri,
    aabe:	8b 45 10             	mov    0x10(%rbp),%eax
    aac1:	44 89 e1             	mov    %r12d,%ecx
    aac4:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    aac8:	45 89 f1             	mov    %r14d,%r9d
    aacb:	45 89 e8             	mov    %r13d,%r8d
    aace:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
    aad2:	48 89 df             	mov    %rbx,%rdi
    aad5:	50                   	push   %rax
    aad6:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
    aada:	ff 50 10             	callq  *0x10(%rax)
    aadd:	5a                   	pop    %rdx
    aade:	59                   	pop    %rcx
                     access, share, create, options);
}
    aadf:	48 8d 65 e0          	lea    -0x20(%rbp),%rsp
    aae3:	5b                   	pop    %rbx
    aae4:	41 5c                	pop    %r12
    aae6:	41 5d                	pop    %r13
    aae8:	41 5e                	pop    %r14
    aaea:	5d                   	pop    %rbp
    aaeb:	c3                   	retq   
    aaec:	0f 1f 40 00          	nopl   0x0(%rax)

    if (ret < 0)
        return ret;

    if (!ops->open)
            return -PAL_ERROR_NOTSUPPORT;
    aaf0:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    aaf5:	eb e8                	jmp    aadf <dev_open+0x8f>
    aaf7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    aafe:	00 00 

000000000000ab00 <dev_attrquery>:
}

/* 'attrquery' operation for device streams */
static int dev_attrquery (const char * type, const char * uri,
                          PAL_STREAM_ATTR * attr)
{
    ab00:	55                   	push   %rbp
    ab01:	48 89 e5             	mov    %rsp,%rbp
    ab04:	53                   	push   %rbx
    ab05:	48 89 d3             	mov    %rdx,%rbx
    struct handle_ops * ops = NULL;
    const char * dev_type = NULL;
    int ret = 0;

    ret = parse_device_uri(&uri, &dev_type, &ops);
    ab08:	48 8d 7d d8          	lea    -0x28(%rbp),%rdi
    ab0c:	48 8d 55 e0          	lea    -0x20(%rbp),%rdx
}

/* 'attrquery' operation for device streams */
static int dev_attrquery (const char * type, const char * uri,
                          PAL_STREAM_ATTR * attr)
{
    ab10:	48 83 ec 28          	sub    $0x28,%rsp
    ab14:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
    struct handle_ops * ops = NULL;
    const char * dev_type = NULL;
    int ret = 0;

    ret = parse_device_uri(&uri, &dev_type, &ops);
    ab18:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi

/* 'attrquery' operation for device streams */
static int dev_attrquery (const char * type, const char * uri,
                          PAL_STREAM_ATTR * attr)
{
    struct handle_ops * ops = NULL;
    ab1c:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    ab23:	00 
    const char * dev_type = NULL;
    ab24:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
    ab2b:	00 
    int ret = 0;

    ret = parse_device_uri(&uri, &dev_type, &ops);
    ab2c:	e8 4f fe ff ff       	callq  a980 <parse_device_uri.constprop.3>

    if (ret < 0)
    ab31:	85 c0                	test   %eax,%eax
    ab33:	78 1f                	js     ab54 <dev_attrquery+0x54>
        return ret;

    if (!ops || !ops->attrquery)
    ab35:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
    ab39:	48 85 c0             	test   %rax,%rax
    ab3c:	74 22                	je     ab60 <dev_attrquery+0x60>
    ab3e:	48 8b 40 68          	mov    0x68(%rax),%rax
    ab42:	48 85 c0             	test   %rax,%rax
    ab45:	74 19                	je     ab60 <dev_attrquery+0x60>
        return -PAL_ERROR_NOTSUPPORT;

    return ops->attrquery(dev_type, uri, attr);
    ab47:	48 89 da             	mov    %rbx,%rdx
    ab4a:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
    ab4e:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
    ab52:	ff d0                	callq  *%rax
}
    ab54:	48 83 c4 28          	add    $0x28,%rsp
    ab58:	5b                   	pop    %rbx
    ab59:	5d                   	pop    %rbp
    ab5a:	c3                   	retq   
    ab5b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

    if (ret < 0)
        return ret;

    if (!ops || !ops->attrquery)
        return -PAL_ERROR_NOTSUPPORT;
    ab60:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
    ab65:	eb ed                	jmp    ab54 <dev_attrquery+0x54>
    ab67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ab6e:	00 00 

000000000000ab70 <char_write>:
}

/* 'write' operation for character streams. */
static int char_write (PAL_HANDLE handle, int offset, int size,
                      const void * buffer)
{
    ab70:	48 63 7f 10          	movslq 0x10(%rdi),%rdi
    int fd = handle->dev.fd_out;

    if (fd == PAL_IDX_POISON)
    ab74:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    ab77:	0f 84 23 01 00 00    	je     aca0 <char_write+0x130>
}

/* 'write' operation for character streams. */
static int char_write (PAL_HANDLE handle, int offset, int size,
                      const void * buffer)
{
    ab7d:	55                   	push   %rbp
    int fd = handle->dev.fd_out;

    if (fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;

    int bytes = INLINE_SYSCALL(write, 3, fd, buffer, size);
    ab7e:	48 63 d2             	movslq %edx,%rdx
    ab81:	48 89 ce             	mov    %rcx,%rsi
}

/* 'write' operation for character streams. */
static int char_write (PAL_HANDLE handle, int offset, int size,
                      const void * buffer)
{
    ab84:	48 89 e5             	mov    %rsp,%rbp
    ab87:	53                   	push   %rbx
    int fd = handle->dev.fd_out;

    if (fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;

    int bytes = INLINE_SYSCALL(write, 3, fd, buffer, size);
    ab88:	bb 04 00 00 00       	mov    $0x4,%ebx
    ab8d:	89 d8                	mov    %ebx,%eax
    ab8f:	cd 80                	int    $0x80
    ab91:	48 89 c2             	mov    %rax,%rdx
    ab94:	bb 00 00 00 00       	mov    $0x0,%ebx
    ab99:	83 d3 00             	adc    $0x0,%ebx
    ab9c:	31 c9                	xor    %ecx,%ecx
    ab9e:	85 db                	test   %ebx,%ebx
    aba0:	0f 95 c1             	setne  %cl
    aba3:	48 89 c8             	mov    %rcx,%rax
    aba6:	48 f7 d8             	neg    %rax
    aba9:	48 31 d0             	xor    %rdx,%rax
    abac:	48 8d 14 08          	lea    (%rax,%rcx,1),%rdx

    if (IS_ERR(bytes))
    abb0:	85 d2                	test   %edx,%edx
    abb2:	89 d0                	mov    %edx,%eax
    abb4:	78 0a                	js     abc0 <char_write+0x50>
        return unix_to_pal_error(ERRNO(bytes));

    return bytes;
}
    abb6:	5b                   	pop    %rbx
    abb7:	5d                   	pop    %rbp
    abb8:	c3                   	retq   
    abb9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        return -PAL_ERROR_DENIED;

    int bytes = INLINE_SYSCALL(write, 3, fd, buffer, size);

    if (IS_ERR(bytes))
        return unix_to_pal_error(ERRNO(bytes));
    abc0:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    abc2:	83 fa 6e             	cmp    $0x6e,%edx
    abc5:	0f 87 c5 00 00 00    	ja     ac90 <char_write+0x120>
    abcb:	48 8d 05 46 f8 00 00 	lea    0xf846(%rip),%rax        # 1a418 <slab_levels+0x1178>
    abd2:	89 d2                	mov    %edx,%edx
    abd4:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    abd8:	48 01 d0             	add    %rdx,%rax
    abdb:	ff e0                	jmpq   *%rax
    abdd:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    abe0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    abe5:	eb cf                	jmp    abb6 <char_write+0x46>
    abe7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    abee:	00 00 
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    abf0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    abf5:	eb bf                	jmp    abb6 <char_write+0x46>
    abf7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    abfe:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    ac00:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    ac05:	eb af                	jmp    abb6 <char_write+0x46>
    ac07:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ac0e:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    ac10:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    ac15:	eb 9f                	jmp    abb6 <char_write+0x46>
    ac17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ac1e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    ac20:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    ac25:	eb 8f                	jmp    abb6 <char_write+0x46>
    ac27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ac2e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    ac30:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    ac35:	e9 7c ff ff ff       	jmpq   abb6 <char_write+0x46>
    ac3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    ac40:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    ac45:	e9 6c ff ff ff       	jmpq   abb6 <char_write+0x46>
    ac4a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    ac50:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    ac55:	e9 5c ff ff ff       	jmpq   abb6 <char_write+0x46>
    ac5a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    ac60:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    ac65:	e9 4c ff ff ff       	jmpq   abb6 <char_write+0x46>
    ac6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    ac70:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    ac75:	e9 3c ff ff ff       	jmpq   abb6 <char_write+0x46>
    ac7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    ac80:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    ac85:	e9 2c ff ff ff       	jmpq   abb6 <char_write+0x46>
    ac8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    ac90:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    ac95:	e9 1c ff ff ff       	jmpq   abb6 <char_write+0x46>
    ac9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                      const void * buffer)
{
    int fd = handle->dev.fd_out;

    if (fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;
    aca0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax

    if (IS_ERR(bytes))
        return unix_to_pal_error(ERRNO(bytes));

    return bytes;
}
    aca5:	c3                   	retq   
    aca6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    acad:	00 00 00 

000000000000acb0 <char_read>:
        .attrquerybyhdl = &term_attrquerybyhdl,
    };

/* 'read' operation for character streams. */
static int char_read (PAL_HANDLE handle, int offset, int size, void * buffer)
{
    acb0:	48 63 7f 0c          	movslq 0xc(%rdi),%rdi
    int fd = handle->dev.fd_in;

    if (fd == PAL_IDX_POISON)
    acb4:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    acb7:	0f 84 23 01 00 00    	je     ade0 <char_read+0x130>
        .attrquerybyhdl = &term_attrquerybyhdl,
    };

/* 'read' operation for character streams. */
static int char_read (PAL_HANDLE handle, int offset, int size, void * buffer)
{
    acbd:	55                   	push   %rbp
    int fd = handle->dev.fd_in;

    if (fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;

    int bytes = INLINE_SYSCALL(read, 3, fd, buffer, size);
    acbe:	48 63 d2             	movslq %edx,%rdx
    acc1:	48 89 ce             	mov    %rcx,%rsi
        .attrquerybyhdl = &term_attrquerybyhdl,
    };

/* 'read' operation for character streams. */
static int char_read (PAL_HANDLE handle, int offset, int size, void * buffer)
{
    acc4:	48 89 e5             	mov    %rsp,%rbp
    acc7:	53                   	push   %rbx
    int fd = handle->dev.fd_in;

    if (fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;

    int bytes = INLINE_SYSCALL(read, 3, fd, buffer, size);
    acc8:	bb 03 00 00 00       	mov    $0x3,%ebx
    accd:	89 d8                	mov    %ebx,%eax
    accf:	cd 80                	int    $0x80
    acd1:	48 89 c2             	mov    %rax,%rdx
    acd4:	bb 00 00 00 00       	mov    $0x0,%ebx
    acd9:	83 d3 00             	adc    $0x0,%ebx
    acdc:	31 c9                	xor    %ecx,%ecx
    acde:	85 db                	test   %ebx,%ebx
    ace0:	0f 95 c1             	setne  %cl
    ace3:	48 89 c8             	mov    %rcx,%rax
    ace6:	48 f7 d8             	neg    %rax
    ace9:	48 31 d0             	xor    %rdx,%rax
    acec:	48 8d 14 08          	lea    (%rax,%rcx,1),%rdx

    if (IS_ERR(bytes))
    acf0:	85 d2                	test   %edx,%edx
    acf2:	89 d0                	mov    %edx,%eax
    acf4:	78 0a                	js     ad00 <char_read+0x50>
        return unix_to_pal_error(ERRNO(bytes));

    return bytes;
}
    acf6:	5b                   	pop    %rbx
    acf7:	5d                   	pop    %rbp
    acf8:	c3                   	retq   
    acf9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        return -PAL_ERROR_DENIED;

    int bytes = INLINE_SYSCALL(read, 3, fd, buffer, size);

    if (IS_ERR(bytes))
        return unix_to_pal_error(ERRNO(bytes));
    ad00:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    ad02:	83 fa 6e             	cmp    $0x6e,%edx
    ad05:	0f 87 c5 00 00 00    	ja     add0 <char_read+0x120>
    ad0b:	48 8d 05 c2 f8 00 00 	lea    0xf8c2(%rip),%rax        # 1a5d4 <slab_levels+0x1334>
    ad12:	89 d2                	mov    %edx,%edx
    ad14:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    ad18:	48 01 d0             	add    %rdx,%rax
    ad1b:	ff e0                	jmpq   *%rax
    ad1d:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    ad20:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    ad25:	eb cf                	jmp    acf6 <char_read+0x46>
    ad27:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ad2e:	00 00 
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    ad30:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    ad35:	eb bf                	jmp    acf6 <char_read+0x46>
    ad37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ad3e:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    ad40:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    ad45:	eb af                	jmp    acf6 <char_read+0x46>
    ad47:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ad4e:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    ad50:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    ad55:	eb 9f                	jmp    acf6 <char_read+0x46>
    ad57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ad5e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    ad60:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    ad65:	eb 8f                	jmp    acf6 <char_read+0x46>
    ad67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ad6e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    ad70:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    ad75:	e9 7c ff ff ff       	jmpq   acf6 <char_read+0x46>
    ad7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    ad80:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    ad85:	e9 6c ff ff ff       	jmpq   acf6 <char_read+0x46>
    ad8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    ad90:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    ad95:	e9 5c ff ff ff       	jmpq   acf6 <char_read+0x46>
    ad9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    ada0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    ada5:	e9 4c ff ff ff       	jmpq   acf6 <char_read+0x46>
    adaa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    adb0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    adb5:	e9 3c ff ff ff       	jmpq   acf6 <char_read+0x46>
    adba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    adc0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    adc5:	e9 2c ff ff ff       	jmpq   acf6 <char_read+0x46>
    adca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    add0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    add5:	e9 1c ff ff ff       	jmpq   acf6 <char_read+0x46>
    adda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
static int char_read (PAL_HANDLE handle, int offset, int size, void * buffer)
{
    int fd = handle->dev.fd_in;

    if (fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;
    ade0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax

    if (IS_ERR(bytes))
        return unix_to_pal_error(ERRNO(bytes));

    return bytes;
}
    ade5:	c3                   	retq   
    ade6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    aded:	00 00 00 

000000000000adf0 <dev_flush>:
    return ops->delete(handle, access);
}

/* 'flush' operation for device streams */
static int dev_flush (PAL_HANDLE handle)
{
    adf0:	55                   	push   %rbp
    adf1:	48 89 fa             	mov    %rdi,%rdx
    adf4:	48 89 e5             	mov    %rsp,%rbp
    adf7:	53                   	push   %rbx
    const struct handle_ops * ops = DEVICE_OPS(handle);
    adf8:	83 7f 14 01          	cmpl   $0x1,0x14(%rdi)
    adfc:	74 73                	je     ae71 <dev_flush+0x81>

    if (ops && ops->flush)
        return ops->flush(handle);

    /* try to flush input stream */
    if (handle->dev.fd_in != PAL_IDX_POISON) {
    adfe:	48 63 7a 0c          	movslq 0xc(%rdx),%rdi
    ae02:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    ae05:	74 2b                	je     ae32 <dev_flush+0x42>
        int fd = handle->dev.fd_in;

        int ret = INLINE_SYSCALL(fsync, 1, fd);
    ae07:	bb 5f 00 00 00       	mov    $0x5f,%ebx
    ae0c:	89 d8                	mov    %ebx,%eax
    ae0e:	cd 80                	int    $0x80
    ae10:	48 89 c6             	mov    %rax,%rsi
    ae13:	bb 00 00 00 00       	mov    $0x0,%ebx
    ae18:	83 d3 00             	adc    $0x0,%ebx
    ae1b:	31 c9                	xor    %ecx,%ecx
    ae1d:	85 db                	test   %ebx,%ebx
    ae1f:	0f 95 c1             	setne  %cl
    ae22:	48 89 c8             	mov    %rcx,%rax
    ae25:	48 f7 d8             	neg    %rax
    ae28:	48 31 c6             	xor    %rax,%rsi
    ae2b:	48 01 f1             	add    %rsi,%rcx

        if (IS_ERR(ret)) {
    ae2e:	85 c9                	test   %ecx,%ecx
    ae30:	78 7e                	js     aeb0 <dev_flush+0xc0>
        }
    }

    /* if output stream exists and does not equal to input stream,
       flush output stream as well */
    if (handle->dev.fd_out != PAL_IDX_POISON &&
    ae32:	48 63 7a 10          	movslq 0x10(%rdx),%rdi
    ae36:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    ae39:	74 31                	je     ae6c <dev_flush+0x7c>
    ae3b:	3b 7a 0c             	cmp    0xc(%rdx),%edi
    ae3e:	74 2c                	je     ae6c <dev_flush+0x7c>
        handle->dev.fd_out != handle->dev.fd_in) {
        int fd = handle->dev.fd_out;

        int ret = INLINE_SYSCALL(fsync, 1, fd);
    ae40:	be 5f 00 00 00       	mov    $0x5f,%esi
    ae45:	89 f0                	mov    %esi,%eax
    ae47:	cd 80                	int    $0x80
    ae49:	48 89 c1             	mov    %rax,%rcx
    ae4c:	bb 00 00 00 00       	mov    $0x0,%ebx
    ae51:	83 d3 00             	adc    $0x0,%ebx
    ae54:	31 d2                	xor    %edx,%edx
    ae56:	85 db                	test   %ebx,%ebx
    ae58:	0f 95 c2             	setne  %dl
    ae5b:	48 89 d0             	mov    %rdx,%rax
    ae5e:	48 f7 d8             	neg    %rax
    ae61:	48 31 c1             	xor    %rax,%rcx
    ae64:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax

        if (IS_ERR(ret)) {
    ae68:	85 c0                	test   %eax,%eax
    ae6a:	78 15                	js     ae81 <dev_flush+0x91>
            else
                return unix_to_pal_error(ERRNO(ret));
        }
    }

    return 0;
    ae6c:	31 c0                	xor    %eax,%eax
}
    ae6e:	5b                   	pop    %rbx
    ae6f:	5d                   	pop    %rbp
    ae70:	c3                   	retq   
/* 'flush' operation for device streams */
static int dev_flush (PAL_HANDLE handle)
{
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (ops && ops->flush)
    ae71:	48 8b 05 60 92 21 00 	mov    0x219260(%rip),%rax        # 2240d8 <term_ops+0x58>
    ae78:	48 85 c0             	test   %rax,%rax
    ae7b:	74 81                	je     adfe <dev_flush+0xe>
                return unix_to_pal_error(ERRNO(ret));
        }
    }

    return 0;
}
    ae7d:	5b                   	pop    %rbx
    ae7e:	5d                   	pop    %rbp
static int dev_flush (PAL_HANDLE handle)
{
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (ops && ops->flush)
        return ops->flush(handle);
    ae7f:	ff e0                	jmpq   *%rax
        int fd = handle->dev.fd_out;

        int ret = INLINE_SYSCALL(fsync, 1, fd);

        if (IS_ERR(ret)) {
            if (ERRNO(ret) == EBADF || ERRNO(ret) == EINVAL)
    ae81:	83 f8 ea             	cmp    $0xffffffffffffffea,%eax
    ae84:	74 5a                	je     aee0 <dev_flush+0xf0>
    ae86:	83 f8 f7             	cmp    $0xfffffffffffffff7,%eax
    ae89:	74 55                	je     aee0 <dev_flush+0xf0>
                return -PAL_ERROR_BADHANDLE;
            else
                return unix_to_pal_error(ERRNO(ret));
    ae8b:	f7 d8                	neg    %eax
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    ae8d:	83 f8 6e             	cmp    $0x6e,%eax
    ae90:	0f 87 fa 00 00 00    	ja     af90 <dev_flush+0x1a0>
    ae96:	48 8d 15 f3 f8 00 00 	lea    0xf8f3(%rip),%rdx        # 1a790 <slab_levels+0x14f0>
    ae9d:	89 c0                	mov    %eax,%eax
    ae9f:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    aea3:	48 01 c2             	add    %rax,%rdx
    aea6:	ff e2                	jmpq   *%rdx
    aea8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    aeaf:	00 
        int fd = handle->dev.fd_in;

        int ret = INLINE_SYSCALL(fsync, 1, fd);

        if (IS_ERR(ret)) {
            if (ERRNO(ret) == EBADF || ERRNO(ret) == EINVAL)
    aeb0:	83 f9 ea             	cmp    $0xffffffffffffffea,%ecx
    aeb3:	74 2b                	je     aee0 <dev_flush+0xf0>
    aeb5:	83 f9 f7             	cmp    $0xfffffffffffffff7,%ecx
    aeb8:	74 26                	je     aee0 <dev_flush+0xf0>
                return -PAL_ERROR_BADHANDLE;
            else
                return unix_to_pal_error(ERRNO(ret));
    aeba:	f7 d9                	neg    %ecx
    aebc:	83 f9 6e             	cmp    $0x6e,%ecx
    aebf:	0f 87 cb 00 00 00    	ja     af90 <dev_flush+0x1a0>
    aec5:	48 8d 05 80 fa 00 00 	lea    0xfa80(%rip),%rax        # 1a94c <slab_levels+0x16ac>
    aecc:	89 c9                	mov    %ecx,%ecx
    aece:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    aed2:	48 01 d0             	add    %rdx,%rax
    aed5:	ff e0                	jmpq   *%rax
    aed7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    aede:	00 00 
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    aee0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    aee5:	eb 87                	jmp    ae6e <dev_flush+0x7e>
    aee7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    aeee:	00 00 
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    aef0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    aef5:	e9 74 ff ff ff       	jmpq   ae6e <dev_flush+0x7e>
    aefa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    af00:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    af05:	e9 64 ff ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    af10:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    af15:	e9 54 ff ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    af20:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    af25:	e9 44 ff ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af2a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    af30:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    af35:	e9 34 ff ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af3a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    af40:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    af45:	e9 24 ff ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af4a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    af50:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    af55:	e9 14 ff ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af5a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    af60:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    af65:	e9 04 ff ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    af70:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    af75:	e9 f4 fe ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    af80:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    af85:	e9 e4 fe ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    af90:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    af95:	e9 d4 fe ff ff       	jmpq   ae6e <dev_flush+0x7e>
    af9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000afa0 <dev_close>:
    return ops->write(handle, offset, size, buffer);
}

/* 'close' operation for device streams */
static int dev_close (PAL_HANDLE handle)
{
    afa0:	55                   	push   %rbp
    afa1:	48 89 fa             	mov    %rdi,%rdx
    afa4:	48 89 e5             	mov    %rsp,%rbp
    afa7:	53                   	push   %rbx
    afa8:	48 83 ec 08          	sub    $0x8,%rsp
    const struct handle_ops * ops = DEVICE_OPS(handle);
    afac:	83 7f 14 01          	cmpl   $0x1,0x14(%rdi)
    afb0:	0f 84 8a 00 00 00    	je     b040 <dev_close+0xa0>

    if (ops && ops->close)
        return ops->close(handle);

    if (handle->dev.fd_in != PAL_IDX_POISON) {
    afb6:	48 63 7a 0c          	movslq 0xc(%rdx),%rdi
    afba:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    afbd:	74 2b                	je     afea <dev_close+0x4a>
        int fd = handle->dev.fd_in;

        int ret = INLINE_SYSCALL(close, 1, fd);
    afbf:	bb 06 00 00 00       	mov    $0x6,%ebx
    afc4:	89 d8                	mov    %ebx,%eax
    afc6:	cd 80                	int    $0x80
    afc8:	48 89 c6             	mov    %rax,%rsi
    afcb:	bb 00 00 00 00       	mov    $0x0,%ebx
    afd0:	83 d3 00             	adc    $0x0,%ebx
    afd3:	31 c9                	xor    %ecx,%ecx
    afd5:	85 db                	test   %ebx,%ebx
    afd7:	0f 95 c1             	setne  %cl
    afda:	48 89 c8             	mov    %rcx,%rax
    afdd:	48 f7 d8             	neg    %rax
    afe0:	48 31 c6             	xor    %rax,%rsi
    afe3:	48 01 f1             	add    %rsi,%rcx

        if (IS_ERR(ret)) {
    afe6:	85 c9                	test   %ecx,%ecx
    afe8:	78 76                	js     b060 <dev_close+0xc0>
            if (ERRNO(ret) != EBADF && ERRNO(ret) != EINVAL)
                return unix_to_pal_error(ERRNO(ret));
        }
    }

    if (handle->dev.fd_out != PAL_IDX_POISON) {
    afea:	48 63 7a 10          	movslq 0x10(%rdx),%rdi
    afee:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    aff1:	74 2b                	je     b01e <dev_close+0x7e>
        int fd = handle->dev.fd_out;

        int ret = INLINE_SYSCALL(close, 1, fd);
    aff3:	be 06 00 00 00       	mov    $0x6,%esi
    aff8:	89 f0                	mov    %esi,%eax
    affa:	cd 80                	int    $0x80
    affc:	48 89 c6             	mov    %rax,%rsi
    afff:	bb 00 00 00 00       	mov    $0x0,%ebx
    b004:	83 d3 00             	adc    $0x0,%ebx
    b007:	31 c9                	xor    %ecx,%ecx
    b009:	85 db                	test   %ebx,%ebx
    b00b:	0f 95 c1             	setne  %cl
    b00e:	48 89 c8             	mov    %rcx,%rax
    b011:	48 f7 d8             	neg    %rax
    b014:	48 31 c6             	xor    %rax,%rsi
    b017:	48 01 f1             	add    %rsi,%rcx

        if (IS_ERR(ret)) {
    b01a:	85 c9                	test   %ecx,%ecx
    b01c:	78 72                	js     b090 <dev_close+0xf0>
            if (ERRNO(ret) != EBADF && ERRNO(ret) != EINVAL)
                return unix_to_pal_error(ERRNO(ret));
        }
    }

    if (handle->file.realpath)
    b01e:	48 8b 7a 20          	mov    0x20(%rdx),%rdi
        free((void *) handle->file.realpath);

    return 0;
    b022:	31 db                	xor    %ebx,%ebx
            if (ERRNO(ret) != EBADF && ERRNO(ret) != EINVAL)
                return unix_to_pal_error(ERRNO(ret));
        }
    }

    if (handle->file.realpath)
    b024:	48 85 ff             	test   %rdi,%rdi
    b027:	74 05                	je     b02e <dev_close+0x8e>
        free((void *) handle->file.realpath);
    b029:	e8 62 dc ff ff       	callq  8c90 <free>

    return 0;
}
    b02e:	48 83 c4 08          	add    $0x8,%rsp
    b032:	89 d8                	mov    %ebx,%eax
    b034:	5b                   	pop    %rbx
    b035:	5d                   	pop    %rbp
    b036:	c3                   	retq   
    b037:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    b03e:	00 00 
/* 'close' operation for device streams */
static int dev_close (PAL_HANDLE handle)
{
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (ops && ops->close)
    b040:	48 8b 05 71 90 21 00 	mov    0x219071(%rip),%rax        # 2240b8 <term_ops+0x38>
    b047:	48 85 c0             	test   %rax,%rax
    b04a:	0f 84 66 ff ff ff    	je     afb6 <dev_close+0x16>

    if (handle->file.realpath)
        free((void *) handle->file.realpath);

    return 0;
}
    b050:	48 83 c4 08          	add    $0x8,%rsp
    b054:	5b                   	pop    %rbx
    b055:	5d                   	pop    %rbp
static int dev_close (PAL_HANDLE handle)
{
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (ops && ops->close)
        return ops->close(handle);
    b056:	ff e0                	jmpq   *%rax
    b058:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    b05f:	00 
        int fd = handle->dev.fd_in;

        int ret = INLINE_SYSCALL(close, 1, fd);

        if (IS_ERR(ret)) {
            if (ERRNO(ret) != EBADF && ERRNO(ret) != EINVAL)
    b060:	83 f9 f7             	cmp    $0xfffffffffffffff7,%ecx
    b063:	74 85                	je     afea <dev_close+0x4a>
    b065:	83 f9 ea             	cmp    $0xffffffffffffffea,%ecx
    b068:	74 80                	je     afea <dev_close+0x4a>
                return unix_to_pal_error(ERRNO(ret));
    b06a:	f7 d9                	neg    %ecx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    b06c:	83 f9 6e             	cmp    $0x6e,%ecx
    b06f:	0f 87 b0 00 00 00    	ja     b125 <dev_close+0x185>
    b075:	48 8d 05 8c fa 00 00 	lea    0xfa8c(%rip),%rax        # 1ab08 <slab_levels+0x1868>
    b07c:	89 c9                	mov    %ecx,%ecx
    b07e:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    b082:	48 01 d0             	add    %rdx,%rax
    b085:	ff e0                	jmpq   *%rax
    b087:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    b08e:	00 00 
        int fd = handle->dev.fd_out;

        int ret = INLINE_SYSCALL(close, 1, fd);

        if (IS_ERR(ret)) {
            if (ERRNO(ret) != EBADF && ERRNO(ret) != EINVAL)
    b090:	83 f9 f7             	cmp    $0xfffffffffffffff7,%ecx
    b093:	74 89                	je     b01e <dev_close+0x7e>
    b095:	83 f9 ea             	cmp    $0xffffffffffffffea,%ecx
    b098:	74 84                	je     b01e <dev_close+0x7e>
                return unix_to_pal_error(ERRNO(ret));
    b09a:	f7 d9                	neg    %ecx
    b09c:	83 f9 6e             	cmp    $0x6e,%ecx
    b09f:	0f 87 80 00 00 00    	ja     b125 <dev_close+0x185>
    b0a5:	48 8d 05 18 fc 00 00 	lea    0xfc18(%rip),%rax        # 1acc4 <slab_levels+0x1a24>
    b0ac:	89 c9                	mov    %ecx,%ecx
    b0ae:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    b0b2:	48 01 d0             	add    %rdx,%rax
    b0b5:	ff e0                	jmpq   *%rax
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    b0b7:	bb f7 ff ff ff       	mov    $0xfffffff7,%ebx
    b0bc:	e9 6d ff ff ff       	jmpq   b02e <dev_close+0x8e>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    b0c1:	bb f9 ff ff ff       	mov    $0xfffffff9,%ebx
    b0c6:	e9 63 ff ff ff       	jmpq   b02e <dev_close+0x8e>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    b0cb:	bb f3 ff ff ff       	mov    $0xfffffff3,%ebx
    b0d0:	e9 59 ff ff ff       	jmpq   b02e <dev_close+0x8e>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    b0d5:	bb fb ff ff ff       	mov    $0xfffffffb,%ebx
    b0da:	e9 4f ff ff ff       	jmpq   b02e <dev_close+0x8e>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    b0df:	bb fc ff ff ff       	mov    $0xfffffffc,%ebx
    b0e4:	e9 45 ff ff ff       	jmpq   b02e <dev_close+0x8e>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    b0e9:	bb f5 ff ff ff       	mov    $0xfffffff5,%ebx
    b0ee:	e9 3b ff ff ff       	jmpq   b02e <dev_close+0x8e>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    b0f3:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
    b0f8:	e9 31 ff ff ff       	jmpq   b02e <dev_close+0x8e>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    b0fd:	bb f8 ff ff ff       	mov    $0xfffffff8,%ebx
    b102:	e9 27 ff ff ff       	jmpq   b02e <dev_close+0x8e>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    b107:	bb f1 ff ff ff       	mov    $0xfffffff1,%ebx
    b10c:	e9 1d ff ff ff       	jmpq   b02e <dev_close+0x8e>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    b111:	bb f0 ff ff ff       	mov    $0xfffffff0,%ebx
    b116:	e9 13 ff ff ff       	jmpq   b02e <dev_close+0x8e>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    b11b:	bb ed ff ff ff       	mov    $0xffffffed,%ebx
    b120:	e9 09 ff ff ff       	jmpq   b02e <dev_close+0x8e>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    b125:	bb fa ff ff ff       	mov    $0xfffffffa,%ebx
    b12a:	e9 ff fe ff ff       	jmpq   b02e <dev_close+0x8e>
    b12f:	90                   	nop    

000000000000b130 <dev_delete>:
    return 0;
}

/* 'delete' operation for device streams */
static int dev_delete (PAL_HANDLE handle, int access)
{
    b130:	83 7f 14 01          	cmpl   $0x1,0x14(%rdi)
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (!ops || !ops->delete)
        return -PAL_ERROR_DENIED;
    b134:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
}

/* 'delete' operation for device streams */
static int dev_delete (PAL_HANDLE handle, int access)
{
    const struct handle_ops * ops = DEVICE_OPS(handle);
    b139:	74 05                	je     b140 <dev_delete+0x10>

    if (ret < 0)
        return ret;

    return ops->delete(handle, access);
}
    b13b:	c3                   	retq   
    b13c:	0f 1f 40 00          	nopl   0x0(%rax)
/* 'delete' operation for device streams */
static int dev_delete (PAL_HANDLE handle, int access)
{
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (!ops || !ops->delete)
    b140:	48 83 3d 78 8f 21 00 	cmpq   $0x0,0x218f78(%rip)        # 2240c0 <term_ops+0x40>
    b147:	00 
    b148:	74 f1                	je     b13b <dev_delete+0xb>
    return 0;
}

/* 'delete' operation for device streams */
static int dev_delete (PAL_HANDLE handle, int access)
{
    b14a:	55                   	push   %rbp
    b14b:	48 89 e5             	mov    %rsp,%rbp
    b14e:	41 54                	push   %r12
    b150:	53                   	push   %rbx
    b151:	41 89 f4             	mov    %esi,%r12d
    b154:	48 89 fb             	mov    %rdi,%rbx
    const struct handle_ops * ops = DEVICE_OPS(handle);

    if (!ops || !ops->delete)
        return -PAL_ERROR_DENIED;

    int ret = dev_close(handle);
    b157:	e8 44 fe ff ff       	callq  afa0 <dev_close>

    if (ret < 0)
    b15c:	85 c0                	test   %eax,%eax
    b15e:	78 13                	js     b173 <dev_delete+0x43>
        return ret;

    return ops->delete(handle, access);
    b160:	44 89 e6             	mov    %r12d,%esi
    b163:	48 89 df             	mov    %rbx,%rdi
    b166:	48 8b 05 53 8f 21 00 	mov    0x218f53(%rip),%rax        # 2240c0 <term_ops+0x40>
}
    b16d:	5b                   	pop    %rbx
    b16e:	41 5c                	pop    %r12
    b170:	5d                   	pop    %rbp
    int ret = dev_close(handle);

    if (ret < 0)
        return ret;

    return ops->delete(handle, access);
    b171:	ff e0                	jmpq   *%rax
}
    b173:	5b                   	pop    %rbx
    b174:	41 5c                	pop    %r12
    b176:	5d                   	pop    %rbp
    b177:	eb c2                	jmp    b13b <dev_delete+0xb>
    b179:	90                   	nop    
    b17a:	90                   	nop    
    b17b:	90                   	nop    
    b17c:	90                   	nop    
    b17d:	90                   	nop    
    b17e:	90                   	nop    
    b17f:	90                   	nop    

000000000000b180 <pipe_read>:
}

/* 'read' operation of pipe stream. offset does not apply here. */
static int pipe_read (PAL_HANDLE handle, int offset, int len,
                      void * buffer)
{
    b180:	55                   	push   %rbp
    b181:	48 89 e5             	mov    %rsp,%rbp
    b184:	53                   	push   %rbx
    if (!IS_HANDLE_TYPE(handle, pipecli) &&
    b185:	44 8b 07             	mov    (%rdi),%r8d
        !IS_HANDLE_TYPE(handle, pipeprv) &&
    b188:	41 8d 40 fc          	lea    -0x4(%r8),%eax

/* 'read' operation of pipe stream. offset does not apply here. */
static int pipe_read (PAL_HANDLE handle, int offset, int len,
                      void * buffer)
{
    if (!IS_HANDLE_TYPE(handle, pipecli) &&
    b18c:	83 f8 01             	cmp    $0x1,%eax
    b18f:	76 0f                	jbe    b1a0 <pipe_read+0x20>
    b191:	41 83 f8 02          	cmp    $0x2,%r8d
        !IS_HANDLE_TYPE(handle, pipeprv) &&
        !IS_HANDLE_TYPE(handle, pipe))
        return -PAL_ERROR_NOTCONNECTION;
    b195:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

/* 'read' operation of pipe stream. offset does not apply here. */
static int pipe_read (PAL_HANDLE handle, int offset, int len,
                      void * buffer)
{
    if (!IS_HANDLE_TYPE(handle, pipecli) &&
    b19a:	0f 85 81 00 00 00    	jne    b221 <pipe_read+0xa1>
        !IS_HANDLE_TYPE(handle, pipeprv) &&
        !IS_HANDLE_TYPE(handle, pipe))
        return -PAL_ERROR_NOTCONNECTION;

    int fd = IS_HANDLE_TYPE(handle, pipeprv) ? handle->pipeprv.fds[0] :
    b1a0:	41 83 f8 05          	cmp    $0x5,%r8d
             handle->pipe.fd;
    int bytes = 0;

#if USE_PIPE_SYSCALL == 1
    if (IS_HANDLE_TYPE(handle, pipeprv)) {
        bytes = INLINE_SYSCALL(read, 3, fd, buffer, len);
    b1a4:	48 63 7f 0c          	movslq 0xc(%rdi),%rdi
    if (!IS_HANDLE_TYPE(handle, pipecli) &&
        !IS_HANDLE_TYPE(handle, pipeprv) &&
        !IS_HANDLE_TYPE(handle, pipe))
        return -PAL_ERROR_NOTCONNECTION;

    int fd = IS_HANDLE_TYPE(handle, pipeprv) ? handle->pipeprv.fds[0] :
    b1a8:	74 7a                	je     b224 <pipe_read+0xa4>

        iov.iov_base = buffer;
        iov.iov_len = len;
        hdr.msg_name = NULL;
        hdr.msg_namelen = 0;
        hdr.msg_iov = &iov;
    b1aa:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
#endif
        struct msghdr hdr;
        struct iovec iov;

        iov.iov_base = buffer;
        iov.iov_len = len;
    b1ae:	48 63 d2             	movslq %edx,%rdx
        hdr.msg_iovlen = 1;
        hdr.msg_control = NULL;
        hdr.msg_controllen = 0;
        hdr.msg_flags = 0;

        bytes = INLINE_SYSCALL(recvmsg, 3, fd, &hdr, 0);
    b1b1:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
#endif
        struct msghdr hdr;
        struct iovec iov;

        iov.iov_base = buffer;
        iov.iov_len = len;
    b1b5:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    } else {
#endif
        struct msghdr hdr;
        struct iovec iov;

        iov.iov_base = buffer;
    b1b9:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
        hdr.msg_iovlen = 1;
        hdr.msg_control = NULL;
        hdr.msg_controllen = 0;
        hdr.msg_flags = 0;

        bytes = INLINE_SYSCALL(recvmsg, 3, fd, &hdr, 0);
    b1bd:	31 d2                	xor    %edx,%edx
        struct msghdr hdr;
        struct iovec iov;

        iov.iov_base = buffer;
        iov.iov_len = len;
        hdr.msg_name = NULL;
    b1bf:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    b1c6:	00 
        hdr.msg_namelen = 0;
    b1c7:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
        hdr.msg_iovlen = 1;
        hdr.msg_control = NULL;
        hdr.msg_controllen = 0;
        hdr.msg_flags = 0;

        bytes = INLINE_SYSCALL(recvmsg, 3, fd, &hdr, 0);
    b1ce:	bb 1b 00 00 00       	mov    $0x1b,%ebx

        iov.iov_base = buffer;
        iov.iov_len = len;
        hdr.msg_name = NULL;
        hdr.msg_namelen = 0;
        hdr.msg_iov = &iov;
    b1d3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        hdr.msg_iovlen = 1;
    b1d7:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
        hdr.msg_control = NULL;
    b1de:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    b1e5:	00 
        hdr.msg_controllen = 0;
    b1e6:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
        hdr.msg_flags = 0;
    b1ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

        bytes = INLINE_SYSCALL(recvmsg, 3, fd, &hdr, 0);
    b1f4:	89 d8                	mov    %ebx,%eax
    b1f6:	cd 80                	int    $0x80
    b1f8:	48 89 c2             	mov    %rax,%rdx
    b1fb:	bb 00 00 00 00       	mov    $0x0,%ebx
    b200:	83 d3 00             	adc    $0x0,%ebx
    b203:	31 c9                	xor    %ecx,%ecx
    b205:	85 db                	test   %ebx,%ebx
    b207:	0f 95 c1             	setne  %cl
    b20a:	48 89 c8             	mov    %rcx,%rax
    b20d:	48 f7 d8             	neg    %rax
    b210:	48 31 d0             	xor    %rdx,%rax
    b213:	01 c8                	add    %ecx,%eax
#if USE_PIPE_SYSCALL == 1
    }
#endif

    if (IS_ERR(bytes))
    b215:	85 c0                	test   %eax,%eax
    b217:	78 18                	js     b231 <pipe_read+0xb1>
                return -PAL_ERROR_INTERRUPTED;
            default:
                return -PAL_ERROR_DENIED;
        }

    if (!bytes)
    b219:	ba ec ff ff ff       	mov    $0xffffffec,%edx
    b21e:	0f 44 c2             	cmove  %edx,%eax
        return -PAL_ERROR_ENDOFSTREAM;

    return bytes;
}
    b221:	5b                   	pop    %rbx
    b222:	5d                   	pop    %rbp
    b223:	c3                   	retq   
             handle->pipe.fd;
    int bytes = 0;

#if USE_PIPE_SYSCALL == 1
    if (IS_HANDLE_TYPE(handle, pipeprv)) {
        bytes = INLINE_SYSCALL(read, 3, fd, buffer, len);
    b224:	48 63 d2             	movslq %edx,%rdx
    b227:	48 89 ce             	mov    %rcx,%rsi
    b22a:	bb 03 00 00 00       	mov    $0x3,%ebx
    b22f:	eb c3                	jmp    b1f4 <pipe_read+0x74>
#if USE_PIPE_SYSCALL == 1
    }
#endif

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    b231:	f7 d8                	neg    %eax
    b233:	89 c2                	mov    %eax,%edx
            case EWOULDBLOCK:
                return-PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
    b235:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
#if USE_PIPE_SYSCALL == 1
    }
#endif

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    b23a:	83 fa 04             	cmp    $0x4,%edx
    b23d:	74 e2                	je     b221 <pipe_read+0xa1>
            case EWOULDBLOCK:
                return-PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
            default:
                return -PAL_ERROR_DENIED;
    b23f:	83 fa 0b             	cmp    $0xb,%edx
    b242:	b0 ed                	mov    $0xed,%al
    b244:	ba fa ff ff ff       	mov    $0xfffffffa,%edx

    if (!bytes)
        return -PAL_ERROR_ENDOFSTREAM;

    return bytes;
}
    b249:	0f 45 c2             	cmovne %edx,%eax
    b24c:	5b                   	pop    %rbx
    b24d:	5d                   	pop    %rbp
    b24e:	c3                   	retq   
    b24f:	90                   	nop    

000000000000b250 <pipe_write>:

/* 'write' operation of pipe stream. offset does not apply here. */
static int pipe_write (PAL_HANDLE handle, int offset, int len,
                       const void * buffer)
{
    b250:	55                   	push   %rbp
    b251:	41 89 d1             	mov    %edx,%r9d
    b254:	49 89 f8             	mov    %rdi,%r8
    b257:	48 89 e5             	mov    %rsp,%rbp
    b25a:	53                   	push   %rbx
    if (!IS_HANDLE_TYPE(handle, pipecli) &&
    b25b:	8b 17                	mov    (%rdi),%edx
        !IS_HANDLE_TYPE(handle, pipeprv) &&
    b25d:	8d 42 fc             	lea    -0x4(%rdx),%eax

/* 'write' operation of pipe stream. offset does not apply here. */
static int pipe_write (PAL_HANDLE handle, int offset, int len,
                       const void * buffer)
{
    if (!IS_HANDLE_TYPE(handle, pipecli) &&
    b260:	83 f8 01             	cmp    $0x1,%eax
    b263:	76 0e                	jbe    b273 <pipe_write+0x23>
    b265:	83 fa 02             	cmp    $0x2,%edx
        !IS_HANDLE_TYPE(handle, pipeprv) &&
        !IS_HANDLE_TYPE(handle, pipe))
        return -PAL_ERROR_NOTCONNECTION;
    b268:	b8 ea ff ff ff       	mov    $0xffffffea,%eax

/* 'write' operation of pipe stream. offset does not apply here. */
static int pipe_write (PAL_HANDLE handle, int offset, int len,
                       const void * buffer)
{
    if (!IS_HANDLE_TYPE(handle, pipecli) &&
    b26d:	0f 85 9b 00 00 00    	jne    b30e <pipe_write+0xbe>
        !IS_HANDLE_TYPE(handle, pipeprv) &&
        !IS_HANDLE_TYPE(handle, pipe))
        return -PAL_ERROR_NOTCONNECTION;

    int fd = IS_HANDLE_TYPE(handle, pipeprv) ? handle->pipeprv.fds[1] :
    b273:	83 fa 05             	cmp    $0x5,%edx
    b276:	0f 84 95 00 00 00    	je     b311 <pipe_write+0xc1>
#endif
        struct msghdr hdr;
        struct iovec iov;

        iov.iov_base = (void *) buffer;
        iov.iov_len = len;
    b27c:	49 63 c1             	movslq %r9d,%rax
        hdr.msg_iovlen = 1;
        hdr.msg_control = NULL;
        hdr.msg_controllen = 0;
        hdr.msg_flags = 0;

        bytes = INLINE_SYSCALL(sendmsg, 3, fd, &hdr, MSG_NOSIGNAL);
    b27f:	49 63 78 0c          	movslq 0xc(%r8),%rdi
    b283:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
#endif
        struct msghdr hdr;
        struct iovec iov;

        iov.iov_base = (void *) buffer;
        iov.iov_len = len;
    b287:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        hdr.msg_name = NULL;
        hdr.msg_namelen = 0;
        hdr.msg_iov = &iov;
    b28b:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
    } else {
#endif
        struct msghdr hdr;
        struct iovec iov;

        iov.iov_base = (void *) buffer;
    b28f:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
        iov.iov_len = len;
        hdr.msg_name = NULL;
    b293:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    b29a:	00 
        hdr.msg_namelen = 0;
    b29b:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
        hdr.msg_iovlen = 1;
        hdr.msg_control = NULL;
        hdr.msg_controllen = 0;
        hdr.msg_flags = 0;

        bytes = INLINE_SYSCALL(sendmsg, 3, fd, &hdr, MSG_NOSIGNAL);
    b2a2:	ba 00 00 02 00       	mov    $0x20000,%edx

        iov.iov_base = (void *) buffer;
        iov.iov_len = len;
        hdr.msg_name = NULL;
        hdr.msg_namelen = 0;
        hdr.msg_iov = &iov;
    b2a7:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
        hdr.msg_iovlen = 1;
    b2ab:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
        hdr.msg_control = NULL;
        hdr.msg_controllen = 0;
        hdr.msg_flags = 0;

        bytes = INLINE_SYSCALL(sendmsg, 3, fd, &hdr, MSG_NOSIGNAL);
    b2b2:	bb 1c 00 00 00       	mov    $0x1c,%ebx
        iov.iov_len = len;
        hdr.msg_name = NULL;
        hdr.msg_namelen = 0;
        hdr.msg_iov = &iov;
        hdr.msg_iovlen = 1;
        hdr.msg_control = NULL;
    b2b7:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    b2be:	00 
        hdr.msg_controllen = 0;
    b2bf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
        hdr.msg_flags = 0;
    b2c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

        bytes = INLINE_SYSCALL(sendmsg, 3, fd, &hdr, MSG_NOSIGNAL);
    b2cd:	89 d8                	mov    %ebx,%eax
    b2cf:	cd 80                	int    $0x80
    b2d1:	48 89 c2             	mov    %rax,%rdx
    b2d4:	bb 00 00 00 00       	mov    $0x0,%ebx
    b2d9:	83 d3 00             	adc    $0x0,%ebx
    b2dc:	31 c9                	xor    %ecx,%ecx
    b2de:	85 db                	test   %ebx,%ebx
    b2e0:	0f 95 c1             	setne  %cl
    b2e3:	48 89 c8             	mov    %rcx,%rax
    b2e6:	48 f7 d8             	neg    %rax
    b2e9:	48 31 d0             	xor    %rdx,%rax
#if USE_PIPE_SYSCALL == 1
    }
#endif

    PAL_FLG writeable = IS_HANDLE_TYPE(handle, pipeprv) ? WRITEABLE(1) :
    b2ec:	ba 40 00 00 00       	mov    $0x40,%edx
        hdr.msg_iovlen = 1;
        hdr.msg_control = NULL;
        hdr.msg_controllen = 0;
        hdr.msg_flags = 0;

        bytes = INLINE_SYSCALL(sendmsg, 3, fd, &hdr, MSG_NOSIGNAL);
    b2f1:	01 c8                	add    %ecx,%eax
#if USE_PIPE_SYSCALL == 1
    }
#endif

    PAL_FLG writeable = IS_HANDLE_TYPE(handle, pipeprv) ? WRITEABLE(1) :
    b2f3:	41 83 38 05          	cmpl   $0x5,(%r8)
    b2f7:	b9 80 00 00 00       	mov    $0x80,%ecx
    b2fc:	0f 45 ca             	cmovne %edx,%ecx
                        WRITEABLE(0);

    if (IS_ERR(bytes))
    b2ff:	85 c0                	test   %eax,%eax
    b301:	78 1f                	js     b322 <pipe_write+0xd2>
                return -PAL_ERROR_INTERRUPTED;
            default:
                return -PAL_ERROR_DENIED;
        }

    if (bytes == len)
    b303:	44 39 c8             	cmp    %r9d,%eax
    b306:	74 3c                	je     b344 <pipe_write+0xf4>
        handle->__in.flags |= writeable;
    else
        handle->__in.flags &= ~writeable;
    b308:	f7 d1                	not    %ecx
    b30a:	41 21 48 08          	and    %ecx,0x8(%r8)

    return bytes;
}
    b30e:	5b                   	pop    %rbx
    b30f:	5d                   	pop    %rbp
    b310:	c3                   	retq   
             handle->pipe.fd;
    int bytes = 0;

#if USE_PIPE_SYSCALL == 1
    if (IS_HANDLE_TYPE(handle, pipeprv)) {
        bytes = INLINE_SYSCALL(write, 3, fd, buffer, len);
    b311:	49 63 78 10          	movslq 0x10(%r8),%rdi
    b315:	49 63 d1             	movslq %r9d,%rdx
    b318:	48 89 ce             	mov    %rcx,%rsi
    b31b:	bb 04 00 00 00       	mov    $0x4,%ebx
    b320:	eb ab                	jmp    b2cd <pipe_write+0x7d>

    PAL_FLG writeable = IS_HANDLE_TYPE(handle, pipeprv) ? WRITEABLE(1) :
                        WRITEABLE(0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    b322:	f7 d8                	neg    %eax
    b324:	89 c2                	mov    %eax,%edx
            case EWOULDBLOCK:
                handle->__in.flags &= ~writeable;
                return-PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
    b326:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax

    PAL_FLG writeable = IS_HANDLE_TYPE(handle, pipeprv) ? WRITEABLE(1) :
                        WRITEABLE(0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    b32b:	83 fa 04             	cmp    $0x4,%edx
    b32e:	74 de                	je     b30e <pipe_write+0xbe>
    b330:	83 fa 0b             	cmp    $0xb,%edx
                handle->__in.flags &= ~writeable;
                return-PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
            default:
                return -PAL_ERROR_DENIED;
    b333:	b0 fa                	mov    $0xfa,%al

    PAL_FLG writeable = IS_HANDLE_TYPE(handle, pipeprv) ? WRITEABLE(1) :
                        WRITEABLE(0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    b335:	75 d7                	jne    b30e <pipe_write+0xbe>
            case EWOULDBLOCK:
                handle->__in.flags &= ~writeable;
    b337:	f7 d1                	not    %ecx
                return-PAL_ERROR_TRYAGAIN;
    b339:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
                        WRITEABLE(0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
            case EWOULDBLOCK:
                handle->__in.flags &= ~writeable;
    b33e:	41 21 48 08          	and    %ecx,0x8(%r8)
                return-PAL_ERROR_TRYAGAIN;
    b342:	eb ca                	jmp    b30e <pipe_write+0xbe>
            default:
                return -PAL_ERROR_DENIED;
        }

    if (bytes == len)
        handle->__in.flags |= writeable;
    b344:	41 09 48 08          	or     %ecx,0x8(%r8)
    else
        handle->__in.flags &= ~writeable;

    return bytes;
}
    b348:	5b                   	pop    %rbx
    b349:	5d                   	pop    %rbp
    b34a:	c3                   	retq   
    b34b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000b350 <pipe_attrsetbyhdl>:
                        handle->pipe.nonblocking;
    return 0;
}

static int pipe_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    b350:	8b 47 0c             	mov    0xc(%rdi),%eax
    b353:	83 f8 ff             	cmp    $0xffffffffffffffff,%eax
    b356:	0f 84 54 01 00 00    	je     b4b0 <pipe_attrsetbyhdl+0x160>
    if (handle->__in.fds[0] == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    int ret;
    PAL_BOL * nonblocking = (handle->__in.type == pal_type_pipeprv) ?
                            &handle->pipeprv.nonblocking :
    b35c:	83 3f 05             	cmpl   $0x5,(%rdi)
    b35f:	49 89 f0             	mov    %rsi,%r8
    b362:	74 5e                	je     b3c2 <pipe_attrsetbyhdl+0x72>
    b364:	0f b6 57 1c          	movzbl 0x1c(%rdi),%edx
    b368:	4c 8d 4f 1c          	lea    0x1c(%rdi),%r9
                            &handle->pipe.nonblocking;

    if (attr->nonblocking != *nonblocking) {
    b36c:	41 38 50 38          	cmp    %dl,0x38(%r8)
    b370:	74 5e                	je     b3d0 <pipe_attrsetbyhdl+0x80>
        ret = INLINE_SYSCALL(fcntl, 3, handle->__in.fds[0], F_SETFL,
    b372:	80 fa 01             	cmp    $0x1,%dl
                        handle->pipe.nonblocking;
    return 0;
}

static int pipe_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    b375:	55                   	push   %rbp
    PAL_BOL * nonblocking = (handle->__in.type == pal_type_pipeprv) ?
                            &handle->pipeprv.nonblocking :
                            &handle->pipe.nonblocking;

    if (attr->nonblocking != *nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->__in.fds[0], F_SETFL,
    b376:	b9 5c 00 00 00       	mov    $0x5c,%ecx
    b37b:	48 19 d2             	sbb    %rdx,%rdx
    b37e:	89 c7                	mov    %eax,%edi
    b380:	be 04 00 00 00       	mov    $0x4,%esi
    b385:	48 f7 d2             	not    %rdx
                        handle->pipe.nonblocking;
    return 0;
}

static int pipe_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    b388:	48 89 e5             	mov    %rsp,%rbp
    PAL_BOL * nonblocking = (handle->__in.type == pal_type_pipeprv) ?
                            &handle->pipeprv.nonblocking :
                            &handle->pipe.nonblocking;

    if (attr->nonblocking != *nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->__in.fds[0], F_SETFL,
    b38b:	89 c8                	mov    %ecx,%eax
                        handle->pipe.nonblocking;
    return 0;
}

static int pipe_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    b38d:	53                   	push   %rbx
    PAL_BOL * nonblocking = (handle->__in.type == pal_type_pipeprv) ?
                            &handle->pipeprv.nonblocking :
                            &handle->pipe.nonblocking;

    if (attr->nonblocking != *nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->__in.fds[0], F_SETFL,
    b38e:	83 e2 04             	and    $0x4,%edx
    b391:	cd 80                	int    $0x80
    b393:	48 89 c1             	mov    %rax,%rcx
    b396:	bb 00 00 00 00       	mov    $0x0,%ebx
    b39b:	83 d3 00             	adc    $0x0,%ebx
    b39e:	31 d2                	xor    %edx,%edx
    b3a0:	85 db                	test   %ebx,%ebx
    b3a2:	0f 95 c2             	setne  %dl
    b3a5:	48 89 d0             	mov    %rdx,%rax
    b3a8:	48 f7 d8             	neg    %rax
    b3ab:	48 31 c8             	xor    %rcx,%rax
    b3ae:	48 01 c2             	add    %rax,%rdx
                             *nonblocking ? O_NONBLOCK : 0);

        if (IS_ERR(ret))
    b3b1:	85 d2                	test   %edx,%edx
    b3b3:	78 1e                	js     b3d3 <pipe_attrsetbyhdl+0x83>
            return unix_to_pal_error(ERRNO(ret));

        *nonblocking = attr->nonblocking;
    b3b5:	41 0f b6 40 38       	movzbl 0x38(%r8),%eax
    b3ba:	41 88 01             	mov    %al,(%r9)
    }

    return 0;
    b3bd:	31 c0                	xor    %eax,%eax
}
    b3bf:	5b                   	pop    %rbx
    b3c0:	5d                   	pop    %rbp
    b3c1:	c3                   	retq   
    if (handle->__in.fds[0] == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    int ret;
    PAL_BOL * nonblocking = (handle->__in.type == pal_type_pipeprv) ?
                            &handle->pipeprv.nonblocking :
    b3c2:	0f b6 57 14          	movzbl 0x14(%rdi),%edx
    b3c6:	4c 8d 4f 14          	lea    0x14(%rdi),%r9
                            &handle->pipe.nonblocking;

    if (attr->nonblocking != *nonblocking) {
    b3ca:	41 38 50 38          	cmp    %dl,0x38(%r8)
    b3ce:	75 a2                	jne    b372 <pipe_attrsetbyhdl+0x22>
            return unix_to_pal_error(ERRNO(ret));

        *nonblocking = attr->nonblocking;
    }

    return 0;
    b3d0:	31 c0                	xor    %eax,%eax
    b3d2:	c3                   	retq   
    if (attr->nonblocking != *nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->__in.fds[0], F_SETFL,
                             *nonblocking ? O_NONBLOCK : 0);

        if (IS_ERR(ret))
            return unix_to_pal_error(ERRNO(ret));
    b3d3:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    b3d5:	83 fa 6e             	cmp    $0x6e,%edx
    b3d8:	0f 87 c2 00 00 00    	ja     b4a0 <pipe_attrsetbyhdl+0x150>
    b3de:	48 8d 05 9b fa 00 00 	lea    0xfa9b(%rip),%rax        # 1ae80 <slab_levels+0x1be0>
    b3e5:	89 d2                	mov    %edx,%edx
    b3e7:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    b3eb:	48 01 d0             	add    %rdx,%rax
    b3ee:	ff e0                	jmpq   *%rax
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    b3f0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    b3f5:	eb c8                	jmp    b3bf <pipe_attrsetbyhdl+0x6f>
    b3f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    b3fe:	00 00 
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    b400:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    b405:	eb b8                	jmp    b3bf <pipe_attrsetbyhdl+0x6f>
    b407:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    b40e:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    b410:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    b415:	eb a8                	jmp    b3bf <pipe_attrsetbyhdl+0x6f>
    b417:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    b41e:	00 00 
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    b420:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    b425:	eb 98                	jmp    b3bf <pipe_attrsetbyhdl+0x6f>
    b427:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    b42e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    b430:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    b435:	eb 88                	jmp    b3bf <pipe_attrsetbyhdl+0x6f>
    b437:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    b43e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    b440:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    b445:	e9 75 ff ff ff       	jmpq   b3bf <pipe_attrsetbyhdl+0x6f>
    b44a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    b450:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    b455:	e9 65 ff ff ff       	jmpq   b3bf <pipe_attrsetbyhdl+0x6f>
    b45a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    b460:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    b465:	e9 55 ff ff ff       	jmpq   b3bf <pipe_attrsetbyhdl+0x6f>
    b46a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    b470:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    b475:	e9 45 ff ff ff       	jmpq   b3bf <pipe_attrsetbyhdl+0x6f>
    b47a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    b480:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    b485:	e9 35 ff ff ff       	jmpq   b3bf <pipe_attrsetbyhdl+0x6f>
    b48a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    b490:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    b495:	e9 25 ff ff ff       	jmpq   b3bf <pipe_attrsetbyhdl+0x6f>
    b49a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    b4a0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    b4a5:	e9 15 ff ff ff       	jmpq   b3bf <pipe_attrsetbyhdl+0x6f>
    b4aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
}

static int pipe_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    if (handle->__in.fds[0] == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    b4b0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

        *nonblocking = attr->nonblocking;
    }

    return 0;
}
    b4b5:	c3                   	retq   
    b4b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    b4bd:	00 00 00 

000000000000b4c0 <pipe_attrquerybyhdl>:
#ifndef FIONREAD
# define FIONREAD 0x541B
#endif

static int pipe_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    b4c0:	83 7f 0c ff          	cmpl   $0xffffffffffffffff,0xc(%rdi)
    b4c4:	0f 84 c6 00 00 00    	je     b590 <pipe_attrquerybyhdl+0xd0>
    b4ca:	55                   	push   %rbp
    int ret, val;

    if (handle->__in.fds[0] == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
    b4cb:	ba 70 00 00 00       	mov    $0x70,%edx
#ifndef FIONREAD
# define FIONREAD 0x541B
#endif

static int pipe_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    b4d0:	48 89 e5             	mov    %rsp,%rbp
    b4d3:	41 55                	push   %r13
    b4d5:	41 54                	push   %r12
    b4d7:	53                   	push   %rbx
    b4d8:	49 89 f4             	mov    %rsi,%r12
    b4db:	49 89 fd             	mov    %rdi,%r13
    int ret, val;

    if (handle->__in.fds[0] == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
    b4de:	31 f6                	xor    %esi,%esi
    b4e0:	4c 89 e7             	mov    %r12,%rdi

    ret = INLINE_SYSCALL(ioctl, 3, handle->__in.fds[0], FIONREAD, &val);
    b4e3:	bb 36 00 00 00       	mov    $0x36,%ebx
#ifndef FIONREAD
# define FIONREAD 0x541B
#endif

static int pipe_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    b4e8:	48 83 ec 18          	sub    $0x18,%rsp
    int ret, val;

    if (handle->__in.fds[0] == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
    b4ec:	e8 af ac 00 00       	callq  161a0 <memset>

    ret = INLINE_SYSCALL(ioctl, 3, handle->__in.fds[0], FIONREAD, &val);
    b4f1:	41 8b 7d 0c          	mov    0xc(%r13),%edi
    b4f5:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
    b4f9:	be 1b 54 00 00       	mov    $0x541b,%esi
    b4fe:	89 d8                	mov    %ebx,%eax
    b500:	cd 80                	int    $0x80
    b502:	48 89 c2             	mov    %rax,%rdx
    b505:	bb 00 00 00 00       	mov    $0x0,%ebx
    b50a:	83 d3 00             	adc    $0x0,%ebx
    b50d:	31 c9                	xor    %ecx,%ecx
    b50f:	85 db                	test   %ebx,%ebx
    b511:	0f 95 c1             	setne  %cl
    b514:	48 89 c8             	mov    %rcx,%rax
    b517:	48 f7 d8             	neg    %rax
    b51a:	48 31 d0             	xor    %rdx,%rax
    if (!IS_ERR(ret))
    b51d:	01 c8                	add    %ecx,%eax
    b51f:	78 61                	js     b582 <pipe_attrquerybyhdl+0xc2>
        attr->size = val;
    b521:	48 63 4d dc          	movslq -0x24(%rbp),%rcx
    b525:	49 89 4c 24 10       	mov    %rcx,0x10(%r12)

    attr->disconnected = handle->__in.flags & ERROR(0);
    b52a:	41 8b 45 08          	mov    0x8(%r13),%eax
    b52e:	89 c2                	mov    %eax,%edx
    b530:	c1 ea 09             	shr    $0x9,%edx
    b533:	83 e2 01             	and    $0x1,%edx
    attr->readable = (attr->size > 0);
    b536:	48 85 c9             	test   %rcx,%rcx

    ret = INLINE_SYSCALL(ioctl, 3, handle->__in.fds[0], FIONREAD, &val);
    if (!IS_ERR(ret))
        attr->size = val;

    attr->disconnected = handle->__in.flags & ERROR(0);
    b539:	41 88 54 24 30       	mov    %dl,0x30(%r12)
    attr->readable = (attr->size > 0);
    b53e:	41 0f 95 44 24 31    	setne  0x31(%r12)
    attr->writeable = handle->__in.flags &
    b544:	41 83 7d 00 05       	cmpl   $0x5,0x0(%r13)
    b549:	74 25                	je     b570 <pipe_attrquerybyhdl+0xb0>
    b54b:	c1 e8 06             	shr    $0x6,%eax
    b54e:	83 e0 01             	and    $0x1,%eax
    b551:	41 88 44 24 32       	mov    %al,0x32(%r12)
        ((HANDLE_TYPE(handle) == pal_type_pipeprv) ? WRITEABLE(1) : WRITEABLE(0));
    attr->nonblocking = (handle->__in.type == pal_type_pipeprv) ?
                        handle->pipeprv.nonblocking :
                        handle->pipe.nonblocking;
    b556:	41 0f b6 45 1c       	movzbl 0x1c(%r13),%eax

    attr->disconnected = handle->__in.flags & ERROR(0);
    attr->readable = (attr->size > 0);
    attr->writeable = handle->__in.flags &
        ((HANDLE_TYPE(handle) == pal_type_pipeprv) ? WRITEABLE(1) : WRITEABLE(0));
    attr->nonblocking = (handle->__in.type == pal_type_pipeprv) ?
    b55b:	41 88 44 24 38       	mov    %al,0x38(%r12)
                        handle->pipeprv.nonblocking :
                        handle->pipe.nonblocking;
    return 0;
}
    b560:	48 83 c4 18          	add    $0x18,%rsp
    attr->writeable = handle->__in.flags &
        ((HANDLE_TYPE(handle) == pal_type_pipeprv) ? WRITEABLE(1) : WRITEABLE(0));
    attr->nonblocking = (handle->__in.type == pal_type_pipeprv) ?
                        handle->pipeprv.nonblocking :
                        handle->pipe.nonblocking;
    return 0;
    b564:	31 c0                	xor    %eax,%eax
}
    b566:	5b                   	pop    %rbx
    b567:	41 5c                	pop    %r12
    b569:	41 5d                	pop    %r13
    b56b:	5d                   	pop    %rbp
    b56c:	c3                   	retq   
    b56d:	0f 1f 00             	nopl   (%rax)
    if (!IS_ERR(ret))
        attr->size = val;

    attr->disconnected = handle->__in.flags & ERROR(0);
    attr->readable = (attr->size > 0);
    attr->writeable = handle->__in.flags &
    b570:	c1 e8 07             	shr    $0x7,%eax
    b573:	83 e0 01             	and    $0x1,%eax
    b576:	41 88 44 24 32       	mov    %al,0x32(%r12)
        ((HANDLE_TYPE(handle) == pal_type_pipeprv) ? WRITEABLE(1) : WRITEABLE(0));
    attr->nonblocking = (handle->__in.type == pal_type_pipeprv) ?
                        handle->pipeprv.nonblocking :
    b57b:	41 0f b6 45 14       	movzbl 0x14(%r13),%eax
    b580:	eb d9                	jmp    b55b <pipe_attrquerybyhdl+0x9b>
    b582:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    b587:	eb a1                	jmp    b52a <pipe_attrquerybyhdl+0x6a>
    b589:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
static int pipe_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    int ret, val;

    if (handle->__in.fds[0] == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    b590:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
        ((HANDLE_TYPE(handle) == pal_type_pipeprv) ? WRITEABLE(1) : WRITEABLE(0));
    attr->nonblocking = (handle->__in.type == pal_type_pipeprv) ?
                        handle->pipeprv.nonblocking :
                        handle->pipe.nonblocking;
    return 0;
}
    b595:	c3                   	retq   
    b596:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    b59d:	00 00 00 

000000000000b5a0 <pipe_waitforclient>:
    *handle = hdl;
    return 0;
}

static int pipe_waitforclient (PAL_HANDLE handle, PAL_HANDLE * client)
{
    b5a0:	83 3f 03             	cmpl   $0x3,(%rdi)
    if (!IS_HANDLE_TYPE(handle, pipesrv))
        return -PAL_ERROR_NOTSERVER;
    b5a3:	b8 eb ff ff ff       	mov    $0xffffffeb,%eax
    return 0;
}

static int pipe_waitforclient (PAL_HANDLE handle, PAL_HANDLE * client)
{
    if (!IS_HANDLE_TYPE(handle, pipesrv))
    b5a8:	0f 85 52 01 00 00    	jne    b700 <pipe_waitforclient+0x160>
        return -PAL_ERROR_NOTSERVER;

    if (handle->pipe.fd == PAL_IDX_POISON)
    b5ae:	8b 7f 0c             	mov    0xc(%rdi),%edi
    b5b1:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    b5b4:	0f 84 76 01 00 00    	je     b730 <pipe_waitforclient+0x190>
    *handle = hdl;
    return 0;
}

static int pipe_waitforclient (PAL_HANDLE handle, PAL_HANDLE * client)
{
    b5ba:	55                   	push   %rbp
        return -PAL_ERROR_NOTSERVER;

    if (handle->pipe.fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;

    int newfd = INLINE_SYSCALL(accept4, 4, handle->pipe.fd, NULL, NULL,
    b5bb:	b9 00 00 00 10       	mov    $0x10000000,%ecx
    b5c0:	31 d2                	xor    %edx,%edx
    *handle = hdl;
    return 0;
}

static int pipe_waitforclient (PAL_HANDLE handle, PAL_HANDLE * client)
{
    b5c2:	48 89 e5             	mov    %rsp,%rbp
    b5c5:	41 55                	push   %r13
    b5c7:	41 54                	push   %r12
    b5c9:	53                   	push   %rbx
        return -PAL_ERROR_NOTSERVER;

    if (handle->pipe.fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;

    int newfd = INLINE_SYSCALL(accept4, 4, handle->pipe.fd, NULL, NULL,
    b5ca:	bb 1d 02 00 00       	mov    $0x21d,%ebx
    b5cf:	49 89 f4             	mov    %rsi,%r12
    b5d2:	89 d8                	mov    %ebx,%eax
    b5d4:	31 f6                	xor    %esi,%esi
    *handle = hdl;
    return 0;
}

static int pipe_waitforclient (PAL_HANDLE handle, PAL_HANDLE * client)
{
    b5d6:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
        return -PAL_ERROR_NOTSERVER;

    if (handle->pipe.fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;

    int newfd = INLINE_SYSCALL(accept4, 4, handle->pipe.fd, NULL, NULL,
    b5dd:	cd 80                	int    $0x80
    b5df:	48 89 c1             	mov    %rax,%rcx
    b5e2:	bb 00 00 00 00       	mov    $0x0,%ebx
    b5e7:	83 d3 00             	adc    $0x0,%ebx
    b5ea:	31 d2                	xor    %edx,%edx
    b5ec:	85 db                	test   %ebx,%ebx
    b5ee:	0f 95 c2             	setne  %dl
    b5f1:	48 89 d0             	mov    %rdx,%rax
    b5f4:	48 f7 d8             	neg    %rax
    b5f7:	48 31 c8             	xor    %rcx,%rax
    b5fa:	48 8d 1c 10          	lea    (%rax,%rdx,1),%rbx
                               SOCK_CLOEXEC);

    if (IS_ERR(newfd))
    b5fe:	85 db                	test   %ebx,%ebx
    b600:	0f 88 fc 00 00 00    	js     b702 <pipe_waitforclient+0x162>
    struct iovec iov;
    char cbuf[sizeof(struct cmsghdr) + 3 * sizeof(int)];
    char b = 0;
    int ret = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    b606:	4c 8d 6d b0          	lea    -0x50(%rbp),%r13
    b60a:	31 f6                	xor    %esi,%esi
    b60c:	ba 30 00 00 00       	mov    $0x30,%edx
#if USE_PIPE_SYSCALL == 1
    int pipes[2];
    struct msghdr hdr;
    struct iovec iov;
    char cbuf[sizeof(struct cmsghdr) + 3 * sizeof(int)];
    char b = 0;
    b611:	c6 85 6f ff ff ff 00 	movb   $0x0,-0x91(%rbp)
    int ret = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    b618:	4c 89 ef             	mov    %r13,%rdi
    b61b:	e8 80 ab 00 00       	callq  161a0 <memset>
    hdr.msg_iov = &iov;
    b620:	48 8d 45 80          	lea    -0x80(%rbp),%rax
    hdr.msg_control = cbuf;
    hdr.msg_controllen = sizeof(cbuf);
    iov.iov_base = &b;
    iov.iov_len = 1;

    ret = INLINE_SYSCALL(recvmsg, 3, newfd, &hdr, 0);
    b624:	48 63 cb             	movslq %ebx,%rcx
    b627:	bb 1b 00 00 00       	mov    $0x1b,%ebx
    char b = 0;
    int ret = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    b62c:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
    hdr.msg_control = cbuf;
    hdr.msg_controllen = sizeof(cbuf);
    b633:	c7 45 d8 18 00 00 00 	movl   $0x18,-0x28(%rbp)
    iov.iov_base = &b;
    iov.iov_len = 1;

    ret = INLINE_SYSCALL(recvmsg, 3, newfd, &hdr, 0);
    b63a:	31 d2                	xor    %edx,%edx
    char cbuf[sizeof(struct cmsghdr) + 3 * sizeof(int)];
    char b = 0;
    int ret = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    hdr.msg_iov = &iov;
    b63c:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = cbuf;
    b640:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    hdr.msg_controllen = sizeof(cbuf);
    iov.iov_base = &b;
    iov.iov_len = 1;
    b644:	48 c7 45 88 01 00 00 	movq   $0x1,-0x78(%rbp)
    b64b:	00 

    ret = INLINE_SYSCALL(recvmsg, 3, newfd, &hdr, 0);
    b64c:	4c 89 ee             	mov    %r13,%rsi
    b64f:	48 89 cf             	mov    %rcx,%rdi
    int ret = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = cbuf;
    b652:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    hdr.msg_controllen = sizeof(cbuf);
    iov.iov_base = &b;
    b656:	48 8d 85 6f ff ff ff 	lea    -0x91(%rbp),%rax
    b65d:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    iov.iov_len = 1;

    ret = INLINE_SYSCALL(recvmsg, 3, newfd, &hdr, 0);
    b661:	89 d8                	mov    %ebx,%eax
    b663:	cd 80                	int    $0x80
    b665:	48 89 c2             	mov    %rax,%rdx
    b668:	bb 00 00 00 00       	mov    $0x0,%ebx
    b66d:	83 d3 00             	adc    $0x0,%ebx
    b670:	31 f6                	xor    %esi,%esi
    b672:	85 db                	test   %ebx,%ebx
    b674:	40 0f 95 c6          	setne  %sil
    b678:	48 89 f0             	mov    %rsi,%rax
    b67b:	48 f7 d8             	neg    %rax
    b67e:	48 31 d0             	xor    %rdx,%rax
    b681:	48 01 c6             	add    %rax,%rsi

    INLINE_SYSCALL(close, 1, newfd);
    b684:	b8 06 00 00 00       	mov    $0x6,%eax
    b689:	cd 80                	int    $0x80
    b68b:	bb 00 00 00 00       	mov    $0x0,%ebx
    b690:	83 d3 00             	adc    $0x0,%ebx

    struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
    b693:	31 d2                	xor    %edx,%edx
    b695:	83 7d d8 0c          	cmpl   $0xc,-0x28(%rbp)
    b699:	48 0f 43 55 d0       	cmovae -0x30(%rbp),%rdx

    if (IS_ERR(ret) || chdr->cmsg_type != SCM_RIGHTS)
    b69e:	85 f6                	test   %esi,%esi
    b6a0:	78 7e                	js     b720 <pipe_waitforclient+0x180>
    b6a2:	83 7a 08 01          	cmpl   $0x1,0x8(%rdx)
    b6a6:	75 78                	jne    b720 <pipe_waitforclient+0x180>
        return -PAL_ERROR_DENIED;

    memcpy(pipes, CMSG_DATA(chdr), sizeof(int) * 2);
    b6a8:	48 8d 72 10          	lea    0x10(%rdx),%rsi
    b6ac:	48 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%rdi
    b6b3:	ba 08 00 00 00       	mov    $0x8,%edx
    b6b8:	e8 c3 ab 00 00       	callq  16280 <memcpy>

    PAL_HANDLE clnt = malloc(HANDLE_SIZE(pipeprv));
    b6bd:	bf 18 00 00 00       	mov    $0x18,%edi
    b6c2:	e8 39 d3 ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(clnt, pipeprv);
    b6c7:	c7 00 05 00 00 00    	movl   $0x5,(%rax)
    b6cd:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    clnt->__in.flags |= RFD(0)|WFD(1)|WRITEABLE(1);
    clnt->pipeprv.fds[0] = pipes[0];
    b6d4:	8b 95 70 ff ff ff    	mov    -0x90(%rbp),%edx

    memcpy(pipes, CMSG_DATA(chdr), sizeof(int) * 2);

    PAL_HANDLE clnt = malloc(HANDLE_SIZE(pipeprv));
    SET_HANDLE_TYPE(clnt, pipeprv);
    clnt->__in.flags |= RFD(0)|WFD(1)|WRITEABLE(1);
    b6da:	c7 40 08 91 00 00 00 	movl   $0x91,0x8(%rax)
    clnt->pipeprv.fds[0] = pipes[0];
    b6e1:	89 50 0c             	mov    %edx,0xc(%rax)
    clnt->pipeprv.fds[1] = pipes[1];
    b6e4:	8b 95 74 ff ff ff    	mov    -0x8c(%rbp),%edx
    b6ea:	89 50 10             	mov    %edx,0x10(%rax)
    *client = clnt;
    b6ed:	49 89 04 24          	mov    %rax,(%r12)
    clnt->pipe.pipeid = handle->pipe.pipeid;
    clnt->pipe.connid = connid;
    *client = clnt;
#endif

    return 0;
    b6f1:	31 c0                	xor    %eax,%eax
}
    b6f3:	48 81 c4 88 00 00 00 	add    $0x88,%rsp
    b6fa:	5b                   	pop    %rbx
    b6fb:	41 5c                	pop    %r12
    b6fd:	41 5d                	pop    %r13
    b6ff:	5d                   	pop    %rbp
    b700:	f3 c3                	repz retq 

    int newfd = INLINE_SYSCALL(accept4, 4, handle->pipe.fd, NULL, NULL,
                               SOCK_CLOEXEC);

    if (IS_ERR(newfd))
        switch (ERRNO(newfd)) {
    b702:	f7 db                	neg    %ebx
            case EWOULDBLOCK:
                return -PAL_ERROR_TRYAGAIN;
    b704:	b8 ed ff ff ff       	mov    $0xffffffed,%eax

    int newfd = INLINE_SYSCALL(accept4, 4, handle->pipe.fd, NULL, NULL,
                               SOCK_CLOEXEC);

    if (IS_ERR(newfd))
        switch (ERRNO(newfd)) {
    b709:	83 fb 0b             	cmp    $0xb,%ebx
    b70c:	74 e5                	je     b6f3 <pipe_waitforclient+0x153>
            case EWOULDBLOCK:
                return -PAL_ERROR_TRYAGAIN;
            case ECONNABORTED:
                return -PAL_ERROR_CONNFAILED;
            default:
                return -PAL_ERROR_DENIED;
    b70e:	83 fb 67             	cmp    $0x67,%ebx
    b711:	ba fa ff ff ff       	mov    $0xfffffffa,%edx
    b716:	b0 e8                	mov    $0xe8,%al
    b718:	0f 45 c2             	cmovne %edx,%eax
    b71b:	eb d6                	jmp    b6f3 <pipe_waitforclient+0x153>
    b71d:	0f 1f 00             	nopl   (%rax)
{
    if (!IS_HANDLE_TYPE(handle, pipesrv))
        return -PAL_ERROR_NOTSERVER;

    if (handle->pipe.fd == PAL_IDX_POISON)
        return -PAL_ERROR_DENIED;
    b720:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    b725:	eb cc                	jmp    b6f3 <pipe_waitforclient+0x153>
    b727:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    b72e:	00 00 
    b730:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    clnt->pipe.connid = connid;
    *client = clnt;
#endif

    return 0;
}
    b735:	c3                   	retq   
    b736:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    b73d:	00 00 00 

000000000000b740 <pipe_getname>:

    return 0;
}

static int pipe_getname (PAL_HANDLE handle, char * buffer, int count)
{
    b740:	55                   	push   %rbp
    b741:	48 89 e5             	mov    %rsp,%rbp
    b744:	41 57                	push   %r15
    b746:	41 56                	push   %r14
    b748:	41 55                	push   %r13
    b74a:	41 54                	push   %r12
    b74c:	49 89 f6             	mov    %rsi,%r14
    b74f:	53                   	push   %rbx
    b750:	48 83 ec 08          	sub    $0x8,%rsp
    int ret;

    const char * prefix = NULL;
    int prefix_len = 0;

    switch (HANDLE_TYPE(handle)) {
    b754:	8b 0f                	mov    (%rdi),%ecx
    b756:	83 f9 02             	cmp    $0x2,%ecx
    b759:	0f 84 d5 00 00 00    	je     b834 <pipe_getname+0xf4>
    b75f:	0f 82 bb 00 00 00    	jb     b820 <pipe_getname+0xe0>
    b765:	83 f9 04             	cmp    $0x4,%ecx
        case pal_type_pipesrv:
        case pal_type_pipecli:
            prefix_len = 8;
    b768:	bb 08 00 00 00       	mov    $0x8,%ebx
            prefix = "pipe.srv";
    b76d:	48 8d 35 16 cf 00 00 	lea    0xcf16(%rip),%rsi        # 1868a <write_config+0xda>
    int ret;

    const char * prefix = NULL;
    int prefix_len = 0;

    switch (HANDLE_TYPE(handle)) {
    b774:	0f 87 a6 00 00 00    	ja     b820 <pipe_getname+0xe0>
        case pal_type_pipeprv:
        default:
            return -PAL_ERROR_INVAL;
    }

    if (prefix_len >= count)
    b77a:	39 d3                	cmp    %edx,%ebx
        return -PAL_ERROR_OVERFLOW;
    b77c:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
        case pal_type_pipeprv:
        default:
            return -PAL_ERROR_INVAL;
    }

    if (prefix_len >= count)
    b781:	7d 64                	jge    b7e7 <pipe_getname+0xa7>
        return -PAL_ERROR_OVERFLOW;

    memcpy(buffer, prefix, prefix_len);
    b783:	4c 63 fb             	movslq %ebx,%r15
    b786:	49 89 fc             	mov    %rdi,%r12
    b789:	41 89 d5             	mov    %edx,%r13d
    b78c:	4c 89 f7             	mov    %r14,%rdi
    b78f:	4c 89 fa             	mov    %r15,%rdx
    buffer[prefix_len] = ':';
    buffer += prefix_len + 1;
    count -= prefix_len + 1;
    b792:	f7 d3                	not    %ebx
    }

    if (prefix_len >= count)
        return -PAL_ERROR_OVERFLOW;

    memcpy(buffer, prefix, prefix_len);
    b794:	e8 e7 aa 00 00       	callq  16280 <memcpy>
    buffer[prefix_len] = ':';
    b799:	43 c6 04 3e 3a       	movb   $0x3a,(%r14,%r15,1)
    buffer += prefix_len + 1;
    count -= prefix_len + 1;

    if (handle->pipe.connid)
    b79e:	45 8b 44 24 18       	mov    0x18(%r12),%r8d
        return -PAL_ERROR_OVERFLOW;

    memcpy(buffer, prefix, prefix_len);
    buffer[prefix_len] = ':';
    buffer += prefix_len + 1;
    count -= prefix_len + 1;
    b7a3:	44 01 eb             	add    %r13d,%ebx

    if (handle->pipe.connid)
        ret = snprintf(buffer, count, "%lu:%u\n", handle->pipe.pipeid,
    b7a6:	49 8b 4c 24 10       	mov    0x10(%r12),%rcx
    if (prefix_len >= count)
        return -PAL_ERROR_OVERFLOW;

    memcpy(buffer, prefix, prefix_len);
    buffer[prefix_len] = ':';
    buffer += prefix_len + 1;
    b7ab:	4f 8d 74 3e 01       	lea    0x1(%r14,%r15,1),%r14
    count -= prefix_len + 1;

    if (handle->pipe.connid)
        ret = snprintf(buffer, count, "%lu:%u\n", handle->pipe.pipeid,
    b7b0:	4c 63 e3             	movslq %ebx,%r12
    memcpy(buffer, prefix, prefix_len);
    buffer[prefix_len] = ':';
    buffer += prefix_len + 1;
    count -= prefix_len + 1;

    if (handle->pipe.connid)
    b7b3:	45 85 c0             	test   %r8d,%r8d
    b7b6:	75 48                	jne    b800 <pipe_getname+0xc0>
        ret = snprintf(buffer, count, "%lu:%u\n", handle->pipe.pipeid,
                       handle->pipe.connid);
    else
        ret = snprintf(buffer, count, "%lu\n", handle->pipe.pipeid);
    b7b8:	48 8d 15 85 f8 00 00 	lea    0xf885(%rip),%rdx        # 1b044 <slab_levels+0x1da4>
    b7bf:	4c 89 e6             	mov    %r12,%rsi
    b7c2:	4c 89 f7             	mov    %r14,%rdi
    b7c5:	31 c0                	xor    %eax,%eax
    b7c7:	e8 e4 d6 ff ff       	callq  8eb0 <pal_snprintf>

    if (buffer[ret - 1] != '\n') {
    b7cc:	48 63 d0             	movslq %eax,%rdx
    b7cf:	49 8d 54 16 ff       	lea    -0x1(%r14,%rdx,1),%rdx
    b7d4:	80 3a 0a             	cmpb   $0xa,(%rdx)
    b7d7:	75 6c                	jne    b845 <pipe_getname+0x105>
        return -PAL_ERROR_OVERFLOW;
    }

    buffer[ret - 1] = 0;
    buffer += ret - 1;
    count -= ret - 1;
    b7d9:	29 c3                	sub    %eax,%ebx
    if (buffer[ret - 1] != '\n') {
        memset(buffer, 0, count);
        return -PAL_ERROR_OVERFLOW;
    }

    buffer[ret - 1] = 0;
    b7db:	c6 02 00             	movb   $0x0,(%rdx)
    buffer += ret - 1;
    count -= ret - 1;
    b7de:	8d 43 01             	lea    0x1(%rbx),%eax

    return old_count - count;
    b7e1:	41 29 c5             	sub    %eax,%r13d
    b7e4:	44 89 e8             	mov    %r13d,%eax
}
    b7e7:	48 83 c4 08          	add    $0x8,%rsp
    b7eb:	5b                   	pop    %rbx
    b7ec:	41 5c                	pop    %r12
    b7ee:	41 5d                	pop    %r13
    b7f0:	41 5e                	pop    %r14
    b7f2:	41 5f                	pop    %r15
    b7f4:	5d                   	pop    %rbp
    b7f5:	c3                   	retq   
    b7f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    b7fd:	00 00 00 
    buffer[prefix_len] = ':';
    buffer += prefix_len + 1;
    count -= prefix_len + 1;

    if (handle->pipe.connid)
        ret = snprintf(buffer, count, "%lu:%u\n", handle->pipe.pipeid,
    b800:	48 8d 15 35 f8 00 00 	lea    0xf835(%rip),%rdx        # 1b03c <slab_levels+0x1d9c>
    b807:	4c 89 e6             	mov    %r12,%rsi
    b80a:	4c 89 f7             	mov    %r14,%rdi
    b80d:	31 c0                	xor    %eax,%eax
    b80f:	e8 9c d6 ff ff       	callq  8eb0 <pal_snprintf>
    b814:	eb b6                	jmp    b7cc <pipe_getname+0x8c>
    b816:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    b81d:	00 00 00 
    buffer[ret - 1] = 0;
    buffer += ret - 1;
    count -= ret - 1;

    return old_count - count;
}
    b820:	48 83 c4 08          	add    $0x8,%rsp
            prefix_len = 4;
            prefix = "pipe";
            break;
        case pal_type_pipeprv:
        default:
            return -PAL_ERROR_INVAL;
    b824:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    buffer[ret - 1] = 0;
    buffer += ret - 1;
    count -= ret - 1;

    return old_count - count;
}
    b829:	5b                   	pop    %rbx
    b82a:	41 5c                	pop    %r12
    b82c:	41 5d                	pop    %r13
    b82e:	41 5e                	pop    %r14
    b830:	41 5f                	pop    %r15
    b832:	5d                   	pop    %rbp
    b833:	c3                   	retq   
        case pal_type_pipecli:
            prefix_len = 8;
            prefix = "pipe.srv";
            break;
        case pal_type_pipe:
            prefix_len = 4;
    b834:	bb 04 00 00 00       	mov    $0x4,%ebx
            prefix = "pipe";
    b839:	48 8d 35 2f 3b 01 00 	lea    0x13b2f(%rip),%rsi        # 1f36f <sys_nerr_internal+0x233>
    b840:	e9 35 ff ff ff       	jmpq   b77a <pipe_getname+0x3a>
                       handle->pipe.connid);
    else
        ret = snprintf(buffer, count, "%lu\n", handle->pipe.pipeid);

    if (buffer[ret - 1] != '\n') {
        memset(buffer, 0, count);
    b845:	4c 89 e2             	mov    %r12,%rdx
    b848:	31 f6                	xor    %esi,%esi
    b84a:	4c 89 f7             	mov    %r14,%rdi
    b84d:	e8 4e a9 00 00       	callq  161a0 <memset>
        return -PAL_ERROR_OVERFLOW;
    b852:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
    b857:	eb 8e                	jmp    b7e7 <pipe_getname+0xa7>
    b859:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000000b860 <pipe_close>:
    return bytes;
}

/* 'close' operation of pipe stream. */
static int pipe_close (PAL_HANDLE handle)
{
    b860:	55                   	push   %rbp
    b861:	48 89 fa             	mov    %rdi,%rdx
    b864:	48 89 e5             	mov    %rsp,%rbp
    b867:	53                   	push   %rbx
    if (IS_HANDLE_TYPE(handle, pipeprv)) {
    b868:	83 3f 05             	cmpl   $0x5,(%rdi)
        if (handle->pipeprv.fds[0] != PAL_IDX_POISON) {
    b86b:	8b 7f 0c             	mov    0xc(%rdi),%edi
}

/* 'close' operation of pipe stream. */
static int pipe_close (PAL_HANDLE handle)
{
    if (IS_HANDLE_TYPE(handle, pipeprv)) {
    b86e:	74 20                	je     b890 <pipe_close+0x30>
            handle->pipeprv.fds[1] = PAL_IDX_POISON;
        }
        return 0;
    }

    if (handle->pipe.fd != PAL_IDX_POISON) {
    b870:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    b873:	74 16                	je     b88b <pipe_close+0x2b>
        INLINE_SYSCALL(close, 1, handle->pipe.fd);
    b875:	b8 06 00 00 00       	mov    $0x6,%eax
    b87a:	cd 80                	int    $0x80
    b87c:	bb 00 00 00 00       	mov    $0x0,%ebx
    b881:	83 d3 00             	adc    $0x0,%ebx
        handle->pipe.fd = PAL_IDX_POISON;
    b884:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rdx)
    }

    return 0;
}
    b88b:	31 c0                	xor    %eax,%eax
    b88d:	5b                   	pop    %rbx
    b88e:	5d                   	pop    %rbp
    b88f:	c3                   	retq   

/* 'close' operation of pipe stream. */
static int pipe_close (PAL_HANDLE handle)
{
    if (IS_HANDLE_TYPE(handle, pipeprv)) {
        if (handle->pipeprv.fds[0] != PAL_IDX_POISON) {
    b890:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    b893:	74 16                	je     b8ab <pipe_close+0x4b>
            INLINE_SYSCALL(close, 1, handle->pipeprv.fds[0]);
    b895:	b8 06 00 00 00       	mov    $0x6,%eax
    b89a:	cd 80                	int    $0x80
    b89c:	bb 00 00 00 00       	mov    $0x0,%ebx
    b8a1:	83 d3 00             	adc    $0x0,%ebx
            handle->pipeprv.fds[0] = PAL_IDX_POISON;
    b8a4:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rdx)
        }
        if (handle->pipeprv.fds[1] != PAL_IDX_POISON) {
    b8ab:	8b 7a 10             	mov    0x10(%rdx),%edi
    b8ae:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    b8b1:	74 d8                	je     b88b <pipe_close+0x2b>
            INLINE_SYSCALL(close, 1, handle->pipeprv.fds[1]);
    b8b3:	b8 06 00 00 00       	mov    $0x6,%eax
    b8b8:	cd 80                	int    $0x80
    b8ba:	bb 00 00 00 00       	mov    $0x0,%ebx
    b8bf:	83 d3 00             	adc    $0x0,%ebx
        INLINE_SYSCALL(close, 1, handle->pipe.fd);
        handle->pipe.fd = PAL_IDX_POISON;
    }

    return 0;
}
    b8c2:	31 c0                	xor    %eax,%eax
            INLINE_SYSCALL(close, 1, handle->pipeprv.fds[0]);
            handle->pipeprv.fds[0] = PAL_IDX_POISON;
        }
        if (handle->pipeprv.fds[1] != PAL_IDX_POISON) {
            INLINE_SYSCALL(close, 1, handle->pipeprv.fds[1]);
            handle->pipeprv.fds[1] = PAL_IDX_POISON;
    b8c4:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rdx)
        INLINE_SYSCALL(close, 1, handle->pipe.fd);
        handle->pipe.fd = PAL_IDX_POISON;
    }

    return 0;
}
    b8cb:	5b                   	pop    %rbx
    b8cc:	5d                   	pop    %rbp
    b8cd:	c3                   	retq   
    b8ce:	66 90                	xchg   %ax,%ax

000000000000b8d0 <pipe_path.constprop.3>:

#if USE_PIPE_SYSCALL == 1
# include <sys/msg.h>
#endif

static int pipe_path (int pipeid, char * path, int len)
    b8d0:	48 8b 05 d1 81 21 00 	mov    0x2181d1(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
    b8d7:	55                   	push   %rbp
    b8d8:	41 89 f9             	mov    %edi,%r9d
    b8db:	48 89 f7             	mov    %rsi,%rdi
    b8de:	48 89 e5             	mov    %rsp,%rbp
{
    if (pal_sec_info.pipe_prefix)
    b8e1:	4c 8b 40 10          	mov    0x10(%rax),%r8
        return snprintf(path, len, GRAPHENE_PIPEDIR "/%08x/%s%08x",
    b8e5:	8b 48 08             	mov    0x8(%rax),%ecx
# include <sys/msg.h>
#endif

static int pipe_path (int pipeid, char * path, int len)
{
    if (pal_sec_info.pipe_prefix)
    b8e8:	4d 85 c0             	test   %r8,%r8
    b8eb:	74 14                	je     b901 <pipe_path.constprop.3+0x31>
                        pal_sec_info.domain_id,
                        pal_sec_info.pipe_prefix, pipeid);
    else
        return snprintf(path, len, GRAPHENE_PIPEDIR "/%08x/%08x",
                        pal_sec_info.domain_id, pipeid);
}
    b8ed:	5d                   	pop    %rbp
#endif

static int pipe_path (int pipeid, char * path, int len)
{
    if (pal_sec_info.pipe_prefix)
        return snprintf(path, len, GRAPHENE_PIPEDIR "/%08x/%s%08x",
    b8ee:	48 8d 15 83 f7 00 00 	lea    0xf783(%rip),%rdx        # 1b078 <slab_levels+0x1dd8>
    b8f5:	be 6c 00 00 00       	mov    $0x6c,%esi
    b8fa:	31 c0                	xor    %eax,%eax
    b8fc:	e9 af d5 ff ff       	jmpq   8eb0 <pal_snprintf>
                        pal_sec_info.domain_id,
                        pal_sec_info.pipe_prefix, pipeid);
    else
        return snprintf(path, len, GRAPHENE_PIPEDIR "/%08x/%08x",
                        pal_sec_info.domain_id, pipeid);
}
    b901:	5d                   	pop    %rbp
    if (pal_sec_info.pipe_prefix)
        return snprintf(path, len, GRAPHENE_PIPEDIR "/%08x/%s%08x",
                        pal_sec_info.domain_id,
                        pal_sec_info.pipe_prefix, pipeid);
    else
        return snprintf(path, len, GRAPHENE_PIPEDIR "/%08x/%08x",
    b902:	48 8d 15 40 f7 00 00 	lea    0xf740(%rip),%rdx        # 1b049 <slab_levels+0x1da9>
    b909:	45 89 c8             	mov    %r9d,%r8d
    b90c:	be 6c 00 00 00       	mov    $0x6c,%esi
    b911:	31 c0                	xor    %eax,%eax
    b913:	e9 98 d5 ff ff       	jmpq   8eb0 <pal_snprintf>
    b918:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    b91f:	00 

000000000000b920 <pipe_open>:
   identified by a decimal number in URI. There could be two
   types: pipe and pipe.srv. They behave pretty much the same,
   except they are two ends of the pipe. */
static int pipe_open (PAL_HANDLE *handle, const char * type, const char * uri,
                      int access, int share, int create, int options)
{
    b920:	55                   	push   %rbp
    b921:	48 89 e5             	mov    %rsp,%rbp
    b924:	41 57                	push   %r15
    b926:	41 56                	push   %r14
    b928:	41 55                	push   %r13
    b92a:	41 54                	push   %r12
    b92c:	49 89 f5             	mov    %rsi,%r13
    b92f:	53                   	push   %rbx
    options &= PAL_OPTION_MASK;

    if (!memcmp(type, "pipe:", 5) && !*uri)
    b930:	48 8d 35 30 f7 00 00 	lea    0xf730(%rip),%rsi        # 1b067 <slab_levels+0x1dc7>
   identified by a decimal number in URI. There could be two
   types: pipe and pipe.srv. They behave pretty much the same,
   except they are two ends of the pipe. */
static int pipe_open (PAL_HANDLE *handle, const char * type, const char * uri,
                      int access, int share, int create, int options)
{
    b937:	49 89 d6             	mov    %rdx,%r14
    options &= PAL_OPTION_MASK;

    if (!memcmp(type, "pipe:", 5) && !*uri)
    b93a:	ba 05 00 00 00       	mov    $0x5,%edx
   identified by a decimal number in URI. There could be two
   types: pipe and pipe.srv. They behave pretty much the same,
   except they are two ends of the pipe. */
static int pipe_open (PAL_HANDLE *handle, const char * type, const char * uri,
                      int access, int share, int create, int options)
{
    b93f:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
    options &= PAL_OPTION_MASK;
    b946:	44 8b 65 10          	mov    0x10(%rbp),%r12d
   identified by a decimal number in URI. There could be two
   types: pipe and pipe.srv. They behave pretty much the same,
   except they are two ends of the pipe. */
static int pipe_open (PAL_HANDLE *handle, const char * type, const char * uri,
                      int access, int share, int create, int options)
{
    b94a:	48 89 bd d8 fe ff ff 	mov    %rdi,-0x128(%rbp)
    options &= PAL_OPTION_MASK;

    if (!memcmp(type, "pipe:", 5) && !*uri)
    b951:	4c 89 ef             	mov    %r13,%rdi
    b954:	e8 b7 a9 00 00       	callq  16310 <memcmp>
   types: pipe and pipe.srv. They behave pretty much the same,
   except they are two ends of the pipe. */
static int pipe_open (PAL_HANDLE *handle, const char * type, const char * uri,
                      int access, int share, int create, int options)
{
    options &= PAL_OPTION_MASK;
    b959:	41 83 e4 04          	and    $0x4,%r12d

    if (!memcmp(type, "pipe:", 5) && !*uri)
    b95d:	85 c0                	test   %eax,%eax
    b95f:	41 89 c7             	mov    %eax,%r15d
    b962:	75 0a                	jne    b96e <pipe_open+0x4e>
    b964:	41 80 3e 00          	cmpb   $0x0,(%r14)
    b968:	0f 84 62 04 00 00    	je     bdd0 <pipe_open+0x4b0>
        return pipe_private(handle, options);

    char * endptr;
    PAL_NUM pipeid = strtol(uri, &endptr, 10);
    b96e:	48 8d 9d e8 fe ff ff 	lea    -0x118(%rbp),%rbx
    b975:	4c 89 f7             	mov    %r14,%rdi
    b978:	ba 0a 00 00 00       	mov    $0xa,%edx
    b97d:	48 89 de             	mov    %rbx,%rsi
    b980:	e8 3b ae 00 00       	callq  167c0 <strtol>
    PAL_IDX connid = 0;

    if (*endptr == ':')
    b985:	48 8b bd e8 fe ff ff 	mov    -0x118(%rbp),%rdi

    if (!memcmp(type, "pipe:", 5) && !*uri)
        return pipe_private(handle, options);

    char * endptr;
    PAL_NUM pipeid = strtol(uri, &endptr, 10);
    b98c:	49 89 c6             	mov    %rax,%r14
    PAL_IDX connid = 0;

    if (*endptr == ':')
    b98f:	0f b6 07             	movzbl (%rdi),%eax
    b992:	3c 3a                	cmp    $0x3a,%al
    b994:	0f 84 c6 04 00 00    	je     be60 <pipe_open+0x540>
        connid = strtol(endptr + 1, &endptr, 10);

    if (*endptr)
    b99a:	84 c0                	test   %al,%al
    b99c:	0f 85 ae 04 00 00    	jne    be50 <pipe_open+0x530>
        return -PAL_ERROR_INVAL;

    if (!memcmp(type, "pipe.srv:", 9))
    b9a2:	48 8d 35 c4 f6 00 00 	lea    0xf6c4(%rip),%rsi        # 1b06d <slab_levels+0x1dcd>
    b9a9:	ba 09 00 00 00       	mov    $0x9,%edx
    b9ae:	4c 89 ef             	mov    %r13,%rdi
    b9b1:	e8 5a a9 00 00       	callq  16310 <memcmp>
    b9b6:	85 c0                	test   %eax,%eax
    b9b8:	41 89 c7             	mov    %eax,%r15d
    b9bb:	0f 84 7f 02 00 00    	je     bc40 <pipe_open+0x320>
        return pipe_listen(handle, pipeid, options);

    if (!memcmp(type, "pipe:", 5))
    b9c1:	48 8d 35 9f f6 00 00 	lea    0xf69f(%rip),%rsi        # 1b067 <slab_levels+0x1dc7>
    b9c8:	ba 05 00 00 00       	mov    $0x5,%edx
    b9cd:	4c 89 ef             	mov    %r13,%rdi
    b9d0:	e8 3b a9 00 00       	callq  16310 <memcmp>
    b9d5:	85 c0                	test   %eax,%eax
    b9d7:	41 89 c7             	mov    %eax,%r15d
    b9da:	0f 85 70 04 00 00    	jne    be50 <pipe_open+0x530>
                         int options)
{
    int ret, fd;

#if USE_PIPE_SYSCALL == 1
    fd = INLINE_SYSCALL(socket, 3, AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC, 0);
    b9e0:	b9 61 00 00 00       	mov    $0x61,%ecx
    b9e5:	31 d2                	xor    %edx,%edx
    b9e7:	be 01 00 00 10       	mov    $0x10000001,%esi
    b9ec:	bf 01 00 00 00       	mov    $0x1,%edi
    b9f1:	89 c8                	mov    %ecx,%eax
    b9f3:	cd 80                	int    $0x80
    b9f5:	48 89 c2             	mov    %rax,%rdx
    b9f8:	bb 00 00 00 00       	mov    $0x0,%ebx
    b9fd:	83 d3 00             	adc    $0x0,%ebx
    ba00:	31 ff                	xor    %edi,%edi
    ba02:	85 db                	test   %ebx,%ebx
    ba04:	40 0f 95 c7          	setne  %dil
    ba08:	48 89 f8             	mov    %rdi,%rax
    ba0b:	48 f7 d8             	neg    %rax
    ba0e:	48 31 d0             	xor    %rdx,%rax
    ba11:	48 8d 1c 38          	lea    (%rax,%rdi,1),%rbx
#else
    fd = INLINE_SYSCALL(socket, 3, AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|options,
                        0);
#endif

    if (IS_ERR(fd))
    ba15:	85 db                	test   %ebx,%ebx
    ba17:	0f 88 63 04 00 00    	js     be80 <pipe_open+0x560>
}

static int pipe_addr (int pipeid, struct sockaddr_un * addr)
{
    addr->sun_family = AF_UNIX;
    return pipe_path(pipeid, (char *) addr->sun_path, 108);
    ba1d:	4c 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%r8
    ba24:	44 89 f7             	mov    %r14d,%edi
                        pal_sec_info.domain_id, pipeid);
}

static int pipe_addr (int pipeid, struct sockaddr_un * addr)
{
    addr->sun_family = AF_UNIX;
    ba27:	c6 85 61 ff ff ff 01 	movb   $0x1,-0x9f(%rbp)
    return pipe_path(pipeid, (char *) addr->sun_path, 108);
    ba2e:	49 8d 70 02          	lea    0x2(%r8),%rsi
    ba32:	4c 89 85 d0 fe ff ff 	mov    %r8,-0x130(%rbp)
    ba39:	e8 92 fe ff ff       	callq  b8d0 <pipe_path.constprop.3>
    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;

    struct sockaddr_un addr;

    if ((ret = pipe_addr(pipeid, &addr)) < 0)
    ba3e:	85 c0                	test   %eax,%eax
    ba40:	0f 88 fa 03 00 00    	js     be40 <pipe_open+0x520>
        return ret;

    ret = INLINE_SYSCALL(connect, 3, fd, &addr,
    ba46:	4c 8b 85 d0 fe ff ff 	mov    -0x130(%rbp),%r8
    ba4d:	4c 63 eb             	movslq %ebx,%r13
    ba50:	b9 62 00 00 00       	mov    $0x62,%ecx
    ba55:	ba 6a 00 00 00       	mov    $0x6a,%edx
    ba5a:	4c 89 ef             	mov    %r13,%rdi
    ba5d:	89 c8                	mov    %ecx,%eax
    ba5f:	4c 89 c6             	mov    %r8,%rsi
    ba62:	cd 80                	int    $0x80
    ba64:	48 89 c6             	mov    %rax,%rsi
    ba67:	bb 00 00 00 00       	mov    $0x0,%ebx
    ba6c:	83 d3 00             	adc    $0x0,%ebx
    ba6f:	31 d2                	xor    %edx,%edx
    ba71:	85 db                	test   %ebx,%ebx
    ba73:	0f 95 c2             	setne  %dl
    ba76:	48 89 d0             	mov    %rdx,%rax
    ba79:	48 f7 d8             	neg    %rax
    ba7c:	48 31 f0             	xor    %rsi,%rax
    ba7f:	48 01 c2             	add    %rax,%rdx
                         sizeof(struct sockaddr_un));
    if (IS_ERR(ret)) {
    ba82:	85 d2                	test   %edx,%edx
    ba84:	0f 88 d6 02 00 00    	js     bd60 <pipe_open+0x440>
    }

#if USE_PIPE_SYSCALL == 1
    int pipes[4], tmp;

    INLINE_SYSCALL(pipe2, 2, &pipes[0], O_CLOEXEC|options);
    ba8a:	44 89 e2             	mov    %r12d,%edx
    ba8d:	41 b9 1e 02 00 00    	mov    $0x21e,%r9d
    ba93:	48 8d bd f0 fe ff ff 	lea    -0x110(%rbp),%rdi
    ba9a:	81 ca 00 00 10 00    	or     $0x100000,%edx
    baa0:	44 89 c8             	mov    %r9d,%eax
    baa3:	48 63 d2             	movslq %edx,%rdx
    baa6:	48 89 d6             	mov    %rdx,%rsi
    baa9:	cd 80                	int    $0x80
    baab:	bb 00 00 00 00       	mov    $0x0,%ebx
    bab0:	83 d3 00             	adc    $0x0,%ebx
    INLINE_SYSCALL(pipe2, 2, &pipes[2], O_CLOEXEC|options);
    bab3:	49 89 fe             	mov    %rdi,%r14
    bab6:	44 89 c8             	mov    %r9d,%eax
    bab9:	48 8d 7f 08          	lea    0x8(%rdi),%rdi
    babd:	cd 80                	int    $0x80
    babf:	bb 00 00 00 00       	mov    $0x0,%ebx
    bac4:	83 d3 00             	adc    $0x0,%ebx

    tmp = pipes[3];
    pipes[3] = pipes[1];
    bac7:	8b 95 f4 fe ff ff    	mov    -0x10c(%rbp),%edx
    int pipes[4], tmp;

    INLINE_SYSCALL(pipe2, 2, &pipes[0], O_CLOEXEC|options);
    INLINE_SYSCALL(pipe2, 2, &pipes[2], O_CLOEXEC|options);

    tmp = pipes[3];
    bacd:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
    struct msghdr hdr;
    struct iovec iov;
    char cbuf[sizeof(struct cmsghdr) + 3 * sizeof(int)];
    char b = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    bad3:	48 8d 9d 30 ff ff ff 	lea    -0xd0(%rbp),%rbx
    bada:	31 f6                	xor    %esi,%esi
    pipes[1] = tmp;

    struct msghdr hdr;
    struct iovec iov;
    char cbuf[sizeof(struct cmsghdr) + 3 * sizeof(int)];
    char b = 0;
    badc:	c6 85 e7 fe ff ff 00 	movb   $0x0,-0x119(%rbp)

    memset(&hdr, 0, sizeof(struct msghdr));
    bae3:	48 89 df             	mov    %rbx,%rdi

    INLINE_SYSCALL(pipe2, 2, &pipes[0], O_CLOEXEC|options);
    INLINE_SYSCALL(pipe2, 2, &pipes[2], O_CLOEXEC|options);

    tmp = pipes[3];
    pipes[3] = pipes[1];
    bae6:	89 95 fc fe ff ff    	mov    %edx,-0x104(%rbp)
    struct msghdr hdr;
    struct iovec iov;
    char cbuf[sizeof(struct cmsghdr) + 3 * sizeof(int)];
    char b = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    baec:	ba 30 00 00 00       	mov    $0x30,%edx
    INLINE_SYSCALL(pipe2, 2, &pipes[0], O_CLOEXEC|options);
    INLINE_SYSCALL(pipe2, 2, &pipes[2], O_CLOEXEC|options);

    tmp = pipes[3];
    pipes[3] = pipes[1];
    pipes[1] = tmp;
    baf1:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%rbp)
    struct msghdr hdr;
    struct iovec iov;
    char cbuf[sizeof(struct cmsghdr) + 3 * sizeof(int)];
    char b = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    baf7:	e8 a4 a6 00 00       	callq  161a0 <memset>
    hdr.msg_iov = &iov;
    bafc:	48 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%rax
    hdr.msg_iovlen = 1;
    hdr.msg_control = cbuf;
    hdr.msg_controllen = sizeof(cbuf);
    iov.iov_base = &b;
    bb03:	48 8d 95 e7 fe ff ff 	lea    -0x119(%rbp),%rdx
    iov.iov_len = 1;
    struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
    chdr->cmsg_level = SOL_SOCKET;
    chdr->cmsg_type = SCM_RIGHTS;
    chdr->cmsg_len = CMSG_LEN(sizeof(int) * 2);
    memcpy(CMSG_DATA(chdr), &pipes[2], sizeof(int) * 2);
    bb0a:	49 8d 76 08          	lea    0x8(%r14),%rsi
    char cbuf[sizeof(struct cmsghdr) + 3 * sizeof(int)];
    char b = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    bb0e:	c7 85 48 ff ff ff 01 	movl   $0x1,-0xb8(%rbp)
    bb15:	00 00 00 
    hdr.msg_control = cbuf;
    hdr.msg_controllen = sizeof(cbuf);
    bb18:	c7 85 58 ff ff ff 18 	movl   $0x18,-0xa8(%rbp)
    bb1f:	00 00 00 
    struct iovec iov;
    char cbuf[sizeof(struct cmsghdr) + 3 * sizeof(int)];
    char b = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    hdr.msg_iov = &iov;
    bb22:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = cbuf;
    bb29:	48 8d 85 10 ff ff ff 	lea    -0xf0(%rbp),%rax
    hdr.msg_controllen = sizeof(cbuf);
    iov.iov_base = &b;
    bb30:	48 89 95 00 ff ff ff 	mov    %rdx,-0x100(%rbp)
    iov.iov_len = 1;
    struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
    chdr->cmsg_level = SOL_SOCKET;
    chdr->cmsg_type = SCM_RIGHTS;
    chdr->cmsg_len = CMSG_LEN(sizeof(int) * 2);
    memcpy(CMSG_DATA(chdr), &pipes[2], sizeof(int) * 2);
    bb37:	ba 08 00 00 00       	mov    $0x8,%edx
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = cbuf;
    hdr.msg_controllen = sizeof(cbuf);
    iov.iov_base = &b;
    iov.iov_len = 1;
    bb3c:	48 c7 85 08 ff ff ff 	movq   $0x1,-0xf8(%rbp)
    bb43:	01 00 00 00 
    struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
    chdr->cmsg_level = SOL_SOCKET;
    bb47:	c7 85 14 ff ff ff ff 	movl   $0xffff,-0xec(%rbp)
    bb4e:	ff 00 00 
    chdr->cmsg_type = SCM_RIGHTS;
    chdr->cmsg_len = CMSG_LEN(sizeof(int) * 2);
    memcpy(CMSG_DATA(chdr), &pipes[2], sizeof(int) * 2);
    bb51:	48 8d 78 10          	lea    0x10(%rax),%rdi
    char b = 0;

    memset(&hdr, 0, sizeof(struct msghdr));
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = cbuf;
    bb55:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
    hdr.msg_controllen = sizeof(cbuf);
    iov.iov_base = &b;
    iov.iov_len = 1;
    struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
    chdr->cmsg_level = SOL_SOCKET;
    chdr->cmsg_type = SCM_RIGHTS;
    bb5c:	c7 85 18 ff ff ff 01 	movl   $0x1,-0xe8(%rbp)
    bb63:	00 00 00 
    chdr->cmsg_len = CMSG_LEN(sizeof(int) * 2);
    bb66:	c7 85 10 ff ff ff 18 	movl   $0x18,-0xf0(%rbp)
    bb6d:	00 00 00 
    memcpy(CMSG_DATA(chdr), &pipes[2], sizeof(int) * 2);
    bb70:	e8 0b a7 00 00       	callq  16280 <memcpy>

    ret = INLINE_SYSCALL(sendmsg, 3, fd, &hdr, 0);
    bb75:	b9 1c 00 00 00       	mov    $0x1c,%ecx
    bb7a:	31 d2                	xor    %edx,%edx
    bb7c:	48 89 de             	mov    %rbx,%rsi
    bb7f:	4c 89 ef             	mov    %r13,%rdi
    bb82:	89 c8                	mov    %ecx,%eax
    bb84:	cd 80                	int    $0x80
    bb86:	48 89 c2             	mov    %rax,%rdx
    bb89:	bb 00 00 00 00       	mov    $0x0,%ebx
    bb8e:	83 d3 00             	adc    $0x0,%ebx
    bb91:	45 31 c0             	xor    %r8d,%r8d
    INLINE_SYSCALL(close, 1, fd);
    bb94:	be 06 00 00 00       	mov    $0x6,%esi
    bb99:	85 db                	test   %ebx,%ebx
    bb9b:	41 0f 95 c0          	setne  %r8b
    bb9f:	89 f0                	mov    %esi,%eax
    bba1:	cd 80                	int    $0x80
    bba3:	bb 00 00 00 00       	mov    $0x0,%ebx
    bba8:	83 d3 00             	adc    $0x0,%ebx
    INLINE_SYSCALL(close, 1, pipes[2]);
    bbab:	48 63 bd f8 fe ff ff 	movslq -0x108(%rbp),%rdi
    bbb2:	89 f0                	mov    %esi,%eax
    bbb4:	cd 80                	int    $0x80
    bbb6:	bb 00 00 00 00       	mov    $0x0,%ebx
    bbbb:	83 d3 00             	adc    $0x0,%ebx
    INLINE_SYSCALL(close, 1, pipes[3]);
    bbbe:	48 63 bd fc fe ff ff 	movslq -0x104(%rbp),%rdi
    bbc5:	89 f0                	mov    %esi,%eax
    bbc7:	cd 80                	int    $0x80
    bbc9:	bb 00 00 00 00       	mov    $0x0,%ebx
    bbce:	83 d3 00             	adc    $0x0,%ebx
    bbd1:	4c 89 c0             	mov    %r8,%rax
    bbd4:	48 f7 d8             	neg    %rax
    bbd7:	48 31 c2             	xor    %rax,%rdx

    if (IS_ERR(ret)) {
    bbda:	89 d0                	mov    %edx,%eax
    bbdc:	44 01 c0             	add    %r8d,%eax
    bbdf:	0f 88 a6 02 00 00    	js     be8b <pipe_open+0x56b>
        INLINE_SYSCALL(close, 1, pipes[0]);
        INLINE_SYSCALL(close, 1, pipes[1]);
        return -PAL_ERROR_DENIED;
    }

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(pipeprv));
    bbe5:	bf 18 00 00 00       	mov    $0x18,%edi
    bbea:	e8 11 ce ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, pipeprv);
    bbef:	c7 00 05 00 00 00    	movl   $0x5,(%rax)
    bbf5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    hdl->__in.flags |= RFD(0)|WFD(1)|WRITEABLE(1);
    bbfc:	c7 40 08 91 00 00 00 	movl   $0x91,0x8(%rax)
    hdl->pipeprv.fds[0] = pipes[0];
    bc03:	8b 95 f0 fe ff ff    	mov    -0x110(%rbp),%edx
    bc09:	89 50 0c             	mov    %edx,0xc(%rax)
    hdl->pipeprv.fds[1] = pipes[1];
    bc0c:	8b 95 f4 fe ff ff    	mov    -0x10c(%rbp),%edx
    hdl->pipeprv.nonblocking = (options & PAL_OPTION_NONBLOCK) ?
                               PAL_TRUE : PAL_FALSE;
    bc12:	45 85 e4             	test   %r12d,%r12d

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(pipeprv));
    SET_HANDLE_TYPE(hdl, pipeprv);
    hdl->__in.flags |= RFD(0)|WFD(1)|WRITEABLE(1);
    hdl->pipeprv.fds[0] = pipes[0];
    hdl->pipeprv.fds[1] = pipes[1];
    bc15:	89 50 10             	mov    %edx,0x10(%rax)
    hdl->pipeprv.nonblocking = (options & PAL_OPTION_NONBLOCK) ?
    bc18:	0f 95 40 14          	setne  0x14(%rax)
    hdl->pipe.pipeid = pipeid;
    hdl->pipe.connid = 0;
    hdl->pipe.nonblocking = (options & PAL_OPTION_NONBLOCK) ?
                            PAL_TRUE : PAL_FALSE;
#endif
    *handle = hdl;
    bc1c:	48 8b 8d d8 fe ff ff 	mov    -0x128(%rbp),%rcx
    bc23:	48 89 01             	mov    %rax,(%rcx)

    if (!memcmp(type, "pipe:", 5))
        return pipe_connect(handle, pipeid, connid, options);

    return -PAL_ERROR_INVAL;
}
    bc26:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
    bc2d:	44 89 f8             	mov    %r15d,%eax
    bc30:	5b                   	pop    %rbx
    bc31:	41 5c                	pop    %r12
    bc33:	41 5d                	pop    %r13
    bc35:	41 5e                	pop    %r14
    bc37:	41 5f                	pop    %r15
    bc39:	5d                   	pop    %rbp
    bc3a:	c3                   	retq   
    bc3b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

static int pipe_listen (PAL_HANDLE * handle, PAL_NUM pipeid, int options)
{
    int ret, fd;

    fd = INLINE_SYSCALL(socket, 3, AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|options,
    bc40:	44 89 e6             	mov    %r12d,%esi
    bc43:	b9 61 00 00 00       	mov    $0x61,%ecx
    bc48:	31 d2                	xor    %edx,%edx
    bc4a:	81 ce 01 00 00 10    	or     $0x10000001,%esi
    bc50:	bf 01 00 00 00       	mov    $0x1,%edi
    bc55:	89 c8                	mov    %ecx,%eax
    bc57:	48 63 f6             	movslq %esi,%rsi
    bc5a:	cd 80                	int    $0x80
    bc5c:	48 89 c2             	mov    %rax,%rdx
    bc5f:	bb 00 00 00 00       	mov    $0x0,%ebx
    bc64:	83 d3 00             	adc    $0x0,%ebx
    bc67:	31 f6                	xor    %esi,%esi
    bc69:	85 db                	test   %ebx,%ebx
    bc6b:	40 0f 95 c6          	setne  %sil
    bc6f:	48 89 f0             	mov    %rsi,%rax
    bc72:	48 f7 d8             	neg    %rax
    bc75:	48 31 d0             	xor    %rdx,%rax
    bc78:	4c 8d 2c 30          	lea    (%rax,%rsi,1),%r13
                        0);
    if (IS_ERR(fd))
    bc7c:	45 85 ed             	test   %r13d,%r13d
    bc7f:	0f 88 fb 01 00 00    	js     be80 <pipe_open+0x560>
}

static int pipe_addr (int pipeid, struct sockaddr_un * addr)
{
    addr->sun_family = AF_UNIX;
    return pipe_path(pipeid, (char *) addr->sun_path, 108);
    bc85:	48 8d 9d 60 ff ff ff 	lea    -0xa0(%rbp),%rbx
    bc8c:	44 89 f7             	mov    %r14d,%edi
                        pal_sec_info.domain_id, pipeid);
}

static int pipe_addr (int pipeid, struct sockaddr_un * addr)
{
    addr->sun_family = AF_UNIX;
    bc8f:	c6 85 61 ff ff ff 01 	movb   $0x1,-0x9f(%rbp)
    return pipe_path(pipeid, (char *) addr->sun_path, 108);
    bc96:	48 8d 73 02          	lea    0x2(%rbx),%rsi
    bc9a:	e8 31 fc ff ff       	callq  b8d0 <pipe_path.constprop.3>
    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;

    struct sockaddr_un addr;

    if ((ret = pipe_addr(pipeid, &addr)) < 0)
    bc9f:	85 c0                	test   %eax,%eax
    bca1:	0f 88 99 01 00 00    	js     be40 <pipe_open+0x520>
        return ret;

    ret = INLINE_SYSCALL(bind, 3, fd, &addr,
    bca7:	4d 63 c5             	movslq %r13d,%r8
    bcaa:	b9 68 00 00 00       	mov    $0x68,%ecx
    bcaf:	ba 6a 00 00 00       	mov    $0x6a,%edx
    bcb4:	48 89 de             	mov    %rbx,%rsi
    bcb7:	4c 89 c7             	mov    %r8,%rdi
    bcba:	89 c8                	mov    %ecx,%eax
    bcbc:	cd 80                	int    $0x80
    bcbe:	48 89 c2             	mov    %rax,%rdx
    bcc1:	bb 00 00 00 00       	mov    $0x0,%ebx
    bcc6:	83 d3 00             	adc    $0x0,%ebx
    bcc9:	31 f6                	xor    %esi,%esi
    bccb:	85 db                	test   %ebx,%ebx
    bccd:	40 0f 95 c6          	setne  %sil
    bcd1:	48 89 f0             	mov    %rsi,%rax
    bcd4:	48 f7 d8             	neg    %rax
    bcd7:	48 31 d0             	xor    %rdx,%rax
    bcda:	48 8d 14 30          	lea    (%rax,%rsi,1),%rdx
                         sizeof(struct sockaddr_un));

    if (IS_ERR(ret)) {
    bcde:	85 d2                	test   %edx,%edx
    bce0:	0f 88 ae 00 00 00    	js     bd94 <pipe_open+0x474>
            default:
                return -PAL_ERROR_DENIED;
        }
    }

    ret = INLINE_SYSCALL(listen, 2, fd, 1);
    bce6:	b9 6a 00 00 00       	mov    $0x6a,%ecx
    bceb:	be 01 00 00 00       	mov    $0x1,%esi
    bcf0:	4c 89 c7             	mov    %r8,%rdi
    bcf3:	89 c8                	mov    %ecx,%eax
    bcf5:	cd 80                	int    $0x80
    bcf7:	48 89 c2             	mov    %rax,%rdx
    bcfa:	bb 00 00 00 00       	mov    $0x0,%ebx
    bcff:	83 d3 00             	adc    $0x0,%ebx
    bd02:	31 f6                	xor    %esi,%esi
    bd04:	85 db                	test   %ebx,%ebx
    bd06:	40 0f 95 c6          	setne  %sil
    bd0a:	48 89 f0             	mov    %rsi,%rax
    bd0d:	48 f7 d8             	neg    %rax
    bd10:	48 31 c2             	xor    %rax,%rdx
    if (IS_ERR(ret))
    bd13:	89 d0                	mov    %edx,%eax
    bd15:	01 f0                	add    %esi,%eax
    bd17:	0f 88 63 01 00 00    	js     be80 <pipe_open+0x560>
        return -PAL_ERROR_DENIED;

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(pipe));
    bd1d:	bf 20 00 00 00       	mov    $0x20,%edi
    bd22:	e8 d9 cc ff ff       	callq  8a00 <malloc>
    hdl->pipe.fd = fd;
    hdl->pipe.pipeid = pipeid;
    hdl->pipe.connid = 0;
    hdl->pipe.nonblocking = options & PAL_OPTION_NONBLOCK ?
                            PAL_TRUE : PAL_FALSE;
    *handle = hdl;
    bd27:	48 8b 8d d8 fe ff ff 	mov    -0x128(%rbp),%rcx
    hdl->__in.flags |= RFD(0);
    hdl->pipe.fd = fd;
    hdl->pipe.pipeid = pipeid;
    hdl->pipe.connid = 0;
    hdl->pipe.nonblocking = options & PAL_OPTION_NONBLOCK ?
                            PAL_TRUE : PAL_FALSE;
    bd2e:	45 85 e4             	test   %r12d,%r12d
    ret = INLINE_SYSCALL(listen, 2, fd, 1);
    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(pipe));
    SET_HANDLE_TYPE(hdl, pipesrv);
    bd31:	c7 00 03 00 00 00    	movl   $0x3,(%rax)
    bd37:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    hdl->__in.flags |= RFD(0);
    bd3e:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)
    hdl->pipe.fd = fd;
    bd45:	44 89 68 0c          	mov    %r13d,0xc(%rax)
    hdl->pipe.pipeid = pipeid;
    bd49:	4c 89 70 10          	mov    %r14,0x10(%rax)
    hdl->pipe.connid = 0;
    bd4d:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%rax)
    hdl->pipe.nonblocking = options & PAL_OPTION_NONBLOCK ?
    bd54:	0f 95 40 1c          	setne  0x1c(%rax)
                            PAL_TRUE : PAL_FALSE;
    *handle = hdl;
    bd58:	48 89 01             	mov    %rax,(%rcx)
    bd5b:	e9 c6 fe ff ff       	jmpq   bc26 <pipe_open+0x306>
        return ret;

    ret = INLINE_SYSCALL(connect, 3, fd, &addr,
                         sizeof(struct sockaddr_un));
    if (IS_ERR(ret)) {
        INLINE_SYSCALL(close, 1, fd);
    bd60:	b8 06 00 00 00       	mov    $0x6,%eax
    bd65:	cd 80                	int    $0x80
    bd67:	bb 00 00 00 00       	mov    $0x0,%ebx
    bd6c:	83 d3 00             	adc    $0x0,%ebx
        switch (ERRNO(ret)) {
    bd6f:	f7 da                	neg    %edx
            case ECONNREFUSED:
                return -PAL_ERROR_STREAMNOTEXIST;
            case EINTR:
                return -PAL_ERROR_TRYAGAIN;
    bd71:	41 bf ed ff ff ff    	mov    $0xffffffed,%r15d

    ret = INLINE_SYSCALL(connect, 3, fd, &addr,
                         sizeof(struct sockaddr_un));
    if (IS_ERR(ret)) {
        INLINE_SYSCALL(close, 1, fd);
        switch (ERRNO(ret)) {
    bd77:	83 fa 04             	cmp    $0x4,%edx
    bd7a:	0f 84 a6 fe ff ff    	je     bc26 <pipe_open+0x306>
            case ECONNREFUSED:
                return -PAL_ERROR_STREAMNOTEXIST;
            case EINTR:
                return -PAL_ERROR_TRYAGAIN;
            default:
                return -PAL_ERROR_DENIED;
    bd80:	45 31 ff             	xor    %r15d,%r15d
    bd83:	83 fa 6f             	cmp    $0x6f,%edx
    bd86:	41 0f 95 c7          	setne  %r15b
    bd8a:	47 8d 7c 7f f7       	lea    -0x9(%r15,%r15,2),%r15d
    bd8f:	e9 92 fe ff ff       	jmpq   bc26 <pipe_open+0x306>

    ret = INLINE_SYSCALL(bind, 3, fd, &addr,
                         sizeof(struct sockaddr_un));

    if (IS_ERR(ret)) {
        INLINE_SYSCALL(close, 1, fd);
    bd94:	b8 06 00 00 00       	mov    $0x6,%eax
    bd99:	cd 80                	int    $0x80
    bd9b:	bb 00 00 00 00       	mov    $0x0,%ebx
    bda0:	83 d3 00             	adc    $0x0,%ebx

        switch(ERRNO(ret)) {
    bda3:	f7 da                	neg    %edx
            case EINVAL:
                return -PAL_ERROR_INVAL;
    bda5:	41 bf fc ff ff ff    	mov    $0xfffffffc,%r15d
                         sizeof(struct sockaddr_un));

    if (IS_ERR(ret)) {
        INLINE_SYSCALL(close, 1, fd);

        switch(ERRNO(ret)) {
    bdab:	83 fa 16             	cmp    $0x16,%edx
    bdae:	0f 84 72 fe ff ff    	je     bc26 <pipe_open+0x306>
            case EINVAL:
                return -PAL_ERROR_INVAL;
            case EADDRINUSE:
                return -PAL_ERROR_STREAMEXIST;
            default:
                return -PAL_ERROR_DENIED;
    bdb4:	45 31 ff             	xor    %r15d,%r15d
    bdb7:	83 fa 62             	cmp    $0x62,%edx
    bdba:	41 0f 95 c7          	setne  %r15b
    bdbe:	47 8d 7c 3f f8       	lea    -0x8(%r15,%r15,1),%r15d
    bdc3:	e9 5e fe ff ff       	jmpq   bc26 <pipe_open+0x306>
    bdc8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    bdcf:	00 
static int pipe_private (PAL_HANDLE * handle, int options)
{
    int ret, fds[2];

#if USE_PIPE_SYSCALL == 1
    ret = INLINE_SYSCALL(pipe2, 2, fds, O_CLOEXEC|options);
    bdd0:	44 89 e6             	mov    %r12d,%esi
    bdd3:	b9 1e 02 00 00       	mov    $0x21e,%ecx
    bdd8:	48 8d bd 60 ff ff ff 	lea    -0xa0(%rbp),%rdi
    bddf:	81 ce 00 00 10 00    	or     $0x100000,%esi
    bde5:	89 c8                	mov    %ecx,%eax
    bde7:	48 63 f6             	movslq %esi,%rsi
    bdea:	cd 80                	int    $0x80
    bdec:	48 89 c2             	mov    %rax,%rdx
    bdef:	bb 00 00 00 00       	mov    $0x0,%ebx
    bdf4:	83 d3 00             	adc    $0x0,%ebx
    bdf7:	31 f6                	xor    %esi,%esi
    bdf9:	85 db                	test   %ebx,%ebx
    bdfb:	40 0f 95 c6          	setne  %sil
    bdff:	48 89 f0             	mov    %rsi,%rax
    be02:	48 f7 d8             	neg    %rax
    be05:	48 31 c2             	xor    %rax,%rdx
#else
    ret = INLINE_SYSCALL(socketpair, 4, AF_UNIX,
                         SOCK_STREAM|SOCK_CLOEXEC|options, 0, fds);
#endif
    if (IS_ERR(ret))
    be08:	89 d0                	mov    %edx,%eax
    be0a:	01 f0                	add    %esi,%eax
    be0c:	78 72                	js     be80 <pipe_open+0x560>
        return -PAL_ERROR_DENIED;

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(pipeprv));
    be0e:	bf 18 00 00 00       	mov    $0x18,%edi
    be13:	e8 e8 cb ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, pipeprv);
    be18:	c7 00 05 00 00 00    	movl   $0x5,(%rax)
    be1e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    hdl->__in.flags |= RFD(0)|WFD(1)|WRITEABLE(1);
    be25:	c7 40 08 91 00 00 00 	movl   $0x91,0x8(%rax)
    hdl->pipeprv.fds[0] = fds[0];
    be2c:	8b 95 60 ff ff ff    	mov    -0xa0(%rbp),%edx
    be32:	89 50 0c             	mov    %edx,0xc(%rax)
    hdl->pipeprv.fds[1] = fds[1];
    be35:	8b 95 64 ff ff ff    	mov    -0x9c(%rbp),%edx
    be3b:	e9 d2 fd ff ff       	jmpq   bc12 <pipe_open+0x2f2>
    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;

    struct sockaddr_un addr;

    if ((ret = pipe_addr(pipeid, &addr)) < 0)
    be40:	41 89 c7             	mov    %eax,%r15d
    be43:	e9 de fd ff ff       	jmpq   bc26 <pipe_open+0x306>
    be48:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    be4f:	00 

    if (*endptr == ':')
        connid = strtol(endptr + 1, &endptr, 10);

    if (*endptr)
        return -PAL_ERROR_INVAL;
    be50:	41 bf fc ff ff ff    	mov    $0xfffffffc,%r15d
    be56:	e9 cb fd ff ff       	jmpq   bc26 <pipe_open+0x306>
    be5b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    char * endptr;
    PAL_NUM pipeid = strtol(uri, &endptr, 10);
    PAL_IDX connid = 0;

    if (*endptr == ':')
        connid = strtol(endptr + 1, &endptr, 10);
    be60:	48 83 c7 01          	add    $0x1,%rdi
    be64:	ba 0a 00 00 00       	mov    $0xa,%edx
    be69:	48 89 de             	mov    %rbx,%rsi
    be6c:	e8 4f a9 00 00       	callq  167c0 <strtol>
    be71:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
    be78:	0f b6 00             	movzbl (%rax),%eax
    be7b:	e9 1a fb ff ff       	jmpq   b99a <pipe_open+0x7a>
    fd = INLINE_SYSCALL(socket, 3, AF_UNIX, SOCK_STREAM|SOCK_CLOEXEC|options,
                        0);
#endif

    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;
    be80:	41 bf fa ff ff ff    	mov    $0xfffffffa,%r15d
    be86:	e9 9b fd ff ff       	jmpq   bc26 <pipe_open+0x306>
    INLINE_SYSCALL(close, 1, fd);
    INLINE_SYSCALL(close, 1, pipes[2]);
    INLINE_SYSCALL(close, 1, pipes[3]);

    if (IS_ERR(ret)) {
        INLINE_SYSCALL(close, 1, pipes[0]);
    be8b:	48 63 bd f0 fe ff ff 	movslq -0x110(%rbp),%rdi
    be92:	89 f0                	mov    %esi,%eax
    be94:	cd 80                	int    $0x80
    be96:	bb 00 00 00 00       	mov    $0x0,%ebx
    be9b:	83 d3 00             	adc    $0x0,%ebx
        INLINE_SYSCALL(close, 1, pipes[1]);
    be9e:	48 63 bd f4 fe ff ff 	movslq -0x10c(%rbp),%rdi
    bea5:	89 f0                	mov    %esi,%eax
    bea7:	cd 80                	int    $0x80
    bea9:	bb 00 00 00 00       	mov    $0x0,%ebx
    beae:	83 d3 00             	adc    $0x0,%ebx
        return -PAL_ERROR_DENIED;
    beb1:	41 bf fa ff ff ff    	mov    $0xfffffffa,%r15d
    beb7:	e9 6a fd ff ff       	jmpq   bc26 <pipe_open+0x306>
    bebc:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000bec0 <pipe_delete>:
    return 0;
}

/* 'delete' operation of pipe stream. */
static int pipe_delete (PAL_HANDLE handle, int access)
{
    bec0:	55                   	push   %rbp
    bec1:	48 89 fa             	mov    %rdi,%rdx
    bec4:	48 89 e5             	mov    %rsp,%rbp
    bec7:	53                   	push   %rbx
    bec8:	48 83 ec 78          	sub    $0x78,%rsp
    if (IS_HANDLE_TYPE(handle, pipeprv)) {
    becc:	8b 07                	mov    (%rdi),%eax
    bece:	83 f8 05             	cmp    $0x5,%eax
    bed1:	74 3d                	je     bf10 <pipe_delete+0x50>
            default:
                return -PAL_ERROR_INVAL;
        }
    }

    if (IS_HANDLE_TYPE(handle, pipesrv)) {
    bed3:	83 f8 03             	cmp    $0x3,%eax
    bed6:	0f 84 f4 00 00 00    	je     bfd0 <pipe_delete+0x110>
    bedc:	8b 7a 0c             	mov    0xc(%rdx),%edi
        pipe_path(handle->pipe.pipeid, buffer, 108);
        INLINE_SYSCALL(unlink, 1, buffer);
        return 0;
    }

    if (handle->pipe.fd == PAL_IDX_POISON)
    bedf:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    bee2:	0f 84 d8 00 00 00    	je     bfc0 <pipe_delete+0x100>
        return 0;

    int shutdown;
    switch (access) {
    bee8:	83 fe 01             	cmp    $0x1,%esi
    beeb:	0f 84 bf 00 00 00    	je     bfb0 <pipe_delete+0xf0>
    bef1:	83 fe 02             	cmp    $0x2,%esi
    bef4:	74 6a                	je     bf60 <pipe_delete+0xa0>
    bef6:	85 f6                	test   %esi,%esi
    bef8:	0f 84 a7 00 00 00    	je     bfa5 <pipe_delete+0xe5>
            break;
        case PAL_DELETE_WR:
            shutdown = SHUT_WR;
            break;
        default:
            return -PAL_ERROR_INVAL;
    befe:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    }

    INLINE_SYSCALL(shutdown, 2, handle->pipe.fd, shutdown);

    return 0;
}
    bf03:	48 83 c4 78          	add    $0x78,%rsp
    bf07:	5b                   	pop    %rbx
    bf08:	5d                   	pop    %rbp
    bf09:	c3                   	retq   
    bf0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

/* 'delete' operation of pipe stream. */
static int pipe_delete (PAL_HANDLE handle, int access)
{
    if (IS_HANDLE_TYPE(handle, pipeprv)) {
        switch (access) {
    bf10:	83 fe 01             	cmp    $0x1,%esi
    bf13:	0f 84 e7 00 00 00    	je     c000 <pipe_delete+0x140>
    bf19:	83 fe 02             	cmp    $0x2,%esi
    bf1c:	74 62                	je     bf80 <pipe_delete+0xc0>
    bf1e:	85 f6                	test   %esi,%esi
    bf20:	75 dc                	jne    befe <pipe_delete+0x3e>
            case 0:
                if (handle->pipeprv.fds[0] != PAL_IDX_POISON) {
    bf22:	8b 7f 0c             	mov    0xc(%rdi),%edi
    bf25:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    bf28:	0f 84 86 00 00 00    	je     bfb4 <pipe_delete+0xf4>
                    INLINE_SYSCALL(close, 1, handle->pipeprv.fds[0]);
    bf2e:	b0 06                	mov    $0x6,%al
    bf30:	cd 80                	int    $0x80
    bf32:	bb 00 00 00 00       	mov    $0x0,%ebx
    bf37:	83 d3 00             	adc    $0x0,%ebx
                    handle->pipeprv.fds[0] = PAL_IDX_POISON;
                }
                if (handle->pipeprv.fds[1] != PAL_IDX_POISON) {
    bf3a:	8b 7a 10             	mov    0x10(%rdx),%edi
    if (IS_HANDLE_TYPE(handle, pipeprv)) {
        switch (access) {
            case 0:
                if (handle->pipeprv.fds[0] != PAL_IDX_POISON) {
                    INLINE_SYSCALL(close, 1, handle->pipeprv.fds[0]);
                    handle->pipeprv.fds[0] = PAL_IDX_POISON;
    bf3d:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rdx)
                }
                if (handle->pipeprv.fds[1] != PAL_IDX_POISON) {
    bf44:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    bf47:	75 3f                	jne    bf88 <pipe_delete+0xc8>
    bf49:	8b 02                	mov    (%rdx),%eax
    bf4b:	eb 86                	jmp    bed3 <pipe_delete+0x13>
    bf4d:	0f 1f 00             	nopl   (%rax)
    bf50:	8b 7a 0c             	mov    0xc(%rdx),%edi
        pipe_path(handle->pipe.pipeid, buffer, 108);
        INLINE_SYSCALL(unlink, 1, buffer);
        return 0;
    }

    if (handle->pipe.fd == PAL_IDX_POISON)
    bf53:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    bf56:	74 68                	je     bfc0 <pipe_delete+0x100>
    bf58:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    bf5f:	00 
        case PAL_DELETE_RD:
            shutdown = SHUT_RD;
            break;
        case PAL_DELETE_WR:
            shutdown = SHUT_WR;
            break;
    bf60:	be 01 00 00 00       	mov    $0x1,%esi
        default:
            return -PAL_ERROR_INVAL;
    }

    INLINE_SYSCALL(shutdown, 2, handle->pipe.fd, shutdown);
    bf65:	b8 86 00 00 00       	mov    $0x86,%eax
    bf6a:	cd 80                	int    $0x80
    bf6c:	bb 00 00 00 00       	mov    $0x0,%ebx
    bf71:	83 d3 00             	adc    $0x0,%ebx

    return 0;
}
    bf74:	48 83 c4 78          	add    $0x78,%rsp
            return -PAL_ERROR_INVAL;
    }

    INLINE_SYSCALL(shutdown, 2, handle->pipe.fd, shutdown);

    return 0;
    bf78:	31 c0                	xor    %eax,%eax
}
    bf7a:	5b                   	pop    %rbx
    bf7b:	5d                   	pop    %rbp
    bf7c:	c3                   	retq   
    bf7d:	0f 1f 00             	nopl   (%rax)
                    INLINE_SYSCALL(close, 1, handle->pipeprv.fds[0]);
                    handle->pipeprv.fds[0] = PAL_IDX_POISON;
                }
                break;
            case PAL_DELETE_WR:
                if (handle->pipeprv.fds[1] != PAL_IDX_POISON) {
    bf80:	8b 7f 10             	mov    0x10(%rdi),%edi
    bf83:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    bf86:	74 c8                	je     bf50 <pipe_delete+0x90>
                    INLINE_SYSCALL(close, 1, handle->pipeprv.fds[1]);
    bf88:	b8 06 00 00 00       	mov    $0x6,%eax
    bf8d:	cd 80                	int    $0x80
    bf8f:	bb 00 00 00 00       	mov    $0x0,%ebx
    bf94:	83 d3 00             	adc    $0x0,%ebx
                    handle->pipeprv.fds[1] = PAL_IDX_POISON;
    bf97:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rdx)
    bf9e:	8b 02                	mov    (%rdx),%eax
    bfa0:	e9 2e ff ff ff       	jmpq   bed3 <pipe_delete+0x13>

    if (handle->pipe.fd == PAL_IDX_POISON)
        return 0;

    int shutdown;
    switch (access) {
    bfa5:	be 02 00 00 00       	mov    $0x2,%esi
    bfaa:	eb b9                	jmp    bf65 <pipe_delete+0xa5>
    bfac:	0f 1f 40 00          	nopl   0x0(%rax)
    bfb0:	31 f6                	xor    %esi,%esi
    bfb2:	eb b1                	jmp    bf65 <pipe_delete+0xa5>
            case 0:
                if (handle->pipeprv.fds[0] != PAL_IDX_POISON) {
                    INLINE_SYSCALL(close, 1, handle->pipeprv.fds[0]);
                    handle->pipeprv.fds[0] = PAL_IDX_POISON;
                }
                if (handle->pipeprv.fds[1] != PAL_IDX_POISON) {
    bfb4:	8b 7a 10             	mov    0x10(%rdx),%edi
    bfb7:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    bfba:	75 cc                	jne    bf88 <pipe_delete+0xc8>
    bfbc:	0f 1f 40 00          	nopl   0x0(%rax)
    }

    INLINE_SYSCALL(shutdown, 2, handle->pipe.fd, shutdown);

    return 0;
}
    bfc0:	48 83 c4 78          	add    $0x78,%rsp
        INLINE_SYSCALL(unlink, 1, buffer);
        return 0;
    }

    if (handle->pipe.fd == PAL_IDX_POISON)
        return 0;
    bfc4:	31 c0                	xor    %eax,%eax
    }

    INLINE_SYSCALL(shutdown, 2, handle->pipe.fd, shutdown);

    return 0;
}
    bfc6:	5b                   	pop    %rbx
    bfc7:	5d                   	pop    %rbp
    bfc8:	c3                   	retq   
    bfc9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        }
    }

    if (IS_HANDLE_TYPE(handle, pipesrv)) {
        char buffer[108];
        pipe_path(handle->pipe.pipeid, buffer, 108);
    bfd0:	48 8d 5d 80          	lea    -0x80(%rbp),%rbx
    bfd4:	48 8b 7a 10          	mov    0x10(%rdx),%rdi
    bfd8:	48 89 de             	mov    %rbx,%rsi
    bfdb:	e8 f0 f8 ff ff       	callq  b8d0 <pipe_path.constprop.3>
        INLINE_SYSCALL(unlink, 1, buffer);
    bfe0:	48 89 df             	mov    %rbx,%rdi
    bfe3:	b8 0a 00 00 00       	mov    $0xa,%eax
    bfe8:	cd 80                	int    $0x80
    bfea:	bb 00 00 00 00       	mov    $0x0,%ebx
    bfef:	83 d3 00             	adc    $0x0,%ebx
        return 0;
    bff2:	31 c0                	xor    %eax,%eax
    bff4:	e9 0a ff ff ff       	jmpq   bf03 <pipe_delete+0x43>
    bff9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                    INLINE_SYSCALL(close, 1, handle->pipeprv.fds[1]);
                    handle->pipeprv.fds[1] = PAL_IDX_POISON;
                }
                break;
            case PAL_DELETE_RD:
                if (handle->pipeprv.fds[0] != PAL_IDX_POISON) {
    c000:	8b 7f 0c             	mov    0xc(%rdi),%edi
        INLINE_SYSCALL(unlink, 1, buffer);
        return 0;
    }

    if (handle->pipe.fd == PAL_IDX_POISON)
        return 0;
    c003:	31 c0                	xor    %eax,%eax
                    INLINE_SYSCALL(close, 1, handle->pipeprv.fds[1]);
                    handle->pipeprv.fds[1] = PAL_IDX_POISON;
                }
                break;
            case PAL_DELETE_RD:
                if (handle->pipeprv.fds[0] != PAL_IDX_POISON) {
    c005:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    c008:	0f 84 f5 fe ff ff    	je     bf03 <pipe_delete+0x43>
                    INLINE_SYSCALL(close, 1, handle->pipeprv.fds[0]);
    c00e:	b0 06                	mov    $0x6,%al
    c010:	cd 80                	int    $0x80
    c012:	bb 00 00 00 00       	mov    $0x0,%ebx
    c017:	83 d3 00             	adc    $0x0,%ebx
                    handle->pipeprv.fds[0] = PAL_IDX_POISON;
    c01a:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rdx)
    c021:	8b 02                	mov    (%rdx),%eax
    c023:	e9 ab fe ff ff       	jmpq   bed3 <pipe_delete+0x13>
    c028:	90                   	nop    
    c029:	90                   	nop    
    c02a:	90                   	nop    
    c02b:	90                   	nop    
    c02c:	90                   	nop    
    c02d:	90                   	nop    
    c02e:	90                   	nop    
    c02f:	90                   	nop    

000000000000c030 <check_zero>:
    hdl->sock.tcp_nodelay    = PAL_FALSE;
    return hdl;
}

static int check_zero (void * mem, int size)
{
    c030:	48 63 c6             	movslq %esi,%rax
    c033:	55                   	push   %rbp
    void * p = mem, * q = mem + size;
    c034:	48 01 f8             	add    %rdi,%rax

    while (p < q) {
    c037:	48 39 c7             	cmp    %rax,%rdi
    hdl->sock.tcp_nodelay    = PAL_FALSE;
    return hdl;
}

static int check_zero (void * mem, int size)
{
    c03a:	48 89 e5             	mov    %rsp,%rbp
    void * p = mem, * q = mem + size;

    while (p < q) {
    c03d:	73 3b                	jae    c07a <check_zero+0x4a>
    c03f:	48 8d 50 f8          	lea    -0x8(%rax),%rdx
        if (p <= q - sizeof(long)) {
            if (*(long *) p)
                return 1;
            p += sizeof(long);
        } else if (p <= q - sizeof(int)) {
    c043:	48 8d 48 fc          	lea    -0x4(%rax),%rcx
            if (*(int *) p)
                return 1;
            p += sizeof(int);
        } else if (p <= q - sizeof(short)) {
    c047:	48 8d 70 fe          	lea    -0x2(%rax),%rsi
    c04b:	eb 12                	jmp    c05f <check_zero+0x2f>
    c04d:	0f 1f 00             	nopl   (%rax)
{
    void * p = mem, * q = mem + size;

    while (p < q) {
        if (p <= q - sizeof(long)) {
            if (*(long *) p)
    c050:	48 83 3f 00          	cmpq   $0x0,(%rdi)
    c054:	75 4a                	jne    c0a0 <check_zero+0x70>
                return 1;
            p += sizeof(long);
    c056:	48 83 c7 08          	add    $0x8,%rdi

static int check_zero (void * mem, int size)
{
    void * p = mem, * q = mem + size;

    while (p < q) {
    c05a:	48 39 f8             	cmp    %rdi,%rax
    c05d:	76 1b                	jbe    c07a <check_zero+0x4a>
        if (p <= q - sizeof(long)) {
    c05f:	48 39 fa             	cmp    %rdi,%rdx
    c062:	73 ec                	jae    c050 <check_zero+0x20>
            if (*(long *) p)
                return 1;
            p += sizeof(long);
        } else if (p <= q - sizeof(int)) {
    c064:	48 39 cf             	cmp    %rcx,%rdi
    c067:	77 17                	ja     c080 <check_zero+0x50>
            if (*(int *) p)
    c069:	44 8b 07             	mov    (%rdi),%r8d
    c06c:	45 85 c0             	test   %r8d,%r8d
    c06f:	75 2f                	jne    c0a0 <check_zero+0x70>
                return 1;
            p += sizeof(int);
    c071:	48 83 c7 04          	add    $0x4,%rdi

static int check_zero (void * mem, int size)
{
    void * p = mem, * q = mem + size;

    while (p < q) {
    c075:	48 39 f8             	cmp    %rdi,%rax
    c078:	77 e5                	ja     c05f <check_zero+0x2f>
                return 1;
            p++;
        }
    }

    return 0;
    c07a:	31 c0                	xor    %eax,%eax
}
    c07c:	5d                   	pop    %rbp
    c07d:	c3                   	retq   
    c07e:	66 90                	xchg   %ax,%ax
            p += sizeof(long);
        } else if (p <= q - sizeof(int)) {
            if (*(int *) p)
                return 1;
            p += sizeof(int);
        } else if (p <= q - sizeof(short)) {
    c080:	48 39 f7             	cmp    %rsi,%rdi
    c083:	77 0c                	ja     c091 <check_zero+0x61>
            if (*(short *) p)
    c085:	66 83 3f 00          	cmpw   $0x0,(%rdi)
    c089:	75 15                	jne    c0a0 <check_zero+0x70>
                return 1;
            p += sizeof(short);
    c08b:	48 83 c7 02          	add    $0x2,%rdi
    c08f:	eb c9                	jmp    c05a <check_zero+0x2a>
        } else {
            if (*(char *) p)
    c091:	80 3f 00             	cmpb   $0x0,(%rdi)
    c094:	75 0a                	jne    c0a0 <check_zero+0x70>
                return 1;
            p++;
    c096:	48 83 c7 01          	add    $0x1,%rdi
    c09a:	eb be                	jmp    c05a <check_zero+0x2a>
    c09c:	0f 1f 40 00          	nopl   0x0(%rax)
    void * p = mem, * q = mem + size;

    while (p < q) {
        if (p <= q - sizeof(long)) {
            if (*(long *) p)
                return 1;
    c0a0:	b8 01 00 00 00       	mov    $0x1,%eax
            p++;
        }
    }

    return 0;
}
    c0a5:	5d                   	pop    %rbp
    c0a6:	c3                   	retq   
    c0a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    c0ae:	00 00 

000000000000c0b0 <socket_delete>:

    return bytes;
}

static int socket_delete (PAL_HANDLE handle, int access)
{
    c0b0:	55                   	push   %rbp
    c0b1:	48 89 e5             	mov    %rsp,%rbp
    c0b4:	53                   	push   %rbx
    if (handle->sock.fd == PAL_IDX_POISON)
    c0b5:	8b 4f 0c             	mov    0xc(%rdi),%ecx
    c0b8:	83 f9 ff             	cmp    $0xffffffffffffffff,%ecx
    c0bb:	74 63                	je     c120 <socket_delete+0x70>
        return 0;

    if (!IS_HANDLE_TYPE(handle, tcp) && access)
    c0bd:	85 f6                	test   %esi,%esi
    c0bf:	8b 17                	mov    (%rdi),%edx
    c0c1:	74 0a                	je     c0cd <socket_delete+0x1d>
    c0c3:	83 fa 08             	cmp    $0x8,%edx
        return -PAL_ERROR_INVAL;
    c0c6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
static int socket_delete (PAL_HANDLE handle, int access)
{
    if (handle->sock.fd == PAL_IDX_POISON)
        return 0;

    if (!IS_HANDLE_TYPE(handle, tcp) && access)
    c0cb:	75 0a                	jne    c0d7 <socket_delete+0x27>
        return -PAL_ERROR_INVAL;

    if (IS_HANDLE_TYPE(handle, tcp) || IS_HANDLE_TYPE(handle, tcpsrv)) {
    c0cd:	83 ea 08             	sub    $0x8,%edx
}

static int socket_delete (PAL_HANDLE handle, int access)
{
    if (handle->sock.fd == PAL_IDX_POISON)
        return 0;
    c0d0:	31 c0                	xor    %eax,%eax

    if (!IS_HANDLE_TYPE(handle, tcp) && access)
        return -PAL_ERROR_INVAL;

    if (IS_HANDLE_TYPE(handle, tcp) || IS_HANDLE_TYPE(handle, tcpsrv)) {
    c0d2:	83 fa 01             	cmp    $0x1,%edx
    c0d5:	76 09                	jbe    c0e0 <socket_delete+0x30>

        INLINE_SYSCALL(shutdown, 2, handle->sock.fd, shutdown);
    }

    return 0;
}
    c0d7:	5b                   	pop    %rbx
    c0d8:	5d                   	pop    %rbp
    c0d9:	c3                   	retq   
    c0da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    if (!IS_HANDLE_TYPE(handle, tcp) && access)
        return -PAL_ERROR_INVAL;

    if (IS_HANDLE_TYPE(handle, tcp) || IS_HANDLE_TYPE(handle, tcpsrv)) {
        int shutdown;
        switch (access) {
    c0e0:	83 fe 01             	cmp    $0x1,%esi
    c0e3:	74 40                	je     c125 <socket_delete+0x75>
    c0e5:	83 fe 02             	cmp    $0x2,%esi
    c0e8:	74 16                	je     c100 <socket_delete+0x50>
    c0ea:	85 f6                	test   %esi,%esi
                break;
            case PAL_DELETE_WR:
                shutdown = SHUT_WR;
                break;
            default:
                return -PAL_ERROR_INVAL;
    c0ec:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    if (!IS_HANDLE_TYPE(handle, tcp) && access)
        return -PAL_ERROR_INVAL;

    if (IS_HANDLE_TYPE(handle, tcp) || IS_HANDLE_TYPE(handle, tcpsrv)) {
        int shutdown;
        switch (access) {
    c0f1:	75 e4                	jne    c0d7 <socket_delete+0x27>
    c0f3:	be 02 00 00 00       	mov    $0x2,%esi
    c0f8:	eb 0b                	jmp    c105 <socket_delete+0x55>
    c0fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            case PAL_DELETE_RD:
                shutdown = SHUT_RD;
                break;
            case PAL_DELETE_WR:
                shutdown = SHUT_WR;
                break;
    c100:	be 01 00 00 00       	mov    $0x1,%esi
            default:
                return -PAL_ERROR_INVAL;
        }

        INLINE_SYSCALL(shutdown, 2, handle->sock.fd, shutdown);
    c105:	89 cf                	mov    %ecx,%edi
    c107:	b8 86 00 00 00       	mov    $0x86,%eax
    c10c:	cd 80                	int    $0x80
    c10e:	bb 00 00 00 00       	mov    $0x0,%ebx
    c113:	83 d3 00             	adc    $0x0,%ebx
    }

    return 0;
    c116:	31 c0                	xor    %eax,%eax
}
    c118:	5b                   	pop    %rbx
    c119:	5d                   	pop    %rbp
    c11a:	c3                   	retq   
    c11b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
}

static int socket_delete (PAL_HANDLE handle, int access)
{
    if (handle->sock.fd == PAL_IDX_POISON)
        return 0;
    c120:	31 c0                	xor    %eax,%eax

        INLINE_SYSCALL(shutdown, 2, handle->sock.fd, shutdown);
    }

    return 0;
}
    c122:	5b                   	pop    %rbx
    c123:	5d                   	pop    %rbp
    c124:	c3                   	retq   
    if (!IS_HANDLE_TYPE(handle, tcp) && access)
        return -PAL_ERROR_INVAL;

    if (IS_HANDLE_TYPE(handle, tcp) || IS_HANDLE_TYPE(handle, tcpsrv)) {
        int shutdown;
        switch (access) {
    c125:	31 f6                	xor    %esi,%esi
    c127:	eb dc                	jmp    c105 <socket_delete+0x55>
    c129:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000000c130 <socket_close>:

    return 0;
}

static int socket_close (PAL_HANDLE handle)
{
    c130:	55                   	push   %rbp
    c131:	48 89 fa             	mov    %rdi,%rdx
    c134:	48 89 e5             	mov    %rsp,%rbp
    c137:	53                   	push   %rbx
    if (handle->sock.fd != PAL_IDX_POISON) {
    c138:	8b 7f 0c             	mov    0xc(%rdi),%edi
    c13b:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    c13e:	74 16                	je     c156 <socket_close+0x26>
        INLINE_SYSCALL(close, 1, handle->sock.fd);
    c140:	b8 06 00 00 00       	mov    $0x6,%eax
    c145:	cd 80                	int    $0x80
    c147:	bb 00 00 00 00       	mov    $0x0,%ebx
    c14c:	83 d3 00             	adc    $0x0,%ebx
        handle->sock.fd = PAL_IDX_POISON;
    c14f:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rdx)
    }

    if (handle->sock.bind)
    c156:	48 83 7a 10 00       	cmpq   $0x0,0x10(%rdx)
    c15b:	74 08                	je     c165 <socket_close+0x35>
        handle->sock.bind = NULL;
    c15d:	48 c7 42 10 00 00 00 	movq   $0x0,0x10(%rdx)
    c164:	00 

    if (handle->sock.conn)
    c165:	48 83 7a 18 00       	cmpq   $0x0,0x18(%rdx)
    c16a:	74 08                	je     c174 <socket_close+0x44>
        handle->sock.conn = NULL;
    c16c:	48 c7 42 18 00 00 00 	movq   $0x0,0x18(%rdx)
    c173:	00 

    return 0;
}
    c174:	31 c0                	xor    %eax,%eax
    c176:	5b                   	pop    %rbx
    c177:	5d                   	pop    %rbp
    c178:	c3                   	retq   
    c179:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000000c180 <mcast_receive>:

    return bytes;
}

static int mcast_receive (PAL_HANDLE handle, int offset, int size, void * buf)
{
    c180:	8b 7f 0c             	mov    0xc(%rdi),%edi
    c183:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    c186:	0f 84 84 00 00 00    	je     c210 <mcast_receive+0x90>
    c18c:	55                   	push   %rbp
        return -PAL_ERROR_BADHANDLE;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = size;
    c18d:	48 63 d2             	movslq %edx,%rdx

    return bytes;
}

static int mcast_receive (PAL_HANDLE handle, int offset, int size, void * buf)
{
    c190:	48 89 e5             	mov    %rsp,%rbp
    c193:	53                   	push   %rbx
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->mcast.cli, &hdr, 0);
    c194:	bb 1b 00 00 00       	mov    $0x1b,%ebx
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = size;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    c199:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->mcast.cli, &hdr, 0);
    c19d:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi

    return bytes;
}

static int mcast_receive (PAL_HANDLE handle, int offset, int size, void * buf)
{
    c1a1:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = size;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    c1a5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->mcast.cli, &hdr, 0);
    c1a9:	31 d2                	xor    %edx,%edx
    if (handle->mcast.cli == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    c1ab:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    iov.iov_len = size;
    hdr.msg_name = NULL;
    c1af:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    c1b6:	00 
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->mcast.cli, &hdr, 0);
    c1b7:	89 d8                	mov    %ebx,%eax
    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = size;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    c1b9:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    c1c0:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    hdr.msg_control = NULL;
    c1c7:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    c1ce:	00 
    hdr.msg_controllen = 0;
    c1cf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    hdr.msg_flags = 0;
    c1d6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->mcast.cli, &hdr, 0);
    c1dd:	cd 80                	int    $0x80
    c1df:	48 89 c1             	mov    %rax,%rcx
    c1e2:	bb 00 00 00 00       	mov    $0x0,%ebx
    c1e7:	83 d3 00             	adc    $0x0,%ebx
    c1ea:	31 d2                	xor    %edx,%edx
    c1ec:	85 db                	test   %ebx,%ebx
    c1ee:	0f 95 c2             	setne  %dl
    c1f1:	48 89 d0             	mov    %rdx,%rax
    c1f4:	48 f7 d8             	neg    %rax
    c1f7:	48 31 c8             	xor    %rcx,%rax
    c1fa:	48 01 d0             	add    %rdx,%rax

    if (IS_ERR(bytes))
    c1fd:	ba fa ff ff ff       	mov    $0xfffffffa,%edx
    c202:	85 c0                	test   %eax,%eax
        return -PAL_ERROR_DENIED;

    return bytes;
}
    c204:	0f 48 c2             	cmovs  %edx,%eax
    c207:	5b                   	pop    %rbx
    c208:	5d                   	pop    %rbp
    c209:	c3                   	retq   
    c20a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
}

static int mcast_receive (PAL_HANDLE handle, int offset, int size, void * buf)
{
    if (handle->mcast.cli == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    c210:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    c215:	c3                   	retq   
    c216:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    c21d:	00 00 00 

000000000000c220 <mcast_close>:

    return bytes;
}

static int mcast_close (PAL_HANDLE handle)
{
    c220:	55                   	push   %rbp
    c221:	48 89 fa             	mov    %rdi,%rdx
    c224:	48 89 e5             	mov    %rsp,%rbp
    c227:	53                   	push   %rbx
    if (handle->mcast.srv != PAL_IDX_POISON) {
    c228:	8b 7f 10             	mov    0x10(%rdi),%edi
    c22b:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    c22e:	74 16                	je     c246 <mcast_close+0x26>
        INLINE_SYSCALL(close, 1, handle->mcast.srv);
    c230:	b8 06 00 00 00       	mov    $0x6,%eax
    c235:	cd 80                	int    $0x80
    c237:	bb 00 00 00 00       	mov    $0x0,%ebx
    c23c:	83 d3 00             	adc    $0x0,%ebx
        handle->mcast.srv = PAL_IDX_POISON;
    c23f:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rdx)
    }
    if (handle->mcast.cli != PAL_IDX_POISON) {
    c246:	8b 7a 0c             	mov    0xc(%rdx),%edi
    c249:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    c24c:	74 16                	je     c264 <mcast_close+0x44>
        INLINE_SYSCALL(close, 1, handle->mcast.cli);
    c24e:	b8 06 00 00 00       	mov    $0x6,%eax
    c253:	cd 80                	int    $0x80
    c255:	bb 00 00 00 00       	mov    $0x0,%ebx
    c25a:	83 d3 00             	adc    $0x0,%ebx
        handle->mcast.cli = PAL_IDX_POISON;
    c25d:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rdx)
    }
    return 0;
}
    c264:	31 c0                	xor    %eax,%eax
    c266:	5b                   	pop    %rbx
    c267:	5d                   	pop    %rbp
    c268:	c3                   	retq   
    c269:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

000000000000c270 <socket_attrquerybyhdl>:
#ifndef FIONREAD
# define FIONREAD 0x541B
#endif

static int socket_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR  * attr)
{
    c270:	55                   	push   %rbp
    c271:	48 89 e5             	mov    %rsp,%rbp
    c274:	41 55                	push   %r13
    c276:	41 54                	push   %r12
    c278:	53                   	push   %rbx
    c279:	48 83 ec 18          	sub    $0x18,%rsp
    if (handle->sock.fd == PAL_IDX_POISON)
    c27d:	8b 5f 0c             	mov    0xc(%rdi),%ebx
    c280:	83 fb ff             	cmp    $0xffffffffffffffff,%ebx
    c283:	0f 84 17 01 00 00    	je     c3a0 <socket_attrquerybyhdl+0x130>
    c289:	49 89 f4             	mov    %rsi,%r12
    c28c:	49 89 fd             	mov    %rdi,%r13
        return -PAL_ERROR_BADHANDLE;

    int fd = handle->sock.fd, ret, val;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
    c28f:	ba 70 00 00 00       	mov    $0x70,%edx
    c294:	31 f6                	xor    %esi,%esi
    c296:	4c 89 e7             	mov    %r12,%rdi
    c299:	e8 02 9f 00 00       	callq  161a0 <memset>

    attr->disconnected = handle->__in.flags & ERROR(0);
    c29e:	41 8b 45 08          	mov    0x8(%r13),%eax
    c2a2:	89 c2                	mov    %eax,%edx
    c2a4:	c1 ea 09             	shr    $0x9,%edx
    c2a7:	83 e2 01             	and    $0x1,%edx
    c2aa:	41 88 54 24 30       	mov    %dl,0x30(%r12)

    if (handle->sock.conn) {
    c2af:	49 83 7d 18 00       	cmpq   $0x0,0x18(%r13)
    c2b4:	0f 84 d6 00 00 00    	je     c390 <socket_attrquerybyhdl+0x120>
        /* try use ioctl FIONEAD to get the size of socket */
        ret = INLINE_SYSCALL(ioctl, 3, fd, FIONREAD, &val);
    c2ba:	b9 36 00 00 00       	mov    $0x36,%ecx
    c2bf:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
    c2c3:	be 1b 54 00 00       	mov    $0x541b,%esi
    c2c8:	48 63 fb             	movslq %ebx,%rdi
    c2cb:	89 c8                	mov    %ecx,%eax
    c2cd:	cd 80                	int    $0x80
    c2cf:	48 89 c2             	mov    %rax,%rdx
    c2d2:	bb 00 00 00 00       	mov    $0x0,%ebx
    c2d7:	83 d3 00             	adc    $0x0,%ebx
    c2da:	31 c9                	xor    %ecx,%ecx
    c2dc:	85 db                	test   %ebx,%ebx
    c2de:	0f 95 c1             	setne  %cl
    c2e1:	48 89 c8             	mov    %rcx,%rax
    c2e4:	48 f7 d8             	neg    %rax
    c2e7:	48 31 d0             	xor    %rdx,%rax
        if (!IS_ERR(ret))
    c2ea:	01 c8                	add    %ecx,%eax
    c2ec:	0f 88 8e 00 00 00    	js     c380 <socket_attrquerybyhdl+0x110>
            attr->size = val;
    c2f2:	48 63 45 dc          	movslq -0x24(%rbp),%rax
    c2f6:	49 89 44 24 10       	mov    %rax,0x10(%r12)
        attr->readable = (attr->size > 0);
    c2fb:	48 85 c0             	test   %rax,%rax
    c2fe:	41 0f 95 44 24 31    	setne  0x31(%r12)
    c304:	41 8b 45 08          	mov    0x8(%r13),%eax
    } else {
        attr->readable = !attr->disconnected;
    }

    attr->writeable = handle->__in.flags & WRITEABLE(0);
    c308:	c1 e8 06             	shr    $0x6,%eax
    c30b:	83 e0 01             	and    $0x1,%eax
    c30e:	41 88 44 24 32       	mov    %al,0x32(%r12)

    attr->nonblocking    = handle->sock.nonblocking;
    c313:	41 0f b6 45 20       	movzbl 0x20(%r13),%eax
    c318:	41 88 44 24 38       	mov    %al,0x38(%r12)
    attr->reuseaddr      = handle->sock.reuseaddr;
    c31d:	41 0f b6 45 21       	movzbl 0x21(%r13),%eax
    c322:	41 88 44 24 39       	mov    %al,0x39(%r12)
    attr->linger         = handle->sock.linger;
    c327:	49 8b 45 28          	mov    0x28(%r13),%rax
    c32b:	49 89 44 24 40       	mov    %rax,0x40(%r12)
    attr->receivebuf     = handle->sock.receivebuf;
    c330:	49 8b 45 30          	mov    0x30(%r13),%rax
    c334:	49 89 44 24 48       	mov    %rax,0x48(%r12)
    attr->sendbuf        = handle->sock.sendbuf;
    c339:	49 8b 45 38          	mov    0x38(%r13),%rax
    c33d:	49 89 44 24 50       	mov    %rax,0x50(%r12)
    attr->receivetimeout = handle->sock.receivetimeout;
    c342:	49 8b 45 40          	mov    0x40(%r13),%rax
    c346:	49 89 44 24 58       	mov    %rax,0x58(%r12)
    attr->sendtimeout    = handle->sock.sendtimeout;
    c34b:	49 8b 45 48          	mov    0x48(%r13),%rax
    c34f:	49 89 44 24 60       	mov    %rax,0x60(%r12)
    attr->tcp_cork       = handle->sock.tcp_cork;
    c354:	41 0f b6 45 50       	movzbl 0x50(%r13),%eax
    c359:	41 88 44 24 68       	mov    %al,0x68(%r12)
    attr->tcp_keepalive  = handle->sock.tcp_keepalive;
    c35e:	41 0f b6 45 51       	movzbl 0x51(%r13),%eax
    c363:	41 88 44 24 69       	mov    %al,0x69(%r12)
    attr->tcp_nodelay    = handle->sock.tcp_nodelay;
    c368:	41 0f b6 45 52       	movzbl 0x52(%r13),%eax
    c36d:	41 88 44 24 6a       	mov    %al,0x6a(%r12)
    return 0;
    c372:	31 c0                	xor    %eax,%eax
}
    c374:	48 83 c4 18          	add    $0x18,%rsp
    c378:	5b                   	pop    %rbx
    c379:	41 5c                	pop    %r12
    c37b:	41 5d                	pop    %r13
    c37d:	5d                   	pop    %rbp
    c37e:	c3                   	retq   
    c37f:	90                   	nop    
    c380:	49 8b 44 24 10       	mov    0x10(%r12),%rax
    c385:	e9 71 ff ff ff       	jmpq   c2fb <socket_attrquerybyhdl+0x8b>
    c38a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        ret = INLINE_SYSCALL(ioctl, 3, fd, FIONREAD, &val);
        if (!IS_ERR(ret))
            attr->size = val;
        attr->readable = (attr->size > 0);
    } else {
        attr->readable = !attr->disconnected;
    c390:	83 f2 01             	xor    $0x1,%edx
    c393:	41 88 54 24 31       	mov    %dl,0x31(%r12)
    c398:	e9 6b ff ff ff       	jmpq   c308 <socket_attrquerybyhdl+0x98>
    c39d:	0f 1f 00             	nopl   (%rax)
#endif

static int socket_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR  * attr)
{
    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    c3a0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    c3a5:	eb cd                	jmp    c374 <socket_attrquerybyhdl+0x104>
    c3a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    c3ae:	00 00 

000000000000c3b0 <mcast_attrquerybyhdl>:
    }
    return 0;
}

static int mcast_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    c3b0:	83 7f 0c ff          	cmpl   $0xffffffffffffffff,0xc(%rdi)
    c3b4:	0f 84 a6 00 00 00    	je     c460 <mcast_attrquerybyhdl+0xb0>
    c3ba:	55                   	push   %rbp
    int ret, val;

    if (handle->mcast.cli == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
    c3bb:	ba 70 00 00 00       	mov    $0x70,%edx
    }
    return 0;
}

static int mcast_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    c3c0:	48 89 e5             	mov    %rsp,%rbp
    c3c3:	41 55                	push   %r13
    c3c5:	41 54                	push   %r12
    c3c7:	53                   	push   %rbx
    c3c8:	49 89 f4             	mov    %rsi,%r12
    c3cb:	49 89 fd             	mov    %rdi,%r13
    int ret, val;

    if (handle->mcast.cli == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
    c3ce:	31 f6                	xor    %esi,%esi
    c3d0:	4c 89 e7             	mov    %r12,%rdi

    ret = INLINE_SYSCALL(ioctl, 3, handle->mcast.cli, FIONREAD, &val);
    c3d3:	bb 36 00 00 00       	mov    $0x36,%ebx
    }
    return 0;
}

static int mcast_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    c3d8:	48 83 ec 18          	sub    $0x18,%rsp
    int ret, val;

    if (handle->mcast.cli == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
    c3dc:	e8 bf 9d 00 00       	callq  161a0 <memset>

    ret = INLINE_SYSCALL(ioctl, 3, handle->mcast.cli, FIONREAD, &val);
    c3e1:	41 8b 7d 0c          	mov    0xc(%r13),%edi
    c3e5:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
    c3e9:	be 1b 54 00 00       	mov    $0x541b,%esi
    c3ee:	89 d8                	mov    %ebx,%eax
    c3f0:	cd 80                	int    $0x80
    c3f2:	48 89 c2             	mov    %rax,%rdx
    c3f5:	bb 00 00 00 00       	mov    $0x0,%ebx
    c3fa:	83 d3 00             	adc    $0x0,%ebx
    c3fd:	31 c9                	xor    %ecx,%ecx
    c3ff:	85 db                	test   %ebx,%ebx
    c401:	0f 95 c1             	setne  %cl
    c404:	48 89 c8             	mov    %rcx,%rax
    c407:	48 f7 d8             	neg    %rax
    c40a:	48 31 d0             	xor    %rdx,%rax
    if (!IS_ERR(ret))
    c40d:	01 c8                	add    %ecx,%eax
    c40f:	78 41                	js     c452 <mcast_attrquerybyhdl+0xa2>
        attr->size = val;
    c411:	48 63 55 dc          	movslq -0x24(%rbp),%rdx
    c415:	49 89 54 24 10       	mov    %rdx,0x10(%r12)

    attr->disconnected = handle->__in.flags & (ERROR(0)|ERROR(1));
    c41a:	41 8b 45 08          	mov    0x8(%r13),%eax
    c41e:	f6 c4 06             	test   $0x6,%ah
    c421:	41 0f 95 44 24 30    	setne  0x30(%r12)
    attr->readable = attr->size > 0;
    c427:	48 85 d2             	test   %rdx,%rdx
    c42a:	41 0f 95 44 24 31    	setne  0x31(%r12)
    attr->writeable = handle->__in.flags & WRITEABLE(1);
    c430:	c1 e8 07             	shr    $0x7,%eax
    c433:	83 e0 01             	and    $0x1,%eax
    c436:	41 88 44 24 32       	mov    %al,0x32(%r12)
    attr->nonblocking = handle->mcast.nonblocking;
    c43b:	41 0f b6 45 18       	movzbl 0x18(%r13),%eax
    c440:	41 88 44 24 38       	mov    %al,0x38(%r12)
    return 0;
}
    c445:	48 83 c4 18          	add    $0x18,%rsp

    attr->disconnected = handle->__in.flags & (ERROR(0)|ERROR(1));
    attr->readable = attr->size > 0;
    attr->writeable = handle->__in.flags & WRITEABLE(1);
    attr->nonblocking = handle->mcast.nonblocking;
    return 0;
    c449:	31 c0                	xor    %eax,%eax
}
    c44b:	5b                   	pop    %rbx
    c44c:	41 5c                	pop    %r12
    c44e:	41 5d                	pop    %r13
    c450:	5d                   	pop    %rbp
    c451:	c3                   	retq   
    c452:	49 8b 54 24 10       	mov    0x10(%r12),%rdx
    c457:	eb c1                	jmp    c41a <mcast_attrquerybyhdl+0x6a>
    c459:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
static int mcast_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    int ret, val;

    if (handle->mcast.cli == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    c460:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    c465:	c3                   	retq   
    c466:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    c46d:	00 00 00 

000000000000c470 <inet_parse_uri>:
}

/* parsing the string of uri, and fill in the socket address structure.
   the latest pointer of uri, length of socket address are returned. */
static int inet_parse_uri (char ** uri, struct sockaddr * addr, int * addrlen)
{
    c470:	55                   	push   %rbp
    c471:	48 89 e5             	mov    %rsp,%rbp
    c474:	41 57                	push   %r15
    c476:	41 56                	push   %r14
    c478:	41 55                	push   %r13
    c47a:	41 54                	push   %r12
    c47c:	49 89 fd             	mov    %rdi,%r13
    c47f:	53                   	push   %rbx
    c480:	49 89 d6             	mov    %rdx,%r14
    c483:	48 89 f3             	mov    %rsi,%rbx
    c486:	48 83 ec 18          	sub    $0x18,%rsp
    char * tmp = *uri, * old;
    c48a:	4c 8b 27             	mov    (%rdi),%r12
    int af;
    void * addr_buf;
    __be16 * port_buf;
    int slen;

    if (tmp[0] == '[') {
    c48d:	41 80 3c 24 5b       	cmpb   $0x5b,(%r12)
    c492:	0f 84 88 00 00 00    	je     c520 <inet_parse_uri+0xb0>
    } else {
        /* for IP, the address will be in the form of "x.x.x.x:port". */
        struct sockaddr_in * addr_in = (struct sockaddr_in *) addr;

        slen = sizeof(struct sockaddr_in);
        memset(addr, 0, slen);
    c498:	31 f6                	xor    %esi,%esi
    c49a:	ba 10 00 00 00       	mov    $0x10,%edx
    c49f:	48 89 df             	mov    %rbx,%rdi
    c4a2:	e8 f9 9c 00 00       	callq  161a0 <memset>

        char * end = strchr(tmp, ':');
    c4a7:	be 3a 00 00 00       	mov    $0x3a,%esi
    c4ac:	4c 89 e7             	mov    %r12,%rdi
    c4af:	e8 5c 9b 00 00       	callq  16010 <strchr>
        if (!end)
    c4b4:	48 85 c0             	test   %rax,%rax
    c4b7:	0f 84 c3 00 00 00    	je     c580 <inet_parse_uri+0x110>
            goto inval;

        addr_str = tmp;
        *end = 0;
    c4bd:	c6 00 00             	movb   $0x0,(%rax)
        port_str = end + 1;
    c4c0:	48 83 c0 01          	add    $0x1,%rax
        addr_in->sin_family = af = AF_INET;
    c4c4:	c6 43 01 02          	movb   $0x2,0x1(%rbx)
        addr_buf = &addr_in->sin_addr.s_addr;
    c4c8:	48 8d 53 04          	lea    0x4(%rbx),%rdx
        if (!end)
            goto inval;

        addr_str = tmp;
        *end = 0;
        port_str = end + 1;
    c4cc:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        addr_in->sin_family = af = AF_INET;
        addr_buf = &addr_in->sin_addr.s_addr;
        port_buf = &addr_in->sin_port;
    c4d0:	48 83 c3 02          	add    $0x2,%rbx
        port_buf = &addr_in6->sin6_port;
    } else {
        /* for IP, the address will be in the form of "x.x.x.x:port". */
        struct sockaddr_in * addr_in = (struct sockaddr_in *) addr;

        slen = sizeof(struct sockaddr_in);
    c4d4:	41 bf 10 00 00 00    	mov    $0x10,%r15d
            goto inval;

        addr_str = tmp;
        *end = 0;
        port_str = end + 1;
        addr_in->sin_family = af = AF_INET;
    c4da:	bf 02 00 00 00       	mov    $0x2,%edi
        addr_buf = &addr_in->sin_addr.s_addr;
        port_buf = &addr_in->sin_port;
    }

    if (inet_pton(af, addr_str, addr_buf) < 0)
    c4df:	4c 89 e6             	mov    %r12,%rsi
    c4e2:	e8 49 ae 00 00       	callq  17330 <__inet_pton>
    c4e7:	85 c0                	test   %eax,%eax
    c4e9:	0f 88 91 00 00 00    	js     c580 <inet_parse_uri+0x110>
        goto inval;

    *port_buf = __htons(atoi(port_str));
    c4ef:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
    c4f3:	e8 f8 a3 00 00       	callq  168f0 <atoi>

static __inline __uint16_t
__bswap16_var(__uint16_t _x)
{

	return (__bswap16_gen(_x));
    c4f8:	66 c1 c0 08          	rol    $0x8,%ax
    *uri = *old ? old : NULL;

    if (addrlen)
    c4fc:	4d 85 f6             	test   %r14,%r14
    c4ff:	66 89 03             	mov    %ax,(%rbx)

    if (inet_pton(af, addr_str, addr_buf) < 0)
        goto inval;

    *port_buf = __htons(atoi(port_str));
    *uri = *old ? old : NULL;
    c502:	49 c7 45 00 00 00 00 	movq   $0x0,0x0(%r13)
    c509:	00 

    if (addrlen)
    c50a:	74 66                	je     c572 <inet_parse_uri+0x102>
        *addrlen = slen;
    c50c:	45 89 3e             	mov    %r15d,(%r14)

    return 0;
    c50f:	31 c0                	xor    %eax,%eax

inval:
    return -PAL_ERROR_INVAL;
}
    c511:	48 83 c4 18          	add    $0x18,%rsp
    c515:	5b                   	pop    %rbx
    c516:	41 5c                	pop    %r12
    c518:	41 5d                	pop    %r13
    c51a:	41 5e                	pop    %r14
    c51c:	41 5f                	pop    %r15
    c51e:	5d                   	pop    %rbp
    c51f:	c3                   	retq   
        /* for IPv6, the address will be in the form of
           "[xx:xx:xx:xx:xx:xx:xx:xx]:port". */
        struct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *) addr;

        slen = sizeof(struct sockaddr_in6);
        memset(addr, 0, slen);
    c520:	31 f6                	xor    %esi,%esi
    c522:	ba 1c 00 00 00       	mov    $0x1c,%edx
    c527:	48 89 df             	mov    %rbx,%rdi

        char * end = strchr(tmp + 1, ']');
    c52a:	49 83 c4 01          	add    $0x1,%r12
        /* for IPv6, the address will be in the form of
           "[xx:xx:xx:xx:xx:xx:xx:xx]:port". */
        struct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *) addr;

        slen = sizeof(struct sockaddr_in6);
        memset(addr, 0, slen);
    c52e:	e8 6d 9c 00 00       	callq  161a0 <memset>

        char * end = strchr(tmp + 1, ']');
    c533:	be 5d 00 00 00       	mov    $0x5d,%esi
    c538:	4c 89 e7             	mov    %r12,%rdi
    c53b:	e8 d0 9a 00 00       	callq  16010 <strchr>
        if (!end || *(end + 1) != ':')
    c540:	48 85 c0             	test   %rax,%rax
    c543:	74 3b                	je     c580 <inet_parse_uri+0x110>
    c545:	80 78 01 3a          	cmpb   $0x3a,0x1(%rax)
    c549:	75 35                	jne    c580 <inet_parse_uri+0x110>
            goto inval;

        addr_str = tmp + 1;
        *end = 0;
    c54b:	c6 00 00             	movb   $0x0,(%rax)
        port_str = end + 2;
    c54e:	48 83 c0 02          	add    $0x2,%rax
        addr_in6->sin6_family = af = AF_INET6;
    c552:	c6 43 01 1c          	movb   $0x1c,0x1(%rbx)
        addr_buf = &addr_in6->sin6_addr.s6_addr;
    c556:	48 8d 53 08          	lea    0x8(%rbx),%rdx
        if (!end || *(end + 1) != ':')
            goto inval;

        addr_str = tmp + 1;
        *end = 0;
        port_str = end + 2;
    c55a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        addr_in6->sin6_family = af = AF_INET6;
        addr_buf = &addr_in6->sin6_addr.s6_addr;
        port_buf = &addr_in6->sin6_port;
    c55e:	48 83 c3 02          	add    $0x2,%rbx
    if (tmp[0] == '[') {
        /* for IPv6, the address will be in the form of
           "[xx:xx:xx:xx:xx:xx:xx:xx]:port". */
        struct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *) addr;

        slen = sizeof(struct sockaddr_in6);
    c562:	41 bf 1c 00 00 00    	mov    $0x1c,%r15d
            goto inval;

        addr_str = tmp + 1;
        *end = 0;
        port_str = end + 2;
        addr_in6->sin6_family = af = AF_INET6;
    c568:	bf 1c 00 00 00       	mov    $0x1c,%edi
    c56d:	e9 6d ff ff ff       	jmpq   c4df <inet_parse_uri+0x6f>
    *uri = *old ? old : NULL;

    if (addrlen)
        *addrlen = slen;

    return 0;
    c572:	31 c0                	xor    %eax,%eax
    c574:	eb 9b                	jmp    c511 <inet_parse_uri+0xa1>
    c576:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    c57d:	00 00 00 

inval:
    return -PAL_ERROR_INVAL;
    c580:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    c585:	eb 8a                	jmp    c511 <inet_parse_uri+0xa1>
    c587:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    c58e:	00 00 

000000000000c590 <socket_parse_uri>:
   of uri will be either "bind-addr:bind-port:connect-addr:connect-port"
   or "addr:port". */
static int socket_parse_uri (char * uri,
                             struct sockaddr ** bind_addr, int * bind_addrlen,
                             struct sockaddr ** dest_addr, int * dest_addrlen)
{
    c590:	55                   	push   %rbp
    c591:	48 89 e5             	mov    %rsp,%rbp
    c594:	41 57                	push   %r15
    c596:	41 56                	push   %r14
    c598:	41 55                	push   %r13
    c59a:	41 54                	push   %r12
    c59c:	53                   	push   %rbx
    c59d:	48 83 ec 28          	sub    $0x28,%rsp
    int ret;

    if (!bind_addr && !dest_addr)
    c5a1:	48 85 f6             	test   %rsi,%rsi
   of uri will be either "bind-addr:bind-port:connect-addr:connect-port"
   or "addr:port". */
static int socket_parse_uri (char * uri,
                             struct sockaddr ** bind_addr, int * bind_addrlen,
                             struct sockaddr ** dest_addr, int * dest_addrlen)
{
    c5a4:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    int ret;

    if (!bind_addr && !dest_addr)
    c5a8:	41 0f 94 c7          	sete   %r15b
    c5ac:	48 85 c9             	test   %rcx,%rcx
    c5af:	41 0f 94 c5          	sete   %r13b
    c5b3:	45 84 ff             	test   %r15b,%r15b
    c5b6:	74 18                	je     c5d0 <socket_parse_uri+0x40>
    c5b8:	45 84 ed             	test   %r13b,%r13b
    c5bb:	74 13                	je     c5d0 <socket_parse_uri+0x40>
        *dest_addrlen = *bind_addrlen;
        *bind_addr = NULL;
        *bind_addrlen = 0;
    }

    return 0;
    c5bd:	31 c0                	xor    %eax,%eax
}
    c5bf:	48 83 c4 28          	add    $0x28,%rsp
    c5c3:	5b                   	pop    %rbx
    c5c4:	41 5c                	pop    %r12
    c5c6:	41 5d                	pop    %r13
    c5c8:	41 5e                	pop    %r14
    c5ca:	41 5f                	pop    %r15
    c5cc:	5d                   	pop    %rbp
    c5cd:	c3                   	retq   
    c5ce:	66 90                	xchg   %ax,%ax
    int ret;

    if (!bind_addr && !dest_addr)
        return 0;

    if (!uri || !(*uri)) {
    c5d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    c5d4:	48 85 c0             	test   %rax,%rax
    c5d7:	74 05                	je     c5de <socket_parse_uri+0x4e>
    c5d9:	80 38 00             	cmpb   $0x0,(%rax)
    c5dc:	75 32                	jne    c610 <socket_parse_uri+0x80>
        if (bind_addr)
    c5de:	48 85 f6             	test   %rsi,%rsi
    c5e1:	74 07                	je     c5ea <socket_parse_uri+0x5a>
            *bind_addr = NULL;
    c5e3:	48 c7 06 00 00 00 00 	movq   $0x0,(%rsi)
        if (dest_addr)
    c5ea:	48 85 c9             	test   %rcx,%rcx
    c5ed:	74 ce                	je     c5bd <socket_parse_uri+0x2d>
            *dest_addr = NULL;
    c5ef:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
        *bind_addr = NULL;
        *bind_addrlen = 0;
    }

    return 0;
}
    c5f6:	48 83 c4 28          	add    $0x28,%rsp
    if (!uri || !(*uri)) {
        if (bind_addr)
            *bind_addr = NULL;
        if (dest_addr)
            *dest_addr = NULL;
        return 0;
    c5fa:	31 c0                	xor    %eax,%eax
        *bind_addr = NULL;
        *bind_addrlen = 0;
    }

    return 0;
}
    c5fc:	5b                   	pop    %rbx
    c5fd:	41 5c                	pop    %r12
    c5ff:	41 5d                	pop    %r13
    c601:	41 5e                	pop    %r14
    c603:	41 5f                	pop    %r15
    c605:	5d                   	pop    %rbp
    c606:	c3                   	retq   
    c607:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    c60e:	00 00 
            *dest_addr = NULL;
        return 0;
    }

    /* at least parse uri once */
    if ((ret = inet_parse_uri(&uri, bind_addr ? *bind_addr : *dest_addr,
    c610:	48 85 f6             	test   %rsi,%rsi
    c613:	0f 84 88 00 00 00    	je     c6a1 <socket_parse_uri+0x111>
    c619:	48 8b 3e             	mov    (%rsi),%rdi
    c61c:	48 89 d0             	mov    %rdx,%rax
    c61f:	4c 8d 65 c8          	lea    -0x38(%rbp),%r12
    c623:	49 89 d6             	mov    %rdx,%r14
    c626:	48 89 f3             	mov    %rsi,%rbx
    c629:	48 89 c2             	mov    %rax,%rdx
    c62c:	48 89 fe             	mov    %rdi,%rsi
    c62f:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
    c633:	4c 89 e7             	mov    %r12,%rdi
    c636:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    c63a:	e8 31 fe ff ff       	callq  c470 <inet_parse_uri>
    c63f:	85 c0                	test   %eax,%eax
    c641:	0f 88 78 ff ff ff    	js     c5bf <socket_parse_uri+0x2f>
                              bind_addr ? bind_addrlen : dest_addrlen)) < 0)
        return ret;

    if (!(bind_addr && dest_addr))
    c647:	45 84 ff             	test   %r15b,%r15b
    c64a:	0f 85 6d ff ff ff    	jne    c5bd <socket_parse_uri+0x2d>
    c650:	45 84 ed             	test   %r13b,%r13b
    c653:	0f 85 64 ff ff ff    	jne    c5bd <socket_parse_uri+0x2d>
        return 0;

    /* if you reach here, it can only be connection address */
    if (!uri || (ret = inet_parse_uri(&uri, *dest_addr, dest_addrlen)) < 0) {
    c659:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
    c65e:	74 1b                	je     c67b <socket_parse_uri+0xeb>
    c660:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
    c664:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
    c668:	4c 89 e7             	mov    %r12,%rdi
    c66b:	48 8b 30             	mov    (%rax),%rsi
    c66e:	e8 fd fd ff ff       	callq  c470 <inet_parse_uri>
    c673:	85 c0                	test   %eax,%eax
    c675:	0f 89 42 ff ff ff    	jns    c5bd <socket_parse_uri+0x2d>
        *dest_addr = *bind_addr;
    c67b:	48 8b 03             	mov    (%rbx),%rax
    c67e:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
    c682:	48 89 07             	mov    %rax,(%rdi)
        *dest_addrlen = *bind_addrlen;
    c685:	41 8b 06             	mov    (%r14),%eax
    c688:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
    c68c:	89 07                	mov    %eax,(%rdi)
        *bind_addr = NULL;
    c68e:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
        *bind_addrlen = 0;
    c695:	41 c7 06 00 00 00 00 	movl   $0x0,(%r14)
    c69c:	e9 1c ff ff ff       	jmpq   c5bd <socket_parse_uri+0x2d>
            *dest_addr = NULL;
        return 0;
    }

    /* at least parse uri once */
    if ((ret = inet_parse_uri(&uri, bind_addr ? *bind_addr : *dest_addr,
    c6a1:	48 8b 39             	mov    (%rcx),%rdi
    c6a4:	4c 89 c0             	mov    %r8,%rax
    c6a7:	e9 73 ff ff ff       	jmpq   c61f <socket_parse_uri+0x8f>
    c6ac:	0f 1f 40 00          	nopl   0x0(%rax)

000000000000c6b0 <inet_create_uri>:
}

/* create the string of uri from the given socket address */
static int inet_create_uri (char * uri, int count, struct sockaddr * addr,
                            int addrlen)
{
    c6b0:	55                   	push   %rbp
    int len = 0;

    if (addr->sa_family == AF_INET) {
    c6b1:	44 0f b6 42 01       	movzbl 0x1(%rdx),%r8d
}

/* create the string of uri from the given socket address */
static int inet_create_uri (char * uri, int count, struct sockaddr * addr,
                            int addrlen)
{
    c6b6:	48 89 e5             	mov    %rsp,%rbp
    int len = 0;

    if (addr->sa_family == AF_INET) {
    c6b9:	41 80 f8 02          	cmp    $0x2,%r8b
    c6bd:	74 21                	je     c6e0 <inet_create_uri+0x30>
                       (unsigned char) addr[0],
                       (unsigned char) addr[1],
                       (unsigned char) addr[2],
                       (unsigned char) addr[3],
                       __ntohs(addr_in->sin_port));
    } else if (addr->sa_family == AF_INET6) {
    c6bf:	41 80 f8 1c          	cmp    $0x1c,%r8b
        len = snprintf(uri, count, "[%x:%x:%x:%x:%x:%x:%x:%x]:%u",
                       addr[0], addr[1], addr[2], addr[3],
                       addr[4], addr[5], addr[6], addr[7],
                       __ntohs(addr_in6->sin6_port));
    } else {
        return -PAL_ERROR_INVAL;
    c6c3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
                       (unsigned char) addr[0],
                       (unsigned char) addr[1],
                       (unsigned char) addr[2],
                       (unsigned char) addr[3],
                       __ntohs(addr_in->sin_port));
    } else if (addr->sa_family == AF_INET6) {
    c6c8:	75 0a                	jne    c6d4 <inet_create_uri+0x24>
        if (addrlen != sizeof(struct sockaddr_in6))
    c6ca:	83 f9 1c             	cmp    $0x1c,%ecx
{
    int len = 0;

    if (addr->sa_family == AF_INET) {
        if (addrlen != sizeof(struct sockaddr_in))
            return PAL_ERROR_INVAL;
    c6cd:	b8 04 00 00 00       	mov    $0x4,%eax
                       (unsigned char) addr[1],
                       (unsigned char) addr[2],
                       (unsigned char) addr[3],
                       __ntohs(addr_in->sin_port));
    } else if (addr->sa_family == AF_INET6) {
        if (addrlen != sizeof(struct sockaddr_in6))
    c6d2:	74 4c                	je     c720 <inet_create_uri+0x70>
    } else {
        return -PAL_ERROR_INVAL;
    }

    return len;
}
    c6d4:	c9                   	leaveq 
    c6d5:	c3                   	retq   
    c6d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    c6dd:	00 00 00 
                            int addrlen)
{
    int len = 0;

    if (addr->sa_family == AF_INET) {
        if (addrlen != sizeof(struct sockaddr_in))
    c6e0:	83 f9 10             	cmp    $0x10,%ecx
            return PAL_ERROR_INVAL;
    c6e3:	b8 04 00 00 00       	mov    $0x4,%eax
                            int addrlen)
{
    int len = 0;

    if (addr->sa_family == AF_INET) {
        if (addrlen != sizeof(struct sockaddr_in))
    c6e8:	75 ea                	jne    c6d4 <inet_create_uri+0x24>
    c6ea:	0f b7 42 02          	movzwl 0x2(%rdx),%eax

        struct sockaddr_in * addr_in = (struct sockaddr_in *) addr;
        char * addr = (char *) &addr_in->sin_addr.s_addr;

        /* for IP, the address will be in the form of "x.x.x.x:port". */
        len = snprintf(uri, count, "%u.%u.%u.%u:%u",
    c6ee:	0f b6 4a 04          	movzbl 0x4(%rdx),%ecx
    c6f2:	48 63 f6             	movslq %esi,%rsi
    c6f5:	66 c1 c0 08          	rol    $0x8,%ax
    c6f9:	0f b7 c0             	movzwl %ax,%eax
    c6fc:	50                   	push   %rax
    c6fd:	0f b6 42 07          	movzbl 0x7(%rdx),%eax
    c701:	50                   	push   %rax
    c702:	44 0f b6 4a 06       	movzbl 0x6(%rdx),%r9d
    c707:	31 c0                	xor    %eax,%eax
    c709:	44 0f b6 42 05       	movzbl 0x5(%rdx),%r8d
    c70e:	48 8d 15 83 e9 00 00 	lea    0xe983(%rip),%rdx        # 1b098 <slab_levels+0x1df8>
    c715:	e8 96 c7 ff ff       	callq  8eb0 <pal_snprintf>
    c71a:	5a                   	pop    %rdx
    c71b:	59                   	pop    %rcx
    } else {
        return -PAL_ERROR_INVAL;
    }

    return len;
}
    c71c:	c9                   	leaveq 
    c71d:	c3                   	retq   
    c71e:	66 90                	xchg   %ax,%ax
    c720:	0f b7 42 02          	movzwl 0x2(%rdx),%eax
        struct sockaddr_in6 * addr_in6 = (struct sockaddr_in6 *) addr;
        short * addr = (short *) &addr_in6->sin6_addr.s6_addr;

        /* for IPv6, the address will be in the form of
           "[xx:xx:xx:xx:xx:xx:xx:xx]:port". */
        len = snprintf(uri, count, "[%x:%x:%x:%x:%x:%x:%x:%x]:%u",
    c724:	0f bf 4a 08          	movswl 0x8(%rdx),%ecx
    c728:	48 63 f6             	movslq %esi,%rsi
    c72b:	66 c1 c0 08          	rol    $0x8,%ax
    c72f:	0f b7 c0             	movzwl %ax,%eax
    c732:	50                   	push   %rax
    c733:	0f bf 42 16          	movswl 0x16(%rdx),%eax
    c737:	50                   	push   %rax
    c738:	0f bf 42 14          	movswl 0x14(%rdx),%eax
    c73c:	50                   	push   %rax
    c73d:	0f bf 42 12          	movswl 0x12(%rdx),%eax
    c741:	50                   	push   %rax
    c742:	0f bf 42 10          	movswl 0x10(%rdx),%eax
    c746:	50                   	push   %rax
    c747:	0f bf 42 0e          	movswl 0xe(%rdx),%eax
    c74b:	50                   	push   %rax
    c74c:	44 0f bf 4a 0c       	movswl 0xc(%rdx),%r9d
    c751:	31 c0                	xor    %eax,%eax
    c753:	44 0f bf 42 0a       	movswl 0xa(%rdx),%r8d
    c758:	48 8d 15 48 e9 00 00 	lea    0xe948(%rip),%rdx        # 1b0a7 <slab_levels+0x1e07>
    c75f:	e8 4c c7 ff ff       	callq  8eb0 <pal_snprintf>
    c764:	48 83 c4 30          	add    $0x30,%rsp
    } else {
        return -PAL_ERROR_INVAL;
    }

    return len;
}
    c768:	c9                   	leaveq 
    c769:	c3                   	retq   
    c76a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000c770 <socket_getname>:

    return 0;
}

static int socket_getname (PAL_HANDLE handle, char * buffer, int count)
{
    c770:	55                   	push   %rbp
    c771:	48 89 e5             	mov    %rsp,%rbp
    c774:	41 57                	push   %r15
    c776:	41 56                	push   %r14
    c778:	41 55                	push   %r13
    c77a:	41 54                	push   %r12
    c77c:	49 89 f5             	mov    %rsi,%r13
    c77f:	53                   	push   %rbx
    c780:	48 83 ec 18          	sub    $0x18,%rsp

    const char * prefix = NULL;
    int prefix_len = 0;
    struct sockaddr * bind_addr = NULL, * dest_addr = NULL;

    switch (HANDLE_TYPE(handle)) {
    c784:	8b 0f                	mov    (%rdi),%ecx
    c786:	83 f9 09             	cmp    $0x9,%ecx
    c789:	0f 84 51 01 00 00    	je     c8e0 <socket_getname+0x170>
    c78f:	0f 86 0b 01 00 00    	jbe    c8a0 <socket_getname+0x130>
    c795:	83 f9 0a             	cmp    $0xa,%ecx
    c798:	0f 84 c4 00 00 00    	je     c862 <socket_getname+0xf2>
    c79e:	83 f9 0b             	cmp    $0xb,%ecx
    c7a1:	0f 85 1c 01 00 00    	jne    c8c3 <socket_getname+0x153>
            dest_addr = handle->sock.conn;
            break;
        case pal_type_udpsrv:
            prefix_len = 7;
            prefix = "udp.srv";
            bind_addr = handle->sock.bind;
    c7a7:	48 8b 47 10          	mov    0x10(%rdi),%rax
            bind_addr = handle->sock.bind;
            dest_addr = handle->sock.conn;
            break;
        case pal_type_udpsrv:
            prefix_len = 7;
            prefix = "udp.srv";
    c7ab:	48 8d 35 d0 be 00 00 	lea    0xbed0(%rip),%rsi        # 18682 <write_config+0xd2>
    int old_count = count;
    int ret;

    const char * prefix = NULL;
    int prefix_len = 0;
    struct sockaddr * bind_addr = NULL, * dest_addr = NULL;
    c7b2:	45 31 e4             	xor    %r12d,%r12d
            prefix = "tcp";
            bind_addr = handle->sock.bind;
            dest_addr = handle->sock.conn;
            break;
        case pal_type_udpsrv:
            prefix_len = 7;
    c7b5:	41 bf 07 00 00 00    	mov    $0x7,%r15d
            prefix = "udp.srv";
            bind_addr = handle->sock.bind;
    c7bb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            break;
        default:
            return -PAL_ERROR_INVAL;
    }

    if (prefix_len >= count)
    c7bf:	41 39 d7             	cmp    %edx,%r15d
    c7c2:	0f 8d 38 01 00 00    	jge    c900 <socket_getname+0x190>
    c7c8:	89 d3                	mov    %edx,%ebx
        return -PAL_ERROR_OVERFLOW;

    memcpy(buffer, prefix, prefix_len + 1);
    c7ca:	41 8d 57 01          	lea    0x1(%r15),%edx
    c7ce:	4c 89 ef             	mov    %r13,%rdi
    buffer += prefix_len;
    count -= prefix_len;
    c7d1:	41 be 01 00 00 00    	mov    $0x1,%r14d
    }

    if (prefix_len >= count)
        return -PAL_ERROR_OVERFLOW;

    memcpy(buffer, prefix, prefix_len + 1);
    c7d7:	48 63 d2             	movslq %edx,%rdx
    c7da:	e8 a1 9a 00 00       	callq  16280 <memcpy>
    buffer += prefix_len;
    c7df:	49 63 c7             	movslq %r15d,%rax
    count -= prefix_len;
    c7e2:	89 de                	mov    %ebx,%esi

    if (prefix_len >= count)
        return -PAL_ERROR_OVERFLOW;

    memcpy(buffer, prefix, prefix_len + 1);
    buffer += prefix_len;
    c7e4:	49 8d 7c 05 00       	lea    0x0(%r13,%rax,1),%rdi
    count -= prefix_len;
    c7e9:	44 29 fe             	sub    %r15d,%esi

    for (int i = 0 ; i < 2 ; i++) {
        struct sockaddr * addr = i ? dest_addr : bind_addr;
    c7ec:	41 83 fe 01          	cmp    $0x1,%r14d
    c7f0:	0f 84 8a 00 00 00    	je     c880 <socket_getname+0x110>
        if (addr) {
    c7f6:	4d 85 e4             	test   %r12,%r12
    c7f9:	74 4e                	je     c849 <socket_getname+0xd9>
    c7fb:	4c 89 e2             	mov    %r12,%rdx
            if (count <= 1)
    c7fe:	83 fe 01             	cmp    $0x1,%esi
    c801:	0f 8e f9 00 00 00    	jle    c900 <socket_getname+0x190>
                return -PAL_ERROR_OVERFLOW;

            buffer[0] = ':';
    c807:	c6 07 3a             	movb   $0x3a,(%rdi)
            buffer[1] = 0;
    c80a:	c6 47 01 00          	movb   $0x0,0x1(%rdi)
            buffer++;
    c80e:	4c 8d 7f 01          	lea    0x1(%rdi),%r15
typedef uint16_t /*__attribute__((bitwise))*/ __be16;
#define SOL_TCP			6
#define TCP_CORK	TCP_NOPUSH //Apparently similar
static inline int addr_size (struct sockaddr * addr)
{
    switch (addr->sa_family) {
    c812:	0f b6 42 01          	movzbl 0x1(%rdx),%eax
                return -PAL_ERROR_OVERFLOW;

            buffer[0] = ':';
            buffer[1] = 0;
            buffer++;
            count--;
    c816:	44 8d 6e ff          	lea    -0x1(%rsi),%r13d
#define TCP_CORK	TCP_NOPUSH //Apparently similar
static inline int addr_size (struct sockaddr * addr)
{
    switch (addr->sa_family) {
        case AF_INET:
            return sizeof(struct sockaddr_in);
    c81a:	b9 10 00 00 00       	mov    $0x10,%ecx
typedef uint16_t /*__attribute__((bitwise))*/ __be16;
#define SOL_TCP			6
#define TCP_CORK	TCP_NOPUSH //Apparently similar
static inline int addr_size (struct sockaddr * addr)
{
    switch (addr->sa_family) {
    c81f:	3c 02                	cmp    $0x2,%al
    c821:	74 0c                	je     c82f <socket_getname+0xbf>
        case AF_INET:
            return sizeof(struct sockaddr_in);
        case AF_INET6:
            return sizeof(struct sockaddr_in6);
        default:
            return 0;
    c823:	3c 1c                	cmp    $0x1c,%al
    c825:	b1 00                	mov    $0x0,%cl
    c827:	b8 1c 00 00 00       	mov    $0x1c,%eax
    c82c:	0f 44 c8             	cmove  %eax,%ecx
            buffer[0] = ':';
            buffer[1] = 0;
            buffer++;
            count--;

            if ((ret = inet_create_uri(buffer, count, addr,
    c82f:	44 89 ee             	mov    %r13d,%esi
    c832:	4c 89 ff             	mov    %r15,%rdi
    c835:	e8 76 fe ff ff       	callq  c6b0 <inet_create_uri>
    c83a:	85 c0                	test   %eax,%eax
    c83c:	78 15                	js     c853 <socket_getname+0xe3>
                                       addr_size(addr))) < 0)
                return ret;

            buffer += ret;
    c83e:	48 63 f8             	movslq %eax,%rdi
            count -= ret;
    c841:	44 89 ee             	mov    %r13d,%esi

            if ((ret = inet_create_uri(buffer, count, addr,
                                       addr_size(addr))) < 0)
                return ret;

            buffer += ret;
    c844:	4c 01 ff             	add    %r15,%rdi
            count -= ret;
    c847:	29 c6                	sub    %eax,%esi

    memcpy(buffer, prefix, prefix_len + 1);
    buffer += prefix_len;
    count -= prefix_len;

    for (int i = 0 ; i < 2 ; i++) {
    c849:	41 83 fe 02          	cmp    $0x2,%r14d
    c84d:	75 41                	jne    c890 <socket_getname+0x120>
            buffer += ret;
            count -= ret;
        }
    }

    return old_count - count;
    c84f:	89 d8                	mov    %ebx,%eax
    c851:	29 f0                	sub    %esi,%eax
}
    c853:	48 83 c4 18          	add    $0x18,%rsp
    c857:	5b                   	pop    %rbx
    c858:	41 5c                	pop    %r12
    c85a:	41 5d                	pop    %r13
    c85c:	41 5e                	pop    %r14
    c85e:	41 5f                	pop    %r15
    c860:	5d                   	pop    %rbp
    c861:	c3                   	retq   
            bind_addr = handle->sock.bind;
            break;
        case pal_type_udp:
            prefix_len = 3;
            prefix = "udp";
            bind_addr = handle->sock.bind;
    c862:	48 8b 47 10          	mov    0x10(%rdi),%rax
            dest_addr = handle->sock.conn;
    c866:	4c 8b 67 18          	mov    0x18(%rdi),%r12
            prefix_len = 7;
            prefix = "udp.srv";
            bind_addr = handle->sock.bind;
            break;
        case pal_type_udp:
            prefix_len = 3;
    c86a:	41 bf 03 00 00 00    	mov    $0x3,%r15d
            prefix = "udp";
    c870:	48 8d 35 fb bd 00 00 	lea    0xbdfb(%rip),%rsi        # 18672 <write_config+0xc2>
            bind_addr = handle->sock.bind;
    c877:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            dest_addr = handle->sock.conn;
            break;
    c87b:	e9 3f ff ff ff       	jmpq   c7bf <socket_getname+0x4f>
    buffer += prefix_len;
    count -= prefix_len;

    for (int i = 0 ; i < 2 ; i++) {
        struct sockaddr * addr = i ? dest_addr : bind_addr;
        if (addr) {
    c880:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    c884:	48 85 c0             	test   %rax,%rax
    c887:	48 89 c2             	mov    %rax,%rdx
    c88a:	0f 85 6e ff ff ff    	jne    c7fe <socket_getname+0x8e>
    c890:	41 83 c6 01          	add    $0x1,%r14d
    c894:	e9 53 ff ff ff       	jmpq   c7ec <socket_getname+0x7c>
    c899:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

    const char * prefix = NULL;
    int prefix_len = 0;
    struct sockaddr * bind_addr = NULL, * dest_addr = NULL;

    switch (HANDLE_TYPE(handle)) {
    c8a0:	83 f9 08             	cmp    $0x8,%ecx
    c8a3:	75 1e                	jne    c8c3 <socket_getname+0x153>
            bind_addr = handle->sock.bind;
            break;
        case pal_type_tcp:
            prefix_len = 3;
            prefix = "tcp";
            bind_addr = handle->sock.bind;
    c8a5:	48 8b 47 10          	mov    0x10(%rdi),%rax
            dest_addr = handle->sock.conn;
    c8a9:	4c 8b 67 18          	mov    0x18(%rdi),%r12
            prefix_len = 7;
            prefix = "tcp.srv";
            bind_addr = handle->sock.bind;
            break;
        case pal_type_tcp:
            prefix_len = 3;
    c8ad:	41 bf 03 00 00 00    	mov    $0x3,%r15d
            prefix = "tcp";
    c8b3:	48 8d 35 b4 bd 00 00 	lea    0xbdb4(%rip),%rsi        # 1866e <write_config+0xbe>
            bind_addr = handle->sock.bind;
    c8ba:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            dest_addr = handle->sock.conn;
            break;
    c8be:	e9 fc fe ff ff       	jmpq   c7bf <socket_getname+0x4f>
            count -= ret;
        }
    }

    return old_count - count;
}
    c8c3:	48 83 c4 18          	add    $0x18,%rsp
            prefix = "udp";
            bind_addr = handle->sock.bind;
            dest_addr = handle->sock.conn;
            break;
        default:
            return -PAL_ERROR_INVAL;
    c8c7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
            count -= ret;
        }
    }

    return old_count - count;
}
    c8cc:	5b                   	pop    %rbx
    c8cd:	41 5c                	pop    %r12
    c8cf:	41 5d                	pop    %r13
    c8d1:	41 5e                	pop    %r14
    c8d3:	41 5f                	pop    %r15
    c8d5:	5d                   	pop    %rbp
    c8d6:	c3                   	retq   
    c8d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    c8de:	00 00 

    switch (HANDLE_TYPE(handle)) {
        case pal_type_tcpsrv:
            prefix_len = 7;
            prefix = "tcp.srv";
            bind_addr = handle->sock.bind;
    c8e0:	48 8b 47 10          	mov    0x10(%rdi),%rax
    int old_count = count;
    int ret;

    const char * prefix = NULL;
    int prefix_len = 0;
    struct sockaddr * bind_addr = NULL, * dest_addr = NULL;
    c8e4:	45 31 e4             	xor    %r12d,%r12d

    switch (HANDLE_TYPE(handle)) {
        case pal_type_tcpsrv:
            prefix_len = 7;
    c8e7:	41 bf 07 00 00 00    	mov    $0x7,%r15d
            prefix = "tcp.srv";
    c8ed:	48 8d 35 86 bd 00 00 	lea    0xbd86(%rip),%rsi        # 1867a <write_config+0xca>
            bind_addr = handle->sock.bind;
    c8f4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
            break;
    c8f8:	e9 c2 fe ff ff       	jmpq   c7bf <socket_getname+0x4f>
    c8fd:	0f 1f 00             	nopl   (%rax)
            count -= ret;
        }
    }

    return old_count - count;
}
    c900:	48 83 c4 18          	add    $0x18,%rsp
        default:
            return -PAL_ERROR_INVAL;
    }

    if (prefix_len >= count)
        return -PAL_ERROR_OVERFLOW;
    c904:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
            count -= ret;
        }
    }

    return old_count - count;
}
    c909:	5b                   	pop    %rbx
    c90a:	41 5c                	pop    %r12
    c90c:	41 5d                	pop    %r13
    c90e:	41 5e                	pop    %r14
    c910:	41 5f                	pop    %r15
    c912:	5d                   	pop    %rbp
    c913:	c3                   	retq   
    c914:	66 66 66 2e 0f 1f 84 	nopw   %cs:0x0(%rax,%rax,1)
    c91b:	00 00 00 00 00 

000000000000c920 <tcp_read>:
    return -PAL_ERROR_NOTSUPPORT;
}

/* 'read' operation of tcp stream */
static int tcp_read (PAL_HANDLE handle, int offset, int len, void * buf)
{
    c920:	83 3f 08             	cmpl   $0x8,(%rdi)
    if (!IS_HANDLE_TYPE(handle, tcp) || !handle->sock.conn)
        return -PAL_ERROR_NOTCONNECTION;
    c923:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}

/* 'read' operation of tcp stream */
static int tcp_read (PAL_HANDLE handle, int offset, int len, void * buf)
{
    if (!IS_HANDLE_TYPE(handle, tcp) || !handle->sock.conn)
    c928:	0f 85 96 00 00 00    	jne    c9c4 <tcp_read+0xa4>
    c92e:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
    c933:	0f 84 8b 00 00 00    	je     c9c4 <tcp_read+0xa4>
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
    c939:	8b 7f 0c             	mov    0xc(%rdi),%edi
    c93c:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    c93f:	0f 84 6b 01 00 00    	je     cab0 <tcp_read+0x190>
    return -PAL_ERROR_NOTSUPPORT;
}

/* 'read' operation of tcp stream */
static int tcp_read (PAL_HANDLE handle, int offset, int len, void * buf)
{
    c945:	55                   	push   %rbp
        return -PAL_ERROR_ENDOFSTREAM;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    c946:	48 63 d2             	movslq %edx,%rdx
    return -PAL_ERROR_NOTSUPPORT;
}

/* 'read' operation of tcp stream */
static int tcp_read (PAL_HANDLE handle, int offset, int len, void * buf)
{
    c949:	48 89 e5             	mov    %rsp,%rbp
    c94c:	53                   	push   %rbx
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    c94d:	bb 1b 00 00 00       	mov    $0x1b,%ebx
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    c952:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    c956:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    return -PAL_ERROR_NOTSUPPORT;
}

/* 'read' operation of tcp stream */
static int tcp_read (PAL_HANDLE handle, int offset, int len, void * buf)
{
    c95a:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    c95e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    c962:	31 d2                	xor    %edx,%edx
    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_ENDOFSTREAM;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    c964:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    iov.iov_len = len;
    hdr.msg_name = NULL;
    c968:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    c96f:	00 
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    c970:	89 d8                	mov    %ebx,%eax
    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    c972:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    c979:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    hdr.msg_control = NULL;
    c980:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    c987:	00 
    hdr.msg_controllen = 0;
    c988:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    hdr.msg_flags = 0;
    c98f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    c996:	cd 80                	int    $0x80
    c998:	48 89 c1             	mov    %rax,%rcx
    c99b:	bb 00 00 00 00       	mov    $0x0,%ebx
    c9a0:	83 d3 00             	adc    $0x0,%ebx
    c9a3:	31 d2                	xor    %edx,%edx
    c9a5:	85 db                	test   %ebx,%ebx
    c9a7:	0f 95 c2             	setne  %dl
    c9aa:	48 89 d0             	mov    %rdx,%rax
    c9ad:	48 f7 d8             	neg    %rax
    c9b0:	48 31 c8             	xor    %rcx,%rax
    c9b3:	48 01 d0             	add    %rdx,%rax

    if (IS_ERR(bytes))
    c9b6:	85 c0                	test   %eax,%eax
    c9b8:	78 16                	js     c9d0 <tcp_read+0xb0>

    if (!bytes)
        return -PAL_ERROR_ENDOFSTREAM;

    return bytes;
}
    c9ba:	5b                   	pop    %rbx
    c9bb:	5d                   	pop    %rbp
                return -PAL_ERROR_TRYAGAIN;
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (!bytes)
    c9bc:	ba ec ff ff ff       	mov    $0xffffffec,%edx
    c9c1:	0f 44 c2             	cmove  %edx,%eax
        return -PAL_ERROR_ENDOFSTREAM;

    return bytes;
}
    c9c4:	f3 c3                	repz retq 
    c9c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    c9cd:	00 00 00 
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);

    if (IS_ERR(bytes))
        switch (ERRNO(bytes)) {
    c9d0:	f7 d8                	neg    %eax
    c9d2:	83 f8 0b             	cmp    $0xb,%eax
    c9d5:	74 1b                	je     c9f2 <tcp_read+0xd2>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    c9d7:	83 f8 6e             	cmp    $0x6e,%eax
    c9da:	0f 87 c0 00 00 00    	ja     caa0 <tcp_read+0x180>
    c9e0:	48 8d 15 1d e7 00 00 	lea    0xe71d(%rip),%rdx        # 1b104 <slab_levels+0x1e64>
    c9e7:	89 c0                	mov    %eax,%eax
    c9e9:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    c9ed:	48 01 c2             	add    %rax,%rdx
    c9f0:	ff e2                	jmpq   *%rdx

    if (!bytes)
        return -PAL_ERROR_ENDOFSTREAM;

    return bytes;
}
    c9f2:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    c9f7:	5b                   	pop    %rbx
    c9f8:	5d                   	pop    %rbp
    c9f9:	eb c9                	jmp    c9c4 <tcp_read+0xa4>
    c9fb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    ca00:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    ca05:	5b                   	pop    %rbx
    ca06:	5d                   	pop    %rbp
    ca07:	eb bb                	jmp    c9c4 <tcp_read+0xa4>
    ca09:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    ca10:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    ca15:	5b                   	pop    %rbx
    ca16:	5d                   	pop    %rbp
    ca17:	eb ab                	jmp    c9c4 <tcp_read+0xa4>
    ca19:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    ca20:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    ca25:	5b                   	pop    %rbx
    ca26:	5d                   	pop    %rbp
    ca27:	eb 9b                	jmp    c9c4 <tcp_read+0xa4>
    ca29:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    ca30:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    ca35:	5b                   	pop    %rbx
    ca36:	5d                   	pop    %rbp
    ca37:	eb 8b                	jmp    c9c4 <tcp_read+0xa4>
    ca39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    ca40:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    ca45:	5b                   	pop    %rbx
    ca46:	5d                   	pop    %rbp
    ca47:	e9 78 ff ff ff       	jmpq   c9c4 <tcp_read+0xa4>
    ca4c:	0f 1f 40 00          	nopl   0x0(%rax)
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    ca50:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    ca55:	5b                   	pop    %rbx
    ca56:	5d                   	pop    %rbp
    ca57:	e9 68 ff ff ff       	jmpq   c9c4 <tcp_read+0xa4>
    ca5c:	0f 1f 40 00          	nopl   0x0(%rax)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    ca60:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    ca65:	5b                   	pop    %rbx
    ca66:	5d                   	pop    %rbp
    ca67:	e9 58 ff ff ff       	jmpq   c9c4 <tcp_read+0xa4>
    ca6c:	0f 1f 40 00          	nopl   0x0(%rax)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    ca70:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    ca75:	5b                   	pop    %rbx
    ca76:	5d                   	pop    %rbp
    ca77:	e9 48 ff ff ff       	jmpq   c9c4 <tcp_read+0xa4>
    ca7c:	0f 1f 40 00          	nopl   0x0(%rax)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    ca80:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    ca85:	5b                   	pop    %rbx
    ca86:	5d                   	pop    %rbp
    ca87:	e9 38 ff ff ff       	jmpq   c9c4 <tcp_read+0xa4>
    ca8c:	0f 1f 40 00          	nopl   0x0(%rax)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    ca90:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    ca95:	5b                   	pop    %rbx
    ca96:	5d                   	pop    %rbp
    ca97:	e9 28 ff ff ff       	jmpq   c9c4 <tcp_read+0xa4>
    ca9c:	0f 1f 40 00          	nopl   0x0(%rax)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    caa0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    caa5:	5b                   	pop    %rbx
    caa6:	5d                   	pop    %rbp
    caa7:	e9 18 ff ff ff       	jmpq   c9c4 <tcp_read+0xa4>
    caac:	0f 1f 40 00          	nopl   0x0(%rax)
{
    if (!IS_HANDLE_TYPE(handle, tcp) || !handle->sock.conn)
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_ENDOFSTREAM;
    cab0:	b8 ec ff ff ff       	mov    $0xffffffec,%eax

    if (!bytes)
        return -PAL_ERROR_ENDOFSTREAM;

    return bytes;
}
    cab5:	c3                   	retq   
    cab6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    cabd:	00 00 00 

000000000000cac0 <mcast_attrsetbyhdl>:
    attr->nonblocking = handle->mcast.nonblocking;
    return 0;
}

static int mcast_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    cac0:	49 89 f8             	mov    %rdi,%r8
    if (handle->mcast.cli == PAL_IDX_POISON)
    cac3:	8b 7f 0c             	mov    0xc(%rdi),%edi
    cac6:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    cac9:	0f 84 41 01 00 00    	je     cc10 <mcast_attrsetbyhdl+0x150>
        return -PAL_ERROR_BADHANDLE;

    int ret;
    PAL_BOL * nonblocking = &handle->mcast.nonblocking;

    if (attr->nonblocking != *nonblocking) {
    cacf:	41 0f b6 40 18       	movzbl 0x18(%r8),%eax
    cad4:	49 89 f1             	mov    %rsi,%r9
    cad7:	38 46 38             	cmp    %al,0x38(%rsi)
    cada:	74 54                	je     cb30 <mcast_attrsetbyhdl+0x70>
        ret = INLINE_SYSCALL(fcntl, 3, handle->mcast.cli, F_SETFL,
    cadc:	3c 01                	cmp    $0x1,%al
    attr->nonblocking = handle->mcast.nonblocking;
    return 0;
}

static int mcast_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    cade:	55                   	push   %rbp

    int ret;
    PAL_BOL * nonblocking = &handle->mcast.nonblocking;

    if (attr->nonblocking != *nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->mcast.cli, F_SETFL,
    cadf:	b9 5c 00 00 00       	mov    $0x5c,%ecx
    cae4:	48 19 d2             	sbb    %rdx,%rdx
    cae7:	be 04 00 00 00       	mov    $0x4,%esi
    caec:	89 c8                	mov    %ecx,%eax
    caee:	48 f7 d2             	not    %rdx
    attr->nonblocking = handle->mcast.nonblocking;
    return 0;
}

static int mcast_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    caf1:	48 89 e5             	mov    %rsp,%rbp
    caf4:	53                   	push   %rbx

    int ret;
    PAL_BOL * nonblocking = &handle->mcast.nonblocking;

    if (attr->nonblocking != *nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->mcast.cli, F_SETFL,
    caf5:	83 e2 04             	and    $0x4,%edx
    caf8:	cd 80                	int    $0x80
    cafa:	48 89 c1             	mov    %rax,%rcx
    cafd:	bb 00 00 00 00       	mov    $0x0,%ebx
    cb02:	83 d3 00             	adc    $0x0,%ebx
    cb05:	31 d2                	xor    %edx,%edx
    cb07:	85 db                	test   %ebx,%ebx
    cb09:	0f 95 c2             	setne  %dl
    cb0c:	48 89 d0             	mov    %rdx,%rax
    cb0f:	48 f7 d8             	neg    %rax
    cb12:	48 31 c8             	xor    %rcx,%rax
    cb15:	48 01 c2             	add    %rax,%rdx
                             *nonblocking ? O_NONBLOCK : 0);

        if (IS_ERR(ret))
    cb18:	85 d2                	test   %edx,%edx
    cb1a:	78 17                	js     cb33 <mcast_attrsetbyhdl+0x73>
            return unix_to_pal_error(ERRNO(ret));

        *nonblocking = attr->nonblocking;
    cb1c:	41 0f b6 41 38       	movzbl 0x38(%r9),%eax
    cb21:	41 88 40 18          	mov    %al,0x18(%r8)
    }

    return 0;
    cb25:	31 c0                	xor    %eax,%eax
}
    cb27:	5b                   	pop    %rbx
    cb28:	5d                   	pop    %rbp
    cb29:	c3                   	retq   
    cb2a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return unix_to_pal_error(ERRNO(ret));

        *nonblocking = attr->nonblocking;
    }

    return 0;
    cb30:	31 c0                	xor    %eax,%eax
    cb32:	c3                   	retq   
    if (attr->nonblocking != *nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->mcast.cli, F_SETFL,
                             *nonblocking ? O_NONBLOCK : 0);

        if (IS_ERR(ret))
            return unix_to_pal_error(ERRNO(ret));
    cb33:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    cb35:	83 fa 6e             	cmp    $0x6e,%edx
    cb38:	0f 87 c2 00 00 00    	ja     cc00 <mcast_attrsetbyhdl+0x140>
    cb3e:	48 8d 05 7b e7 00 00 	lea    0xe77b(%rip),%rax        # 1b2c0 <slab_levels+0x2020>
    cb45:	89 d2                	mov    %edx,%edx
    cb47:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    cb4b:	48 01 d0             	add    %rdx,%rax
    cb4e:	ff e0                	jmpq   *%rax
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    cb50:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    cb55:	eb d0                	jmp    cb27 <mcast_attrsetbyhdl+0x67>
    cb57:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    cb5e:	00 00 
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    cb60:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    cb65:	eb c0                	jmp    cb27 <mcast_attrsetbyhdl+0x67>
    cb67:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    cb6e:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    cb70:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    cb75:	eb b0                	jmp    cb27 <mcast_attrsetbyhdl+0x67>
    cb77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    cb7e:	00 00 
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    cb80:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    cb85:	eb a0                	jmp    cb27 <mcast_attrsetbyhdl+0x67>
    cb87:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    cb8e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    cb90:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    cb95:	eb 90                	jmp    cb27 <mcast_attrsetbyhdl+0x67>
    cb97:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    cb9e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    cba0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    cba5:	eb 80                	jmp    cb27 <mcast_attrsetbyhdl+0x67>
    cba7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    cbae:	00 00 
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    cbb0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    cbb5:	e9 6d ff ff ff       	jmpq   cb27 <mcast_attrsetbyhdl+0x67>
    cbba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    cbc0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    cbc5:	e9 5d ff ff ff       	jmpq   cb27 <mcast_attrsetbyhdl+0x67>
    cbca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    cbd0:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    cbd5:	e9 4d ff ff ff       	jmpq   cb27 <mcast_attrsetbyhdl+0x67>
    cbda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    cbe0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    cbe5:	e9 3d ff ff ff       	jmpq   cb27 <mcast_attrsetbyhdl+0x67>
    cbea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    cbf0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    cbf5:	e9 2d ff ff ff       	jmpq   cb27 <mcast_attrsetbyhdl+0x67>
    cbfa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    cc00:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    cc05:	e9 1d ff ff ff       	jmpq   cb27 <mcast_attrsetbyhdl+0x67>
    cc0a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
}

static int mcast_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    if (handle->mcast.cli == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    cc10:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

        *nonblocking = attr->nonblocking;
    }

    return 0;
}
    cc15:	c3                   	retq   
    cc16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    cc1d:	00 00 00 

000000000000cc20 <udp_receive>:

    return -PAL_ERROR_NOTSUPPORT;
}

static int udp_receive (PAL_HANDLE handle, int offset, int len, void * buf)
{
    cc20:	83 3f 0a             	cmpl   $0xa,(%rdi)
    if (!IS_HANDLE_TYPE(handle, udp))
        return -PAL_ERROR_NOTCONNECTION;
    cc23:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    return -PAL_ERROR_NOTSUPPORT;
}

static int udp_receive (PAL_HANDLE handle, int offset, int len, void * buf)
{
    if (!IS_HANDLE_TYPE(handle, udp))
    cc28:	0f 85 86 00 00 00    	jne    ccb4 <udp_receive+0x94>
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
    cc2e:	8b 7f 0c             	mov    0xc(%rdi),%edi
    cc31:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    cc34:	0f 84 28 01 00 00    	je     cd62 <udp_receive+0x142>

    return -PAL_ERROR_NOTSUPPORT;
}

static int udp_receive (PAL_HANDLE handle, int offset, int len, void * buf)
{
    cc3a:	55                   	push   %rbp
        return -PAL_ERROR_BADHANDLE;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    cc3b:	48 63 d2             	movslq %edx,%rdx

    return -PAL_ERROR_NOTSUPPORT;
}

static int udp_receive (PAL_HANDLE handle, int offset, int len, void * buf)
{
    cc3e:	48 89 e5             	mov    %rsp,%rbp
    cc41:	53                   	push   %rbx
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    cc42:	bb 1b 00 00 00       	mov    $0x1b,%ebx
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    cc47:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    cc4b:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi

    return -PAL_ERROR_NOTSUPPORT;
}

static int udp_receive (PAL_HANDLE handle, int offset, int len, void * buf)
{
    cc4f:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    cc53:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    cc57:	31 d2                	xor    %edx,%edx
    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    cc59:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    iov.iov_len = len;
    hdr.msg_name = NULL;
    cc5d:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    cc64:	00 
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    cc65:	89 d8                	mov    %ebx,%eax
    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    cc67:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    cc6e:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    hdr.msg_control = NULL;
    cc75:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    cc7c:	00 
    hdr.msg_controllen = 0;
    cc7d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    hdr.msg_flags = 0;
    cc84:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    cc8b:	cd 80                	int    $0x80
    cc8d:	48 89 c2             	mov    %rax,%rdx
    cc90:	bb 00 00 00 00       	mov    $0x0,%ebx
    cc95:	83 d3 00             	adc    $0x0,%ebx
    cc98:	31 c9                	xor    %ecx,%ecx
    cc9a:	85 db                	test   %ebx,%ebx
    cc9c:	0f 95 c1             	setne  %cl
    cc9f:	48 89 c8             	mov    %rcx,%rax
    cca2:	48 f7 d8             	neg    %rax
    cca5:	48 31 d0             	xor    %rdx,%rax
    cca8:	48 8d 14 08          	lea    (%rax,%rcx,1),%rdx

    if (IS_ERR(bytes))
    ccac:	85 d2                	test   %edx,%edx
    ccae:	89 d0                	mov    %edx,%eax
    ccb0:	78 0e                	js     ccc0 <udp_receive+0xa0>
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    return bytes;
}
    ccb2:	5b                   	pop    %rbx
    ccb3:	5d                   	pop    %rbp
    ccb4:	f3 c3                	repz retq 
    ccb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    ccbd:	00 00 00 
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    ccc0:	f7 da                	neg    %edx
            case EWOULDBLOCK:
                return -PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
    ccc2:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    ccc7:	83 fa 04             	cmp    $0x4,%edx
    ccca:	74 e6                	je     ccb2 <udp_receive+0x92>
    cccc:	83 fa 0b             	cmp    $0xb,%edx
            case EWOULDBLOCK:
                return -PAL_ERROR_TRYAGAIN;
    cccf:	b0 ed                	mov    $0xed,%al
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    ccd1:	74 df                	je     ccb2 <udp_receive+0x92>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    ccd3:	83 fa 6e             	cmp    $0x6e,%edx
    ccd6:	77 7e                	ja     cd56 <udp_receive+0x136>
    ccd8:	48 8d 05 9d e7 00 00 	lea    0xe79d(%rip),%rax        # 1b47c <slab_levels+0x21dc>
    ccdf:	89 d2                	mov    %edx,%edx
    cce1:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    cce5:	48 01 d0             	add    %rdx,%rax
    cce8:	ff e0                	jmpq   *%rax
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    return bytes;
}
    ccea:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    ccef:	5b                   	pop    %rbx
    ccf0:	5d                   	pop    %rbp
    ccf1:	eb c1                	jmp    ccb4 <udp_receive+0x94>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    ccf3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    ccf8:	5b                   	pop    %rbx
    ccf9:	5d                   	pop    %rbp
    ccfa:	eb b8                	jmp    ccb4 <udp_receive+0x94>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    ccfc:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    cd01:	5b                   	pop    %rbx
    cd02:	5d                   	pop    %rbp
    cd03:	eb af                	jmp    ccb4 <udp_receive+0x94>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    cd05:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    cd0a:	5b                   	pop    %rbx
    cd0b:	5d                   	pop    %rbp
    cd0c:	eb a6                	jmp    ccb4 <udp_receive+0x94>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    cd0e:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    cd13:	5b                   	pop    %rbx
    cd14:	5d                   	pop    %rbp
    cd15:	eb 9d                	jmp    ccb4 <udp_receive+0x94>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    cd17:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    cd1c:	5b                   	pop    %rbx
    cd1d:	5d                   	pop    %rbp
    cd1e:	eb 94                	jmp    ccb4 <udp_receive+0x94>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    cd20:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    cd25:	5b                   	pop    %rbx
    cd26:	5d                   	pop    %rbp
    cd27:	eb 8b                	jmp    ccb4 <udp_receive+0x94>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    cd29:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    cd2e:	5b                   	pop    %rbx
    cd2f:	5d                   	pop    %rbp
    cd30:	eb 82                	jmp    ccb4 <udp_receive+0x94>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    cd32:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    cd37:	5b                   	pop    %rbx
    cd38:	5d                   	pop    %rbp
    cd39:	e9 76 ff ff ff       	jmpq   ccb4 <udp_receive+0x94>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    cd3e:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    cd43:	5b                   	pop    %rbx
    cd44:	5d                   	pop    %rbp
    cd45:	e9 6a ff ff ff       	jmpq   ccb4 <udp_receive+0x94>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    cd4a:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    cd4f:	5b                   	pop    %rbx
    cd50:	5d                   	pop    %rbp
    cd51:	e9 5e ff ff ff       	jmpq   ccb4 <udp_receive+0x94>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    cd56:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    cd5b:	5b                   	pop    %rbx
    cd5c:	5d                   	pop    %rbp
    cd5d:	e9 52 ff ff ff       	jmpq   ccb4 <udp_receive+0x94>
{
    if (!IS_HANDLE_TYPE(handle, udp))
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    cd62:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    return bytes;
}
    cd67:	c3                   	retq   
    cd68:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    cd6f:	00 

000000000000cd70 <tcp_write>:
    return bytes;
}

/* write' operation of tcp stream */
static int tcp_write (PAL_HANDLE handle, int offset, int len, const void * buf)
{
    cd70:	83 3f 08             	cmpl   $0x8,(%rdi)
    cd73:	49 89 f8             	mov    %rdi,%r8
    if (!IS_HANDLE_TYPE(handle, tcp) || !handle->sock.conn)
        return -PAL_ERROR_NOTCONNECTION;
    cd76:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}

/* write' operation of tcp stream */
static int tcp_write (PAL_HANDLE handle, int offset, int len, const void * buf)
{
    if (!IS_HANDLE_TYPE(handle, tcp) || !handle->sock.conn)
    cd7b:	0f 85 9e 00 00 00    	jne    ce1f <tcp_write+0xaf>
    cd81:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
    cd86:	0f 84 93 00 00 00    	je     ce1f <tcp_write+0xaf>
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
    cd8c:	8b 7f 0c             	mov    0xc(%rdi),%edi
    cd8f:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    cd92:	0f 84 6d 01 00 00    	je     cf05 <tcp_write+0x195>
    return bytes;
}

/* write' operation of tcp stream */
static int tcp_write (PAL_HANDLE handle, int offset, int len, const void * buf)
{
    cd98:	55                   	push   %rbp
        return -PAL_ERROR_CONNFAILED;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    cd99:	48 63 c2             	movslq %edx,%rax
    cd9c:	41 89 d1             	mov    %edx,%r9d
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    cd9f:	ba 00 00 02 00       	mov    $0x20000,%edx
    return bytes;
}

/* write' operation of tcp stream */
static int tcp_write (PAL_HANDLE handle, int offset, int len, const void * buf)
{
    cda4:	48 89 e5             	mov    %rsp,%rbp
    cda7:	53                   	push   %rbx
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    cda8:	bb 1c 00 00 00       	mov    $0x1c,%ebx
    cdad:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    return bytes;
}

/* write' operation of tcp stream */
static int tcp_write (PAL_HANDLE handle, int offset, int len, const void * buf)
{
    cdb1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    cdb5:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_CONNFAILED;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    cdb9:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    iov.iov_len = len;
    hdr.msg_name = NULL;
    cdbd:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    cdc4:	00 
    hdr.msg_namelen = 0;
    cdc5:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
    hdr.msg_iov = &iov;
    cdcc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    hdr.msg_iovlen = 1;
    cdd0:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    cdd7:	89 d8                	mov    %ebx,%eax
    iov.iov_len = len;
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    cdd9:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    cde0:	00 
    hdr.msg_controllen = 0;
    cde1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    hdr.msg_flags = 0;
    cde8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    cdef:	cd 80                	int    $0x80
    cdf1:	48 89 c6             	mov    %rax,%rsi
    cdf4:	bb 00 00 00 00       	mov    $0x0,%ebx
    cdf9:	83 d3 00             	adc    $0x0,%ebx
    cdfc:	31 c9                	xor    %ecx,%ecx
    cdfe:	85 db                	test   %ebx,%ebx
    ce00:	0f 95 c1             	setne  %cl
    ce03:	48 89 c8             	mov    %rcx,%rax
    ce06:	48 f7 d8             	neg    %rax
    ce09:	48 31 f0             	xor    %rsi,%rax
    ce0c:	48 01 c8             	add    %rcx,%rax

    if (IS_ERR(bytes))
    ce0f:	85 c0                	test   %eax,%eax
    ce11:	78 0e                	js     ce21 <tcp_write+0xb1>
                return -PAL_ERROR_TRYAGAIN;
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (bytes == len)
    ce13:	44 39 c8             	cmp    %r9d,%eax
    ce16:	74 38                	je     ce50 <tcp_write+0xe0>
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);
    ce18:	41 83 60 08 bf       	andl   $0xffffffffffffffbf,0x8(%r8)

    return bytes;
}
    ce1d:	5b                   	pop    %rbx
    ce1e:	5d                   	pop    %rbp
    ce1f:	f3 c3                	repz retq 
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    ce21:	f7 d8                	neg    %eax
    ce23:	83 f8 20             	cmp    $0x20,%eax
    ce26:	74 38                	je     ce60 <tcp_write+0xf0>
    ce28:	83 f8 68             	cmp    $0x68,%eax
    ce2b:	74 33                	je     ce60 <tcp_write+0xf0>
    ce2d:	83 f8 0b             	cmp    $0xb,%eax
    ce30:	74 3e                	je     ce70 <tcp_write+0x100>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    ce32:	83 f8 6e             	cmp    $0x6e,%eax
    ce35:	0f 87 be 00 00 00    	ja     cef9 <tcp_write+0x189>
    ce3b:	48 8d 15 f6 e7 00 00 	lea    0xe7f6(%rip),%rdx        # 1b638 <slab_levels+0x2398>
    ce42:	89 c0                	mov    %eax,%eax
    ce44:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    ce48:	48 01 c2             	add    %rax,%rdx
    ce4b:	ff e2                	jmpq   *%rdx
    ce4d:	0f 1f 00             	nopl   (%rax)
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (bytes == len)
        handle->__in.flags |= WRITEABLE(0);
    ce50:	41 83 48 08 40       	orl    $0x40,0x8(%r8)
    else
        handle->__in.flags &= ~WRITEABLE(0);

    return bytes;
}
    ce55:	5b                   	pop    %rbx
    ce56:	5d                   	pop    %rbp
    ce57:	eb c6                	jmp    ce1f <tcp_write+0xaf>
    ce59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
            case ECONNRESET:
            case EPIPE:
                return -PAL_ERROR_CONNFAILED;
    ce60:	b8 e8 ff ff ff       	mov    $0xffffffe8,%eax
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);

    return bytes;
}
    ce65:	5b                   	pop    %rbx
    ce66:	5d                   	pop    %rbp
    ce67:	eb b6                	jmp    ce1f <tcp_write+0xaf>
    ce69:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        switch(ERRNO(bytes)) {
            case ECONNRESET:
            case EPIPE:
                return -PAL_ERROR_CONNFAILED;
            case EWOULDBLOCK:
                handle->__in.flags &= ~WRITEABLE(0);
    ce70:	41 83 60 08 bf       	andl   $0xffffffffffffffbf,0x8(%r8)
                return -PAL_ERROR_TRYAGAIN;
    ce75:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);

    return bytes;
}
    ce7a:	5b                   	pop    %rbx
    ce7b:	5d                   	pop    %rbp
    ce7c:	eb a1                	jmp    ce1f <tcp_write+0xaf>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    ce7e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    ce83:	5b                   	pop    %rbx
    ce84:	5d                   	pop    %rbp
    ce85:	eb 98                	jmp    ce1f <tcp_write+0xaf>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    ce87:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    ce8c:	5b                   	pop    %rbx
    ce8d:	5d                   	pop    %rbp
    ce8e:	eb 8f                	jmp    ce1f <tcp_write+0xaf>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    ce90:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    ce95:	5b                   	pop    %rbx
    ce96:	5d                   	pop    %rbp
    ce97:	eb 86                	jmp    ce1f <tcp_write+0xaf>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    ce99:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    ce9e:	5b                   	pop    %rbx
    ce9f:	5d                   	pop    %rbp
    cea0:	e9 7a ff ff ff       	jmpq   ce1f <tcp_write+0xaf>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    cea5:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    ceaa:	5b                   	pop    %rbx
    ceab:	5d                   	pop    %rbp
    ceac:	e9 6e ff ff ff       	jmpq   ce1f <tcp_write+0xaf>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    ceb1:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    ceb6:	5b                   	pop    %rbx
    ceb7:	5d                   	pop    %rbp
    ceb8:	e9 62 ff ff ff       	jmpq   ce1f <tcp_write+0xaf>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    cebd:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    cec2:	5b                   	pop    %rbx
    cec3:	5d                   	pop    %rbp
    cec4:	e9 56 ff ff ff       	jmpq   ce1f <tcp_write+0xaf>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    cec9:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    cece:	5b                   	pop    %rbx
    cecf:	5d                   	pop    %rbp
    ced0:	e9 4a ff ff ff       	jmpq   ce1f <tcp_write+0xaf>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    ced5:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    ceda:	5b                   	pop    %rbx
    cedb:	5d                   	pop    %rbp
    cedc:	e9 3e ff ff ff       	jmpq   ce1f <tcp_write+0xaf>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    cee1:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    cee6:	5b                   	pop    %rbx
    cee7:	5d                   	pop    %rbp
    cee8:	e9 32 ff ff ff       	jmpq   ce1f <tcp_write+0xaf>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    ceed:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    cef2:	5b                   	pop    %rbx
    cef3:	5d                   	pop    %rbp
    cef4:	e9 26 ff ff ff       	jmpq   ce1f <tcp_write+0xaf>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    cef9:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    cefe:	5b                   	pop    %rbx
    ceff:	5d                   	pop    %rbp
    cf00:	e9 1a ff ff ff       	jmpq   ce1f <tcp_write+0xaf>
{
    if (!IS_HANDLE_TYPE(handle, tcp) || !handle->sock.conn)
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_CONNFAILED;
    cf05:	b8 e8 ff ff ff       	mov    $0xffffffe8,%eax
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);

    return bytes;
}
    cf0a:	c3                   	retq   
    cf0b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000cf10 <udp_send>:

    return bytes;
}

static int udp_send (PAL_HANDLE handle, int offset, int len, const void * buf)
{
    cf10:	83 3f 0a             	cmpl   $0xa,(%rdi)
    cf13:	49 89 f8             	mov    %rdi,%r8
    if (!IS_HANDLE_TYPE(handle, udp))
        return -PAL_ERROR_NOTCONNECTION;
    cf16:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    return bytes;
}

static int udp_send (PAL_HANDLE handle, int offset, int len, const void * buf)
{
    if (!IS_HANDLE_TYPE(handle, udp))
    cf1b:	0f 85 aa 00 00 00    	jne    cfcb <udp_send+0xbb>
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
    cf21:	8b 7f 0c             	mov    0xc(%rdi),%edi
    cf24:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    cf27:	0f 84 88 01 00 00    	je     d0b5 <udp_send+0x1a5>

    return bytes;
}

static int udp_send (PAL_HANDLE handle, int offset, int len, const void * buf)
{
    cf2d:	55                   	push   %rbp
        return -PAL_ERROR_BADHANDLE;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    cf2e:	48 63 c2             	movslq %edx,%rax
    cf31:	41 89 d1             	mov    %edx,%r9d

    return bytes;
}

static int udp_send (PAL_HANDLE handle, int offset, int len, const void * buf)
{
    cf34:	48 89 e5             	mov    %rsp,%rbp
    cf37:	53                   	push   %rbx
        return -PAL_ERROR_BADHANDLE;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    cf38:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    hdr.msg_name = handle->sock.conn;
    cf3c:	49 8b 40 18          	mov    0x18(%r8),%rax
    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    cf40:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
    iov.iov_len = len;
    hdr.msg_name = handle->sock.conn;
    cf44:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
typedef uint16_t /*__attribute__((bitwise))*/ __be16;
#define SOL_TCP			6
#define TCP_CORK	TCP_NOPUSH //Apparently similar
static inline int addr_size (struct sockaddr * addr)
{
    switch (addr->sa_family) {
    cf48:	0f b6 50 01          	movzbl 0x1(%rax),%edx
    cf4c:	b8 10 00 00 00       	mov    $0x10,%eax
    cf51:	80 fa 02             	cmp    $0x2,%dl
    cf54:	74 0d                	je     cf63 <udp_send+0x53>
    cf56:	80 fa 1c             	cmp    $0x1c,%dl
    cf59:	b0 1c                	mov    $0x1c,%al
    cf5b:	ba 00 00 00 00       	mov    $0x0,%edx
    cf60:	0f 45 c2             	cmovne %edx,%eax
    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    hdr.msg_name = handle->sock.conn;
    hdr.msg_namelen = addr_size(handle->sock.conn);
    cf63:	89 45 c8             	mov    %eax,-0x38(%rbp)
    hdr.msg_iov = &iov;
    cf66:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    cf6a:	bb 1c 00 00 00       	mov    $0x1c,%ebx
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    hdr.msg_name = handle->sock.conn;
    hdr.msg_namelen = addr_size(handle->sock.conn);
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    cf6f:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%rbp)
    hdr.msg_control = NULL;
    cf76:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
    cf7d:	00 
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    cf7e:	ba 00 00 02 00       	mov    $0x20000,%edx
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    hdr.msg_name = handle->sock.conn;
    hdr.msg_namelen = addr_size(handle->sock.conn);
    hdr.msg_iov = &iov;
    cf83:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    cf87:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    cf8e:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    hdr.msg_namelen = addr_size(handle->sock.conn);
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;
    cf92:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    cf99:	89 d8                	mov    %ebx,%eax
    cf9b:	cd 80                	int    $0x80
    cf9d:	48 89 c6             	mov    %rax,%rsi
    cfa0:	bb 00 00 00 00       	mov    $0x0,%ebx
    cfa5:	83 d3 00             	adc    $0x0,%ebx
    cfa8:	31 c9                	xor    %ecx,%ecx
    cfaa:	85 db                	test   %ebx,%ebx
    cfac:	0f 95 c1             	setne  %cl
    cfaf:	48 89 c8             	mov    %rcx,%rax
    cfb2:	48 f7 d8             	neg    %rax
    cfb5:	48 31 f0             	xor    %rsi,%rax
    cfb8:	48 01 c8             	add    %rcx,%rax

    if (IS_ERR(bytes))
    cfbb:	85 c0                	test   %eax,%eax
    cfbd:	78 11                	js     cfd0 <udp_send+0xc0>
                return -PAL_ERROR_CONNFAILED;
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (bytes == len)
    cfbf:	44 39 c8             	cmp    %r9d,%eax
    cfc2:	74 3c                	je     d000 <udp_send+0xf0>
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);
    cfc4:	41 83 60 08 bf       	andl   $0xffffffffffffffbf,0x8(%r8)

    return bytes;
}
    cfc9:	5b                   	pop    %rbx
    cfca:	5d                   	pop    %rbp
    cfcb:	f3 c3                	repz retq 
    cfcd:	0f 1f 00             	nopl   (%rax)
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    cfd0:	f7 d8                	neg    %eax
    cfd2:	83 f8 20             	cmp    $0x20,%eax
    cfd5:	74 39                	je     d010 <udp_send+0x100>
    cfd7:	83 f8 68             	cmp    $0x68,%eax
    cfda:	74 34                	je     d010 <udp_send+0x100>
    cfdc:	83 f8 0b             	cmp    $0xb,%eax
    cfdf:	74 3f                	je     d020 <udp_send+0x110>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    cfe1:	83 f8 6e             	cmp    $0x6e,%eax
    cfe4:	0f 87 bf 00 00 00    	ja     d0a9 <udp_send+0x199>
    cfea:	48 8d 15 03 e8 00 00 	lea    0xe803(%rip),%rdx        # 1b7f4 <slab_levels+0x2554>
    cff1:	89 c0                	mov    %eax,%eax
    cff3:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    cff7:	48 01 c2             	add    %rax,%rdx
    cffa:	ff e2                	jmpq   *%rdx
    cffc:	0f 1f 40 00          	nopl   0x0(%rax)
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (bytes == len)
        handle->__in.flags |= WRITEABLE(0);
    d000:	41 83 48 08 40       	orl    $0x40,0x8(%r8)
    else
        handle->__in.flags &= ~WRITEABLE(0);

    return bytes;
}
    d005:	5b                   	pop    %rbx
    d006:	5d                   	pop    %rbp
    d007:	eb c2                	jmp    cfcb <udp_send+0xbb>
    d009:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            case EAGAIN:
                handle->__in.flags &= ~WRITEABLE(0);
                return -PAL_ERROR_TRYAGAIN;
            case ECONNRESET:
            case EPIPE:
                return -PAL_ERROR_CONNFAILED;
    d010:	b8 e8 ff ff ff       	mov    $0xffffffe8,%eax
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);

    return bytes;
}
    d015:	5b                   	pop    %rbx
    d016:	5d                   	pop    %rbp
    d017:	eb b2                	jmp    cfcb <udp_send+0xbb>
    d019:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
            case EAGAIN:
                handle->__in.flags &= ~WRITEABLE(0);
    d020:	41 83 60 08 bf       	andl   $0xffffffffffffffbf,0x8(%r8)
                return -PAL_ERROR_TRYAGAIN;
    d025:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);

    return bytes;
}
    d02a:	5b                   	pop    %rbx
    d02b:	5d                   	pop    %rbp
    d02c:	eb 9d                	jmp    cfcb <udp_send+0xbb>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    d02e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    d033:	5b                   	pop    %rbx
    d034:	5d                   	pop    %rbp
    d035:	eb 94                	jmp    cfcb <udp_send+0xbb>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    d037:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    d03c:	5b                   	pop    %rbx
    d03d:	5d                   	pop    %rbp
    d03e:	eb 8b                	jmp    cfcb <udp_send+0xbb>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    d040:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    d045:	5b                   	pop    %rbx
    d046:	5d                   	pop    %rbp
    d047:	eb 82                	jmp    cfcb <udp_send+0xbb>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    d049:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    d04e:	5b                   	pop    %rbx
    d04f:	5d                   	pop    %rbp
    d050:	e9 76 ff ff ff       	jmpq   cfcb <udp_send+0xbb>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    d055:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    d05a:	5b                   	pop    %rbx
    d05b:	5d                   	pop    %rbp
    d05c:	e9 6a ff ff ff       	jmpq   cfcb <udp_send+0xbb>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    d061:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    d066:	5b                   	pop    %rbx
    d067:	5d                   	pop    %rbp
    d068:	e9 5e ff ff ff       	jmpq   cfcb <udp_send+0xbb>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    d06d:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    d072:	5b                   	pop    %rbx
    d073:	5d                   	pop    %rbp
    d074:	e9 52 ff ff ff       	jmpq   cfcb <udp_send+0xbb>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    d079:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    d07e:	5b                   	pop    %rbx
    d07f:	5d                   	pop    %rbp
    d080:	e9 46 ff ff ff       	jmpq   cfcb <udp_send+0xbb>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    d085:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    d08a:	5b                   	pop    %rbx
    d08b:	5d                   	pop    %rbp
    d08c:	e9 3a ff ff ff       	jmpq   cfcb <udp_send+0xbb>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    d091:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    d096:	5b                   	pop    %rbx
    d097:	5d                   	pop    %rbp
    d098:	e9 2e ff ff ff       	jmpq   cfcb <udp_send+0xbb>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    d09d:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    d0a2:	5b                   	pop    %rbx
    d0a3:	5d                   	pop    %rbp
    d0a4:	e9 22 ff ff ff       	jmpq   cfcb <udp_send+0xbb>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    d0a9:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    d0ae:	5b                   	pop    %rbx
    d0af:	5d                   	pop    %rbp
    d0b0:	e9 16 ff ff ff       	jmpq   cfcb <udp_send+0xbb>
{
    if (!IS_HANDLE_TYPE(handle, udp))
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    d0b5:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);

    return bytes;
}
    d0ba:	c3                   	retq   
    d0bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000d0c0 <mcast_send>:
    return hdl;
}

static int mcast_send (PAL_HANDLE handle, int offset, int size,
                       const void * buf)
{
    d0c0:	83 7f 10 ff          	cmpl   $0xffffffffffffffff,0x10(%rdi)
    d0c4:	0f 84 b6 01 00 00    	je     d280 <mcast_send+0x1c0>
    d0ca:	55                   	push   %rbp
    if (handle->mcast.srv == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    inet_pton(AF_INET, MCAST_GROUP, &addr.sin_addr.s_addr);
    d0cb:	48 8d 35 f2 df 00 00 	lea    0xdff2(%rip),%rsi        # 1b0c4 <slab_levels+0x1e24>
    return hdl;
}

static int mcast_send (PAL_HANDLE handle, int offset, int size,
                       const void * buf)
{
    d0d2:	48 89 e5             	mov    %rsp,%rbp
    d0d5:	41 56                	push   %r14
    d0d7:	41 55                	push   %r13
    if (handle->mcast.srv == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    inet_pton(AF_INET, MCAST_GROUP, &addr.sin_addr.s_addr);
    d0d9:	4c 8d 75 90          	lea    -0x70(%rbp),%r14
    return hdl;
}

static int mcast_send (PAL_HANDLE handle, int offset, int size,
                       const void * buf)
{
    d0dd:	41 54                	push   %r12
    d0df:	53                   	push   %rbx
    d0e0:	41 89 d5             	mov    %edx,%r13d
    d0e3:	49 89 fc             	mov    %rdi,%r12
    if (handle->mcast.srv == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    inet_pton(AF_INET, MCAST_GROUP, &addr.sin_addr.s_addr);
    d0e6:	bf 02 00 00 00       	mov    $0x2,%edi
    d0eb:	49 8d 56 04          	lea    0x4(%r14),%rdx
    return hdl;
}

static int mcast_send (PAL_HANDLE handle, int offset, int size,
                       const void * buf)
{
    d0ef:	48 83 ec 50          	sub    $0x50,%rsp
    d0f3:	48 89 cb             	mov    %rcx,%rbx
    if (handle->mcast.srv == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    d0f6:	c6 45 91 02          	movb   $0x2,-0x6f(%rbp)
    inet_pton(AF_INET, MCAST_GROUP, &addr.sin_addr.s_addr);
    d0fa:	e8 31 a2 00 00       	callq  17330 <__inet_pton>
    d0ff:	41 0f b7 44 24 14    	movzwl 0x14(%r12),%eax
    addr.sin_port = htons(handle->mcast.port);

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    d105:	48 89 5d a0          	mov    %rbx,-0x60(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->mcast.srv, &hdr,
    d109:	bb 1c 00 00 00       	mov    $0x1c,%ebx

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = size;
    hdr.msg_name = &addr;
    d10e:	4c 89 75 b0          	mov    %r14,-0x50(%rbp)
    hdr.msg_namelen = sizeof(addr);
    d112:	c7 45 b8 10 00 00 00 	movl   $0x10,-0x48(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->mcast.srv, &hdr,
    d119:	ba 00 00 02 00       	mov    $0x20000,%edx
    iov.iov_base = (void *) buf;
    iov.iov_len = size;
    hdr.msg_name = &addr;
    hdr.msg_namelen = sizeof(addr);
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    d11e:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
    hdr.msg_control = NULL;
    d125:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    d12c:	00 
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->mcast.srv, &hdr,
    d12d:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
    hdr.msg_name = &addr;
    hdr.msg_namelen = sizeof(addr);
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    d131:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
    hdr.msg_flags = 0;
    d138:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
    d13f:	66 c1 c0 08          	rol    $0x8,%ax

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->mcast.srv, &hdr,
    d143:	41 8b 7c 24 10       	mov    0x10(%r12),%edi
    d148:	66 89 45 92          	mov    %ax,-0x6e(%rbp)
    addr.sin_port = htons(handle->mcast.port);

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = size;
    d14c:	49 63 c5             	movslq %r13d,%rax
    d14f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
    hdr.msg_name = &addr;
    hdr.msg_namelen = sizeof(addr);
    hdr.msg_iov = &iov;
    d153:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
    d157:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->mcast.srv, &hdr,
    d15b:	89 d8                	mov    %ebx,%eax
    d15d:	cd 80                	int    $0x80
    d15f:	48 89 c6             	mov    %rax,%rsi
    d162:	bb 00 00 00 00       	mov    $0x0,%ebx
    d167:	83 d3 00             	adc    $0x0,%ebx
    d16a:	31 c9                	xor    %ecx,%ecx
    d16c:	85 db                	test   %ebx,%ebx
    d16e:	0f 95 c1             	setne  %cl
    d171:	48 89 c8             	mov    %rcx,%rax
    d174:	48 f7 d8             	neg    %rax
    d177:	48 31 f0             	xor    %rsi,%rax
    d17a:	48 01 c8             	add    %rcx,%rax
                               MSG_NOSIGNAL);

    if (IS_ERR(bytes))
    d17d:	85 c0                	test   %eax,%eax
    d17f:	0f 88 1b 00 00 00    	js     d1a0 <mcast_send+0xe0>
                handle->__in.flags &= ~WRITEABLE(1);
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (bytes == size)
    d185:	44 39 e8             	cmp    %r13d,%eax
    d188:	74 56                	je     d1e0 <mcast_send+0x120>
        handle->__in.flags |= WRITEABLE(1);
    else
        handle->__in.flags &= ~WRITEABLE(1);
    d18a:	41 81 64 24 08 7f ff 	andl   $0xffffff7f,0x8(%r12)
    d191:	ff ff 

    return bytes;
}
    d193:	48 83 c4 50          	add    $0x50,%rsp
    d197:	5b                   	pop    %rbx
    d198:	41 5c                	pop    %r12
    d19a:	41 5d                	pop    %r13
    d19c:	41 5e                	pop    %r14
    d19e:	5d                   	pop    %rbp
    d19f:	c3                   	retq   

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->mcast.srv, &hdr,
                               MSG_NOSIGNAL);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    d1a0:	f7 d8                	neg    %eax
    d1a2:	83 f8 20             	cmp    $0x20,%eax
    d1a5:	74 29                	je     d1d0 <mcast_send+0x110>
    d1a7:	83 f8 68             	cmp    $0x68,%eax
    d1aa:	74 24                	je     d1d0 <mcast_send+0x110>
    d1ac:	83 f8 0b             	cmp    $0xb,%eax
    d1af:	74 4f                	je     d200 <mcast_send+0x140>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    d1b1:	83 f8 6e             	cmp    $0x6e,%eax
    d1b4:	0f 87 ba 00 00 00    	ja     d274 <mcast_send+0x1b4>
    d1ba:	48 8d 15 ef e7 00 00 	lea    0xe7ef(%rip),%rdx        # 1b9b0 <slab_levels+0x2710>
    d1c1:	89 c0                	mov    %eax,%eax
    d1c3:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
    d1c7:	48 01 c2             	add    %rax,%rdx
    d1ca:	ff e2                	jmpq   *%rdx
    d1cc:	0f 1f 40 00          	nopl   0x0(%rax)
            case ECONNRESET:
            case EPIPE:
                return -PAL_ERROR_CONNFAILED;
    d1d0:	b8 e8 ff ff ff       	mov    $0xffffffe8,%eax
    d1d5:	eb bc                	jmp    d193 <mcast_send+0xd3>
    d1d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    d1de:	00 00 
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (bytes == size)
        handle->__in.flags |= WRITEABLE(1);
    d1e0:	41 81 4c 24 08 80 00 	orl    $0x80,0x8(%r12)
    d1e7:	00 00 
    else
        handle->__in.flags &= ~WRITEABLE(1);

    return bytes;
}
    d1e9:	48 83 c4 50          	add    $0x50,%rsp
    d1ed:	5b                   	pop    %rbx
    d1ee:	41 5c                	pop    %r12
    d1f0:	41 5d                	pop    %r13
    d1f2:	41 5e                	pop    %r14
    d1f4:	5d                   	pop    %rbp
    d1f5:	c3                   	retq   
    d1f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    d1fd:	00 00 00 
        switch(ERRNO(bytes)) {
            case ECONNRESET:
            case EPIPE:
                return -PAL_ERROR_CONNFAILED;
            case EAGAIN:
                handle->__in.flags &= ~WRITEABLE(1);
    d200:	41 81 64 24 08 7f ff 	andl   $0xffffff7f,0x8(%r12)
    d207:	ff ff 
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    d209:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    d20e:	eb 83                	jmp    d193 <mcast_send+0xd3>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    d210:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    d215:	e9 79 ff ff ff       	jmpq   d193 <mcast_send+0xd3>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    d21a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    d21f:	e9 6f ff ff ff       	jmpq   d193 <mcast_send+0xd3>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    d224:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    d229:	e9 65 ff ff ff       	jmpq   d193 <mcast_send+0xd3>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    d22e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    d233:	e9 5b ff ff ff       	jmpq   d193 <mcast_send+0xd3>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    d238:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    d23d:	e9 51 ff ff ff       	jmpq   d193 <mcast_send+0xd3>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    d242:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    d247:	e9 47 ff ff ff       	jmpq   d193 <mcast_send+0xd3>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    d24c:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    d251:	e9 3d ff ff ff       	jmpq   d193 <mcast_send+0xd3>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    d256:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    d25b:	e9 33 ff ff ff       	jmpq   d193 <mcast_send+0xd3>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    d260:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    d265:	e9 29 ff ff ff       	jmpq   d193 <mcast_send+0xd3>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    d26a:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    d26f:	e9 1f ff ff ff       	jmpq   d193 <mcast_send+0xd3>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    d274:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    d279:	e9 15 ff ff ff       	jmpq   d193 <mcast_send+0xd3>
    d27e:	66 90                	xchg   %ax,%ax

static int mcast_send (PAL_HANDLE handle, int offset, int size,
                       const void * buf)
{
    if (handle->mcast.srv == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    d280:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
        handle->__in.flags |= WRITEABLE(1);
    else
        handle->__in.flags &= ~WRITEABLE(1);

    return bytes;
}
    d285:	c3                   	retq   
    d286:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    d28d:	00 00 00 

000000000000d290 <tcp_accept>:
    return ret;
}

/* accept a tcp connection */
static int tcp_accept (PAL_HANDLE handle, PAL_HANDLE * client)
{
    d290:	83 3f 09             	cmpl   $0x9,(%rdi)
    if (!IS_HANDLE_TYPE(handle, tcpsrv) ||
        !handle->sock.bind || handle->sock.conn)
        return -PAL_ERROR_NOTSERVER;
    d293:	b8 eb ff ff ff       	mov    $0xffffffeb,%eax
}

/* accept a tcp connection */
static int tcp_accept (PAL_HANDLE handle, PAL_HANDLE * client)
{
    if (!IS_HANDLE_TYPE(handle, tcpsrv) ||
    d298:	0f 85 fb 01 00 00    	jne    d499 <tcp_accept+0x209>
    return ret;
}

/* accept a tcp connection */
static int tcp_accept (PAL_HANDLE handle, PAL_HANDLE * client)
{
    d29e:	55                   	push   %rbp
    d29f:	48 89 e5             	mov    %rsp,%rbp
    d2a2:	41 57                	push   %r15
    d2a4:	41 56                	push   %r14
    d2a6:	41 55                	push   %r13
    d2a8:	41 54                	push   %r12
    d2aa:	53                   	push   %rbx
    d2ab:	48 83 ec 38          	sub    $0x38,%rsp
    if (!IS_HANDLE_TYPE(handle, tcpsrv) ||
        !handle->sock.bind || handle->sock.conn)
    d2af:	4c 8b 7f 10          	mov    0x10(%rdi),%r15
}

/* accept a tcp connection */
static int tcp_accept (PAL_HANDLE handle, PAL_HANDLE * client)
{
    if (!IS_HANDLE_TYPE(handle, tcpsrv) ||
    d2b3:	4d 85 ff             	test   %r15,%r15
    d2b6:	0f 84 cf 01 00 00    	je     d48b <tcp_accept+0x1fb>
        !handle->sock.bind || handle->sock.conn)
    d2bc:	48 83 7f 18 00       	cmpq   $0x0,0x18(%rdi)
    d2c1:	0f 85 c4 01 00 00    	jne    d48b <tcp_accept+0x1fb>
        return -PAL_ERROR_NOTSERVER;

    if (handle->sock.fd == PAL_IDX_POISON)
    d2c7:	8b 7f 0c             	mov    0xc(%rdi),%edi
    d2ca:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    d2cd:	0f 84 1f 02 00 00    	je     d4f2 <tcp_accept+0x262>
typedef uint16_t /*__attribute__((bitwise))*/ __be16;
#define SOL_TCP			6
#define TCP_CORK	TCP_NOPUSH //Apparently similar
static inline int addr_size (struct sockaddr * addr)
{
    switch (addr->sa_family) {
    d2d3:	41 0f b6 47 01       	movzbl 0x1(%r15),%eax
    d2d8:	49 89 f5             	mov    %rsi,%r13
        case AF_INET:
            return sizeof(struct sockaddr_in);
    d2db:	41 be 10 00 00 00    	mov    $0x10,%r14d
typedef uint16_t /*__attribute__((bitwise))*/ __be16;
#define SOL_TCP			6
#define TCP_CORK	TCP_NOPUSH //Apparently similar
static inline int addr_size (struct sockaddr * addr)
{
    switch (addr->sa_family) {
    d2e1:	3c 02                	cmp    $0x2,%al
    d2e3:	74 0e                	je     d2f3 <tcp_accept+0x63>
        case AF_INET:
            return sizeof(struct sockaddr_in);
        case AF_INET6:
            return sizeof(struct sockaddr_in6);
        default:
            return 0;
    d2e5:	3c 1c                	cmp    $0x1c,%al
    d2e7:	41 b6 1c             	mov    $0x1c,%r14b
    d2ea:	b8 00 00 00 00       	mov    $0x0,%eax
    d2ef:	44 0f 45 f0          	cmovne %eax,%r14d
    int bind_addrlen = addr_size(bind_addr);
    struct sockaddr buffer;
    socklen_t addrlen = sizeof(struct sockaddr);
    int ret = 0;

    int newfd = INLINE_SYSCALL(accept4, 4, handle->sock.fd, &buffer,
    d2f3:	bb 1d 02 00 00       	mov    $0x21d,%ebx
        return -PAL_ERROR_BADHANDLE;

    struct sockaddr * bind_addr = (struct sockaddr *) handle->sock.bind;
    int bind_addrlen = addr_size(bind_addr);
    struct sockaddr buffer;
    socklen_t addrlen = sizeof(struct sockaddr);
    d2f8:	c7 45 b4 10 00 00 00 	movl   $0x10,-0x4c(%rbp)
    int ret = 0;

    int newfd = INLINE_SYSCALL(accept4, 4, handle->sock.fd, &buffer,
    d2ff:	b9 00 00 00 10       	mov    $0x10000000,%ecx
    d304:	48 8d 55 b4          	lea    -0x4c(%rbp),%rdx
    d308:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    d30c:	89 d8                	mov    %ebx,%eax
    d30e:	cd 80                	int    $0x80
    d310:	48 89 c2             	mov    %rax,%rdx
    d313:	bb 00 00 00 00       	mov    $0x0,%ebx
    d318:	83 d3 00             	adc    $0x0,%ebx
    d31b:	31 c9                	xor    %ecx,%ecx
    d31d:	85 db                	test   %ebx,%ebx
    d31f:	0f 95 c1             	setne  %cl
    d322:	48 89 c8             	mov    %rcx,%rax
    d325:	48 f7 d8             	neg    %rax
    d328:	48 31 d0             	xor    %rdx,%rax
    d32b:	48 8d 1c 08          	lea    (%rax,%rcx,1),%rbx
                               &addrlen, SOCK_CLOEXEC);

    if (IS_ERR(newfd))
    d32f:	85 db                	test   %ebx,%ebx
    d331:	0f 88 69 01 00 00    	js     d4a0 <tcp_accept+0x210>
            default:
                return unix_to_pal_error(ERRNO(newfd));
        }

    struct sockaddr * dest_addr = &buffer;
    int dest_addrlen = addrlen;
    d337:	8b 45 b4             	mov    -0x4c(%rbp),%eax
    d33a:	4c 89 6d a8          	mov    %r13,-0x58(%rbp)
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    d33e:	41 8d 7c 06 58       	lea    0x58(%r14,%rax,1),%edi
            default:
                return unix_to_pal_error(ERRNO(newfd));
        }

    struct sockaddr * dest_addr = &buffer;
    int dest_addrlen = addrlen;
    d343:	89 45 a4             	mov    %eax,-0x5c(%rbp)
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    d346:	e8 b5 b6 ff ff       	callq  8a00 <malloc>
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    d34b:	48 85 c0             	test   %rax,%rax
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    d34e:	49 89 c4             	mov    %rax,%r12
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    d351:	0f 84 77 01 00 00    	je     d4ce <tcp_accept+0x23e>
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    d357:	31 f6                	xor    %esi,%esi
    d359:	4c 89 e7             	mov    %r12,%rdi
    d35c:	ba 58 00 00 00       	mov    $0x58,%edx
    d361:	e8 3a 8e 00 00       	callq  161a0 <memset>
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    d366:	41 83 4c 24 08 09    	orl    $0x9,0x8(%r12)
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    d36c:	4d 8d 6c 24 58       	lea    0x58(%r12),%r13
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
    d371:	4d 63 f6             	movslq %r14d,%r14
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    d374:	41 89 5c 24 0c       	mov    %ebx,0xc(%r12)
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
    d379:	4c 89 f2             	mov    %r14,%rdx
    d37c:	4c 89 fe             	mov    %r15,%rsi
    d37f:	4c 89 ef             	mov    %r13,%rdi

    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    d382:	41 c7 04 24 08 00 00 	movl   $0x8,(%r12)
    d389:	00 
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
    d38a:	4d 89 6c 24 10       	mov    %r13,0x10(%r12)
        memcpy(addr, bind_addr, bind_addrlen);
    d38f:	e8 ec 8e 00 00       	callq  16280 <memcpy>
    } else {
        hdl->sock.bind = NULL;
    }
    if (dest_addr) {
        hdl->sock.conn = addr;
        memcpy(addr, dest_addr, dest_addrlen);
    d394:	48 63 55 a4          	movslq -0x5c(%rbp),%rdx
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
        addr += bind_addrlen;
    d398:	4b 8d 7c 35 00       	lea    0x0(%r13,%r14,1),%rdi
    } else {
        hdl->sock.bind = NULL;
    }
    if (dest_addr) {
        hdl->sock.conn = addr;
        memcpy(addr, dest_addr, dest_addrlen);
    d39d:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    d3a1:	4c 8d 75 bc          	lea    -0x44(%rbp),%r14
        addr += bind_addrlen;
    } else {
        hdl->sock.bind = NULL;
    }
    if (dest_addr) {
        hdl->sock.conn = addr;
    d3a5:	49 89 7c 24 18       	mov    %rdi,0x18(%r12)
        memcpy(addr, dest_addr, dest_addrlen);
    d3aa:	e8 d1 8e 00 00       	callq  16280 <memcpy>
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    d3af:	4c 8d 55 b8          	lea    -0x48(%rbp),%r10
    d3b3:	4c 63 cb             	movslq %ebx,%r9
    d3b6:	bb 76 00 00 00       	mov    $0x76,%ebx
        addr += dest_addrlen;
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
    d3bb:	41 c6 44 24 20 00    	movb   $0x0,0x20(%r12)
                              PAL_TRUE : PAL_FALSE;
    hdl->sock.reuseaddr     = PAL_FALSE;
    d3c1:	41 c6 44 24 21 00    	movb   $0x0,0x21(%r12)
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    d3c7:	4d 89 f0             	mov    %r14,%r8
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    hdl->sock.reuseaddr     = PAL_FALSE;
    hdl->sock.linger        = 0;
    d3ca:	49 c7 44 24 28 00 00 	movq   $0x0,0x28(%r12)
    d3d1:	00 00 

    if (type == pal_type_tcpsrv) {
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);
    d3d3:	c7 45 bc 04 00 00 00 	movl   $0x4,-0x44(%rbp)

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    d3da:	4c 89 d1             	mov    %r10,%rcx
    d3dd:	ba 02 10 00 00       	mov    $0x1002,%edx
    d3e2:	be ff ff 00 00       	mov    $0xffff,%esi
    d3e7:	4c 89 cf             	mov    %r9,%rdi
    d3ea:	89 d8                	mov    %ebx,%eax
    d3ec:	cd 80                	int    $0x80
    d3ee:	48 89 c2             	mov    %rax,%rdx
    d3f1:	bb 00 00 00 00       	mov    $0x0,%ebx
    d3f6:	83 d3 00             	adc    $0x0,%ebx
    d3f9:	31 c9                	xor    %ecx,%ecx
    d3fb:	85 db                	test   %ebx,%ebx
    d3fd:	0f 95 c1             	setne  %cl
    d400:	48 89 c8             	mov    %rcx,%rax
    d403:	48 f7 d8             	neg    %rax
    d406:	48 31 d0             	xor    %rdx,%rax
                             &val, &len);
        hdl->sock.receivebuf = IS_ERR(ret) ? 0 : val;
    d409:	31 d2                	xor    %edx,%edx
    d40b:	01 c8                	add    %ecx,%eax
    d40d:	78 04                	js     d413 <tcp_accept+0x183>
    d40f:	48 63 55 b8          	movslq -0x48(%rbp),%rdx

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    d413:	bb 76 00 00 00       	mov    $0x76,%ebx
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
                             &val, &len);
        hdl->sock.receivebuf = IS_ERR(ret) ? 0 : val;
    d418:	49 89 54 24 30       	mov    %rdx,0x30(%r12)

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    d41d:	4d 89 f0             	mov    %r14,%r8
    d420:	4c 89 d1             	mov    %r10,%rcx
    d423:	ba 01 10 00 00       	mov    $0x1001,%edx
    d428:	be ff ff 00 00       	mov    $0xffff,%esi
    d42d:	4c 89 cf             	mov    %r9,%rdi
    d430:	89 d8                	mov    %ebx,%eax
    d432:	cd 80                	int    $0x80
    d434:	48 89 c2             	mov    %rax,%rdx
    d437:	bb 00 00 00 00       	mov    $0x0,%ebx
    d43c:	83 d3 00             	adc    $0x0,%ebx
    d43f:	31 c9                	xor    %ecx,%ecx
    d441:	85 db                	test   %ebx,%ebx
    d443:	0f 95 c1             	setne  %cl
    d446:	48 89 c8             	mov    %rcx,%rax
    d449:	48 f7 d8             	neg    %rax
    d44c:	48 31 d0             	xor    %rdx,%rax
                             &val, &len);
        hdl->sock.sendbuf = IS_ERR(ret) ? 0 : val;
    d44f:	31 d2                	xor    %edx,%edx
    d451:	01 c8                	add    %ecx,%eax
    d453:	78 04                	js     d459 <tcp_accept+0x1c9>
    d455:	48 63 55 b8          	movslq -0x48(%rbp),%rdx
        }

    struct sockaddr * dest_addr = &buffer;
    int dest_addrlen = addrlen;

    *client = socket_create_handle(pal_type_tcp, newfd, 0,
    d459:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
                             &val, &len);
        hdl->sock.receivebuf = IS_ERR(ret) ? 0 : val;

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
                             &val, &len);
        hdl->sock.sendbuf = IS_ERR(ret) ? 0 : val;
    d45d:	49 89 54 24 38       	mov    %rdx,0x38(%r12)
    }

    hdl->sock.receivetimeout = 0;
    d462:	49 c7 44 24 40 00 00 	movq   $0x0,0x40(%r12)
    d469:	00 00 
    hdl->sock.sendtimeout    = 0;
    d46b:	49 c7 44 24 48 00 00 	movq   $0x0,0x48(%r12)
    d472:	00 00 
    hdl->sock.tcp_cork       = PAL_FALSE;
    d474:	41 c6 44 24 50 00    	movb   $0x0,0x50(%r12)
    hdl->sock.tcp_keepalive  = PAL_FALSE;
    d47a:	41 c6 44 24 51 00    	movb   $0x0,0x51(%r12)
    hdl->sock.tcp_nodelay    = PAL_FALSE;
    d480:	41 c6 44 24 52 00    	movb   $0x0,0x52(%r12)
        }

    struct sockaddr * dest_addr = &buffer;
    int dest_addrlen = addrlen;

    *client = socket_create_handle(pal_type_tcp, newfd, 0,
    d486:	4c 89 20             	mov    %r12,(%rax)
    if (!(*client)) {
        ret = -PAL_ERROR_NOMEM;
        goto failed;
    }

    return 0;
    d489:	31 c0                	xor    %eax,%eax

failed:
    INLINE_SYSCALL(close, 1, newfd);
    return ret;
}
    d48b:	48 83 c4 38          	add    $0x38,%rsp
    d48f:	5b                   	pop    %rbx
    d490:	41 5c                	pop    %r12
    d492:	41 5d                	pop    %r13
    d494:	41 5e                	pop    %r14
    d496:	41 5f                	pop    %r15
    d498:	5d                   	pop    %rbp
    d499:	f3 c3                	repz retq 
    d49b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

    int newfd = INLINE_SYSCALL(accept4, 4, handle->sock.fd, &buffer,
                               &addrlen, SOCK_CLOEXEC);

    if (IS_ERR(newfd))
        switch(ERRNO(newfd)) {
    d4a0:	f7 db                	neg    %ebx
            case EWOULDBLOCK:
                return -PAL_ERROR_TRYAGAIN;
    d4a2:	b8 ed ff ff ff       	mov    $0xffffffed,%eax

    int newfd = INLINE_SYSCALL(accept4, 4, handle->sock.fd, &buffer,
                               &addrlen, SOCK_CLOEXEC);

    if (IS_ERR(newfd))
        switch(ERRNO(newfd)) {
    d4a7:	83 fb 0b             	cmp    $0xb,%ebx
    d4aa:	74 df                	je     d48b <tcp_accept+0x1fb>
    d4ac:	83 fb 67             	cmp    $0x67,%ebx
            case EWOULDBLOCK:
                return -PAL_ERROR_TRYAGAIN;
            case ECONNABORTED:
                return -PAL_ERROR_STREAMNOTEXIST;
    d4af:	b0 f7                	mov    $0xf7,%al

    int newfd = INLINE_SYSCALL(accept4, 4, handle->sock.fd, &buffer,
                               &addrlen, SOCK_CLOEXEC);

    if (IS_ERR(newfd))
        switch(ERRNO(newfd)) {
    d4b1:	74 d8                	je     d48b <tcp_accept+0x1fb>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    d4b3:	83 fb 6e             	cmp    $0x6e,%ebx
    d4b6:	0f 87 91 00 00 00    	ja     d54d <tcp_accept+0x2bd>
    d4bc:	48 8d 05 a9 e6 00 00 	lea    0xe6a9(%rip),%rax        # 1bb6c <slab_levels+0x28cc>
    d4c3:	89 db                	mov    %ebx,%ebx
    d4c5:	48 63 14 98          	movslq (%rax,%rbx,4),%rdx
    d4c9:	48 01 d0             	add    %rdx,%rax
    d4cc:	ff e0                	jmpq   *%rax
        }

    struct sockaddr * dest_addr = &buffer;
    int dest_addrlen = addrlen;

    *client = socket_create_handle(pal_type_tcp, newfd, 0,
    d4ce:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
    }

    return 0;

failed:
    INLINE_SYSCALL(close, 1, newfd);
    d4d2:	48 63 fb             	movslq %ebx,%rdi
        }

    struct sockaddr * dest_addr = &buffer;
    int dest_addrlen = addrlen;

    *client = socket_create_handle(pal_type_tcp, newfd, 0,
    d4d5:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
    }

    return 0;

failed:
    INLINE_SYSCALL(close, 1, newfd);
    d4dc:	b8 06 00 00 00       	mov    $0x6,%eax
    d4e1:	cd 80                	int    $0x80
    d4e3:	bb 00 00 00 00       	mov    $0x0,%ebx
    d4e8:	83 d3 00             	adc    $0x0,%ebx
    return ret;
    d4eb:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    d4f0:	eb 99                	jmp    d48b <tcp_accept+0x1fb>
    if (!IS_HANDLE_TYPE(handle, tcpsrv) ||
        !handle->sock.bind || handle->sock.conn)
        return -PAL_ERROR_NOTSERVER;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    d4f2:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    d4f7:	eb 92                	jmp    d48b <tcp_accept+0x1fb>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    d4f9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    d4fe:	eb 8b                	jmp    d48b <tcp_accept+0x1fb>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    d500:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    d505:	eb 84                	jmp    d48b <tcp_accept+0x1fb>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    d507:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    d50c:	e9 7a ff ff ff       	jmpq   d48b <tcp_accept+0x1fb>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    d511:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    d516:	e9 70 ff ff ff       	jmpq   d48b <tcp_accept+0x1fb>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    d51b:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    d520:	e9 66 ff ff ff       	jmpq   d48b <tcp_accept+0x1fb>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    d525:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    d52a:	e9 5c ff ff ff       	jmpq   d48b <tcp_accept+0x1fb>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    d52f:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    d534:	e9 52 ff ff ff       	jmpq   d48b <tcp_accept+0x1fb>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    d539:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    d53e:	e9 48 ff ff ff       	jmpq   d48b <tcp_accept+0x1fb>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    d543:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    d548:	e9 3e ff ff ff       	jmpq   d48b <tcp_accept+0x1fb>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    d54d:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    d552:	e9 34 ff ff ff       	jmpq   d48b <tcp_accept+0x1fb>
    d557:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    d55e:	00 00 

000000000000d560 <udp_sendbyaddr>:
    return bytes;
}

static int udp_sendbyaddr (PAL_HANDLE handle, int offset, int len,
                           const void * buf, const char * addr, int addrlen)
{
    d560:	83 3f 0b             	cmpl   $0xb,(%rdi)
    if (!IS_HANDLE_TYPE(handle, udpsrv))
        return -PAL_ERROR_NOTCONNECTION;
    d563:	41 ba ea ff ff ff    	mov    $0xffffffea,%r10d
}

static int udp_sendbyaddr (PAL_HANDLE handle, int offset, int len,
                           const void * buf, const char * addr, int addrlen)
{
    if (!IS_HANDLE_TYPE(handle, udpsrv))
    d569:	0f 85 77 01 00 00    	jne    d6e6 <udp_sendbyaddr+0x186>
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
    d56f:	83 7f 0c ff          	cmpl   $0xffffffffffffffff,0xc(%rdi)
    d573:	0f 84 67 01 00 00    	je     d6e0 <udp_sendbyaddr+0x180>
    return bytes;
}

static int udp_sendbyaddr (PAL_HANDLE handle, int offset, int len,
                           const void * buf, const char * addr, int addrlen)
{
    d579:	55                   	push   %rbp
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    if (memcmp(addr, "udp:", 4))
    d57a:	48 8d 35 4d db 00 00 	lea    0xdb4d(%rip),%rsi        # 1b0ce <slab_levels+0x1e2e>
    return bytes;
}

static int udp_sendbyaddr (PAL_HANDLE handle, int offset, int len,
                           const void * buf, const char * addr, int addrlen)
{
    d581:	48 89 e5             	mov    %rsp,%rbp
    d584:	41 57                	push   %r15
    d586:	41 56                	push   %r14
    d588:	41 55                	push   %r13
    d58a:	41 54                	push   %r12
    d58c:	41 89 d5             	mov    %edx,%r13d
    d58f:	53                   	push   %rbx
    d590:	49 89 fc             	mov    %rdi,%r12
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    if (memcmp(addr, "udp:", 4))
    d593:	ba 04 00 00 00       	mov    $0x4,%edx
    d598:	4c 89 c7             	mov    %r8,%rdi
    d59b:	45 89 ce             	mov    %r9d,%r14d
    d59e:	4d 89 c7             	mov    %r8,%r15
    return bytes;
}

static int udp_sendbyaddr (PAL_HANDLE handle, int offset, int len,
                           const void * buf, const char * addr, int addrlen)
{
    d5a1:	48 83 ec 68          	sub    $0x68,%rsp
    d5a5:	48 89 cb             	mov    %rcx,%rbx
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    if (memcmp(addr, "udp:", 4))
    d5a8:	e8 63 8d 00 00       	callq  16310 <memcmp>
    d5ad:	85 c0                	test   %eax,%eax
        return -PAL_ERROR_INVAL;
    d5af:	41 ba fc ff ff ff    	mov    $0xfffffffc,%r10d
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    if (memcmp(addr, "udp:", 4))
    d5b5:	0f 85 cf 00 00 00    	jne    d68a <udp_sendbyaddr+0x12a>
        return -PAL_ERROR_INVAL;

    char * addrbuf = __alloca(addrlen - 3);
    d5bb:	41 8d 56 fd          	lea    -0x3(%r14),%edx
    memcpy(addrbuf, addr + 4, addrlen - 3);
    d5bf:	49 8d 77 04          	lea    0x4(%r15),%rsi

    struct sockaddr conn_addr;
    int conn_addrlen;

    int ret = inet_parse_uri(&addrbuf, &conn_addr, &conn_addrlen);
    d5c3:	4c 8d 75 80          	lea    -0x80(%rbp),%r14
        return -PAL_ERROR_BADHANDLE;

    if (memcmp(addr, "udp:", 4))
        return -PAL_ERROR_INVAL;

    char * addrbuf = __alloca(addrlen - 3);
    d5c7:	48 63 d2             	movslq %edx,%rdx
    d5ca:	48 8d 42 1e          	lea    0x1e(%rdx),%rax
    d5ce:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    d5d2:	48 29 c4             	sub    %rax,%rsp
    d5d5:	48 8d 7c 24 0f       	lea    0xf(%rsp),%rdi
    d5da:	48 83 e7 f0          	and    $0xfffffffffffffff0,%rdi
    d5de:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
    memcpy(addrbuf, addr + 4, addrlen - 3);
    d5e5:	e8 96 8c 00 00       	callq  16280 <memcpy>

    struct sockaddr conn_addr;
    int conn_addrlen;

    int ret = inet_parse_uri(&addrbuf, &conn_addr, &conn_addrlen);
    d5ea:	48 8d 95 74 ff ff ff 	lea    -0x8c(%rbp),%rdx
    d5f1:	48 8d bd 78 ff ff ff 	lea    -0x88(%rbp),%rdi
    d5f8:	4c 89 f6             	mov    %r14,%rsi
    d5fb:	e8 70 ee ff ff       	callq  c470 <inet_parse_uri>
    if (ret < 0)
    d600:	85 c0                	test   %eax,%eax
    d602:	0f 88 ca 00 00 00    	js     d6d2 <udp_sendbyaddr+0x172>
        return ret;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    d608:	49 63 c5             	movslq %r13d,%rax
    if (ret < 0)
        return ret;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    d60b:	48 89 5d 90          	mov    %rbx,-0x70(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    d60f:	bb 1c 00 00 00       	mov    $0x1c,%ebx
        return ret;

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    d614:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    hdr.msg_name = &conn_addr;
    hdr.msg_namelen = conn_addrlen;
    d618:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    d61e:	ba 00 00 02 00       	mov    $0x20000,%edx

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    hdr.msg_name = &conn_addr;
    d623:	4c 89 75 a0          	mov    %r14,-0x60(%rbp)
    hdr.msg_namelen = conn_addrlen;
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    d627:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    d62e:	48 8d 75 a0          	lea    -0x60(%rbp),%rsi
    iov.iov_len = len;
    hdr.msg_name = &conn_addr;
    hdr.msg_namelen = conn_addrlen;
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    d632:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    d639:	00 
    hdr.msg_controllen = 0;
    d63a:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    hdr.msg_name = &conn_addr;
    hdr.msg_namelen = conn_addrlen;
    d641:	89 45 a8             	mov    %eax,-0x58(%rbp)
    hdr.msg_iov = &iov;
    d644:	48 8d 45 90          	lea    -0x70(%rbp),%rax
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;
    d648:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    d64f:	41 8b 7c 24 0c       	mov    0xc(%r12),%edi
    struct iovec iov;
    iov.iov_base = (void *) buf;
    iov.iov_len = len;
    hdr.msg_name = &conn_addr;
    hdr.msg_namelen = conn_addrlen;
    hdr.msg_iov = &iov;
    d654:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);
    d658:	89 d8                	mov    %ebx,%eax
    d65a:	cd 80                	int    $0x80
    d65c:	49 89 c2             	mov    %rax,%r10
    d65f:	bb 00 00 00 00       	mov    $0x0,%ebx
    d664:	83 d3 00             	adc    $0x0,%ebx
    d667:	31 d2                	xor    %edx,%edx
    d669:	85 db                	test   %ebx,%ebx
    d66b:	0f 95 c2             	setne  %dl
    d66e:	48 89 d0             	mov    %rdx,%rax
    d671:	48 f7 d8             	neg    %rax
    d674:	49 31 c2             	xor    %rax,%r10
    d677:	49 01 d2             	add    %rdx,%r10

    if (IS_ERR(bytes))
    d67a:	45 85 d2             	test   %r10d,%r10d
    d67d:	78 21                	js     d6a0 <udp_sendbyaddr+0x140>
                handle->__in.flags &= ~WRITEABLE(0);
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (bytes == len)
    d67f:	45 39 ea             	cmp    %r13d,%r10d
    d682:	74 6c                	je     d6f0 <udp_sendbyaddr+0x190>
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);
    d684:	41 83 64 24 08 bf    	andl   $0xffffffffffffffbf,0x8(%r12)

    return bytes;
}
    d68a:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    d68e:	44 89 d0             	mov    %r10d,%eax
    d691:	5b                   	pop    %rbx
    d692:	41 5c                	pop    %r12
    d694:	41 5d                	pop    %r13
    d696:	41 5e                	pop    %r14
    d698:	41 5f                	pop    %r15
    d69a:	5d                   	pop    %rbp
    d69b:	c3                   	retq   
    d69c:	0f 1f 40 00          	nopl   0x0(%rax)
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(sendmsg, 3, handle->sock.fd, &hdr, MSG_NOSIGNAL);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    d6a0:	41 f7 da             	neg    %r10d
    d6a3:	41 83 fa 20          	cmp    $0x20,%r10d
    d6a7:	74 68                	je     d711 <udp_sendbyaddr+0x1b1>
    d6a9:	41 83 fa 68          	cmp    $0x68,%r10d
    d6ad:	74 62                	je     d711 <udp_sendbyaddr+0x1b1>
    d6af:	41 83 fa 0b          	cmp    $0xb,%r10d
    d6b3:	74 4b                	je     d700 <udp_sendbyaddr+0x1a0>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    d6b5:	41 83 fa 6e          	cmp    $0x6e,%r10d
    d6b9:	0f 87 cb 00 00 00    	ja     d78a <udp_sendbyaddr+0x22a>
    d6bf:	48 8d 05 62 e6 00 00 	lea    0xe662(%rip),%rax        # 1bd28 <slab_levels+0x2a88>
    d6c6:	45 89 d2             	mov    %r10d,%r10d
    d6c9:	4a 63 14 90          	movslq (%rax,%r10,4),%rdx
    d6cd:	48 01 d0             	add    %rdx,%rax
    d6d0:	ff e0                	jmpq   *%rax
    d6d2:	41 89 c2             	mov    %eax,%r10d
    d6d5:	eb b3                	jmp    d68a <udp_sendbyaddr+0x12a>
    d6d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    d6de:	00 00 
{
    if (!IS_HANDLE_TYPE(handle, udpsrv))
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    d6e0:	41 ba f9 ff ff ff    	mov    $0xfffffff9,%r10d
        handle->__in.flags |= WRITEABLE(0);
    else
        handle->__in.flags &= ~WRITEABLE(0);

    return bytes;
}
    d6e6:	44 89 d0             	mov    %r10d,%eax
    d6e9:	c3                   	retq   
    d6ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (bytes == len)
        handle->__in.flags |= WRITEABLE(0);
    d6f0:	41 83 4c 24 08 40    	orl    $0x40,0x8(%r12)
    d6f6:	eb 92                	jmp    d68a <udp_sendbyaddr+0x12a>
    d6f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    d6ff:	00 
        switch(ERRNO(bytes)) {
            case ECONNRESET:
            case EPIPE:
                return -PAL_ERROR_CONNFAILED;
            case EAGAIN:
                handle->__in.flags &= ~WRITEABLE(0);
    d700:	41 83 64 24 08 bf    	andl   $0xffffffffffffffbf,0x8(%r12)
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    d706:	41 ba ed ff ff ff    	mov    $0xffffffed,%r10d
    d70c:	e9 79 ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
            case ECONNRESET:
            case EPIPE:
                return -PAL_ERROR_CONNFAILED;
    d711:	41 ba e8 ff ff ff    	mov    $0xffffffe8,%r10d
    d717:	e9 6e ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    d71c:	41 ba f9 ff ff ff    	mov    $0xfffffff9,%r10d
    d722:	e9 63 ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    d727:	41 ba fb ff ff ff    	mov    $0xfffffffb,%r10d
    d72d:	e9 58 ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    d732:	41 ba fc ff ff ff    	mov    $0xfffffffc,%r10d
    d738:	e9 4d ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    d73d:	41 ba f5 ff ff ff    	mov    $0xfffffff5,%r10d
    d743:	e9 42 ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    d748:	41 ba f6 ff ff ff    	mov    $0xfffffff6,%r10d
    d74e:	e9 37 ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    d753:	41 ba f8 ff ff ff    	mov    $0xfffffff8,%r10d
    d759:	e9 2c ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    d75e:	41 ba f1 ff ff ff    	mov    $0xfffffff1,%r10d
    d764:	e9 21 ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    d769:	41 ba f0 ff ff ff    	mov    $0xfffffff0,%r10d
    d76f:	e9 16 ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    d774:	41 ba f7 ff ff ff    	mov    $0xfffffff7,%r10d
    d77a:	e9 0b ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    d77f:	41 ba f3 ff ff ff    	mov    $0xfffffff3,%r10d
    d785:	e9 00 ff ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    d78a:	41 ba fa ff ff ff    	mov    $0xfffffffa,%r10d
    d790:	e9 f5 fe ff ff       	jmpq   d68a <udp_sendbyaddr+0x12a>
    d795:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
    d79c:	00 00 00 00 

000000000000d7a0 <udp_receivebyaddr>:
    return bytes;
}

static int udp_receivebyaddr (PAL_HANDLE handle, int offset, int len,
                              void * buf, char * addr, int addrlen)
{
    d7a0:	83 3f 0b             	cmpl   $0xb,(%rdi)
    if (!IS_HANDLE_TYPE(handle, udpsrv))
        return -PAL_ERROR_NOTCONNECTION;
    d7a3:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
}

static int udp_receivebyaddr (PAL_HANDLE handle, int offset, int len,
                              void * buf, char * addr, int addrlen)
{
    if (!IS_HANDLE_TYPE(handle, udpsrv))
    d7a8:	0f 85 d2 00 00 00    	jne    d880 <udp_receivebyaddr+0xe0>
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
    d7ae:	8b 7f 0c             	mov    0xc(%rdi),%edi
    d7b1:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
    d7b4:	0f 84 5b 01 00 00    	je     d915 <udp_receivebyaddr+0x175>
    return bytes;
}

static int udp_receivebyaddr (PAL_HANDLE handle, int offset, int len,
                              void * buf, char * addr, int addrlen)
{
    d7ba:	55                   	push   %rbp
    socklen_t conn_addrlen = sizeof(struct sockaddr);

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    d7bb:	48 63 d2             	movslq %edx,%rdx
    return bytes;
}

static int udp_receivebyaddr (PAL_HANDLE handle, int offset, int len,
                              void * buf, char * addr, int addrlen)
{
    d7be:	48 89 e5             	mov    %rsp,%rbp
    d7c1:	41 56                	push   %r14
    d7c3:	41 55                	push   %r13
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    hdr.msg_name = &conn_addr;
    hdr.msg_namelen = conn_addrlen;
    hdr.msg_iov = &iov;
    d7c5:	48 8d 45 a0          	lea    -0x60(%rbp),%rax
    return bytes;
}

static int udp_receivebyaddr (PAL_HANDLE handle, int offset, int len,
                              void * buf, char * addr, int addrlen)
{
    d7c9:	41 54                	push   %r12

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    hdr.msg_name = &conn_addr;
    d7cb:	4c 8d 65 90          	lea    -0x70(%rbp),%r12
    return bytes;
}

static int udp_receivebyaddr (PAL_HANDLE handle, int offset, int len,
                              void * buf, char * addr, int addrlen)
{
    d7cf:	53                   	push   %rbx
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    d7d0:	bb 1b 00 00 00       	mov    $0x1b,%ebx
    d7d5:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
    return bytes;
}

static int udp_receivebyaddr (PAL_HANDLE handle, int offset, int len,
                              void * buf, char * addr, int addrlen)
{
    d7d9:	48 83 ec 50          	sub    $0x50,%rsp
    socklen_t conn_addrlen = sizeof(struct sockaddr);

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    d7dd:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
    hdr.msg_name = &conn_addr;
    hdr.msg_namelen = conn_addrlen;
    hdr.msg_iov = &iov;
    d7e1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    struct sockaddr conn_addr;
    socklen_t conn_addrlen = sizeof(struct sockaddr);

    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    d7e5:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    iov.iov_len = len;
    hdr.msg_name = &conn_addr;
    d7e9:	4c 89 65 b0          	mov    %r12,-0x50(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    d7ed:	31 d2                	xor    %edx,%edx
    struct msghdr hdr;
    struct iovec iov;
    iov.iov_base = buf;
    iov.iov_len = len;
    hdr.msg_name = &conn_addr;
    hdr.msg_namelen = conn_addrlen;
    d7ef:	c7 45 b8 10 00 00 00 	movl   $0x10,-0x48(%rbp)
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    d7f6:	c7 45 c8 01 00 00 00 	movl   $0x1,-0x38(%rbp)
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    d7fd:	89 d8                	mov    %ebx,%eax
    iov.iov_len = len;
    hdr.msg_name = &conn_addr;
    hdr.msg_namelen = conn_addrlen;
    hdr.msg_iov = &iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    d7ff:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
    d806:	00 
    hdr.msg_controllen = 0;
    d807:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%rbp)
    hdr.msg_flags = 0;
    d80e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);
    d815:	cd 80                	int    $0x80
    d817:	49 89 c2             	mov    %rax,%r10
    d81a:	bb 00 00 00 00       	mov    $0x0,%ebx
    d81f:	83 d3 00             	adc    $0x0,%ebx
    d822:	31 c9                	xor    %ecx,%ecx
    d824:	85 db                	test   %ebx,%ebx
    d826:	0f 95 c1             	setne  %cl
    d829:	48 89 c8             	mov    %rcx,%rax
    d82c:	48 f7 d8             	neg    %rax
    d82f:	4c 31 d0             	xor    %r10,%rax
    d832:	48 8d 1c 08          	lea    (%rax,%rcx,1),%rbx

    if (IS_ERR(bytes))
    d836:	85 db                	test   %ebx,%ebx
    d838:	78 48                	js     d882 <udp_receivebyaddr+0xe2>
                return -PAL_ERROR_STREAMNOTEXIST;
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (addrlen < 5)
    d83a:	41 83 f9 04          	cmp    $0x4,%r9d
        return -PAL_ERROR_OVERFLOW;
    d83e:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
                return -PAL_ERROR_STREAMNOTEXIST;
            default:
                return unix_to_pal_error(ERRNO(bytes));
        }

    if (addrlen < 5)
    d843:	7e 2f                	jle    d874 <udp_receivebyaddr+0xd4>
        return -PAL_ERROR_OVERFLOW;

    memcpy(addr, "udp:", 5);
    d845:	48 8d 35 82 d8 00 00 	lea    0xd882(%rip),%rsi        # 1b0ce <slab_levels+0x1e2e>
    d84c:	4c 89 c7             	mov    %r8,%rdi
    d84f:	ba 05 00 00 00       	mov    $0x5,%edx
    d854:	45 89 cd             	mov    %r9d,%r13d
    d857:	4d 89 c6             	mov    %r8,%r14
    d85a:	e8 21 8a 00 00       	callq  16280 <memcpy>
    inet_create_uri(addr + 4, addrlen - 4, &conn_addr, hdr.msg_namelen);
    d85f:	8b 4d b8             	mov    -0x48(%rbp),%ecx
    d862:	41 8d 75 fc          	lea    -0x4(%r13),%esi
    d866:	49 8d 7e 04          	lea    0x4(%r14),%rdi
    d86a:	4c 89 e2             	mov    %r12,%rdx
    d86d:	e8 3e ee ff ff       	callq  c6b0 <inet_create_uri>

    return bytes;
    d872:	89 d8                	mov    %ebx,%eax
}
    d874:	48 83 c4 50          	add    $0x50,%rsp
    d878:	5b                   	pop    %rbx
    d879:	41 5c                	pop    %r12
    d87b:	41 5d                	pop    %r13
    d87d:	41 5e                	pop    %r14
    d87f:	5d                   	pop    %rbp
    d880:	f3 c3                	repz retq 
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    d882:	89 d9                	mov    %ebx,%ecx
            case EWOULDBLOCK:
                return -PAL_ERROR_TRYAGAIN;
    d884:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    d889:	f7 d9                	neg    %ecx
    d88b:	83 f9 0b             	cmp    $0xb,%ecx
    d88e:	74 e4                	je     d874 <udp_receivebyaddr+0xd4>
    d890:	83 f9 6f             	cmp    $0x6f,%ecx
            case EWOULDBLOCK:
                return -PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
            case ECONNREFUSED:
                return -PAL_ERROR_STREAMNOTEXIST;
    d893:	b0 f7                	mov    $0xf7,%al
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    d895:	74 dd                	je     d874 <udp_receivebyaddr+0xd4>
    d897:	83 f9 04             	cmp    $0x4,%ecx
            case EWOULDBLOCK:
                return -PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
    d89a:	b0 f3                	mov    $0xf3,%al
    hdr.msg_flags = 0;

    int bytes = INLINE_SYSCALL(recvmsg, 3, handle->sock.fd, &hdr, 0);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
    d89c:	74 d6                	je     d874 <udp_receivebyaddr+0xd4>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    d89e:	83 f9 6e             	cmp    $0x6e,%ecx
    d8a1:	77 68                	ja     d90b <udp_receivebyaddr+0x16b>
    d8a3:	48 8d 05 3a e6 00 00 	lea    0xe63a(%rip),%rax        # 1bee4 <slab_levels+0x2c44>
    d8aa:	89 c9                	mov    %ecx,%ecx
    d8ac:	48 63 14 88          	movslq (%rax,%rcx,4),%rdx
    d8b0:	48 01 d0             	add    %rdx,%rax
    d8b3:	ff e0                	jmpq   *%rax
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    d8b5:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    d8ba:	eb b8                	jmp    d874 <udp_receivebyaddr+0xd4>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    d8bc:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    d8c1:	eb b1                	jmp    d874 <udp_receivebyaddr+0xd4>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    d8c3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    d8c8:	eb aa                	jmp    d874 <udp_receivebyaddr+0xd4>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    d8ca:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    d8cf:	eb a3                	jmp    d874 <udp_receivebyaddr+0xd4>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    d8d1:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    d8d6:	eb 9c                	jmp    d874 <udp_receivebyaddr+0xd4>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    d8d8:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    d8dd:	eb 95                	jmp    d874 <udp_receivebyaddr+0xd4>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    d8df:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    d8e4:	eb 8e                	jmp    d874 <udp_receivebyaddr+0xd4>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    d8e6:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    d8eb:	eb 87                	jmp    d874 <udp_receivebyaddr+0xd4>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    d8ed:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    d8f2:	e9 7d ff ff ff       	jmpq   d874 <udp_receivebyaddr+0xd4>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    d8f7:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    d8fc:	e9 73 ff ff ff       	jmpq   d874 <udp_receivebyaddr+0xd4>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    d901:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    d906:	e9 69 ff ff ff       	jmpq   d874 <udp_receivebyaddr+0xd4>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    d90b:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    d910:	e9 5f ff ff ff       	jmpq   d874 <udp_receivebyaddr+0xd4>
{
    if (!IS_HANDLE_TYPE(handle, udpsrv))
        return -PAL_ERROR_NOTCONNECTION;

    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    d915:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

    memcpy(addr, "udp:", 5);
    inet_create_uri(addr + 4, addrlen - 4, &conn_addr, hdr.msg_namelen);

    return bytes;
}
    d91a:	c3                   	retq   
    d91b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

000000000000d920 <tcp_open>:
}

/* 'open' operation of tcp stream */
static int tcp_open (PAL_HANDLE *handle, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    d920:	55                   	push   %rbp
    d921:	48 89 e5             	mov    %rsp,%rbp
    d924:	41 57                	push   %r15
    d926:	41 56                	push   %r14
    d928:	41 55                	push   %r13
    d92a:	41 54                	push   %r12
    d92c:	49 89 fd             	mov    %rdi,%r13
    d92f:	53                   	push   %rbx
    int uri_len = strlen(uri) + 1;
    d930:	48 89 d7             	mov    %rdx,%rdi
}

/* 'open' operation of tcp stream */
static int tcp_open (PAL_HANDLE *handle, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    d933:	48 89 f3             	mov    %rsi,%rbx
    d936:	49 89 d7             	mov    %rdx,%r15
    int uri_len = strlen(uri) + 1;

    if (uri_len > PAL_SOCKADDR_SIZE)
        return -PAL_ERROR_TOOLONG;
    d939:	41 bc fb ff ff ff    	mov    $0xfffffffb,%r12d
}

/* 'open' operation of tcp stream */
static int tcp_open (PAL_HANDLE *handle, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    d93f:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    int uri_len = strlen(uri) + 1;
    d946:	e8 55 8e 00 00       	callq  167a0 <strlen>
    d94b:	83 c0 01             	add    $0x1,%eax

    if (uri_len > PAL_SOCKADDR_SIZE)
    d94e:	83 f8 60             	cmp    $0x60,%eax
    d951:	0f 8f 39 03 00 00    	jg     dc90 <tcp_open+0x370>
        return -PAL_ERROR_TOOLONG;

    char uri_buf[PAL_SOCKADDR_SIZE];
    memcpy(uri_buf, uri, uri_len);
    d957:	4c 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%r14
    d95e:	48 63 d0             	movslq %eax,%rdx
    d961:	4c 89 fe             	mov    %r15,%rsi
    d964:	4c 89 f7             	mov    %r14,%rdi
    d967:	e8 14 89 00 00       	callq  16280 <memcpy>

    if (!memcmp(type, "tcp.srv:", 8))
    d96c:	48 8d 35 60 d7 00 00 	lea    0xd760(%rip),%rsi        # 1b0d3 <slab_levels+0x1e33>
    d973:	ba 08 00 00 00       	mov    $0x8,%edx
    d978:	48 89 df             	mov    %rbx,%rdi
    d97b:	e8 90 89 00 00       	callq  16310 <memcmp>
    d980:	85 c0                	test   %eax,%eax
    d982:	41 89 c4             	mov    %eax,%r12d
    d985:	0f 84 1a 03 00 00    	je     dca5 <tcp_open+0x385>
        return tcp_listen(handle, uri_buf, options);

    if (!memcmp(type, "tcp:", 4))
    d98b:	48 8d 35 4a d7 00 00 	lea    0xd74a(%rip),%rsi        # 1b0dc <slab_levels+0x1e3c>
    d992:	ba 04 00 00 00       	mov    $0x4,%edx
    d997:	48 89 df             	mov    %rbx,%rdi
    d99a:	e8 71 89 00 00       	callq  16310 <memcmp>
    d99f:	85 c0                	test   %eax,%eax
    d9a1:	41 89 c4             	mov    %eax,%r12d
    d9a4:	0f 85 c6 05 00 00    	jne    df70 <tcp_open+0x650>

/* connect on a tcp socket */
static int tcp_connect (PAL_HANDLE * handle, char * uri, int options)
{
    struct sockaddr buffer[3];
    struct sockaddr * bind_addr = buffer, * dest_addr = buffer + 1;
    d9aa:	4c 8d 8d 40 ff ff ff 	lea    -0xc0(%rbp),%r9
    int bind_addrlen, dest_addrlen;
    int ret, fd = -1;

    /* accepting two kind of different uri:
       dest-ip:dest-port or bind-ip:bind-port:dest-ip:dest-port */
    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    d9b1:	48 8d 8d 38 ff ff ff 	lea    -0xc8(%rbp),%rcx
    d9b8:	48 8d 95 20 ff ff ff 	lea    -0xe0(%rbp),%rdx
    d9bf:	48 8d b5 30 ff ff ff 	lea    -0xd0(%rbp),%rsi
    d9c6:	4c 8d 85 24 ff ff ff 	lea    -0xdc(%rbp),%r8
    d9cd:	4c 89 f7             	mov    %r14,%rdi

/* connect on a tcp socket */
static int tcp_connect (PAL_HANDLE * handle, char * uri, int options)
{
    struct sockaddr buffer[3];
    struct sockaddr * bind_addr = buffer, * dest_addr = buffer + 1;
    d9d0:	49 8d 41 10          	lea    0x10(%r9),%rax
    d9d4:	4c 89 8d 30 ff ff ff 	mov    %r9,-0xd0(%rbp)
    d9db:	4c 89 8d 18 ff ff ff 	mov    %r9,-0xe8(%rbp)
    d9e2:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
    int bind_addrlen, dest_addrlen;
    int ret, fd = -1;

    /* accepting two kind of different uri:
       dest-ip:dest-port or bind-ip:bind-port:dest-ip:dest-port */
    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    d9e9:	e8 a2 eb ff ff       	callq  c590 <socket_parse_uri>
    d9ee:	85 c0                	test   %eax,%eax
    d9f0:	0f 88 ca 04 00 00    	js     dec0 <tcp_open+0x5a0>
                                &dest_addr, &dest_addrlen)) < 0)
        return ret;

    if (!dest_addr)
    d9f6:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
    d9fd:	48 85 c0             	test   %rax,%rax
    da00:	0f 84 1e 05 00 00    	je     df24 <tcp_open+0x604>
        return -PAL_ERROR_INVAL;

    if (bind_addr && bind_addr->sa_family != dest_addr->sa_family)
    da06:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
    da0d:	0f b6 78 01          	movzbl 0x1(%rax),%edi
    da11:	4c 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%r9
    da18:	48 85 d2             	test   %rdx,%rdx
    da1b:	74 0a                	je     da27 <tcp_open+0x107>
    da1d:	40 38 7a 01          	cmp    %dil,0x1(%rdx)
    da21:	0f 85 fd 04 00 00    	jne    df24 <tcp_open+0x604>
        return -PAL_ERROR_INVAL;

    fd = INLINE_SYSCALL(socket, 3, dest_addr->sa_family,
    da27:	8b 75 10             	mov    0x10(%rbp),%esi
    da2a:	b9 61 00 00 00       	mov    $0x61,%ecx
    da2f:	31 d2                	xor    %edx,%edx
    da31:	89 c8                	mov    %ecx,%eax
    da33:	81 ce 01 00 00 10    	or     $0x10000001,%esi
    da39:	48 63 f6             	movslq %esi,%rsi
    da3c:	cd 80                	int    $0x80
    da3e:	48 89 c2             	mov    %rax,%rdx
    da41:	bb 00 00 00 00       	mov    $0x0,%ebx
    da46:	83 d3 00             	adc    $0x0,%ebx
    da49:	31 f6                	xor    %esi,%esi
    da4b:	85 db                	test   %ebx,%ebx
    da4d:	40 0f 95 c6          	setne  %sil
    da51:	48 89 f0             	mov    %rsi,%rax
    da54:	48 f7 d8             	neg    %rax
    da57:	48 31 d0             	xor    %rdx,%rax
    da5a:	4c 8d 3c 30          	lea    (%rax,%rsi,1),%r15
                        SOCK_STREAM|SOCK_CLOEXEC|options, 0);
    if (IS_ERR(fd))
    da5e:	45 85 ff             	test   %r15d,%r15d
    da61:	0f 88 69 06 00 00    	js     e0d0 <tcp_open+0x7b0>
                    goto failed;
            }
        }
    }

    ret = INLINE_SYSCALL(connect, 3, fd, dest_addr, dest_addrlen);
    da67:	4d 63 f7             	movslq %r15d,%r14
    da6a:	b1 62                	mov    $0x62,%cl
    da6c:	48 63 95 24 ff ff ff 	movslq -0xdc(%rbp),%rdx
    da73:	48 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%rsi
    da7a:	4c 89 f7             	mov    %r14,%rdi
    da7d:	89 c8                	mov    %ecx,%eax
    da7f:	cd 80                	int    $0x80
    da81:	48 89 c6             	mov    %rax,%rsi
    da84:	bb 00 00 00 00       	mov    $0x0,%ebx
    da89:	83 d3 00             	adc    $0x0,%ebx
    da8c:	31 d2                	xor    %edx,%edx
    da8e:	85 db                	test   %ebx,%ebx
    da90:	0f 95 c2             	setne  %dl
    da93:	48 89 d0             	mov    %rdx,%rax
    da96:	48 f7 d8             	neg    %rax
    da99:	48 31 f0             	xor    %rsi,%rax
    da9c:	48 01 c2             	add    %rax,%rdx

    if (IS_ERR(ret)) {
    da9f:	85 d2                	test   %edx,%edx
    daa1:	0f 88 89 04 00 00    	js     df30 <tcp_open+0x610>
        ret = unix_to_pal_error(ERRNO(ret));
        goto failed;
    }

    if (!bind_addr) {
    daa7:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
    daae:	48 85 c0             	test   %rax,%rax
    dab1:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
    dab8:	0f 84 c2 04 00 00    	je     df80 <tcp_open+0x660>
        if ((ret = INLINE_SYSCALL(getsockname, 3, fd,
                                  bind_addr, &bind_addrlen)) < 0)
            bind_addr = NULL;
    }

    *handle = socket_create_handle(pal_type_tcp, fd, options,
    dabe:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
    dac4:	48 8b 9d 38 ff ff ff 	mov    -0xc8(%rbp),%rbx
    dacb:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%rbp)
    dad1:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
    dad7:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
    dadd:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
    dae3:	8d 78 58             	lea    0x58(%rax),%edi
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    dae6:	48 85 db             	test   %rbx,%rbx
    dae9:	b8 00 00 00 00       	mov    $0x0,%eax
    daee:	0f 45 85 18 ff ff ff 	cmovne -0xe8(%rbp),%eax
    daf5:	01 c7                	add    %eax,%edi
    daf7:	e8 04 af ff ff       	callq  8a00 <malloc>
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    dafc:	48 85 c0             	test   %rax,%rax
    daff:	0f 84 07 05 00 00    	je     e00c <tcp_open+0x6ec>
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    db05:	31 f6                	xor    %esi,%esi
    db07:	ba 58 00 00 00       	mov    $0x58,%edx
    db0c:	48 89 c7             	mov    %rax,%rdi
    db0f:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
    db16:	e8 85 86 00 00       	callq  161a0 <memset>
    HANDLE_TYPE(hdl) = type;
    db1b:	4c 8b 8d 00 ff ff ff 	mov    -0x100(%rbp),%r9
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
    db22:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    db29:	41 83 49 08 09       	orl    $0x9,0x8(%r9)
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
    db2e:	48 85 c0             	test   %rax,%rax
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    db31:	45 89 79 0c          	mov    %r15d,0xc(%r9)

    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    db35:	41 c7 01 08 00 00 00 	movl   $0x8,(%r9)
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    db3c:	4d 8d 79 58          	lea    0x58(%r9),%r15
    if (bind_addr) {
    db40:	0f 84 1a 04 00 00    	je     df60 <tcp_open+0x640>
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
    db46:	4c 63 85 10 ff ff ff 	movslq -0xf0(%rbp),%r8
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
    db4d:	4d 89 79 10          	mov    %r15,0x10(%r9)
        memcpy(addr, bind_addr, bind_addrlen);
    db51:	4c 89 ff             	mov    %r15,%rdi
    db54:	48 89 c6             	mov    %rax,%rsi
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
    db57:	4c 89 8d 08 ff ff ff 	mov    %r9,-0xf8(%rbp)
        memcpy(addr, bind_addr, bind_addrlen);
    db5e:	4c 89 c2             	mov    %r8,%rdx
    db61:	4c 89 85 10 ff ff ff 	mov    %r8,-0xf0(%rbp)
    db68:	e8 13 87 00 00       	callq  16280 <memcpy>
        addr += bind_addrlen;
    db6d:	4c 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%r8
    db74:	4c 8b 8d 08 ff ff ff 	mov    -0xf8(%rbp),%r9
    db7b:	4d 01 c7             	add    %r8,%r15
    } else {
        hdl->sock.bind = NULL;
    }
    if (dest_addr) {
    db7e:	48 85 db             	test   %rbx,%rbx
    db81:	0f 84 c9 03 00 00    	je     df50 <tcp_open+0x630>
        hdl->sock.conn = addr;
        memcpy(addr, dest_addr, dest_addrlen);
    db87:	48 63 95 18 ff ff ff 	movslq -0xe8(%rbp),%rdx
        addr += bind_addrlen;
    } else {
        hdl->sock.bind = NULL;
    }
    if (dest_addr) {
        hdl->sock.conn = addr;
    db8e:	4d 89 79 18          	mov    %r15,0x18(%r9)
        memcpy(addr, dest_addr, dest_addrlen);
    db92:	48 89 de             	mov    %rbx,%rsi
    db95:	4c 89 ff             	mov    %r15,%rdi
        addr += bind_addrlen;
    } else {
        hdl->sock.bind = NULL;
    }
    if (dest_addr) {
        hdl->sock.conn = addr;
    db98:	4c 89 8d 10 ff ff ff 	mov    %r9,-0xf0(%rbp)
        memcpy(addr, dest_addr, dest_addrlen);
    db9f:	e8 dc 86 00 00       	callq  16280 <memcpy>
    dba4:	4c 8b 8d 10 ff ff ff 	mov    -0xf0(%rbp),%r9
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    dbab:	8b 45 10             	mov    0x10(%rbp),%eax
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    dbae:	4c 8d bd 2c ff ff ff 	lea    -0xd4(%rbp),%r15
    dbb5:	4c 8d 95 28 ff ff ff 	lea    -0xd8(%rbp),%r10
    dbbc:	bb 76 00 00 00       	mov    $0x76,%ebx
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    hdl->sock.reuseaddr     = PAL_FALSE;
    dbc1:	41 c6 41 21 00       	movb   $0x0,0x21(%r9)
    hdl->sock.linger        = 0;
    dbc6:	49 c7 41 28 00 00 00 	movq   $0x0,0x28(%r9)
    dbcd:	00 

    if (type == pal_type_tcpsrv) {
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);
    dbce:	c7 85 2c ff ff ff 04 	movl   $0x4,-0xd4(%rbp)
    dbd5:	00 00 00 

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    dbd8:	4d 89 f8             	mov    %r15,%r8
    dbdb:	4c 89 d1             	mov    %r10,%rcx
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    dbde:	c1 e8 02             	shr    $0x2,%eax
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    dbe1:	ba 02 10 00 00       	mov    $0x1002,%edx
    dbe6:	be ff ff 00 00       	mov    $0xffff,%esi
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    dbeb:	83 e0 01             	and    $0x1,%eax
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    dbee:	4c 89 f7             	mov    %r14,%rdi
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    dbf1:	41 88 41 20          	mov    %al,0x20(%r9)
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    dbf5:	89 d8                	mov    %ebx,%eax
    dbf7:	cd 80                	int    $0x80
    dbf9:	48 89 c2             	mov    %rax,%rdx
    dbfc:	bb 00 00 00 00       	mov    $0x0,%ebx
    dc01:	83 d3 00             	adc    $0x0,%ebx
    dc04:	31 c9                	xor    %ecx,%ecx
    dc06:	85 db                	test   %ebx,%ebx
    dc08:	0f 95 c1             	setne  %cl
    dc0b:	48 89 c8             	mov    %rcx,%rax
    dc0e:	48 f7 d8             	neg    %rax
    dc11:	48 31 d0             	xor    %rdx,%rax
                             &val, &len);
        hdl->sock.receivebuf = IS_ERR(ret) ? 0 : val;
    dc14:	31 d2                	xor    %edx,%edx
    dc16:	01 c8                	add    %ecx,%eax
    dc18:	78 07                	js     dc21 <tcp_open+0x301>
    dc1a:	48 63 95 28 ff ff ff 	movslq -0xd8(%rbp),%rdx

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    dc21:	bb 76 00 00 00       	mov    $0x76,%ebx
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
                             &val, &len);
        hdl->sock.receivebuf = IS_ERR(ret) ? 0 : val;
    dc26:	49 89 51 30          	mov    %rdx,0x30(%r9)

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    dc2a:	4d 89 f8             	mov    %r15,%r8
    dc2d:	4c 89 d1             	mov    %r10,%rcx
    dc30:	ba 01 10 00 00       	mov    $0x1001,%edx
    dc35:	be ff ff 00 00       	mov    $0xffff,%esi
    dc3a:	4c 89 f7             	mov    %r14,%rdi
    dc3d:	89 d8                	mov    %ebx,%eax
    dc3f:	cd 80                	int    $0x80
    dc41:	48 89 c2             	mov    %rax,%rdx
    dc44:	bb 00 00 00 00       	mov    $0x0,%ebx
    dc49:	83 d3 00             	adc    $0x0,%ebx
    dc4c:	31 c9                	xor    %ecx,%ecx
    dc4e:	85 db                	test   %ebx,%ebx
    dc50:	0f 95 c1             	setne  %cl
    dc53:	48 89 c8             	mov    %rcx,%rax
    dc56:	48 f7 d8             	neg    %rax
    dc59:	48 31 d0             	xor    %rdx,%rax
                             &val, &len);
        hdl->sock.sendbuf = IS_ERR(ret) ? 0 : val;
    dc5c:	31 d2                	xor    %edx,%edx
    dc5e:	01 c8                	add    %ecx,%eax
    dc60:	78 07                	js     dc69 <tcp_open+0x349>
    dc62:	48 63 95 28 ff ff ff 	movslq -0xd8(%rbp),%rdx
    dc69:	49 89 51 38          	mov    %rdx,0x38(%r9)
    }

    hdl->sock.receivetimeout = 0;
    dc6d:	49 c7 41 40 00 00 00 	movq   $0x0,0x40(%r9)
    dc74:	00 
    hdl->sock.sendtimeout    = 0;
    dc75:	49 c7 41 48 00 00 00 	movq   $0x0,0x48(%r9)
    dc7c:	00 
    hdl->sock.tcp_cork       = PAL_FALSE;
    dc7d:	41 c6 41 50 00       	movb   $0x0,0x50(%r9)
    hdl->sock.tcp_keepalive  = PAL_FALSE;
    dc82:	41 c6 41 51 00       	movb   $0x0,0x51(%r9)
    hdl->sock.tcp_nodelay    = PAL_FALSE;
    dc87:	41 c6 41 52 00       	movb   $0x0,0x52(%r9)
        if ((ret = INLINE_SYSCALL(getsockname, 3, fd,
                                  bind_addr, &bind_addrlen)) < 0)
            bind_addr = NULL;
    }

    *handle = socket_create_handle(pal_type_tcp, fd, options,
    dc8c:	4d 89 4d 00          	mov    %r9,0x0(%r13)

    if (!memcmp(type, "tcp:", 4))
        return tcp_connect(handle, uri_buf, options);

    return -PAL_ERROR_NOTSUPPORT;
}
    dc90:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    dc97:	44 89 e0             	mov    %r12d,%eax
    dc9a:	5b                   	pop    %rbx
    dc9b:	41 5c                	pop    %r12
    dc9d:	41 5d                	pop    %r13
    dc9f:	41 5e                	pop    %r14
    dca1:	41 5f                	pop    %r15
    dca3:	5d                   	pop    %rbp
    dca4:	c3                   	retq   
}

/* listen on a tcp socket */
static int tcp_listen (PAL_HANDLE * handle, char * uri, int options)
{
    struct sockaddr buffer, * bind_addr = &buffer;
    dca5:	48 8d 85 40 ff ff ff 	lea    -0xc0(%rbp),%rax
    int bind_addrlen;
    int ret, fd = -1;

    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    dcac:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
    dcb3:	48 8d b5 38 ff ff ff 	lea    -0xc8(%rbp),%rsi
    dcba:	45 31 c0             	xor    %r8d,%r8d
    dcbd:	31 c9                	xor    %ecx,%ecx
    dcbf:	4c 89 f7             	mov    %r14,%rdi
}

/* listen on a tcp socket */
static int tcp_listen (PAL_HANDLE * handle, char * uri, int options)
{
    struct sockaddr buffer, * bind_addr = &buffer;
    dcc2:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
    int bind_addrlen;
    int ret, fd = -1;

    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    dcc9:	e8 c2 e8 ff ff       	callq  c590 <socket_parse_uri>
    dcce:	85 c0                	test   %eax,%eax
    dcd0:	0f 88 ea 01 00 00    	js     dec0 <tcp_open+0x5a0>
                                NULL, NULL)) < 0)
        return ret;

    /* the socket need to have a binding address, a null address or an
       any address is not allowed */
    if (!bind_addr || addr_check_any(bind_addr) == 0)
    dcd6:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
    dcdd:	48 85 c0             	test   %rax,%rax
    dce0:	0f 84 3e 02 00 00    	je     df24 <tcp_open+0x604>
}

/* check if an address is "Any" */
static int addr_check_any (struct sockaddr * addr)
{
    if (addr->sa_family == AF_INET) {
    dce6:	0f b6 58 01          	movzbl 0x1(%rax),%ebx
    dcea:	80 fb 02             	cmp    $0x2,%bl
    dced:	0f 84 10 02 00 00    	je     df03 <tcp_open+0x5e3>
                        (struct sockaddr_in *) addr;

        return addr_in->sin_port ||
               check_zero(&addr_in->sin_addr,
                          sizeof(addr_in->sin_addr));
    } else if (addr->sa_family == AF_INET6) {
    dcf3:	80 fb 1c             	cmp    $0x1c,%bl
    dcf6:	75 1d                	jne    dd15 <tcp_open+0x3f5>
        struct sockaddr_in6 * addr_in6 =
                        (struct sockaddr_in6 *) addr;

        return addr_in6->sin6_port ||
    dcf8:	66 83 78 02 00       	cmpw   $0x0,0x2(%rax)
    dcfd:	75 16                	jne    dd15 <tcp_open+0x3f5>
               check_zero(&addr_in6->sin6_addr,
    dcff:	48 8d 78 08          	lea    0x8(%rax),%rdi
    dd03:	be 10 00 00 00       	mov    $0x10,%esi
    dd08:	e8 23 e3 ff ff       	callq  c030 <check_zero>
                          sizeof(addr_in->sin_addr));
    } else if (addr->sa_family == AF_INET6) {
        struct sockaddr_in6 * addr_in6 =
                        (struct sockaddr_in6 *) addr;

        return addr_in6->sin6_port ||
    dd0d:	85 c0                	test   %eax,%eax
    dd0f:	0f 84 0f 02 00 00    	je     df24 <tcp_open+0x604>
    /* the socket need to have a binding address, a null address or an
       any address is not allowed */
    if (!bind_addr || addr_check_any(bind_addr) == 0)
        return -PAL_ERROR_INVAL;

    fd = INLINE_SYSCALL(socket, 3, bind_addr->sa_family,
    dd15:	8b 75 10             	mov    0x10(%rbp),%esi
    dd18:	b9 61 00 00 00       	mov    $0x61,%ecx
    dd1d:	31 d2                	xor    %edx,%edx
    dd1f:	0f b6 fb             	movzbl %bl,%edi
    dd22:	89 c8                	mov    %ecx,%eax
    dd24:	81 ce 01 00 00 10    	or     $0x10000001,%esi
    dd2a:	48 63 f6             	movslq %esi,%rsi
    dd2d:	cd 80                	int    $0x80
    dd2f:	48 89 c2             	mov    %rax,%rdx
    dd32:	bb 00 00 00 00       	mov    $0x0,%ebx
    dd37:	83 d3 00             	adc    $0x0,%ebx
    dd3a:	31 c9                	xor    %ecx,%ecx
    dd3c:	85 db                	test   %ebx,%ebx
    dd3e:	0f 95 c1             	setne  %cl
    dd41:	48 89 c8             	mov    %rcx,%rax
    dd44:	48 f7 d8             	neg    %rax
    dd47:	48 31 d0             	xor    %rdx,%rax
    dd4a:	4c 8d 34 08          	lea    (%rax,%rcx,1),%r14
                        SOCK_STREAM|SOCK_CLOEXEC|options, 0);

    if (IS_ERR(fd))
    dd4e:	45 85 f6             	test   %r14d,%r14d
    dd51:	0f 88 79 03 00 00    	js     e0d0 <tcp_open+0x7b0>
        return -PAL_ERROR_DENIED;

    ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);
    dd57:	4d 63 fe             	movslq %r14d,%r15
    dd5a:	b9 68 00 00 00       	mov    $0x68,%ecx
    dd5f:	48 63 95 30 ff ff ff 	movslq -0xd0(%rbp),%rdx
    dd66:	48 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%rsi
    dd6d:	4c 89 ff             	mov    %r15,%rdi
    dd70:	89 c8                	mov    %ecx,%eax
    dd72:	cd 80                	int    $0x80
    dd74:	48 89 c2             	mov    %rax,%rdx
    dd77:	bb 00 00 00 00       	mov    $0x0,%ebx
    dd7c:	83 d3 00             	adc    $0x0,%ebx
    dd7f:	31 c9                	xor    %ecx,%ecx
    dd81:	85 db                	test   %ebx,%ebx
    dd83:	0f 95 c1             	setne  %cl
    dd86:	48 89 c8             	mov    %rcx,%rax
    dd89:	48 f7 d8             	neg    %rax
    dd8c:	48 31 d0             	xor    %rdx,%rax
    dd8f:	48 01 c8             	add    %rcx,%rax

    if (IS_ERR(ret)) {
    dd92:	85 c0                	test   %eax,%eax
    dd94:	0f 88 36 01 00 00    	js     ded0 <tcp_open+0x5b0>
                ret = -PAL_ERROR_DENIED;
                goto failed;
        }
    }

    ret = INLINE_SYSCALL(listen, 2, fd, DEFAULT_BACKLOG);
    dd9a:	b9 6a 00 00 00       	mov    $0x6a,%ecx
    dd9f:	be 00 08 00 00       	mov    $0x800,%esi
    dda4:	4c 89 ff             	mov    %r15,%rdi
    dda7:	89 c8                	mov    %ecx,%eax
    dda9:	cd 80                	int    $0x80
    ddab:	48 89 c2             	mov    %rax,%rdx
    ddae:	bb 00 00 00 00       	mov    $0x0,%ebx
    ddb3:	83 d3 00             	adc    $0x0,%ebx
    ddb6:	31 c9                	xor    %ecx,%ecx
    ddb8:	85 db                	test   %ebx,%ebx
    ddba:	0f 95 c1             	setne  %cl
    ddbd:	48 89 c8             	mov    %rcx,%rax
    ddc0:	48 f7 d8             	neg    %rax
    ddc3:	48 31 c2             	xor    %rax,%rdx
    if (IS_ERR(ret))
    ddc6:	89 d0                	mov    %edx,%eax
    ddc8:	01 c8                	add    %ecx,%eax
    ddca:	0f 88 00 03 00 00    	js     e0d0 <tcp_open+0x7b0>
        return -PAL_ERROR_DENIED;

    *handle = socket_create_handle(pal_type_tcpsrv, fd, options,
    ddd0:	48 8b 8d 38 ff ff ff 	mov    -0xc8(%rbp),%rcx
    ddd7:	44 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%r8d
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    ddde:	48 85 c9             	test   %rcx,%rcx
    dde1:	48 89 8d 18 ff ff ff 	mov    %rcx,-0xe8(%rbp)
    dde8:	0f 84 a2 02 00 00    	je     e090 <tcp_open+0x770>
    ddee:	41 8d 78 58          	lea    0x58(%r8),%edi
    ddf2:	44 89 85 10 ff ff ff 	mov    %r8d,-0xf0(%rbp)
    ddf9:	e8 02 ac ff ff       	callq  8a00 <malloc>
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    ddfe:	48 85 c0             	test   %rax,%rax
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    de01:	48 89 c3             	mov    %rax,%rbx
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    de04:	44 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%r8d
    de0b:	48 8b 8d 18 ff ff ff 	mov    -0xe8(%rbp),%rcx
    de12:	0f 84 c3 02 00 00    	je     e0db <tcp_open+0x7bb>
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    de18:	ba 58 00 00 00       	mov    $0x58,%edx
    de1d:	31 f6                	xor    %esi,%esi
    de1f:	48 89 c7             	mov    %rax,%rdi
    de22:	48 89 8d 10 ff ff ff 	mov    %rcx,-0xf0(%rbp)
    de29:	44 89 85 18 ff ff ff 	mov    %r8d,-0xe8(%rbp)
    de30:	e8 6b 83 00 00       	callq  161a0 <memset>
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
    de35:	48 8b 8d 10 ff ff ff 	mov    -0xf0(%rbp),%rcx
    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    de3c:	83 4b 08 01          	orl    $0x1,0x8(%rbx)
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    de40:	48 8d 7b 58          	lea    0x58(%rbx),%rdi
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
    de44:	48 63 95 18 ff ff ff 	movslq -0xe8(%rbp),%rdx

    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    de4b:	c7 03 09 00 00 00    	movl   $0x9,(%rbx)
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    de51:	44 89 73 0c          	mov    %r14d,0xc(%rbx)
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
    de55:	48 89 7b 10          	mov    %rdi,0x10(%rbx)
        memcpy(addr, bind_addr, bind_addrlen);
    de59:	48 89 ce             	mov    %rcx,%rsi
    de5c:	e8 1f 84 00 00       	callq  16280 <memcpy>
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    de61:	8b 45 10             	mov    0x10(%rbp),%eax
    if (dest_addr) {
        hdl->sock.conn = addr;
        memcpy(addr, dest_addr, dest_addrlen);
        addr += dest_addrlen;
    } else {
        hdl->sock.conn = NULL;
    de64:	48 c7 43 18 00 00 00 	movq   $0x0,0x18(%rbx)
    de6b:	00 
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    hdl->sock.reuseaddr     = PAL_FALSE;
    de6c:	c6 43 21 00          	movb   $0x0,0x21(%rbx)
    hdl->sock.linger        = 0;
    de70:	48 c7 43 28 00 00 00 	movq   $0x0,0x28(%rbx)
    de77:	00 

    if (type == pal_type_tcpsrv) {
        hdl->sock.receivebuf     = 0;
    de78:	48 c7 43 30 00 00 00 	movq   $0x0,0x30(%rbx)
    de7f:	00 
        hdl->sock.sendbuf        = 0;
    de80:	48 c7 43 38 00 00 00 	movq   $0x0,0x38(%rbx)
    de87:	00 
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    de88:	c1 e8 02             	shr    $0x2,%eax
        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
                             &val, &len);
        hdl->sock.sendbuf = IS_ERR(ret) ? 0 : val;
    }

    hdl->sock.receivetimeout = 0;
    de8b:	48 c7 43 40 00 00 00 	movq   $0x0,0x40(%rbx)
    de92:	00 
    hdl->sock.sendtimeout    = 0;
    de93:	48 c7 43 48 00 00 00 	movq   $0x0,0x48(%rbx)
    de9a:	00 
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    de9b:	83 e0 01             	and    $0x1,%eax
        hdl->sock.sendbuf = IS_ERR(ret) ? 0 : val;
    }

    hdl->sock.receivetimeout = 0;
    hdl->sock.sendtimeout    = 0;
    hdl->sock.tcp_cork       = PAL_FALSE;
    de9e:	c6 43 50 00          	movb   $0x0,0x50(%rbx)
    hdl->sock.tcp_keepalive  = PAL_FALSE;
    dea2:	c6 43 51 00          	movb   $0x0,0x51(%rbx)
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    dea6:	88 43 20             	mov    %al,0x20(%rbx)

    hdl->sock.receivetimeout = 0;
    hdl->sock.sendtimeout    = 0;
    hdl->sock.tcp_cork       = PAL_FALSE;
    hdl->sock.tcp_keepalive  = PAL_FALSE;
    hdl->sock.tcp_nodelay    = PAL_FALSE;
    dea9:	c6 43 52 00          	movb   $0x0,0x52(%rbx)

    ret = INLINE_SYSCALL(listen, 2, fd, DEFAULT_BACKLOG);
    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    *handle = socket_create_handle(pal_type_tcpsrv, fd, options,
    dead:	49 89 5d 00          	mov    %rbx,0x0(%r13)
    deb1:	e9 da fd ff ff       	jmpq   dc90 <tcp_open+0x370>
    deb6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    debd:	00 00 00 
    int bind_addrlen, dest_addrlen;
    int ret, fd = -1;

    /* accepting two kind of different uri:
       dest-ip:dest-port or bind-ip:bind-port:dest-ip:dest-port */
    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    dec0:	41 89 c4             	mov    %eax,%r12d
    dec3:	e9 c8 fd ff ff       	jmpq   dc90 <tcp_open+0x370>
    dec8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    decf:	00 
        return -PAL_ERROR_DENIED;

    ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);

    if (IS_ERR(ret)) {
        switch(ERRNO(ret)) {
    ded0:	f7 d8                	neg    %eax
            case EINVAL:
                ret = -PAL_ERROR_INVAL;
    ded2:	41 bc fc ff ff ff    	mov    $0xfffffffc,%r12d
        return -PAL_ERROR_DENIED;

    ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);

    if (IS_ERR(ret)) {
        switch(ERRNO(ret)) {
    ded8:	83 f8 16             	cmp    $0x16,%eax
    dedb:	74 0f                	je     deec <tcp_open+0x5cc>
                goto failed;
            case EADDRINUSE:
                ret = -PAL_ERROR_STREAMEXIST;
                goto failed;
            default:
                ret = -PAL_ERROR_DENIED;
    dedd:	45 31 e4             	xor    %r12d,%r12d
    dee0:	83 f8 62             	cmp    $0x62,%eax
    dee3:	41 0f 95 c4          	setne  %r12b
    dee7:	47 8d 64 24 f8       	lea    -0x8(%r12,%r12,1),%r12d
    }

    return 0;

failed:
    INLINE_SYSCALL(close, 1, fd);
    deec:	4c 89 ff             	mov    %r15,%rdi
    deef:	b8 06 00 00 00       	mov    $0x6,%eax
    def4:	cd 80                	int    $0x80
    def6:	bb 00 00 00 00       	mov    $0x0,%ebx
    defb:	83 d3 00             	adc    $0x0,%ebx
    defe:	e9 8d fd ff ff       	jmpq   dc90 <tcp_open+0x370>
{
    if (addr->sa_family == AF_INET) {
        struct sockaddr_in * addr_in =
                        (struct sockaddr_in *) addr;

        return addr_in->sin_port ||
    df03:	66 83 78 02 00       	cmpw   $0x0,0x2(%rax)
    df08:	0f 85 07 fe ff ff    	jne    dd15 <tcp_open+0x3f5>
               check_zero(&addr_in->sin_addr,
    df0e:	48 8d 78 04          	lea    0x4(%rax),%rdi
    df12:	be 04 00 00 00       	mov    $0x4,%esi
    df17:	e8 14 e1 ff ff       	callq  c030 <check_zero>
{
    if (addr->sa_family == AF_INET) {
        struct sockaddr_in * addr_in =
                        (struct sockaddr_in *) addr;

        return addr_in->sin_port ||
    df1c:	85 c0                	test   %eax,%eax
    df1e:	0f 85 f1 fd ff ff    	jne    dd15 <tcp_open+0x3f5>
    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
                                &dest_addr, &dest_addrlen)) < 0)
        return ret;

    if (!dest_addr)
        return -PAL_ERROR_INVAL;
    df24:	41 bc fc ff ff ff    	mov    $0xfffffffc,%r12d
    df2a:	e9 61 fd ff ff       	jmpq   dc90 <tcp_open+0x370>
    df2f:	90                   	nop    
    }

    ret = INLINE_SYSCALL(connect, 3, fd, dest_addr, dest_addrlen);

    if (IS_ERR(ret)) {
        ret = unix_to_pal_error(ERRNO(ret));
    df30:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    df32:	83 fa 6e             	cmp    $0x6e,%edx
    df35:	0f 87 4c 01 00 00    	ja     e087 <tcp_open+0x767>
    df3b:	48 8d 05 5e e1 00 00 	lea    0xe15e(%rip),%rax        # 1c0a0 <slab_levels+0x2e00>
    df42:	89 d2                	mov    %edx,%edx
    df44:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    df48:	48 01 d0             	add    %rdx,%rax
    df4b:	ff e0                	jmpq   *%rax
    df4d:	0f 1f 00             	nopl   (%rax)
    if (dest_addr) {
        hdl->sock.conn = addr;
        memcpy(addr, dest_addr, dest_addrlen);
        addr += dest_addrlen;
    } else {
        hdl->sock.conn = NULL;
    df50:	49 c7 41 18 00 00 00 	movq   $0x0,0x18(%r9)
    df57:	00 
    df58:	e9 4e fc ff ff       	jmpq   dbab <tcp_open+0x28b>
    df5d:	0f 1f 00             	nopl   (%rax)
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
        addr += bind_addrlen;
    } else {
        hdl->sock.bind = NULL;
    df60:	49 c7 41 10 00 00 00 	movq   $0x0,0x10(%r9)
    df67:	00 
    df68:	e9 11 fc ff ff       	jmpq   db7e <tcp_open+0x25e>
    df6d:	0f 1f 00             	nopl   (%rax)
        return tcp_listen(handle, uri_buf, options);

    if (!memcmp(type, "tcp:", 4))
        return tcp_connect(handle, uri_buf, options);

    return -PAL_ERROR_NOTSUPPORT;
    df70:	41 bc fd ff ff ff    	mov    $0xfffffffd,%r12d
    df76:	e9 15 fd ff ff       	jmpq   dc90 <tcp_open+0x370>
    df7b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        goto failed;
    }

    if (!bind_addr) {
        /* save some space to get socket address */
        bind_addr = buffer + 2;
    df80:	49 8d 71 20          	lea    0x20(%r9),%rsi
        bind_addrlen = sizeof(struct sockaddr);

        /* call getsockname to get socket address */
        if ((ret = INLINE_SYSCALL(getsockname, 3, fd,
    df84:	b9 20 00 00 00       	mov    $0x20,%ecx
    }

    if (!bind_addr) {
        /* save some space to get socket address */
        bind_addr = buffer + 2;
        bind_addrlen = sizeof(struct sockaddr);
    df89:	c7 85 20 ff ff ff 10 	movl   $0x10,-0xe0(%rbp)
    df90:	00 00 00 

        /* call getsockname to get socket address */
        if ((ret = INLINE_SYSCALL(getsockname, 3, fd,
    df93:	48 8d 95 20 ff ff ff 	lea    -0xe0(%rbp),%rdx
    df9a:	4c 89 f7             	mov    %r14,%rdi
    df9d:	89 c8                	mov    %ecx,%eax
        goto failed;
    }

    if (!bind_addr) {
        /* save some space to get socket address */
        bind_addr = buffer + 2;
    df9f:	48 89 b5 30 ff ff ff 	mov    %rsi,-0xd0(%rbp)
        bind_addrlen = sizeof(struct sockaddr);

        /* call getsockname to get socket address */
        if ((ret = INLINE_SYSCALL(getsockname, 3, fd,
    dfa6:	cd 80                	int    $0x80
    dfa8:	48 89 c2             	mov    %rax,%rdx
    dfab:	bb 00 00 00 00       	mov    $0x0,%ebx
    dfb0:	83 d3 00             	adc    $0x0,%ebx
    dfb3:	31 f6                	xor    %esi,%esi
    dfb5:	85 db                	test   %ebx,%ebx
    dfb7:	40 0f 95 c6          	setne  %sil
    dfbb:	48 89 f0             	mov    %rsi,%rax
    dfbe:	48 f7 d8             	neg    %rax
    dfc1:	48 31 d0             	xor    %rdx,%rax
    dfc4:	01 f0                	add    %esi,%eax
    dfc6:	0f 88 22 01 00 00    	js     e0ee <tcp_open+0x7ce>
                                  bind_addr, &bind_addrlen)) < 0)
            bind_addr = NULL;
    }

    *handle = socket_create_handle(pal_type_tcp, fd, options,
    dfcc:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
    dfd2:	48 8b 9d 38 ff ff ff 	mov    -0xc8(%rbp),%rbx
    dfd9:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%rbp)
    dfdf:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
    dfe5:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
    dfeb:	48 8b 85 30 ff ff ff 	mov    -0xd0(%rbp),%rax
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    dff2:	48 85 c0             	test   %rax,%rax
        if ((ret = INLINE_SYSCALL(getsockname, 3, fd,
                                  bind_addr, &bind_addrlen)) < 0)
            bind_addr = NULL;
    }

    *handle = socket_create_handle(pal_type_tcp, fd, options,
    dff5:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    dffc:	0f 85 db fa ff ff    	jne    dadd <tcp_open+0x1bd>
    e002:	bf 58 00 00 00       	mov    $0x58,%edi
    e007:	e9 da fa ff ff       	jmpq   dae6 <tcp_open+0x1c6>
        if ((ret = INLINE_SYSCALL(getsockname, 3, fd,
                                  bind_addr, &bind_addrlen)) < 0)
            bind_addr = NULL;
    }

    *handle = socket_create_handle(pal_type_tcp, fd, options,
    e00c:	49 c7 45 00 00 00 00 	movq   $0x0,0x0(%r13)
    e013:	00 
                                   bind_addr, bind_addrlen,
                                   dest_addr, dest_addrlen);

    if (!(*handle)) {
        ret = -PAL_ERROR_NOMEM;
    e014:	41 bc f0 ff ff ff    	mov    $0xfffffff0,%r12d
    e01a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    }

    return 0;

failed:
    INLINE_SYSCALL(close, 1, fd);
    e020:	4c 89 f7             	mov    %r14,%rdi
    e023:	b8 06 00 00 00       	mov    $0x6,%eax
    e028:	cd 80                	int    $0x80
    e02a:	bb 00 00 00 00       	mov    $0x0,%ebx
    e02f:	83 d3 00             	adc    $0x0,%ebx
    e032:	e9 59 fc ff ff       	jmpq   dc90 <tcp_open+0x370>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    e037:	41 bc f9 ff ff ff    	mov    $0xfffffff9,%r12d
    e03d:	eb e1                	jmp    e020 <tcp_open+0x700>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    e03f:	41 bc f3 ff ff ff    	mov    $0xfffffff3,%r12d
    e045:	eb d9                	jmp    e020 <tcp_open+0x700>
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    e047:	41 bc ed ff ff ff    	mov    $0xffffffed,%r12d
    e04d:	eb d1                	jmp    e020 <tcp_open+0x700>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    e04f:	41 bc f7 ff ff ff    	mov    $0xfffffff7,%r12d
    e055:	eb c9                	jmp    e020 <tcp_open+0x700>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    e057:	41 bc fb ff ff ff    	mov    $0xfffffffb,%r12d
    e05d:	eb c1                	jmp    e020 <tcp_open+0x700>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    e05f:	41 bc fc ff ff ff    	mov    $0xfffffffc,%r12d
    e065:	eb b9                	jmp    e020 <tcp_open+0x700>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    e067:	41 bc f5 ff ff ff    	mov    $0xfffffff5,%r12d
    e06d:	eb b1                	jmp    e020 <tcp_open+0x700>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    e06f:	41 bc f6 ff ff ff    	mov    $0xfffffff6,%r12d
    e075:	eb a9                	jmp    e020 <tcp_open+0x700>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    e077:	41 bc f8 ff ff ff    	mov    $0xfffffff8,%r12d
    e07d:	eb a1                	jmp    e020 <tcp_open+0x700>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    e07f:	41 bc f1 ff ff ff    	mov    $0xfffffff1,%r12d
    e085:	eb 99                	jmp    e020 <tcp_open+0x700>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    e087:	41 bc fa ff ff ff    	mov    $0xfffffffa,%r12d
    e08d:	eb 91                	jmp    e020 <tcp_open+0x700>
    e08f:	90                   	nop    
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    e090:	bf 58 00 00 00       	mov    $0x58,%edi
    e095:	e8 66 a9 ff ff       	callq  8a00 <malloc>
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    e09a:	48 85 c0             	test   %rax,%rax
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    e09d:	48 89 c3             	mov    %rax,%rbx
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    e0a0:	74 39                	je     e0db <tcp_open+0x7bb>
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    e0a2:	ba 58 00 00 00       	mov    $0x58,%edx
    e0a7:	31 f6                	xor    %esi,%esi
    e0a9:	48 89 df             	mov    %rbx,%rdi
    e0ac:	e8 ef 80 00 00       	callq  161a0 <memset>
    HANDLE_TYPE(hdl) = type;
    e0b1:	c7 03 09 00 00 00    	movl   $0x9,(%rbx)
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    e0b7:	83 4b 08 01          	orl    $0x1,0x8(%rbx)
    hdl->sock.fd = fd;
    e0bb:	44 89 73 0c          	mov    %r14d,0xc(%rbx)
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
        addr += bind_addrlen;
    } else {
        hdl->sock.bind = NULL;
    e0bf:	48 c7 43 10 00 00 00 	movq   $0x0,0x10(%rbx)
    e0c6:	00 
    e0c7:	e9 95 fd ff ff       	jmpq   de61 <tcp_open+0x541>
    e0cc:	0f 1f 40 00          	nopl   0x0(%rax)
        return -PAL_ERROR_INVAL;

    fd = INLINE_SYSCALL(socket, 3, dest_addr->sa_family,
                        SOCK_STREAM|SOCK_CLOEXEC|options, 0);
    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;
    e0d0:	41 bc fa ff ff ff    	mov    $0xfffffffa,%r12d

    if (!memcmp(type, "tcp.srv:", 8))
        return tcp_listen(handle, uri_buf, options);

    if (!memcmp(type, "tcp:", 4))
        return tcp_connect(handle, uri_buf, options);
    e0d6:	e9 b5 fb ff ff       	jmpq   dc90 <tcp_open+0x370>

    ret = INLINE_SYSCALL(listen, 2, fd, DEFAULT_BACKLOG);
    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    *handle = socket_create_handle(pal_type_tcpsrv, fd, options,
    e0db:	49 c7 45 00 00 00 00 	movq   $0x0,0x0(%r13)
    e0e2:	00 
                                   bind_addr, bind_addrlen, NULL, 0);
    if (!(*handle)) {
        ret = -PAL_ERROR_NOMEM;
    e0e3:	41 bc f0 ff ff ff    	mov    $0xfffffff0,%r12d
    e0e9:	e9 fe fd ff ff       	jmpq   deec <tcp_open+0x5cc>
        if ((ret = INLINE_SYSCALL(getsockname, 3, fd,
                                  bind_addr, &bind_addrlen)) < 0)
            bind_addr = NULL;
    }

    *handle = socket_create_handle(pal_type_tcp, fd, options,
    e0ee:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
        bind_addrlen = sizeof(struct sockaddr);

        /* call getsockname to get socket address */
        if ((ret = INLINE_SYSCALL(getsockname, 3, fd,
                                  bind_addr, &bind_addrlen)) < 0)
            bind_addr = NULL;
    e0f4:	48 c7 85 30 ff ff ff 	movq   $0x0,-0xd0(%rbp)
    e0fb:	00 00 00 00 
    }

    *handle = socket_create_handle(pal_type_tcp, fd, options,
    e0ff:	bf 58 00 00 00       	mov    $0x58,%edi
    e104:	48 8b 9d 38 ff ff ff 	mov    -0xc8(%rbp),%rbx
    e10b:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%rbp)
    e111:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
    e117:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
    e11d:	e9 c4 f9 ff ff       	jmpq   dae6 <tcp_open+0x1c6>
    e122:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
    e129:	1f 84 00 00 00 00 00 

000000000000e130 <udp_open>:
    return ret;
}

static int udp_open (PAL_HANDLE *hdl, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    e130:	55                   	push   %rbp
    e131:	48 89 e5             	mov    %rsp,%rbp
    e134:	41 57                	push   %r15
    e136:	41 56                	push   %r14
    e138:	41 55                	push   %r13
    e13a:	41 54                	push   %r12
    e13c:	49 89 fe             	mov    %rdi,%r14
    e13f:	53                   	push   %rbx
    char buf[PAL_SOCKADDR_SIZE];
    int len = strlen(uri);
    e140:	48 89 d7             	mov    %rdx,%rdi
    return ret;
}

static int udp_open (PAL_HANDLE *hdl, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    e143:	48 89 f3             	mov    %rsi,%rbx
    e146:	49 89 d5             	mov    %rdx,%r13
    char buf[PAL_SOCKADDR_SIZE];
    int len = strlen(uri);

    if (len >= PAL_SOCKADDR_SIZE)
        return -PAL_ERROR_TOOLONG;
    e149:	41 bc fb ff ff ff    	mov    $0xfffffffb,%r12d
    return ret;
}

static int udp_open (PAL_HANDLE *hdl, const char * type, const char * uri,
                     int access, int share, int create, int options)
{
    e14f:	48 81 ec d8 00 00 00 	sub    $0xd8,%rsp
    char buf[PAL_SOCKADDR_SIZE];
    int len = strlen(uri);
    e156:	e8 45 86 00 00       	callq  167a0 <strlen>

    if (len >= PAL_SOCKADDR_SIZE)
    e15b:	83 f8 5f             	cmp    $0x5f,%eax
    e15e:	0f 8f 38 03 00 00    	jg     e49c <udp_open+0x36c>
        return -PAL_ERROR_TOOLONG;

    memcpy(buf, uri, len + 1);
    e164:	4c 8d bd 70 ff ff ff 	lea    -0x90(%rbp),%r15
    e16b:	83 c0 01             	add    $0x1,%eax
    e16e:	4c 89 ee             	mov    %r13,%rsi
    e171:	48 63 d0             	movslq %eax,%rdx
    e174:	4c 89 ff             	mov    %r15,%rdi
    e177:	e8 04 81 00 00       	callq  16280 <memcpy>
    options &= PAL_OPTION_MASK;
    e17c:	44 8b 6d 10          	mov    0x10(%rbp),%r13d

    if (!memcmp(type, "udp.srv:", 8))
    e180:	48 8d 35 5a cf 00 00 	lea    0xcf5a(%rip),%rsi        # 1b0e1 <slab_levels+0x1e41>
    e187:	ba 08 00 00 00       	mov    $0x8,%edx
    e18c:	48 89 df             	mov    %rbx,%rdi
    e18f:	e8 7c 81 00 00       	callq  16310 <memcmp>

    if (len >= PAL_SOCKADDR_SIZE)
        return -PAL_ERROR_TOOLONG;

    memcpy(buf, uri, len + 1);
    options &= PAL_OPTION_MASK;
    e194:	41 83 e5 04          	and    $0x4,%r13d

    if (!memcmp(type, "udp.srv:", 8))
    e198:	85 c0                	test   %eax,%eax
    e19a:	41 89 c4             	mov    %eax,%r12d
    e19d:	0f 84 0e 03 00 00    	je     e4b1 <udp_open+0x381>
        return udp_bind(hdl, buf, options);

    if (!memcmp(type, "udp:", 4))
    e1a3:	48 8d 35 24 cf 00 00 	lea    0xcf24(%rip),%rsi        # 1b0ce <slab_levels+0x1e2e>
    e1aa:	ba 04 00 00 00       	mov    $0x4,%edx
    e1af:	48 89 df             	mov    %rbx,%rdi
    e1b2:	e8 59 81 00 00       	callq  16310 <memcmp>
    e1b7:	85 c0                	test   %eax,%eax
    e1b9:	41 89 c4             	mov    %eax,%r12d
    e1bc:	0f 85 31 07 00 00    	jne    e8f3 <udp_open+0x7c3>

/* used by 'open' operation of tcp stream for connected socket */
static int udp_connect (PAL_HANDLE * handle, char * uri, int options)
{
    struct sockaddr buffer[2];
    struct sockaddr * bind_addr = buffer, * dest_addr = buffer + 1;
    e1c2:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
    int bind_addrlen, dest_addrlen;
    int ret, fd = -1;

    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    e1c9:	48 8d 8d 48 ff ff ff 	lea    -0xb8(%rbp),%rcx
    e1d0:	48 8d 95 30 ff ff ff 	lea    -0xd0(%rbp),%rdx
    e1d7:	48 8d b5 40 ff ff ff 	lea    -0xc0(%rbp),%rsi
    e1de:	4c 8d 85 34 ff ff ff 	lea    -0xcc(%rbp),%r8
    e1e5:	4c 89 ff             	mov    %r15,%rdi

/* used by 'open' operation of tcp stream for connected socket */
static int udp_connect (PAL_HANDLE * handle, char * uri, int options)
{
    struct sockaddr buffer[2];
    struct sockaddr * bind_addr = buffer, * dest_addr = buffer + 1;
    e1e8:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    e1ef:	48 83 c0 10          	add    $0x10,%rax
    e1f3:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    int bind_addrlen, dest_addrlen;
    int ret, fd = -1;

    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    e1fa:	e8 91 e3 ff ff       	callq  c590 <socket_parse_uri>
    e1ff:	85 c0                	test   %eax,%eax
    e201:	0f 88 89 05 00 00    	js     e790 <udp_open+0x660>
                                &dest_addr, &dest_addrlen)) < 0)
        return ret;

    fd = INLINE_SYSCALL(socket, 3, dest_addr ? dest_addr->sa_family : AF_INET,
    e207:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    e20e:	44 89 ee             	mov    %r13d,%esi
    e211:	81 ce 02 00 00 10    	or     $0x10000002,%esi
    e217:	48 63 f6             	movslq %esi,%rsi
    e21a:	48 85 c0             	test   %rax,%rax
    e21d:	0f 84 7e 06 00 00    	je     e8a1 <udp_open+0x771>
    e223:	0f b6 78 01          	movzbl 0x1(%rax),%edi
    e227:	bb 61 00 00 00       	mov    $0x61,%ebx
    e22c:	31 d2                	xor    %edx,%edx
    e22e:	89 d8                	mov    %ebx,%eax
    e230:	cd 80                	int    $0x80
    e232:	48 89 c2             	mov    %rax,%rdx
    e235:	bb 00 00 00 00       	mov    $0x0,%ebx
    e23a:	83 d3 00             	adc    $0x0,%ebx
    e23d:	31 f6                	xor    %esi,%esi
    e23f:	85 db                	test   %ebx,%ebx
    e241:	40 0f 95 c6          	setne  %sil
    e245:	48 89 f0             	mov    %rsi,%rax
    e248:	48 f7 d8             	neg    %rax
    e24b:	48 31 d0             	xor    %rdx,%rax
    e24e:	48 8d 0c 30          	lea    (%rax,%rsi,1),%rcx
                        SOCK_DGRAM|SOCK_CLOEXEC|options, 0);

    if (IS_ERR(fd))
    e252:	85 c9                	test   %ecx,%ecx
    e254:	0f 88 98 08 00 00    	js     eaf2 <udp_open+0x9c2>
        return -PAL_ERROR_DENIED;

    if (bind_addr) {
    e25a:	48 8b 9d 40 ff ff ff 	mov    -0xc0(%rbp),%rbx
    e261:	48 85 db             	test   %rbx,%rbx
    e264:	0f 84 46 06 00 00    	je     e8b0 <udp_open+0x780>
        ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);
    e26a:	4c 63 c1             	movslq %ecx,%r8
    e26d:	48 89 de             	mov    %rbx,%rsi
    e270:	bb 68 00 00 00       	mov    $0x68,%ebx
    e275:	48 63 95 30 ff ff ff 	movslq -0xd0(%rbp),%rdx
    e27c:	4c 89 c7             	mov    %r8,%rdi
    e27f:	89 d8                	mov    %ebx,%eax
    e281:	cd 80                	int    $0x80
    e283:	48 89 c6             	mov    %rax,%rsi
    e286:	bb 00 00 00 00       	mov    $0x0,%ebx
    e28b:	83 d3 00             	adc    $0x0,%ebx
    e28e:	31 d2                	xor    %edx,%edx
    e290:	85 db                	test   %ebx,%ebx
    e292:	0f 95 c2             	setne  %dl
    e295:	48 89 d0             	mov    %rdx,%rax
    e298:	48 f7 d8             	neg    %rax
    e29b:	48 31 f0             	xor    %rsi,%rax
    e29e:	48 01 c2             	add    %rax,%rdx

        if (IS_ERR(ret)) {
    e2a1:	85 d2                	test   %edx,%edx
    e2a3:	0f 88 17 05 00 00    	js     e7c0 <udp_open+0x690>
                    goto failed;
            }
        }
    }

    *handle = socket_create_handle(dest_addr ? pal_type_udp : pal_type_udpsrv,
    e2a9:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
    e2af:	48 8b 9d 40 ff ff ff 	mov    -0xc0(%rbp),%rbx
    e2b6:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    e2bc:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
    e2c2:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%rbp)
    e2c8:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    e2cf:	48 85 c0             	test   %rax,%rax
    e2d2:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
    e2d9:	0f 84 21 07 00 00    	je     ea00 <udp_open+0x8d0>
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    e2df:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
    e2e5:	48 85 db             	test   %rbx,%rbx
    e2e8:	4c 89 85 28 ff ff ff 	mov    %r8,-0xd8(%rbp)
    e2ef:	8d 78 58             	lea    0x58(%rax),%edi
    e2f2:	b8 58 00 00 00       	mov    $0x58,%eax
    e2f7:	0f 44 f8             	cmove  %eax,%edi
    e2fa:	03 bd 1c ff ff ff    	add    -0xe4(%rbp),%edi
    e300:	c7 85 18 ff ff ff 0a 	movl   $0xa,-0xe8(%rbp)
    e307:	00 00 00 
    e30a:	48 89 8d 08 ff ff ff 	mov    %rcx,-0xf8(%rbp)
    e311:	e8 ea a6 ff ff       	callq  8a00 <malloc>
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    e316:	48 85 c0             	test   %rax,%rax
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    e319:	49 89 c7             	mov    %rax,%r15
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    e31c:	0f 84 be 07 00 00    	je     eae0 <udp_open+0x9b0>
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    e322:	31 f6                	xor    %esi,%esi
    e324:	ba 58 00 00 00       	mov    $0x58,%edx
    e329:	48 89 c7             	mov    %rax,%rdi
    e32c:	e8 6f 7e 00 00       	callq  161a0 <memset>
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    e331:	48 8b 8d 08 ff ff ff 	mov    -0xf8(%rbp),%rcx

    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    e338:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    e33e:	41 83 4f 08 09       	orl    $0x9,0x8(%r15)
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
    e343:	48 85 db             	test   %rbx,%rbx
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    e346:	41 89 4f 0c          	mov    %ecx,0xc(%r15)

    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    e34a:	41 89 07             	mov    %eax,(%r15)
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    e34d:	49 8d 4f 58          	lea    0x58(%r15),%rcx
    if (bind_addr) {
    e351:	0f 84 3d 05 00 00    	je     e894 <udp_open+0x764>
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
    e357:	4c 63 85 20 ff ff ff 	movslq -0xe0(%rbp),%r8
    e35e:	48 89 cf             	mov    %rcx,%rdi
    e361:	48 89 de             	mov    %rbx,%rsi
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
    e364:	49 89 4f 10          	mov    %rcx,0x10(%r15)
        memcpy(addr, bind_addr, bind_addrlen);
    e368:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
    e36f:	4c 89 c2             	mov    %r8,%rdx
    e372:	4c 89 85 08 ff ff ff 	mov    %r8,-0xf8(%rbp)
    e379:	e8 02 7f 00 00       	callq  16280 <memcpy>
        addr += bind_addrlen;
    e37e:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    e385:	4c 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%r8
    e38c:	4c 01 c1             	add    %r8,%rcx
    } else {
        hdl->sock.bind = NULL;
    }
    if (dest_addr) {
    e38f:	48 8b 85 10 ff ff ff 	mov    -0xf0(%rbp),%rax
    e396:	48 85 c0             	test   %rax,%rax
    e399:	0f 84 81 04 00 00    	je     e820 <udp_open+0x6f0>
        hdl->sock.conn = addr;
        memcpy(addr, dest_addr, dest_addrlen);
    e39f:	48 63 95 1c ff ff ff 	movslq -0xe4(%rbp),%rdx
        addr += bind_addrlen;
    } else {
        hdl->sock.bind = NULL;
    }
    if (dest_addr) {
        hdl->sock.conn = addr;
    e3a6:	49 89 4f 18          	mov    %rcx,0x18(%r15)
        memcpy(addr, dest_addr, dest_addrlen);
    e3aa:	48 89 c6             	mov    %rax,%rsi
    e3ad:	48 89 cf             	mov    %rcx,%rdi
    e3b0:	e8 cb 7e 00 00       	callq  16280 <memcpy>
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    e3b5:	45 85 ed             	test   %r13d,%r13d
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    e3b8:	4c 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%r10
    e3bf:	4c 8d ad 3c ff ff ff 	lea    -0xc4(%rbp),%r13
    e3c6:	bb 76 00 00 00       	mov    $0x76,%ebx
        addr += dest_addrlen;
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
    e3cb:	41 0f 95 47 20       	setne  0x20(%r15)
                              PAL_TRUE : PAL_FALSE;
    hdl->sock.reuseaddr     = PAL_FALSE;
    e3d0:	41 c6 47 21 00       	movb   $0x0,0x21(%r15)
    hdl->sock.linger        = 0;
    e3d5:	49 c7 47 28 00 00 00 	movq   $0x0,0x28(%r15)
    e3dc:	00 
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    e3dd:	4d 89 e8             	mov    %r13,%r8

    if (type == pal_type_tcpsrv) {
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);
    e3e0:	c7 85 3c ff ff ff 04 	movl   $0x4,-0xc4(%rbp)
    e3e7:	00 00 00 

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    e3ea:	4c 89 d1             	mov    %r10,%rcx
    e3ed:	ba 02 10 00 00       	mov    $0x1002,%edx
    e3f2:	be ff ff 00 00       	mov    $0xffff,%esi
    e3f7:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
    e3fe:	89 d8                	mov    %ebx,%eax
    e400:	cd 80                	int    $0x80
    e402:	48 89 c2             	mov    %rax,%rdx
    e405:	bb 00 00 00 00       	mov    $0x0,%ebx
    e40a:	83 d3 00             	adc    $0x0,%ebx
    e40d:	31 c9                	xor    %ecx,%ecx
    e40f:	85 db                	test   %ebx,%ebx
    e411:	0f 95 c1             	setne  %cl
    e414:	48 89 c8             	mov    %rcx,%rax
    e417:	48 f7 d8             	neg    %rax
    e41a:	48 31 d0             	xor    %rdx,%rax
                             &val, &len);
        hdl->sock.receivebuf = IS_ERR(ret) ? 0 : val;
    e41d:	31 d2                	xor    %edx,%edx
    e41f:	01 c8                	add    %ecx,%eax
    e421:	78 07                	js     e42a <udp_open+0x2fa>
    e423:	48 63 95 38 ff ff ff 	movslq -0xc8(%rbp),%rdx

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    e42a:	bb 76 00 00 00       	mov    $0x76,%ebx
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
                             &val, &len);
        hdl->sock.receivebuf = IS_ERR(ret) ? 0 : val;
    e42f:	49 89 57 30          	mov    %rdx,0x30(%r15)

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    e433:	4d 89 e8             	mov    %r13,%r8
    e436:	4c 89 d1             	mov    %r10,%rcx
    e439:	ba 01 10 00 00       	mov    $0x1001,%edx
    e43e:	be ff ff 00 00       	mov    $0xffff,%esi
    e443:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
    e44a:	89 d8                	mov    %ebx,%eax
    e44c:	cd 80                	int    $0x80
    e44e:	48 89 c2             	mov    %rax,%rdx
    e451:	bb 00 00 00 00       	mov    $0x0,%ebx
    e456:	83 d3 00             	adc    $0x0,%ebx
    e459:	31 c9                	xor    %ecx,%ecx
    e45b:	85 db                	test   %ebx,%ebx
    e45d:	0f 95 c1             	setne  %cl
    e460:	48 89 c8             	mov    %rcx,%rax
    e463:	48 f7 d8             	neg    %rax
    e466:	48 31 d0             	xor    %rdx,%rax
                             &val, &len);
        hdl->sock.sendbuf = IS_ERR(ret) ? 0 : val;
    e469:	31 d2                	xor    %edx,%edx
    e46b:	01 c8                	add    %ecx,%eax
    e46d:	78 07                	js     e476 <udp_open+0x346>
    e46f:	48 63 95 38 ff ff ff 	movslq -0xc8(%rbp),%rdx
    e476:	49 89 57 38          	mov    %rdx,0x38(%r15)
    }

    hdl->sock.receivetimeout = 0;
    e47a:	49 c7 47 40 00 00 00 	movq   $0x0,0x40(%r15)
    e481:	00 
    hdl->sock.sendtimeout    = 0;
    e482:	49 c7 47 48 00 00 00 	movq   $0x0,0x48(%r15)
    e489:	00 
    hdl->sock.tcp_cork       = PAL_FALSE;
    e48a:	41 c6 47 50 00       	movb   $0x0,0x50(%r15)
    hdl->sock.tcp_keepalive  = PAL_FALSE;
    e48f:	41 c6 47 51 00       	movb   $0x0,0x51(%r15)
    hdl->sock.tcp_nodelay    = PAL_FALSE;
    e494:	41 c6 47 52 00       	movb   $0x0,0x52(%r15)
                    goto failed;
            }
        }
    }

    *handle = socket_create_handle(dest_addr ? pal_type_udp : pal_type_udpsrv,
    e499:	4d 89 3e             	mov    %r15,(%r14)

    if (!memcmp(type, "udp:", 4))
        return udp_connect(hdl, buf, options);

    return -PAL_ERROR_NOTSUPPORT;
}
    e49c:	48 81 c4 d8 00 00 00 	add    $0xd8,%rsp
    e4a3:	44 89 e0             	mov    %r12d,%eax
    e4a6:	5b                   	pop    %rbx
    e4a7:	41 5c                	pop    %r12
    e4a9:	41 5d                	pop    %r13
    e4ab:	41 5e                	pop    %r14
    e4ad:	41 5f                	pop    %r15
    e4af:	5d                   	pop    %rbp
    e4b0:	c3                   	retq   
}

/* used by 'open' operation of tcp stream for bound socket */
static int udp_bind (PAL_HANDLE * handle, char * uri, int options)
{
    struct sockaddr buffer, * bind_addr = &buffer;
    e4b1:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
    int bind_addrlen;
    int ret = 0, fd = -1;

    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    e4b8:	48 8d 95 38 ff ff ff 	lea    -0xc8(%rbp),%rdx
    e4bf:	48 8d b5 48 ff ff ff 	lea    -0xb8(%rbp),%rsi
    e4c6:	45 31 c0             	xor    %r8d,%r8d
    e4c9:	31 c9                	xor    %ecx,%ecx
    e4cb:	4c 89 ff             	mov    %r15,%rdi
}

/* used by 'open' operation of tcp stream for bound socket */
static int udp_bind (PAL_HANDLE * handle, char * uri, int options)
{
    struct sockaddr buffer, * bind_addr = &buffer;
    e4ce:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
    int bind_addrlen;
    int ret = 0, fd = -1;

    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    e4d5:	e8 b6 e0 ff ff       	callq  c590 <socket_parse_uri>
    e4da:	85 c0                	test   %eax,%eax
    e4dc:	0f 88 ae 02 00 00    	js     e790 <udp_open+0x660>
                                NULL, NULL)) < 0)
        return ret;

    assert(bind_addr);
    e4e2:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    e4e9:	48 85 c0             	test   %rax,%rax
    e4ec:	0f 84 ae 05 00 00    	je     eaa0 <udp_open+0x970>
    e4f2:	0f b6 78 01          	movzbl 0x1(%rax),%edi
#define TCP_CORK	TCP_NOPUSH //Apparently similar
static inline int addr_size (struct sockaddr * addr)
{
    switch (addr->sa_family) {
        case AF_INET:
            return sizeof(struct sockaddr_in);
    e4f6:	b8 10 00 00 00       	mov    $0x10,%eax
typedef uint16_t /*__attribute__((bitwise))*/ __be16;
#define SOL_TCP			6
#define TCP_CORK	TCP_NOPUSH //Apparently similar
static inline int addr_size (struct sockaddr * addr)
{
    switch (addr->sa_family) {
    e4fb:	40 80 ff 02          	cmp    $0x2,%dil
    e4ff:	74 0e                	je     e50f <udp_open+0x3df>
        case AF_INET:
            return sizeof(struct sockaddr_in);
        case AF_INET6:
            return sizeof(struct sockaddr_in6);
        default:
            return 0;
    e501:	40 80 ff 1c          	cmp    $0x1c,%dil
    e505:	ba 00 00 00 00       	mov    $0x0,%edx
    e50a:	b0 1c                	mov    $0x1c,%al
    e50c:	0f 45 c2             	cmovne %edx,%eax
    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
                                NULL, NULL)) < 0)
        return ret;

    assert(bind_addr);
    assert(bind_addrlen == addr_size(bind_addr));
    e50f:	39 85 38 ff ff ff    	cmp    %eax,-0xc8(%rbp)
    e515:	74 3b                	je     e552 <udp_open+0x422>
    e517:	48 8d 15 cc cb 00 00 	lea    0xcbcc(%rip),%rdx        # 1b0ea <slab_levels+0x1e4a>
    e51e:	48 8d 35 0b f2 00 00 	lea    0xf20b(%rip),%rsi        # 1d730 <slab_levels+0x4490>
    e525:	48 8d 3d 0c a2 00 00 	lea    0xa20c(%rip),%rdi        # 18738 <write_config+0x188>
    e52c:	b9 64 02 00 00       	mov    $0x264,%ecx
    e531:	31 c0                	xor    %eax,%eax
    e533:	e8 e8 a8 ff ff       	callq  8e20 <pal_printf>
    e538:	e8 33 85 ff ff       	callq  6a70 <__assert>
    e53d:	bf 01 00 00 00       	mov    $0x1,%edi
    e542:	e8 39 40 00 00       	callq  12580 <_DkProcessExit>
    e547:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    e54e:	0f b6 78 01          	movzbl 0x1(%rax),%edi

    fd = INLINE_SYSCALL(socket, 3, bind_addr->sa_family,
    e552:	44 89 ee             	mov    %r13d,%esi
    e555:	b9 61 00 00 00       	mov    $0x61,%ecx
    e55a:	31 d2                	xor    %edx,%edx
    e55c:	81 ce 02 00 00 10    	or     $0x10000002,%esi
    e562:	89 c8                	mov    %ecx,%eax
    e564:	48 63 f6             	movslq %esi,%rsi
    e567:	cd 80                	int    $0x80
    e569:	48 89 c2             	mov    %rax,%rdx
    e56c:	bb 00 00 00 00       	mov    $0x0,%ebx
    e571:	83 d3 00             	adc    $0x0,%ebx
    e574:	31 c9                	xor    %ecx,%ecx
    e576:	85 db                	test   %ebx,%ebx
    e578:	0f 95 c1             	setne  %cl
    e57b:	48 89 c8             	mov    %rcx,%rax
    e57e:	48 f7 d8             	neg    %rax
    e581:	48 31 d0             	xor    %rdx,%rax
    e584:	48 01 c1             	add    %rax,%rcx
                        SOCK_DGRAM|SOCK_CLOEXEC|options, 0);

    if (IS_ERR(fd))
    e587:	85 c9                	test   %ecx,%ecx
    e589:	0f 88 63 05 00 00    	js     eaf2 <udp_open+0x9c2>
        return -PAL_ERROR_DENIED;

    ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);
    e58f:	4c 63 f9             	movslq %ecx,%r15
    e592:	bb 68 00 00 00       	mov    $0x68,%ebx
    e597:	48 63 95 38 ff ff ff 	movslq -0xc8(%rbp),%rdx
    e59e:	48 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%rsi
    e5a5:	4c 89 ff             	mov    %r15,%rdi
    e5a8:	89 d8                	mov    %ebx,%eax
    e5aa:	cd 80                	int    $0x80
    e5ac:	48 89 c6             	mov    %rax,%rsi
    e5af:	bb 00 00 00 00       	mov    $0x0,%ebx
    e5b4:	83 d3 00             	adc    $0x0,%ebx
    e5b7:	31 d2                	xor    %edx,%edx
    e5b9:	85 db                	test   %ebx,%ebx
    e5bb:	0f 95 c2             	setne  %dl
    e5be:	48 89 d0             	mov    %rdx,%rax
    e5c1:	48 f7 d8             	neg    %rax
    e5c4:	48 31 f0             	xor    %rsi,%rax
    e5c7:	48 01 c2             	add    %rax,%rdx

    if (IS_ERR(ret)) {
    e5ca:	85 d2                	test   %edx,%edx
    e5cc:	0f 88 91 01 00 00    	js     e763 <udp_open+0x633>
                ret = unix_to_pal_error(ERRNO(ret));
                goto failed;
        }
    }

    *handle = socket_create_handle(pal_type_udpsrv, fd, options,
    e5d2:	48 8b 9d 48 ff ff ff 	mov    -0xb8(%rbp),%rbx
    e5d9:	44 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%r8d
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    e5e0:	48 85 db             	test   %rbx,%rbx
    e5e3:	0f 84 47 04 00 00    	je     ea30 <udp_open+0x900>
    e5e9:	41 8d 78 58          	lea    0x58(%r8),%edi
    e5ed:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
    e5f4:	44 89 85 28 ff ff ff 	mov    %r8d,-0xd8(%rbp)
    e5fb:	e8 00 a4 ff ff       	callq  8a00 <malloc>
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    e600:	48 85 c0             	test   %rax,%rax
    e603:	44 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%r8d
    e60a:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    e611:	0f 84 e6 04 00 00    	je     eafd <udp_open+0x9cd>
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    e617:	ba 58 00 00 00       	mov    $0x58,%edx
    e61c:	31 f6                	xor    %esi,%esi
    e61e:	48 89 c7             	mov    %rax,%rdi
    e621:	44 89 85 1c ff ff ff 	mov    %r8d,-0xe4(%rbp)
    e628:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
    e62f:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
    e636:	e8 65 7b 00 00       	callq  161a0 <memset>
    HANDLE_TYPE(hdl) = type;
    e63b:	4c 8b 8d 28 ff ff ff 	mov    -0xd8(%rbp),%r9
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    e642:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
    e649:	48 89 de             	mov    %rbx,%rsi
    e64c:	48 63 95 1c ff ff ff 	movslq -0xe4(%rbp),%rdx
    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    e653:	41 83 49 08 09       	orl    $0x9,0x8(%r9)
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    e658:	49 8d 79 58          	lea    0x58(%r9),%rdi

    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    e65c:	41 c7 01 0b 00 00 00 	movl   $0xb,(%r9)
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    e663:	41 89 49 0c          	mov    %ecx,0xc(%r9)
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    if (bind_addr) {
        hdl->sock.bind = addr;
    e667:	49 89 79 10          	mov    %rdi,0x10(%r9)
        memcpy(addr, bind_addr, bind_addrlen);
    e66b:	e8 10 7c 00 00       	callq  16280 <memcpy>
    e670:	4c 8b 8d 28 ff ff ff 	mov    -0xd8(%rbp),%r9
    } else {
        hdl->sock.conn = NULL;
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
                              PAL_TRUE : PAL_FALSE;
    e677:	45 85 ed             	test   %r13d,%r13d
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    e67a:	4c 8d 95 3c ff ff ff 	lea    -0xc4(%rbp),%r10
    e681:	4c 8d ad 40 ff ff ff 	lea    -0xc0(%rbp),%r13
    e688:	bb 76 00 00 00       	mov    $0x76,%ebx
    if (dest_addr) {
        hdl->sock.conn = addr;
        memcpy(addr, dest_addr, dest_addrlen);
        addr += dest_addrlen;
    } else {
        hdl->sock.conn = NULL;
    e68d:	49 c7 41 18 00 00 00 	movq   $0x0,0x18(%r9)
    e694:	00 
    }

    hdl->sock.nonblocking   = (options & PAL_OPTION_NONBLOCK) ?
    e695:	41 0f 95 41 20       	setne  0x20(%r9)
                              PAL_TRUE : PAL_FALSE;
    hdl->sock.reuseaddr     = PAL_FALSE;
    e69a:	41 c6 41 21 00       	movb   $0x0,0x21(%r9)
    hdl->sock.linger        = 0;
    e69f:	49 c7 41 28 00 00 00 	movq   $0x0,0x28(%r9)
    e6a6:	00 
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    e6a7:	4d 89 e8             	mov    %r13,%r8

    if (type == pal_type_tcpsrv) {
        hdl->sock.receivebuf     = 0;
        hdl->sock.sendbuf        = 0;
    } else {
        int ret, val, len = sizeof(int);
    e6aa:	c7 85 40 ff ff ff 04 	movl   $0x4,-0xc0(%rbp)
    e6b1:	00 00 00 

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    e6b4:	4c 89 d1             	mov    %r10,%rcx
    e6b7:	ba 02 10 00 00       	mov    $0x1002,%edx
    e6bc:	be ff ff 00 00       	mov    $0xffff,%esi
    e6c1:	4c 89 ff             	mov    %r15,%rdi
    e6c4:	89 d8                	mov    %ebx,%eax
    e6c6:	cd 80                	int    $0x80
    e6c8:	48 89 c2             	mov    %rax,%rdx
    e6cb:	bb 00 00 00 00       	mov    $0x0,%ebx
    e6d0:	83 d3 00             	adc    $0x0,%ebx
    e6d3:	31 c9                	xor    %ecx,%ecx
    e6d5:	85 db                	test   %ebx,%ebx
    e6d7:	0f 95 c1             	setne  %cl
    e6da:	48 89 c8             	mov    %rcx,%rax
    e6dd:	48 f7 d8             	neg    %rax
    e6e0:	48 31 d0             	xor    %rdx,%rax
                             &val, &len);
        hdl->sock.receivebuf = IS_ERR(ret) ? 0 : val;
    e6e3:	31 d2                	xor    %edx,%edx
    e6e5:	01 c8                	add    %ecx,%eax
    e6e7:	78 07                	js     e6f0 <udp_open+0x5c0>
    e6e9:	48 63 95 3c ff ff ff 	movslq -0xc4(%rbp),%rdx

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    e6f0:	bb 76 00 00 00       	mov    $0x76,%ebx
    } else {
        int ret, val, len = sizeof(int);

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
                             &val, &len);
        hdl->sock.receivebuf = IS_ERR(ret) ? 0 : val;
    e6f5:	49 89 51 30          	mov    %rdx,0x30(%r9)

        ret = INLINE_SYSCALL(getsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    e6f9:	4d 89 e8             	mov    %r13,%r8
    e6fc:	4c 89 d1             	mov    %r10,%rcx
    e6ff:	ba 01 10 00 00       	mov    $0x1001,%edx
    e704:	be ff ff 00 00       	mov    $0xffff,%esi
    e709:	4c 89 ff             	mov    %r15,%rdi
    e70c:	89 d8                	mov    %ebx,%eax
    e70e:	cd 80                	int    $0x80
    e710:	48 89 c2             	mov    %rax,%rdx
    e713:	bb 00 00 00 00       	mov    $0x0,%ebx
    e718:	83 d3 00             	adc    $0x0,%ebx
    e71b:	31 c9                	xor    %ecx,%ecx
    e71d:	85 db                	test   %ebx,%ebx
    e71f:	0f 95 c1             	setne  %cl
    e722:	48 89 c8             	mov    %rcx,%rax
    e725:	48 f7 d8             	neg    %rax
    e728:	48 31 d0             	xor    %rdx,%rax
                             &val, &len);
        hdl->sock.sendbuf = IS_ERR(ret) ? 0 : val;
    e72b:	31 d2                	xor    %edx,%edx
    e72d:	01 c8                	add    %ecx,%eax
    e72f:	78 07                	js     e738 <udp_open+0x608>
    e731:	48 63 95 3c ff ff ff 	movslq -0xc4(%rbp),%rdx
    e738:	49 89 51 38          	mov    %rdx,0x38(%r9)
    }

    hdl->sock.receivetimeout = 0;
    e73c:	49 c7 41 40 00 00 00 	movq   $0x0,0x40(%r9)
    e743:	00 
    hdl->sock.sendtimeout    = 0;
    e744:	49 c7 41 48 00 00 00 	movq   $0x0,0x48(%r9)
    e74b:	00 
    hdl->sock.tcp_cork       = PAL_FALSE;
    e74c:	41 c6 41 50 00       	movb   $0x0,0x50(%r9)
    hdl->sock.tcp_keepalive  = PAL_FALSE;
    e751:	41 c6 41 51 00       	movb   $0x0,0x51(%r9)
    hdl->sock.tcp_nodelay    = PAL_FALSE;
    e756:	41 c6 41 52 00       	movb   $0x0,0x52(%r9)
                ret = unix_to_pal_error(ERRNO(ret));
                goto failed;
        }
    }

    *handle = socket_create_handle(pal_type_udpsrv, fd, options,
    e75b:	4d 89 0e             	mov    %r9,(%r14)
    e75e:	e9 39 fd ff ff       	jmpq   e49c <udp_open+0x36c>
        return -PAL_ERROR_DENIED;

    ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);

    if (IS_ERR(ret)) {
        switch (ERRNO(ret)) {
    e763:	f7 da                	neg    %edx
            case EADDRINUSE:
                ret = -PAL_ERROR_STREAMEXIST;
    e765:	41 bc f8 ff ff ff    	mov    $0xfffffff8,%r12d
        return -PAL_ERROR_DENIED;

    ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);

    if (IS_ERR(ret)) {
        switch (ERRNO(ret)) {
    e76b:	83 fa 62             	cmp    $0x62,%edx
    e76e:	74 30                	je     e7a0 <udp_open+0x670>
    e770:	83 fa 63             	cmp    $0x63,%edx
            case EADDRINUSE:
                ret = -PAL_ERROR_STREAMEXIST;
                goto failed;
            case EADDRNOTAVAIL:
                ret = -PAL_ERROR_ADDRNOTEXIST;
    e773:	41 b4 e7             	mov    $0xe7,%r12b
        return -PAL_ERROR_DENIED;

    ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);

    if (IS_ERR(ret)) {
        switch (ERRNO(ret)) {
    e776:	74 28                	je     e7a0 <udp_open+0x670>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    e778:	83 fa 6e             	cmp    $0x6e,%edx
    e77b:	77 1b                	ja     e798 <udp_open+0x668>
    e77d:	48 8d 05 d8 da 00 00 	lea    0xdad8(%rip),%rax        # 1c25c <slab_levels+0x2fbc>
    e784:	89 d2                	mov    %edx,%edx
    e786:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    e78a:	48 01 d0             	add    %rdx,%rax
    e78d:	ff e0                	jmpq   *%rax
    e78f:	90                   	nop    
    struct sockaddr buffer[2];
    struct sockaddr * bind_addr = buffer, * dest_addr = buffer + 1;
    int bind_addrlen, dest_addrlen;
    int ret, fd = -1;

    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
    e790:	41 89 c4             	mov    %eax,%r12d
    e793:	e9 04 fd ff ff       	jmpq   e49c <udp_open+0x36c>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    e798:	41 bc fa ff ff ff    	mov    $0xfffffffa,%r12d
    e79e:	66 90                	xchg   %ax,%ax
    }

    return 0;

failed:
    INLINE_SYSCALL(close, 1, fd);
    e7a0:	4c 89 ff             	mov    %r15,%rdi
    e7a3:	b8 06 00 00 00       	mov    $0x6,%eax
    e7a8:	cd 80                	int    $0x80
    e7aa:	bb 00 00 00 00       	mov    $0x0,%ebx
    e7af:	83 d3 00             	adc    $0x0,%ebx
    e7b2:	e9 e5 fc ff ff       	jmpq   e49c <udp_open+0x36c>
    e7b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    e7be:	00 00 

    if (bind_addr) {
        ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);

        if (IS_ERR(ret)) {
            switch (ERRNO(ret)) {
    e7c0:	f7 da                	neg    %edx
    e7c2:	4c 89 85 28 ff ff ff 	mov    %r8,-0xd8(%rbp)
    e7c9:	83 fa 62             	cmp    $0x62,%edx
    e7cc:	0f 84 ae 01 00 00    	je     e980 <udp_open+0x850>
    e7d2:	83 fa 63             	cmp    $0x63,%edx
                case EADDRINUSE:
                    ret = -PAL_ERROR_STREAMEXIST;
                    goto failed;
                case EADDRNOTAVAIL:
                    ret = -PAL_ERROR_ADDRNOTEXIST;
    e7d5:	41 bc e7 ff ff ff    	mov    $0xffffffe7,%r12d

    if (bind_addr) {
        ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);

        if (IS_ERR(ret)) {
            switch (ERRNO(ret)) {
    e7db:	74 28                	je     e805 <udp_open+0x6d5>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    e7dd:	83 fa 6e             	cmp    $0x6e,%edx
    e7e0:	4c 89 85 28 ff ff ff 	mov    %r8,-0xd8(%rbp)
    e7e7:	0f 87 01 02 00 00    	ja     e9ee <udp_open+0x8be>
    e7ed:	48 8d 05 24 dc 00 00 	lea    0xdc24(%rip),%rax        # 1c418 <slab_levels+0x3178>
    e7f4:	89 d2                	mov    %edx,%edx
    e7f6:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    e7fa:	48 01 d0             	add    %rdx,%rax
    e7fd:	ff e0                	jmpq   *%rax
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    e7ff:	41 bc f3 ff ff ff    	mov    $0xfffffff3,%r12d
    }

    return 0;

failed:
    INLINE_SYSCALL(close, 1, fd);
    e805:	48 8b bd 28 ff ff ff 	mov    -0xd8(%rbp),%rdi
    e80c:	b8 06 00 00 00       	mov    $0x6,%eax
    e811:	cd 80                	int    $0x80
    e813:	bb 00 00 00 00       	mov    $0x0,%ebx
    e818:	83 d3 00             	adc    $0x0,%ebx
    e81b:	e9 7c fc ff ff       	jmpq   e49c <udp_open+0x36c>
    if (dest_addr) {
        hdl->sock.conn = addr;
        memcpy(addr, dest_addr, dest_addrlen);
        addr += dest_addrlen;
    } else {
        hdl->sock.conn = NULL;
    e820:	49 c7 47 18 00 00 00 	movq   $0x0,0x18(%r15)
    e827:	00 
    e828:	e9 88 fb ff ff       	jmpq   e3b5 <udp_open+0x285>
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    e82d:	4c 89 85 28 ff ff ff 	mov    %r8,-0xd8(%rbp)
    e834:	bf 58 00 00 00       	mov    $0x58,%edi
    e839:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
    e840:	e8 bb a1 ff ff       	callq  8a00 <malloc>
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    e845:	48 85 c0             	test   %rax,%rax
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    e848:	49 89 c7             	mov    %rax,%r15
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    e84b:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    e852:	0f 84 88 02 00 00    	je     eae0 <udp_open+0x9b0>
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    e858:	ba 58 00 00 00       	mov    $0x58,%edx
    e85d:	31 f6                	xor    %esi,%esi
    e85f:	4c 89 ff             	mov    %r15,%rdi
    e862:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
    e869:	e8 32 79 00 00       	callq  161a0 <memset>
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    e86e:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx
    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    e875:	41 83 4f 08 09       	orl    $0x9,0x8(%r15)

    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    e87a:	41 c7 07 0b 00 00 00 	movl   $0xb,(%r15)
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    e881:	48 c7 85 10 ff ff ff 	movq   $0x0,-0xf0(%rbp)
    e888:	00 00 00 00 
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    e88c:	41 89 4f 0c          	mov    %ecx,0xc(%r15)
    void * addr = (void *) hdl + HANDLE_SIZE(sock);
    e890:	49 8d 4f 58          	lea    0x58(%r15),%rcx
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
        addr += bind_addrlen;
    } else {
        hdl->sock.bind = NULL;
    e894:	49 c7 47 10 00 00 00 	movq   $0x0,0x10(%r15)
    e89b:	00 
    e89c:	e9 ee fa ff ff       	jmpq   e38f <udp_open+0x25f>

    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
                                &dest_addr, &dest_addrlen)) < 0)
        return ret;

    fd = INLINE_SYSCALL(socket, 3, dest_addr ? dest_addr->sa_family : AF_INET,
    e8a1:	bf 02 00 00 00       	mov    $0x2,%edi
    e8a6:	e9 7c f9 ff ff       	jmpq   e227 <udp_open+0xf7>
    e8ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    e8b0:	48 63 c1             	movslq %ecx,%rax
    e8b3:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
                    goto failed;
            }
        }
    }

    *handle = socket_create_handle(dest_addr ? pal_type_udp : pal_type_udpsrv,
    e8ba:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
    e8c0:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
    e8c6:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
    e8cc:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%rbp)
    e8d2:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    e8d9:	48 85 c0             	test   %rax,%rax
    e8dc:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
    e8e3:	0f 84 4b ff ff ff    	je     e834 <udp_open+0x704>
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    e8e9:	bf 58 00 00 00       	mov    $0x58,%edi
    e8ee:	e9 07 fa ff ff       	jmpq   e2fa <udp_open+0x1ca>
        return udp_bind(hdl, buf, options);

    if (!memcmp(type, "udp:", 4))
        return udp_connect(hdl, buf, options);

    return -PAL_ERROR_NOTSUPPORT;
    e8f3:	41 bc fd ff ff ff    	mov    $0xfffffffd,%r12d
    e8f9:	e9 9e fb ff ff       	jmpq   e49c <udp_open+0x36c>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    e8fe:	41 bc f7 ff ff ff    	mov    $0xfffffff7,%r12d
    e904:	e9 97 fe ff ff       	jmpq   e7a0 <udp_open+0x670>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    e909:	41 bc f8 ff ff ff    	mov    $0xfffffff8,%r12d
    e90f:	e9 8c fe ff ff       	jmpq   e7a0 <udp_open+0x670>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    e914:	41 bc f1 ff ff ff    	mov    $0xfffffff1,%r12d
    e91a:	e9 81 fe ff ff       	jmpq   e7a0 <udp_open+0x670>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    e91f:	41 bc f0 ff ff ff    	mov    $0xfffffff0,%r12d
    e925:	e9 76 fe ff ff       	jmpq   e7a0 <udp_open+0x670>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    e92a:	41 bc ed ff ff ff    	mov    $0xffffffed,%r12d
    e930:	e9 6b fe ff ff       	jmpq   e7a0 <udp_open+0x670>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    e935:	41 bc fb ff ff ff    	mov    $0xfffffffb,%r12d
    e93b:	e9 60 fe ff ff       	jmpq   e7a0 <udp_open+0x670>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    e940:	41 bc fc ff ff ff    	mov    $0xfffffffc,%r12d
    e946:	e9 55 fe ff ff       	jmpq   e7a0 <udp_open+0x670>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    e94b:	41 bc f5 ff ff ff    	mov    $0xfffffff5,%r12d
    e951:	e9 4a fe ff ff       	jmpq   e7a0 <udp_open+0x670>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    e956:	41 bc f6 ff ff ff    	mov    $0xfffffff6,%r12d
    e95c:	e9 3f fe ff ff       	jmpq   e7a0 <udp_open+0x670>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    e961:	41 bc f9 ff ff ff    	mov    $0xfffffff9,%r12d
    e967:	e9 34 fe ff ff       	jmpq   e7a0 <udp_open+0x670>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    e96c:	41 bc f3 ff ff ff    	mov    $0xfffffff3,%r12d
    e972:	e9 29 fe ff ff       	jmpq   e7a0 <udp_open+0x670>
    e977:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    e97e:	00 00 
        ret = INLINE_SYSCALL(bind, 3, fd, bind_addr, bind_addrlen);

        if (IS_ERR(ret)) {
            switch (ERRNO(ret)) {
                case EADDRINUSE:
                    ret = -PAL_ERROR_STREAMEXIST;
    e980:	41 bc f8 ff ff ff    	mov    $0xfffffff8,%r12d
    e986:	e9 7a fe ff ff       	jmpq   e805 <udp_open+0x6d5>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    e98b:	41 bc f7 ff ff ff    	mov    $0xfffffff7,%r12d
    e991:	e9 6f fe ff ff       	jmpq   e805 <udp_open+0x6d5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    e996:	41 bc fc ff ff ff    	mov    $0xfffffffc,%r12d
    e99c:	e9 64 fe ff ff       	jmpq   e805 <udp_open+0x6d5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    e9a1:	41 bc f5 ff ff ff    	mov    $0xfffffff5,%r12d
    e9a7:	e9 59 fe ff ff       	jmpq   e805 <udp_open+0x6d5>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    e9ac:	41 bc f9 ff ff ff    	mov    $0xfffffff9,%r12d
    e9b2:	e9 4e fe ff ff       	jmpq   e805 <udp_open+0x6d5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    e9b7:	41 bc f6 ff ff ff    	mov    $0xfffffff6,%r12d
    e9bd:	e9 43 fe ff ff       	jmpq   e805 <udp_open+0x6d5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    e9c2:	41 bc f1 ff ff ff    	mov    $0xfffffff1,%r12d
    e9c8:	e9 38 fe ff ff       	jmpq   e805 <udp_open+0x6d5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    e9cd:	41 bc f0 ff ff ff    	mov    $0xfffffff0,%r12d
    e9d3:	e9 2d fe ff ff       	jmpq   e805 <udp_open+0x6d5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    e9d8:	41 bc ed ff ff ff    	mov    $0xffffffed,%r12d
    e9de:	e9 22 fe ff ff       	jmpq   e805 <udp_open+0x6d5>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    e9e3:	41 bc fb ff ff ff    	mov    $0xfffffffb,%r12d
    e9e9:	e9 17 fe ff ff       	jmpq   e805 <udp_open+0x6d5>
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    e9ee:	41 bc fa ff ff ff    	mov    $0xfffffffa,%r12d
    e9f4:	e9 0c fe ff ff       	jmpq   e805 <udp_open+0x6d5>
    e9f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    ea00:	48 85 db             	test   %rbx,%rbx
    ea03:	0f 84 24 fe ff ff    	je     e82d <udp_open+0x6fd>
    ea09:	8b 85 20 ff ff ff    	mov    -0xe0(%rbp),%eax
    ea0f:	4c 89 85 28 ff ff ff 	mov    %r8,-0xd8(%rbp)
                    goto failed;
            }
        }
    }

    *handle = socket_create_handle(dest_addr ? pal_type_udp : pal_type_udpsrv,
    ea16:	c7 85 18 ff ff ff 0b 	movl   $0xb,-0xe8(%rbp)
    ea1d:	00 00 00 
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    ea20:	8d 78 58             	lea    0x58(%rax),%edi
    ea23:	e9 e2 f8 ff ff       	jmpq   e30a <udp_open+0x1da>
    ea28:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    ea2f:	00 
    ea30:	bf 58 00 00 00       	mov    $0x58,%edi
    ea35:	48 89 8d 28 ff ff ff 	mov    %rcx,-0xd8(%rbp)
    ea3c:	e8 bf 9f ff ff       	callq  8a00 <malloc>
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    ea41:	48 85 c0             	test   %rax,%rax
static inline
PAL_HANDLE socket_create_handle (int type, int fd, int options,
                                 struct sockaddr * bind_addr, int bind_addrlen,
                                 struct sockaddr * dest_addr, int dest_addrlen)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(sock) + (bind_addr ? bind_addrlen : 0) +
    ea44:	49 89 c1             	mov    %rax,%r9
                            (dest_addr ? dest_addrlen : 0));

    if (!hdl)
    ea47:	48 8b 8d 28 ff ff ff 	mov    -0xd8(%rbp),%rcx
    ea4e:	0f 84 a9 00 00 00    	je     eafd <udp_open+0x9cd>
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    ea54:	4c 89 cf             	mov    %r9,%rdi
    ea57:	ba 58 00 00 00       	mov    $0x58,%edx
    ea5c:	31 f6                	xor    %esi,%esi
    ea5e:	48 89 8d 20 ff ff ff 	mov    %rcx,-0xe0(%rbp)
    ea65:	4c 89 8d 28 ff ff ff 	mov    %r9,-0xd8(%rbp)
    ea6c:	e8 2f 77 00 00       	callq  161a0 <memset>
    HANDLE_TYPE(hdl) = type;
    ea71:	4c 8b 8d 28 ff ff ff 	mov    -0xd8(%rbp),%r9
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    hdl->sock.fd = fd;
    ea78:	48 8b 8d 20 ff ff ff 	mov    -0xe0(%rbp),%rcx

    if (!hdl)
        return NULL;

    memset(hdl, 0, sizeof(union pal_handle));
    HANDLE_TYPE(hdl) = type;
    ea7f:	41 c7 01 0b 00 00 00 	movl   $0xb,(%r9)
    hdl->__in.flags |= RFD(0)|(type != pal_type_tcpsrv ? WFD(0) : 0);
    ea86:	41 83 49 08 09       	orl    $0x9,0x8(%r9)
    hdl->sock.fd = fd;
    ea8b:	41 89 49 0c          	mov    %ecx,0xc(%r9)
    if (bind_addr) {
        hdl->sock.bind = addr;
        memcpy(addr, bind_addr, bind_addrlen);
        addr += bind_addrlen;
    } else {
        hdl->sock.bind = NULL;
    ea8f:	49 c7 41 10 00 00 00 	movq   $0x0,0x10(%r9)
    ea96:	00 
    ea97:	e9 db fb ff ff       	jmpq   e677 <udp_open+0x547>
    ea9c:	0f 1f 40 00          	nopl   0x0(%rax)

    if ((ret = socket_parse_uri(uri, &bind_addr, &bind_addrlen,
                                NULL, NULL)) < 0)
        return ret;

    assert(bind_addr);
    eaa0:	48 8d 15 43 c6 00 00 	lea    0xc643(%rip),%rdx        # 1b0ea <slab_levels+0x1e4a>
    eaa7:	48 8d 35 49 c6 00 00 	lea    0xc649(%rip),%rsi        # 1b0f7 <slab_levels+0x1e57>
    eaae:	48 8d 3d 83 9c 00 00 	lea    0x9c83(%rip),%rdi        # 18738 <write_config+0x188>
    eab5:	b9 63 02 00 00       	mov    $0x263,%ecx
    eaba:	e8 61 a3 ff ff       	callq  8e20 <pal_printf>
    eabf:	e8 ac 7f ff ff       	callq  6a70 <__assert>
    eac4:	bf 01 00 00 00       	mov    $0x1,%edi
    eac9:	e8 b2 3a 00 00       	callq  12580 <_DkProcessExit>
    eace:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
    ead5:	e9 18 fa ff ff       	jmpq   e4f2 <udp_open+0x3c2>
    eada:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                    goto failed;
            }
        }
    }

    *handle = socket_create_handle(dest_addr ? pal_type_udp : pal_type_udpsrv,
    eae0:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
                                   fd, options,
                                   bind_addr, bind_addrlen,
                                   dest_addr, dest_addrlen);

    if (!(*handle)) {
        ret = -ENOMEM;
    eae7:	41 bc f4 ff ff ff    	mov    $0xfffffff4,%r12d
    eaed:	e9 13 fd ff ff       	jmpq   e805 <udp_open+0x6d5>

    fd = INLINE_SYSCALL(socket, 3, dest_addr ? dest_addr->sa_family : AF_INET,
                        SOCK_DGRAM|SOCK_CLOEXEC|options, 0);

    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;
    eaf2:	41 bc fa ff ff ff    	mov    $0xfffffffa,%r12d

    if (!memcmp(type, "udp.srv:", 8))
        return udp_bind(hdl, buf, options);

    if (!memcmp(type, "udp:", 4))
        return udp_connect(hdl, buf, options);
    eaf8:	e9 9f f9 ff ff       	jmpq   e49c <udp_open+0x36c>
                ret = unix_to_pal_error(ERRNO(ret));
                goto failed;
        }
    }

    *handle = socket_create_handle(pal_type_udpsrv, fd, options,
    eafd:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
                                   bind_addr, bind_addrlen, NULL, 0);

    if (!(*handle)) {
        ret = -ENOMEM;
    eb04:	41 bc f4 ff ff ff    	mov    $0xfffffff4,%r12d
    eb0a:	e9 91 fc ff ff       	jmpq   e7a0 <udp_open+0x670>
    eb0f:	90                   	nop    

000000000000eb10 <socket_attrsetbyhdl>:
    attr->tcp_nodelay    = handle->sock.tcp_nodelay;
    return 0;
}

static int socket_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR  * attr)
{
    eb10:	55                   	push   %rbp
    eb11:	49 89 f9             	mov    %rdi,%r9
    eb14:	48 89 e5             	mov    %rsp,%rbp
    eb17:	41 54                	push   %r12
    eb19:	53                   	push   %rbx
    if (handle->sock.fd == PAL_IDX_POISON)
    eb1a:	44 8b 67 0c          	mov    0xc(%rdi),%r12d
    eb1e:	41 83 fc ff          	cmp    $0xffffffffffffffff,%r12d
    eb22:	0f 84 fd 09 00 00    	je     f525 <socket_attrsetbyhdl+0xa15>
        return -PAL_ERROR_BADHANDLE;

    int fd = handle->sock.fd, ret, val;

    if (attr->nonblocking != handle->sock.nonblocking) {
    eb28:	0f b6 46 38          	movzbl 0x38(%rsi),%eax
    eb2c:	49 89 f2             	mov    %rsi,%r10
    eb2f:	3a 47 20             	cmp    0x20(%rdi),%al
    eb32:	74 4b                	je     eb7f <socket_attrsetbyhdl+0x6f>
        ret = INLINE_SYSCALL(fcntl, 3, fd, F_SETFL,
    eb34:	3c 01                	cmp    $0x1,%al
    eb36:	bb 5c 00 00 00       	mov    $0x5c,%ebx
    eb3b:	be 04 00 00 00       	mov    $0x4,%esi
    eb40:	48 19 d2             	sbb    %rdx,%rdx
    eb43:	49 63 fc             	movslq %r12d,%rdi
    eb46:	89 d8                	mov    %ebx,%eax
    eb48:	48 f7 d2             	not    %rdx
    eb4b:	83 e2 04             	and    $0x4,%edx
    eb4e:	cd 80                	int    $0x80
    eb50:	48 89 c1             	mov    %rax,%rcx
    eb53:	bb 00 00 00 00       	mov    $0x0,%ebx
    eb58:	83 d3 00             	adc    $0x0,%ebx
    eb5b:	31 d2                	xor    %edx,%edx
    eb5d:	85 db                	test   %ebx,%ebx
    eb5f:	0f 95 c2             	setne  %dl
    eb62:	48 89 d0             	mov    %rdx,%rax
    eb65:	48 f7 d8             	neg    %rax
    eb68:	48 31 c8             	xor    %rcx,%rax
    eb6b:	48 01 c2             	add    %rax,%rdx
                             attr->nonblocking ? O_NONBLOCK : 0);

        if (IS_ERR(ret))
    eb6e:	85 d2                	test   %edx,%edx
    eb70:	0f 88 9a 03 00 00    	js     ef10 <socket_attrsetbyhdl+0x400>
            return unix_to_pal_error(ERRNO(ret));

        handle->sock.nonblocking = attr->nonblocking;
    eb76:	41 0f b6 42 38       	movzbl 0x38(%r10),%eax
    eb7b:	41 88 41 20          	mov    %al,0x20(%r9)
    }

    if (attr->reuseaddr != handle->sock.reuseaddr) {
    eb7f:	41 0f b6 42 39       	movzbl 0x39(%r10),%eax
    eb84:	41 3a 41 21          	cmp    0x21(%r9),%al
    eb88:	74 52                	je     ebdc <socket_attrsetbyhdl+0xcc>
        val = attr->reuseaddr ? 1 : 0;
        ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_REUSEADDR,
    eb8a:	bb 69 00 00 00       	mov    $0x69,%ebx

        handle->sock.nonblocking = attr->nonblocking;
    }

    if (attr->reuseaddr != handle->sock.reuseaddr) {
        val = attr->reuseaddr ? 1 : 0;
    eb8f:	89 45 dc             	mov    %eax,-0x24(%rbp)
        ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_REUSEADDR,
    eb92:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    eb98:	48 8d 4d dc          	lea    -0x24(%rbp),%rcx
    eb9c:	ba 04 00 00 00       	mov    $0x4,%edx
    eba1:	be ff ff 00 00       	mov    $0xffff,%esi
    eba6:	49 63 fc             	movslq %r12d,%rdi
    eba9:	89 d8                	mov    %ebx,%eax
    ebab:	cd 80                	int    $0x80
    ebad:	48 89 c1             	mov    %rax,%rcx
    ebb0:	bb 00 00 00 00       	mov    $0x0,%ebx
    ebb5:	83 d3 00             	adc    $0x0,%ebx
    ebb8:	31 d2                	xor    %edx,%edx
    ebba:	85 db                	test   %ebx,%ebx
    ebbc:	0f 95 c2             	setne  %dl
    ebbf:	48 89 d0             	mov    %rdx,%rax
    ebc2:	48 f7 d8             	neg    %rax
    ebc5:	48 31 c8             	xor    %rcx,%rax
    ebc8:	48 01 c2             	add    %rax,%rdx
                             &val, sizeof(int));

        if (IS_ERR(ret))
    ebcb:	85 d2                	test   %edx,%edx
    ebcd:	0f 88 1f 03 00 00    	js     eef2 <socket_attrsetbyhdl+0x3e2>
            return unix_to_pal_error(ERRNO(ret));

        handle->sock.reuseaddr = attr->reuseaddr;
    ebd3:	41 0f b6 42 39       	movzbl 0x39(%r10),%eax
    ebd8:	41 88 41 21          	mov    %al,0x21(%r9)
    }

    if (handle->__in.type != pal_type_tcpsrv) {
    ebdc:	41 83 39 09          	cmpl   $0x9,(%r9)
    ebe0:	0f 84 ea 01 00 00    	je     edd0 <socket_attrsetbyhdl+0x2c0>
        struct __kernel_linger {
            int l_onoff;
            int l_linger;
        };

        if (attr->linger != handle->sock.linger) {
    ebe6:	49 8b 42 40          	mov    0x40(%r10),%rax
    ebea:	49 3b 41 28          	cmp    0x28(%r9),%rax
    ebee:	74 5c                	je     ec4c <socket_attrsetbyhdl+0x13c>
            struct __kernel_linger l;
            l.l_onoff = attr->linger ? 1 : 0;
    ebf0:	31 d2                	xor    %edx,%edx
    ebf2:	48 85 c0             	test   %rax,%rax
            l.l_linger = attr->linger;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_LINGER,
    ebf5:	bb 69 00 00 00       	mov    $0x69,%ebx
            int l_linger;
        };

        if (attr->linger != handle->sock.linger) {
            struct __kernel_linger l;
            l.l_onoff = attr->linger ? 1 : 0;
    ebfa:	0f 95 c2             	setne  %dl
            l.l_linger = attr->linger;
    ebfd:	89 45 e4             	mov    %eax,-0x1c(%rbp)
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_LINGER,
    ec00:	41 b8 08 00 00 00    	mov    $0x8,%r8d
            int l_linger;
        };

        if (attr->linger != handle->sock.linger) {
            struct __kernel_linger l;
            l.l_onoff = attr->linger ? 1 : 0;
    ec06:	89 55 e0             	mov    %edx,-0x20(%rbp)
            l.l_linger = attr->linger;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_LINGER,
    ec09:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
    ec0d:	ba 80 00 00 00       	mov    $0x80,%edx
    ec12:	be ff ff 00 00       	mov    $0xffff,%esi
    ec17:	49 63 fc             	movslq %r12d,%rdi
    ec1a:	89 d8                	mov    %ebx,%eax
    ec1c:	cd 80                	int    $0x80
    ec1e:	48 89 c1             	mov    %rax,%rcx
    ec21:	bb 00 00 00 00       	mov    $0x0,%ebx
    ec26:	83 d3 00             	adc    $0x0,%ebx
    ec29:	31 d2                	xor    %edx,%edx
    ec2b:	85 db                	test   %ebx,%ebx
    ec2d:	0f 95 c2             	setne  %dl
    ec30:	48 89 d0             	mov    %rdx,%rax
    ec33:	48 f7 d8             	neg    %rax
    ec36:	48 31 c8             	xor    %rcx,%rax
    ec39:	48 01 c2             	add    %rax,%rdx
                                 &l, sizeof(struct __kernel_linger));

            if (IS_ERR(ret))
    ec3c:	85 d2                	test   %edx,%edx
    ec3e:	0f 88 ec 02 00 00    	js     ef30 <socket_attrsetbyhdl+0x420>
                return unix_to_pal_error(ERRNO(ret));

            handle->sock.linger = attr->linger;
    ec44:	49 8b 42 40          	mov    0x40(%r10),%rax
    ec48:	49 89 41 28          	mov    %rax,0x28(%r9)
        }

        if (attr->receivebuf != handle->sock.receivebuf) {
    ec4c:	49 8b 42 48          	mov    0x48(%r10),%rax
    ec50:	49 3b 41 30          	cmp    0x30(%r9),%rax
    ec54:	74 51                	je     eca7 <socket_attrsetbyhdl+0x197>
            int val = attr->receivebuf;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    ec56:	bb 69 00 00 00       	mov    $0x69,%ebx

            handle->sock.linger = attr->linger;
        }

        if (attr->receivebuf != handle->sock.receivebuf) {
            int val = attr->receivebuf;
    ec5b:	89 45 e0             	mov    %eax,-0x20(%rbp)
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
    ec5e:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    ec64:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
    ec68:	ba 02 10 00 00       	mov    $0x1002,%edx
    ec6d:	be ff ff 00 00       	mov    $0xffff,%esi
    ec72:	49 63 fc             	movslq %r12d,%rdi
    ec75:	89 d8                	mov    %ebx,%eax
    ec77:	cd 80                	int    $0x80
    ec79:	48 89 c1             	mov    %rax,%rcx
    ec7c:	bb 00 00 00 00       	mov    $0x0,%ebx
    ec81:	83 d3 00             	adc    $0x0,%ebx
    ec84:	31 d2                	xor    %edx,%edx
    ec86:	85 db                	test   %ebx,%ebx
    ec88:	0f 95 c2             	setne  %dl
    ec8b:	48 89 d0             	mov    %rdx,%rax
    ec8e:	48 f7 d8             	neg    %rax
    ec91:	48 31 c8             	xor    %rcx,%rax
    ec94:	48 01 c2             	add    %rax,%rdx
                                 &val, sizeof(int));

            if (IS_ERR(ret))
    ec97:	85 d2                	test   %edx,%edx
    ec99:	0f 88 b1 02 00 00    	js     ef50 <socket_attrsetbyhdl+0x440>
                return unix_to_pal_error(ERRNO(ret));

            handle->sock.receivebuf = attr->receivebuf;
    ec9f:	49 8b 42 48          	mov    0x48(%r10),%rax
    eca3:	49 89 41 30          	mov    %rax,0x30(%r9)
        }

        if (attr->sendbuf != handle->sock.sendbuf) {
    eca7:	49 8b 42 50          	mov    0x50(%r10),%rax
    ecab:	49 3b 41 38          	cmp    0x38(%r9),%rax
    ecaf:	74 51                	je     ed02 <socket_attrsetbyhdl+0x1f2>
            int val = attr->sendbuf;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    ecb1:	bb 69 00 00 00       	mov    $0x69,%ebx

            handle->sock.receivebuf = attr->receivebuf;
        }

        if (attr->sendbuf != handle->sock.sendbuf) {
            int val = attr->sendbuf;
    ecb6:	89 45 e0             	mov    %eax,-0x20(%rbp)
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
    ecb9:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    ecbf:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
    ecc3:	ba 01 10 00 00       	mov    $0x1001,%edx
    ecc8:	be ff ff 00 00       	mov    $0xffff,%esi
    eccd:	49 63 fc             	movslq %r12d,%rdi
    ecd0:	89 d8                	mov    %ebx,%eax
    ecd2:	cd 80                	int    $0x80
    ecd4:	48 89 c1             	mov    %rax,%rcx
    ecd7:	bb 00 00 00 00       	mov    $0x0,%ebx
    ecdc:	83 d3 00             	adc    $0x0,%ebx
    ecdf:	31 d2                	xor    %edx,%edx
    ece1:	85 db                	test   %ebx,%ebx
    ece3:	0f 95 c2             	setne  %dl
    ece6:	48 89 d0             	mov    %rdx,%rax
    ece9:	48 f7 d8             	neg    %rax
    ecec:	48 31 c8             	xor    %rcx,%rax
    ecef:	48 01 c2             	add    %rax,%rdx
                                 &val, sizeof(int));

            if (IS_ERR(ret))
    ecf2:	85 d2                	test   %edx,%edx
    ecf4:	0f 88 76 02 00 00    	js     ef70 <socket_attrsetbyhdl+0x460>
                return unix_to_pal_error(ERRNO(ret));

            handle->sock.sendbuf = attr->sendbuf;
    ecfa:	49 8b 42 50          	mov    0x50(%r10),%rax
    ecfe:	49 89 41 38          	mov    %rax,0x38(%r9)
        }

        if (attr->receivetimeout != handle->sock.receivetimeout) {
    ed02:	49 8b 42 58          	mov    0x58(%r10),%rax
    ed06:	49 3b 41 40          	cmp    0x40(%r9),%rax
    ed0a:	74 51                	je     ed5d <socket_attrsetbyhdl+0x24d>
            int val = attr->receivetimeout;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_RCVTIMEO,
    ed0c:	bb 69 00 00 00       	mov    $0x69,%ebx

            handle->sock.sendbuf = attr->sendbuf;
        }

        if (attr->receivetimeout != handle->sock.receivetimeout) {
            int val = attr->receivetimeout;
    ed11:	89 45 e0             	mov    %eax,-0x20(%rbp)
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_RCVTIMEO,
    ed14:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    ed1a:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
    ed1e:	ba 06 10 00 00       	mov    $0x1006,%edx
    ed23:	be ff ff 00 00       	mov    $0xffff,%esi
    ed28:	49 63 fc             	movslq %r12d,%rdi
    ed2b:	89 d8                	mov    %ebx,%eax
    ed2d:	cd 80                	int    $0x80
    ed2f:	48 89 c1             	mov    %rax,%rcx
    ed32:	bb 00 00 00 00       	mov    $0x0,%ebx
    ed37:	83 d3 00             	adc    $0x0,%ebx
    ed3a:	31 d2                	xor    %edx,%edx
    ed3c:	85 db                	test   %ebx,%ebx
    ed3e:	0f 95 c2             	setne  %dl
    ed41:	48 89 d0             	mov    %rdx,%rax
    ed44:	48 f7 d8             	neg    %rax
    ed47:	48 31 c8             	xor    %rcx,%rax
    ed4a:	48 01 c2             	add    %rax,%rdx
                                 &val, sizeof(int));

            if (IS_ERR(ret))
    ed4d:	85 d2                	test   %edx,%edx
    ed4f:	0f 88 3b 02 00 00    	js     ef90 <socket_attrsetbyhdl+0x480>
                return unix_to_pal_error(ERRNO(ret));

            handle->sock.receivetimeout = attr->receivetimeout;
    ed55:	49 8b 42 58          	mov    0x58(%r10),%rax
    ed59:	49 89 41 40          	mov    %rax,0x40(%r9)
        }

        if (attr->sendtimeout != handle->sock.sendtimeout) {
    ed5d:	49 8b 42 60          	mov    0x60(%r10),%rax
    ed61:	49 3b 41 48          	cmp    0x48(%r9),%rax
    ed65:	74 51                	je     edb8 <socket_attrsetbyhdl+0x2a8>
            int val = attr->sendtimeout;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_SNDTIMEO,
    ed67:	bb 69 00 00 00       	mov    $0x69,%ebx

            handle->sock.receivetimeout = attr->receivetimeout;
        }

        if (attr->sendtimeout != handle->sock.sendtimeout) {
            int val = attr->sendtimeout;
    ed6c:	89 45 e0             	mov    %eax,-0x20(%rbp)
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_SNDTIMEO,
    ed6f:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    ed75:	48 8d 4d e0          	lea    -0x20(%rbp),%rcx
    ed79:	ba 05 10 00 00       	mov    $0x1005,%edx
    ed7e:	be ff ff 00 00       	mov    $0xffff,%esi
    ed83:	49 63 fc             	movslq %r12d,%rdi
    ed86:	89 d8                	mov    %ebx,%eax
    ed88:	cd 80                	int    $0x80
    ed8a:	48 89 c1             	mov    %rax,%rcx
    ed8d:	bb 00 00 00 00       	mov    $0x0,%ebx
    ed92:	83 d3 00             	adc    $0x0,%ebx
    ed95:	31 d2                	xor    %edx,%edx
    ed97:	85 db                	test   %ebx,%ebx
    ed99:	0f 95 c2             	setne  %dl
    ed9c:	48 89 d0             	mov    %rdx,%rax
    ed9f:	48 f7 d8             	neg    %rax
    eda2:	48 31 c8             	xor    %rcx,%rax
    eda5:	48 01 c2             	add    %rax,%rdx
                                 &val, sizeof(int));

            if (IS_ERR(ret))
    eda8:	85 d2                	test   %edx,%edx
    edaa:	0f 88 00 02 00 00    	js     efb0 <socket_attrsetbyhdl+0x4a0>
                return unix_to_pal_error(ERRNO(ret));

            handle->sock.sendtimeout = attr->sendtimeout;
    edb0:	49 8b 42 60          	mov    0x60(%r10),%rax
    edb4:	49 89 41 48          	mov    %rax,0x48(%r9)
        }
    }

    if (handle->__in.type == pal_type_tcp ||
    edb8:	41 8b 01             	mov    (%r9),%eax
    edbb:	83 e8 08             	sub    $0x8,%eax
    edbe:	83 f8 01             	cmp    $0x1,%eax
    edc1:	76 0d                	jbe    edd0 <socket_attrsetbyhdl+0x2c0>

            handle->sock.tcp_nodelay = attr->tcp_nodelay;
        }
    }

    return 0;
    edc3:	31 c0                	xor    %eax,%eax
}
    edc5:	5b                   	pop    %rbx
    edc6:	41 5c                	pop    %r12
    edc8:	5d                   	pop    %rbp
    edc9:	c3                   	retq   
    edca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    }

    if (handle->__in.type == pal_type_tcp ||
        handle->__in.type == pal_type_tcpsrv) {

        if (attr->tcp_cork != handle->sock.tcp_cork) {
    edd0:	41 0f b6 42 68       	movzbl 0x68(%r10),%eax
    edd5:	41 3a 41 50          	cmp    0x50(%r9),%al
    edd9:	74 52                	je     ee2d <socket_attrsetbyhdl+0x31d>
            val = attr->tcp_cork ? 1 : 0;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_TCP, TCP_CORK,
    eddb:	bb 69 00 00 00       	mov    $0x69,%ebx

    if (handle->__in.type == pal_type_tcp ||
        handle->__in.type == pal_type_tcpsrv) {

        if (attr->tcp_cork != handle->sock.tcp_cork) {
            val = attr->tcp_cork ? 1 : 0;
    ede0:	89 45 dc             	mov    %eax,-0x24(%rbp)
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_TCP, TCP_CORK,
    ede3:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    ede9:	48 8d 4d dc          	lea    -0x24(%rbp),%rcx
    eded:	ba 04 00 00 00       	mov    $0x4,%edx
    edf2:	be 06 00 00 00       	mov    $0x6,%esi
    edf7:	49 63 fc             	movslq %r12d,%rdi
    edfa:	89 d8                	mov    %ebx,%eax
    edfc:	cd 80                	int    $0x80
    edfe:	48 89 c1             	mov    %rax,%rcx
    ee01:	bb 00 00 00 00       	mov    $0x0,%ebx
    ee06:	83 d3 00             	adc    $0x0,%ebx
    ee09:	31 d2                	xor    %edx,%edx
    ee0b:	85 db                	test   %ebx,%ebx
    ee0d:	0f 95 c2             	setne  %dl
    ee10:	48 89 d0             	mov    %rdx,%rax
    ee13:	48 f7 d8             	neg    %rax
    ee16:	48 31 c8             	xor    %rcx,%rax
    ee19:	48 01 c2             	add    %rax,%rdx
                                 &val, sizeof(int));

            if (IS_ERR(ret))
    ee1c:	85 d2                	test   %edx,%edx
    ee1e:	0f 88 3c 05 00 00    	js     f360 <socket_attrsetbyhdl+0x850>
                return unix_to_pal_error(ERRNO(ret));

            handle->sock.tcp_cork = attr->tcp_cork;
    ee24:	41 0f b6 42 68       	movzbl 0x68(%r10),%eax
    ee29:	41 88 41 50          	mov    %al,0x50(%r9)
        }

        if (attr->tcp_keepalive != handle->sock.tcp_keepalive) {
    ee2d:	41 0f b6 42 69       	movzbl 0x69(%r10),%eax
    ee32:	41 3a 41 51          	cmp    0x51(%r9),%al
    ee36:	74 52                	je     ee8a <socket_attrsetbyhdl+0x37a>
            val = attr->tcp_keepalive ? 1 : 0;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_KEEPALIVE,
    ee38:	bb 69 00 00 00       	mov    $0x69,%ebx

            handle->sock.tcp_cork = attr->tcp_cork;
        }

        if (attr->tcp_keepalive != handle->sock.tcp_keepalive) {
            val = attr->tcp_keepalive ? 1 : 0;
    ee3d:	89 45 dc             	mov    %eax,-0x24(%rbp)
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_KEEPALIVE,
    ee40:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    ee46:	48 8d 4d dc          	lea    -0x24(%rbp),%rcx
    ee4a:	ba 08 00 00 00       	mov    $0x8,%edx
    ee4f:	be ff ff 00 00       	mov    $0xffff,%esi
    ee54:	49 63 fc             	movslq %r12d,%rdi
    ee57:	89 d8                	mov    %ebx,%eax
    ee59:	cd 80                	int    $0x80
    ee5b:	48 89 c1             	mov    %rax,%rcx
    ee5e:	bb 00 00 00 00       	mov    $0x0,%ebx
    ee63:	83 d3 00             	adc    $0x0,%ebx
    ee66:	31 d2                	xor    %edx,%edx
    ee68:	85 db                	test   %ebx,%ebx
    ee6a:	0f 95 c2             	setne  %dl
    ee6d:	48 89 d0             	mov    %rdx,%rax
    ee70:	48 f7 d8             	neg    %rax
    ee73:	48 31 c8             	xor    %rcx,%rax
    ee76:	48 01 c2             	add    %rax,%rdx
                                 &val, sizeof(int));

            if (IS_ERR(ret))
    ee79:	85 d2                	test   %edx,%edx
    ee7b:	0f 88 74 05 00 00    	js     f3f5 <socket_attrsetbyhdl+0x8e5>
                return unix_to_pal_error(ERRNO(ret));

            handle->sock.tcp_keepalive = attr->tcp_keepalive;
    ee81:	41 0f b6 42 69       	movzbl 0x69(%r10),%eax
    ee86:	41 88 41 51          	mov    %al,0x51(%r9)
        }

        if (attr->tcp_nodelay != handle->sock.tcp_nodelay) {
    ee8a:	41 0f b6 42 6a       	movzbl 0x6a(%r10),%eax
    ee8f:	41 3a 41 52          	cmp    0x52(%r9),%al
    ee93:	0f 84 2a ff ff ff    	je     edc3 <socket_attrsetbyhdl+0x2b3>
            val = attr->tcp_nodelay ? 1 : 0;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_TCP, TCP_NODELAY,
    ee99:	bb 69 00 00 00       	mov    $0x69,%ebx

            handle->sock.tcp_keepalive = attr->tcp_keepalive;
        }

        if (attr->tcp_nodelay != handle->sock.tcp_nodelay) {
            val = attr->tcp_nodelay ? 1 : 0;
    ee9e:	89 45 dc             	mov    %eax,-0x24(%rbp)
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_TCP, TCP_NODELAY,
    eea1:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    eea7:	48 8d 4d dc          	lea    -0x24(%rbp),%rcx
    eeab:	ba 01 00 00 00       	mov    $0x1,%edx
    eeb0:	be 06 00 00 00       	mov    $0x6,%esi
    eeb5:	49 63 fc             	movslq %r12d,%rdi
    eeb8:	89 d8                	mov    %ebx,%eax
    eeba:	cd 80                	int    $0x80
    eebc:	48 89 c1             	mov    %rax,%rcx
    eebf:	bb 00 00 00 00       	mov    $0x0,%ebx
    eec4:	83 d3 00             	adc    $0x0,%ebx
    eec7:	31 d2                	xor    %edx,%edx
    eec9:	85 db                	test   %ebx,%ebx
    eecb:	0f 95 c2             	setne  %dl
    eece:	48 89 d0             	mov    %rdx,%rax
    eed1:	48 f7 d8             	neg    %rax
    eed4:	48 31 c8             	xor    %rcx,%rax
    eed7:	48 01 c2             	add    %rax,%rdx
                                 &val, sizeof(int));

            if (IS_ERR(ret))
    eeda:	85 d2                	test   %edx,%edx
    eedc:	0f 88 ae 05 00 00    	js     f490 <socket_attrsetbyhdl+0x980>
                return unix_to_pal_error(ERRNO(ret));

            handle->sock.tcp_nodelay = attr->tcp_nodelay;
    eee2:	41 0f b6 42 6a       	movzbl 0x6a(%r10),%eax
    eee7:	41 88 41 52          	mov    %al,0x52(%r9)
        }
    }

    return 0;
    eeeb:	31 c0                	xor    %eax,%eax
    eeed:	e9 d3 fe ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        val = attr->reuseaddr ? 1 : 0;
        ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_REUSEADDR,
                             &val, sizeof(int));

        if (IS_ERR(ret))
            return unix_to_pal_error(ERRNO(ret));
    eef2:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    eef4:	83 fa 6e             	cmp    $0x6e,%edx
    eef7:	0f 87 db 02 00 00    	ja     f1d8 <socket_attrsetbyhdl+0x6c8>
    eefd:	48 8d 05 d0 d6 00 00 	lea    0xd6d0(%rip),%rax        # 1c5d4 <slab_levels+0x3334>
    ef04:	89 d2                	mov    %edx,%edx
    ef06:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    ef0a:	48 01 d0             	add    %rdx,%rax
    ef0d:	ff e0                	jmpq   *%rax
    ef0f:	90                   	nop    
    if (attr->nonblocking != handle->sock.nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, fd, F_SETFL,
                             attr->nonblocking ? O_NONBLOCK : 0);

        if (IS_ERR(ret))
            return unix_to_pal_error(ERRNO(ret));
    ef10:	f7 da                	neg    %edx
    ef12:	83 fa 6e             	cmp    $0x6e,%edx
    ef15:	0f 87 45 02 00 00    	ja     f160 <socket_attrsetbyhdl+0x650>
    ef1b:	48 8d 05 6e d8 00 00 	lea    0xd86e(%rip),%rax        # 1c790 <slab_levels+0x34f0>
    ef22:	89 d2                	mov    %edx,%edx
    ef24:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    ef28:	48 01 d0             	add    %rdx,%rax
    ef2b:	ff e0                	jmpq   *%rax
    ef2d:	0f 1f 00             	nopl   (%rax)
            l.l_linger = attr->linger;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_LINGER,
                                 &l, sizeof(struct __kernel_linger));

            if (IS_ERR(ret))
                return unix_to_pal_error(ERRNO(ret));
    ef30:	f7 da                	neg    %edx
    ef32:	83 fa 6e             	cmp    $0x6e,%edx
    ef35:	0f 87 f1 03 00 00    	ja     f32c <socket_attrsetbyhdl+0x81c>
    ef3b:	48 8d 05 0a da 00 00 	lea    0xda0a(%rip),%rax        # 1c94c <slab_levels+0x36ac>
    ef42:	89 d2                	mov    %edx,%edx
    ef44:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    ef48:	48 01 d0             	add    %rdx,%rax
    ef4b:	ff e0                	jmpq   *%rax
    ef4d:	0f 1f 00             	nopl   (%rax)
            int val = attr->receivebuf;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_RCVBUF,
                                 &val, sizeof(int));

            if (IS_ERR(ret))
                return unix_to_pal_error(ERRNO(ret));
    ef50:	f7 da                	neg    %edx
    ef52:	83 fa 6e             	cmp    $0x6e,%edx
    ef55:	0f 87 db 03 00 00    	ja     f336 <socket_attrsetbyhdl+0x826>
    ef5b:	48 8d 05 a6 db 00 00 	lea    0xdba6(%rip),%rax        # 1cb08 <slab_levels+0x3868>
    ef62:	89 d2                	mov    %edx,%edx
    ef64:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    ef68:	48 01 d0             	add    %rdx,%rax
    ef6b:	ff e0                	jmpq   *%rax
    ef6d:	0f 1f 00             	nopl   (%rax)
            int val = attr->sendbuf;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_SNDBUF,
                                 &val, sizeof(int));

            if (IS_ERR(ret))
                return unix_to_pal_error(ERRNO(ret));
    ef70:	f7 da                	neg    %edx
    ef72:	83 fa 6e             	cmp    $0x6e,%edx
    ef75:	0f 87 c5 03 00 00    	ja     f340 <socket_attrsetbyhdl+0x830>
    ef7b:	48 8d 05 42 dd 00 00 	lea    0xdd42(%rip),%rax        # 1ccc4 <slab_levels+0x3a24>
    ef82:	89 d2                	mov    %edx,%edx
    ef84:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    ef88:	48 01 d0             	add    %rdx,%rax
    ef8b:	ff e0                	jmpq   *%rax
    ef8d:	0f 1f 00             	nopl   (%rax)
            int val = attr->receivetimeout;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_RCVTIMEO,
                                 &val, sizeof(int));

            if (IS_ERR(ret))
                return unix_to_pal_error(ERRNO(ret));
    ef90:	f7 da                	neg    %edx
    ef92:	83 fa 6e             	cmp    $0x6e,%edx
    ef95:	0f 87 af 03 00 00    	ja     f34a <socket_attrsetbyhdl+0x83a>
    ef9b:	48 8d 05 de de 00 00 	lea    0xdede(%rip),%rax        # 1ce80 <slab_levels+0x3be0>
    efa2:	89 d2                	mov    %edx,%edx
    efa4:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    efa8:	48 01 d0             	add    %rdx,%rax
    efab:	ff e0                	jmpq   *%rax
    efad:	0f 1f 00             	nopl   (%rax)
            int val = attr->sendtimeout;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_SNDTIMEO,
                                 &val, sizeof(int));

            if (IS_ERR(ret))
                return unix_to_pal_error(ERRNO(ret));
    efb0:	f7 da                	neg    %edx
    efb2:	83 fa 6e             	cmp    $0x6e,%edx
    efb5:	0f 87 99 03 00 00    	ja     f354 <socket_attrsetbyhdl+0x844>
    efbb:	48 8d 05 7a e0 00 00 	lea    0xe07a(%rip),%rax        # 1d03c <slab_levels+0x3d9c>
    efc2:	89 d2                	mov    %edx,%edx
    efc4:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    efc8:	48 01 d0             	add    %rdx,%rax
    efcb:	ff e0                	jmpq   *%rax
    efcd:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    efd0:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    efd5:	e9 eb fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    efda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    efe0:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    efe5:	e9 db fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    efea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    eff0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    eff5:	e9 cb fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    effa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f000:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f005:	e9 bb fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f00a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f010:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f015:	e9 ab fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f01a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f020:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f025:	e9 9b fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f02a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f030:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f035:	e9 8b fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f03a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f040:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f045:	e9 7b fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f04a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f050:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f055:	e9 6b fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f05a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f060:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f065:	e9 5b fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f06a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f070:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f075:	e9 4b fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    f07a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    f07f:	e9 41 fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    f084:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f089:	e9 37 fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f08e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f093:	e9 2d fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f098:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f09d:	e9 23 fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f0a2:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f0a7:	e9 19 fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f0ac:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f0b1:	e9 0f fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f0b6:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f0bb:	e9 05 fd ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f0c0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f0c5:	e9 fb fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f0ca:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f0cf:	e9 f1 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f0d4:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f0d9:	e9 e7 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    f0de:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f0e3:	e9 dd fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    f0e8:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    f0ed:	e9 d3 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    f0f2:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f0f7:	e9 c9 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    f0fc:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f101:	e9 bf fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f106:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f10b:	e9 b5 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f110:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f115:	e9 ab fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f11a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f11f:	e9 a1 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f124:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f129:	e9 97 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f12e:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f133:	e9 8d fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f138:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f13d:	e9 83 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f142:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f147:	e9 79 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f14c:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f151:	e9 6f fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f156:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    f15d:	00 00 00 
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    f160:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f165:	e9 5b fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    f16a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    f16f:	e9 51 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    f174:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f179:	e9 47 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f17e:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f183:	e9 3d fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f188:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f18d:	e9 33 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f192:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f197:	e9 29 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f19c:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f1a1:	e9 1f fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    f1a6:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f1ab:	e9 15 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f1b0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f1b5:	e9 0b fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f1ba:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f1bf:	e9 01 fc ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f1c4:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f1c9:	e9 f7 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f1ce:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f1d3:	e9 ed fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    f1d8:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f1dd:	e9 e3 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    f1e2:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    f1e7:	e9 d9 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    f1ec:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f1f1:	e9 cf fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f1f6:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f1fb:	e9 c5 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f200:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f205:	e9 bb fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f20a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f20f:	e9 b1 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f214:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f219:	e9 a7 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f21e:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f223:	e9 9d fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f228:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f22d:	e9 93 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f232:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f237:	e9 89 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f23c:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f241:	e9 7f fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    f246:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f24b:	e9 75 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    f250:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    f255:	e9 6b fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    f25a:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f25f:	e9 61 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f264:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f269:	e9 57 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f26e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f273:	e9 4d fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f278:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f27d:	e9 43 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f282:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f287:	e9 39 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    f28c:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f291:	e9 2f fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f296:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f29b:	e9 25 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f2a0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f2a5:	e9 1b fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f2aa:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f2af:	e9 11 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f2b4:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f2b9:	e9 07 fb ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    f2be:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    f2c3:	e9 fd fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f2c8:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f2cd:	e9 f3 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    f2d2:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f2d7:	e9 e9 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f2dc:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f2e1:	e9 df fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f2e6:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f2eb:	e9 d5 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f2f0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f2f5:	e9 cb fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f2fa:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f2ff:	e9 c1 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    f304:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f309:	e9 b7 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f30e:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f313:	e9 ad fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f318:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f31d:	e9 a3 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f322:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f327:	e9 99 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    f32c:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f331:	e9 8f fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f336:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f33b:	e9 85 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f340:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f345:	e9 7b fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f34a:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f34f:	e9 71 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f354:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f359:	e9 67 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f35e:	66 90                	xchg   %ax,%ax
            val = attr->tcp_cork ? 1 : 0;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_TCP, TCP_CORK,
                                 &val, sizeof(int));

            if (IS_ERR(ret))
                return unix_to_pal_error(ERRNO(ret));
    f360:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    f362:	83 fa 6e             	cmp    $0x6e,%edx
    f365:	0f 87 80 00 00 00    	ja     f3eb <socket_attrsetbyhdl+0x8db>
    f36b:	48 8d 05 86 de 00 00 	lea    0xde86(%rip),%rax        # 1d1f8 <slab_levels+0x3f58>
    f372:	89 d2                	mov    %edx,%edx
    f374:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    f378:	48 01 d0             	add    %rdx,%rax
    f37b:	ff e0                	jmpq   *%rax
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    f37d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    f382:	e9 3e fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    f387:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f38c:	e9 34 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f391:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f396:	e9 2a fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f39b:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f3a0:	e9 20 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f3a5:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f3aa:	e9 16 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f3af:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f3b4:	e9 0c fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f3b9:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f3be:	e9 02 fa ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f3c3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f3c8:	e9 f8 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f3cd:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f3d2:	e9 ee f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f3d7:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f3dc:	e9 e4 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    f3e1:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f3e6:	e9 da f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    f3eb:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f3f0:	e9 d0 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            val = attr->tcp_keepalive ? 1 : 0;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_KEEPALIVE,
                                 &val, sizeof(int));

            if (IS_ERR(ret))
                return unix_to_pal_error(ERRNO(ret));
    f3f5:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    f3f7:	83 fa 6e             	cmp    $0x6e,%edx
    f3fa:	0f 87 80 00 00 00    	ja     f480 <socket_attrsetbyhdl+0x970>
    f400:	48 8d 05 ad df 00 00 	lea    0xdfad(%rip),%rax        # 1d3b4 <slab_levels+0x4114>
    f407:	89 d2                	mov    %edx,%edx
    f409:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    f40d:	48 01 d0             	add    %rdx,%rax
    f410:	ff e0                	jmpq   *%rax
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    f412:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f417:	e9 a9 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f41c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f421:	e9 9f f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f426:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f42b:	e9 95 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f430:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f435:	e9 8b f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f43a:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f43f:	e9 81 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f444:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f449:	e9 77 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f44e:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f453:	e9 6d f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f458:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f45d:	e9 63 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f462:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f467:	e9 59 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    f46c:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    f471:	e9 4f f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    f476:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f47b:	e9 45 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    f480:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f485:	e9 3b f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f48a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            val = attr->tcp_nodelay ? 1 : 0;
            ret = INLINE_SYSCALL(setsockopt, 5, fd, SOL_TCP, TCP_NODELAY,
                                 &val, sizeof(int));

            if (IS_ERR(ret))
                return unix_to_pal_error(ERRNO(ret));
    f490:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
    f492:	83 fa 6e             	cmp    $0x6e,%edx
    f495:	0f 87 80 00 00 00    	ja     f51b <socket_attrsetbyhdl+0xa0b>
    f49b:	48 8d 05 ce e0 00 00 	lea    0xe0ce(%rip),%rax        # 1d570 <slab_levels+0x42d0>
    f4a2:	89 d2                	mov    %edx,%edx
    f4a4:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    f4a8:	48 01 d0             	add    %rdx,%rax
    f4ab:	ff e0                	jmpq   *%rax
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
    f4ad:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    f4b2:	e9 0e f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
    f4b7:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
    f4bc:	e9 04 f9 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
    f4c1:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    f4c6:	e9 fa f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
    f4cb:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
    f4d0:	e9 f0 f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
    f4d5:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    f4da:	e9 e6 f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
    f4df:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
    f4e4:	e9 dc f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
    f4e9:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
    f4ee:	e9 d2 f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
    f4f3:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
    f4f8:	e9 c8 f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
    f4fd:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    f502:	e9 be f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
    f507:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f50c:	e9 b4 f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
    f511:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
    f516:	e9 aa f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
    f51b:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    f520:	e9 a0 f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
}

static int socket_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR  * attr)
{
    if (handle->sock.fd == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
    f525:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
    f52a:	e9 96 f8 ff ff       	jmpq   edc5 <socket_attrsetbyhdl+0x2b5>
    f52f:	90                   	nop    

000000000000f530 <_DkBroadcastStreamOpen>:
    handle->mcast.nonblocking = PAL_FALSE;
    return 0;
}

PAL_HANDLE _DkBroadcastStreamOpen (int port)
{
    f530:	55                   	push   %rbp
    f531:	48 89 e5             	mov    %rsp,%rbp
    f534:	41 57                	push   %r15
    f536:	41 56                	push   %r14
    f538:	41 55                	push   %r13
    f53a:	41 54                	push   %r12
    f53c:	41 89 fe             	mov    %edi,%r14d
    f53f:	53                   	push   %rbx
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file));
    f540:	bf 28 00 00 00       	mov    $0x28,%edi
static int mcast_s (PAL_HANDLE handle, int port)
{
    handle->mcast.srv = PAL_IDX_POISON;
    int ret = 0;

    int fd = INLINE_SYSCALL(socket, 3, AF_INET, SOCK_DGRAM, 0);
    f545:	bb 61 00 00 00       	mov    $0x61,%ebx
    handle->mcast.nonblocking = PAL_FALSE;
    return 0;
}

PAL_HANDLE _DkBroadcastStreamOpen (int port)
{
    f54a:	48 83 ec 48          	sub    $0x48,%rsp
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file));
    f54e:	e8 ad 94 ff ff       	callq  8a00 <malloc>
static int mcast_s (PAL_HANDLE handle, int port)
{
    handle->mcast.srv = PAL_IDX_POISON;
    int ret = 0;

    int fd = INLINE_SYSCALL(socket, 3, AF_INET, SOCK_DGRAM, 0);
    f553:	31 d2                	xor    %edx,%edx
    return 0;
}

PAL_HANDLE _DkBroadcastStreamOpen (int port)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file));
    f555:	49 89 c4             	mov    %rax,%r12
    SET_HANDLE_TYPE(hdl, mcast);
    f558:	c7 00 0d 00 00 00    	movl   $0xd,(%rax)
    f55e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    f565:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
static int mcast_s (PAL_HANDLE handle, int port)
{
    handle->mcast.srv = PAL_IDX_POISON;
    int ret = 0;

    int fd = INLINE_SYSCALL(socket, 3, AF_INET, SOCK_DGRAM, 0);
    f56c:	be 02 00 00 00       	mov    $0x2,%esi
        .attrsetbyhdl   = &socket_attrsetbyhdl,
    };

static int mcast_s (PAL_HANDLE handle, int port)
{
    handle->mcast.srv = PAL_IDX_POISON;
    f571:	c7 40 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rax)
    int ret = 0;

    int fd = INLINE_SYSCALL(socket, 3, AF_INET, SOCK_DGRAM, 0);
    f578:	bf 02 00 00 00       	mov    $0x2,%edi
    f57d:	89 d8                	mov    %ebx,%eax
    f57f:	cd 80                	int    $0x80
    f581:	48 89 c2             	mov    %rax,%rdx
    f584:	bb 00 00 00 00       	mov    $0x0,%ebx
    f589:	83 d3 00             	adc    $0x0,%ebx
    f58c:	31 c9                	xor    %ecx,%ecx
    f58e:	85 db                	test   %ebx,%ebx
    f590:	0f 95 c1             	setne  %cl
    f593:	48 89 c8             	mov    %rcx,%rax
    f596:	48 f7 d8             	neg    %rax
    f599:	48 31 d0             	xor    %rdx,%rax
    f59c:	4c 8d 0c 08          	lea    (%rax,%rcx,1),%r9

    if (IS_ERR(fd))
    f5a0:	45 85 c9             	test   %r9d,%r9d
    f5a3:	78 52                	js     f5f7 <_DkBroadcastStreamOpen+0xc7>
        return -PAL_ERROR_DENIED;

    struct in_addr local;
    local.s_addr  = INADDR_ANY;
    ret = INLINE_SYSCALL(setsockopt, 5, fd, IPPROTO_IP, IP_MULTICAST_IF,
    f5a5:	bb 69 00 00 00       	mov    $0x69,%ebx

    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;

    struct in_addr local;
    local.s_addr  = INADDR_ANY;
    f5aa:	c7 45 c0 00 00 00 00 	movl   $0x0,-0x40(%rbp)
    ret = INLINE_SYSCALL(setsockopt, 5, fd, IPPROTO_IP, IP_MULTICAST_IF,
    f5b1:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    f5b7:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
    f5bb:	ba 09 00 00 00       	mov    $0x9,%edx
    f5c0:	40 30 f6             	xor    %sil,%sil
    f5c3:	49 63 f9             	movslq %r9d,%rdi
    f5c6:	89 d8                	mov    %ebx,%eax
    f5c8:	cd 80                	int    $0x80
    f5ca:	48 89 c2             	mov    %rax,%rdx
    f5cd:	bb 00 00 00 00       	mov    $0x0,%ebx
    f5d2:	83 d3 00             	adc    $0x0,%ebx
    f5d5:	31 c9                	xor    %ecx,%ecx
    f5d7:	85 db                	test   %ebx,%ebx
    f5d9:	0f 95 c1             	setne  %cl
    f5dc:	48 89 c8             	mov    %rcx,%rax
    f5df:	48 f7 d8             	neg    %rax
    f5e2:	48 31 d0             	xor    %rdx,%rax
                         &local, sizeof(local));
    if (IS_ERR(ret))
    f5e5:	01 c8                	add    %ecx,%eax
    f5e7:	78 0e                	js     f5f7 <_DkBroadcastStreamOpen+0xc7>
        return -PAL_ERROR_DENIED;

    handle->__in.flags |= WFD(1)|WRITEABLE(1);
    f5e9:	41 81 4c 24 08 90 00 	orl    $0x90,0x8(%r12)
    f5f0:	00 00 
    handle->mcast.srv = fd;
    f5f2:	45 89 4c 24 10       	mov    %r9d,0x10(%r12)
static int mcast_c (PAL_HANDLE handle, int port)
{
    handle->mcast.cli = PAL_IDX_POISON;
    int ret = 0;

    int fd = INLINE_SYSCALL(socket, 3, AF_INET, SOCK_DGRAM, 0);
    f5f7:	bb 61 00 00 00       	mov    $0x61,%ebx
    return 0;
}

static int mcast_c (PAL_HANDLE handle, int port)
{
    handle->mcast.cli = PAL_IDX_POISON;
    f5fc:	41 c7 44 24 0c ff ff 	movl   $0xffffffff,0xc(%r12)
    f603:	ff ff 
    int ret = 0;

    int fd = INLINE_SYSCALL(socket, 3, AF_INET, SOCK_DGRAM, 0);
    f605:	31 d2                	xor    %edx,%edx
    f607:	be 02 00 00 00       	mov    $0x2,%esi
    f60c:	bf 02 00 00 00       	mov    $0x2,%edi
    f611:	89 d8                	mov    %ebx,%eax
    f613:	cd 80                	int    $0x80
    f615:	48 89 c2             	mov    %rax,%rdx
    f618:	bb 00 00 00 00       	mov    $0x0,%ebx
    f61d:	83 d3 00             	adc    $0x0,%ebx
    f620:	31 c9                	xor    %ecx,%ecx
    f622:	85 db                	test   %ebx,%ebx
    f624:	0f 95 c1             	setne  %cl
    f627:	48 89 c8             	mov    %rcx,%rax
    f62a:	48 f7 d8             	neg    %rax
    f62d:	48 31 d0             	xor    %rdx,%rax
    f630:	4c 8d 3c 08          	lea    (%rax,%rcx,1),%r15

    if (IS_ERR(fd))
    f634:	45 85 ff             	test   %r15d,%r15d
    f637:	0f 88 1f 01 00 00    	js     f75c <_DkBroadcastStreamOpen+0x22c>
        return -PAL_ERROR_DENIED;

    int reuse = 1;
    INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_REUSEADDR,
    f63d:	4d 63 cf             	movslq %r15d,%r9
    f640:	41 bd 69 00 00 00    	mov    $0x69,%r13d
    int fd = INLINE_SYSCALL(socket, 3, AF_INET, SOCK_DGRAM, 0);

    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;

    int reuse = 1;
    f646:	c7 45 ac 01 00 00 00 	movl   $0x1,-0x54(%rbp)
    INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_REUSEADDR,
    f64d:	41 b8 04 00 00 00    	mov    $0x4,%r8d
    f653:	48 8d 4d ac          	lea    -0x54(%rbp),%rcx
    f657:	ba 04 00 00 00       	mov    $0x4,%edx
    f65c:	66 be ff ff          	mov    $0xffff,%si
    f660:	4c 89 cf             	mov    %r9,%rdi
    f663:	44 89 e8             	mov    %r13d,%eax
    f666:	cd 80                	int    $0x80
    f668:	bb 00 00 00 00       	mov    $0x0,%ebx
    f66d:	83 d3 00             	adc    $0x0,%ebx
    f670:	44 89 f0             	mov    %r14d,%eax

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port = htons(port);
    ret = INLINE_SYSCALL(bind, 3, fd, &addr, sizeof(addr));
    f673:	bb 68 00 00 00       	mov    $0x68,%ebx
    int reuse = 1;
    INLINE_SYSCALL(setsockopt, 5, fd, SOL_SOCKET, SO_REUSEADDR,
                   &reuse, sizeof(reuse));

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    f678:	c6 45 c1 02          	movb   $0x2,-0x3f(%rbp)
    f67c:	66 c1 c0 08          	rol    $0x8,%ax
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    f680:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
    addr.sin_port = htons(port);
    ret = INLINE_SYSCALL(bind, 3, fd, &addr, sizeof(addr));
    f687:	b2 10                	mov    $0x10,%dl
    f689:	66 89 45 c2          	mov    %ax,-0x3e(%rbp)
    f68d:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
    f691:	89 d8                	mov    %ebx,%eax
    f693:	cd 80                	int    $0x80
    f695:	48 89 c2             	mov    %rax,%rdx
    f698:	bb 00 00 00 00       	mov    $0x0,%ebx
    f69d:	83 d3 00             	adc    $0x0,%ebx
    f6a0:	31 c9                	xor    %ecx,%ecx
    f6a2:	85 db                	test   %ebx,%ebx
    f6a4:	0f 95 c1             	setne  %cl
    f6a7:	48 89 c8             	mov    %rcx,%rax
    f6aa:	48 f7 d8             	neg    %rax
    f6ad:	48 31 d0             	xor    %rdx,%rax
    if (IS_ERR(ret))
    f6b0:	01 c8                	add    %ecx,%eax
    f6b2:	0f 88 a4 00 00 00    	js     f75c <_DkBroadcastStreamOpen+0x22c>
        return -PAL_ERROR_DENIED;

    struct in_addr local;
    local.s_addr = INADDR_ANY;
    f6b8:	c7 45 a0 00 00 00 00 	movl   $0x0,-0x60(%rbp)
    ret = INLINE_SYSCALL(setsockopt, 5, fd, IPPROTO_IP, IP_MULTICAST_IF,
    f6bf:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
    f6c3:	ba 09 00 00 00       	mov    $0x9,%edx
    f6c8:	31 f6                	xor    %esi,%esi
    f6ca:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    f6ce:	44 89 e8             	mov    %r13d,%eax
    f6d1:	cd 80                	int    $0x80
    f6d3:	48 89 c2             	mov    %rax,%rdx
    f6d6:	bb 00 00 00 00       	mov    $0x0,%ebx
    f6db:	83 d3 00             	adc    $0x0,%ebx
    f6de:	31 c0                	xor    %eax,%eax
    f6e0:	85 db                	test   %ebx,%ebx
    f6e2:	0f 95 c0             	setne  %al
    f6e5:	48 89 c1             	mov    %rax,%rcx
    f6e8:	48 f7 d9             	neg    %rcx
    f6eb:	48 31 ca             	xor    %rcx,%rdx
                         &local, sizeof(local));
    if (IS_ERR(ret))
    f6ee:	89 d6                	mov    %edx,%esi
    f6f0:	01 c6                	add    %eax,%esi
    f6f2:	78 68                	js     f75c <_DkBroadcastStreamOpen+0x22c>
        return -PAL_ERROR_DENIED;

    struct ip_mreq group;
    inet_pton(AF_INET, MCAST_GROUP, &group.imr_multiaddr.s_addr);
    f6f4:	48 8d 5d b0          	lea    -0x50(%rbp),%rbx
    f6f8:	48 8d 35 c5 b9 00 00 	lea    0xb9c5(%rip),%rsi        # 1b0c4 <slab_levels+0x1e24>
    f6ff:	bf 02 00 00 00       	mov    $0x2,%edi
    f704:	48 89 da             	mov    %rbx,%rdx
    f707:	e8 24 7c 00 00       	callq  17330 <__inet_pton>
    group.imr_interface.s_addr = htonl(INADDR_ANY);
    ret = INLINE_SYSCALL(setsockopt, 5, fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
    f70c:	4c 8b 4d 98          	mov    -0x68(%rbp),%r9
    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    struct ip_mreq group;
    inet_pton(AF_INET, MCAST_GROUP, &group.imr_multiaddr.s_addr);
    group.imr_interface.s_addr = htonl(INADDR_ANY);
    f710:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
    ret = INLINE_SYSCALL(setsockopt, 5, fd, IPPROTO_IP, IP_ADD_MEMBERSHIP,
    f717:	41 b8 08 00 00 00    	mov    $0x8,%r8d
    f71d:	48 89 d9             	mov    %rbx,%rcx
    f720:	ba 0c 00 00 00       	mov    $0xc,%edx
    f725:	31 f6                	xor    %esi,%esi
    f727:	44 89 e8             	mov    %r13d,%eax
    f72a:	4c 89 cf             	mov    %r9,%rdi
    f72d:	cd 80                	int    $0x80
    f72f:	49 89 c5             	mov    %rax,%r13
    f732:	bb 00 00 00 00       	mov    $0x0,%ebx
    f737:	83 d3 00             	adc    $0x0,%ebx
    f73a:	31 c0                	xor    %eax,%eax
    f73c:	85 db                	test   %ebx,%ebx
    f73e:	0f 95 c0             	setne  %al
    f741:	48 89 c2             	mov    %rax,%rdx
    f744:	48 f7 da             	neg    %rdx
    f747:	49 31 d5             	xor    %rdx,%r13
                         &group, sizeof(group));
    if (IS_ERR(ret))
    f74a:	44 89 eb             	mov    %r13d,%ebx
    f74d:	01 c3                	add    %eax,%ebx
    f74f:	78 0b                	js     f75c <_DkBroadcastStreamOpen+0x22c>
        return -PAL_ERROR_DENIED;

    handle->mcast.cli = fd;
    f751:	45 89 7c 24 0c       	mov    %r15d,0xc(%r12)
    handle->mcast.nonblocking = PAL_FALSE;
    f756:	41 c6 44 24 18 00    	movb   $0x0,0x18(%r12)
{
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file));
    SET_HANDLE_TYPE(hdl, mcast);
    mcast_s(hdl, port);
    mcast_c(hdl, port);
    hdl->mcast.port = port;
    f75c:	45 89 74 24 14       	mov    %r14d,0x14(%r12)
    return hdl;
}
    f761:	48 83 c4 48          	add    $0x48,%rsp
    f765:	4c 89 e0             	mov    %r12,%rax
    f768:	5b                   	pop    %rbx
    f769:	41 5c                	pop    %r12
    f76b:	41 5d                	pop    %r13
    f76d:	41 5e                	pop    %r14
    f76f:	41 5f                	pop    %r15
    f771:	5d                   	pop    %rbp
    f772:	c3                   	retq   
    f773:	90                   	nop    
    f774:	90                   	nop    
    f775:	90                   	nop    
    f776:	90                   	nop    
    f777:	90                   	nop    
    f778:	90                   	nop    
    f779:	90                   	nop    
    f77a:	90                   	nop    
    f77b:	90                   	nop    
    f77c:	90                   	nop    
    f77d:	90                   	nop    
    f77e:	90                   	nop    
    f77f:	90                   	nop    

000000000000f780 <_DkPrintConsole>:
#include <sys/signal.h>
#include <netinet/in.h>
#include <asm-errno.h>

void _DkPrintConsole (const void * buf, int size)
{
    f780:	55                   	push   %rbp
    INLINE_SYSCALL(write, 3, 2, buf, size);
    f781:	48 63 d6             	movslq %esi,%rdx
    f784:	b8 04 00 00 00       	mov    $0x4,%eax
    f789:	48 89 fe             	mov    %rdi,%rsi
    f78c:	bf 02 00 00 00       	mov    $0x2,%edi
#include <sys/signal.h>
#include <netinet/in.h>
#include <asm-errno.h>

void _DkPrintConsole (const void * buf, int size)
{
    f791:	48 89 e5             	mov    %rsp,%rbp
    f794:	53                   	push   %rbx
    INLINE_SYSCALL(write, 3, 2, buf, size);
    f795:	cd 80                	int    $0x80
    f797:	bb 00 00 00 00       	mov    $0x0,%ebx
    f79c:	83 d3 00             	adc    $0x0,%ebx
}
    f79f:	5b                   	pop    %rbx
    f7a0:	5d                   	pop    %rbp
    f7a1:	c3                   	retq   
    f7a2:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
    f7a9:	1f 84 00 00 00 00 00 

000000000000f7b0 <stataccess>:

bool stataccess (struct stat * stat, int acc)
{
    f7b0:	48 8b 15 a9 41 21 00 	mov    0x2141a9(%rip),%rdx        # 223960 <_DYNAMIC+0x178>
    f7b7:	55                   	push   %rbp
    mode_t mode = stat->st_mode;
    f7b8:	0f b7 47 08          	movzwl 0x8(%rdi),%eax
{
    INLINE_SYSCALL(write, 3, 2, buf, size);
}

bool stataccess (struct stat * stat, int acc)
{
    f7bc:	48 89 e5             	mov    %rsp,%rbp
    mode_t mode = stat->st_mode;

    if (pal_linux_config.uid && pal_linux_config.uid == stat->st_uid) {
    f7bf:	8b 4a 04             	mov    0x4(%rdx),%ecx
    f7c2:	85 c9                	test   %ecx,%ecx
    f7c4:	74 1a                	je     f7e0 <stataccess+0x30>
    f7c6:	3b 4f 0c             	cmp    0xc(%rdi),%ecx
    f7c9:	74 21                	je     f7ec <stataccess+0x3c>
        mode >>= 6;
        goto out;
    }

    if (pal_linux_config.gid && pal_linux_config.gid == stat->st_gid) {
    f7cb:	8b 52 08             	mov    0x8(%rdx),%edx
    f7ce:	85 d2                	test   %edx,%edx
    f7d0:	74 1e                	je     f7f0 <stataccess+0x40>
    f7d2:	39 57 10             	cmp    %edx,0x10(%rdi)
    f7d5:	75 19                	jne    f7f0 <stataccess+0x40>
        mode >>= 3;
    f7d7:	66 c1 e8 03          	shr    $0x3,%ax
        goto out;
    f7db:	eb 13                	jmp    f7f0 <stataccess+0x40>
    f7dd:	0f 1f 00             	nopl   (%rax)
    if (pal_linux_config.uid && pal_linux_config.uid == stat->st_uid) {
        mode >>= 6;
        goto out;
    }

    if (pal_linux_config.gid && pal_linux_config.gid == stat->st_gid) {
    f7e0:	8b 52 08             	mov    0x8(%rdx),%edx
    f7e3:	85 d2                	test   %edx,%edx
    f7e5:	74 05                	je     f7ec <stataccess+0x3c>
    f7e7:	3b 57 10             	cmp    0x10(%rdi),%edx
    f7ea:	74 eb                	je     f7d7 <stataccess+0x27>
        mode >>= 3;
        goto out;
    }

    if (!pal_linux_config.uid)
        mode >>= 6;
    f7ec:	66 c1 e8 06          	shr    $0x6,%ax

out:
    return (mode & acc);
    f7f0:	0f b7 c0             	movzwl %ax,%eax
    f7f3:	85 f0                	test   %esi,%eax
    f7f5:	0f 95 c0             	setne  %al
}
    f7f8:	5d                   	pop    %rbp
    f7f9:	c3                   	retq   
    f7fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

000000000000f800 <_DkStreamUnmap>:

/* _DkStreamUnmap for internal use. Unmap stream at certain memory address.
   The memory is unmapped as a whole.*/
int _DkStreamUnmap (void * addr, size_t size)
{
    f800:	55                   	push   %rbp
    f801:	48 89 e5             	mov    %rsp,%rbp
    f804:	53                   	push   %rbx
    /* Just let the kernel tell us if the mapping isn't good. */
    int ret = INLINE_SYSCALL(munmap, 2, addr, size);
    f805:	bb 49 00 00 00       	mov    $0x49,%ebx
    f80a:	89 d8                	mov    %ebx,%eax
    f80c:	cd 80                	int    $0x80
    f80e:	48 89 c1             	mov    %rax,%rcx
    f811:	bb 00 00 00 00       	mov    $0x0,%ebx
    f816:	83 d3 00             	adc    $0x0,%ebx
    f819:	31 d2                	xor    %edx,%edx
    f81b:	85 db                	test   %ebx,%ebx
    f81d:	0f 95 c2             	setne  %dl
    f820:	48 89 d0             	mov    %rdx,%rax
    f823:	48 f7 d8             	neg    %rax
    f826:	48 31 c1             	xor    %rax,%rcx
    f829:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax

    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
}
    f82d:	5b                   	pop    %rbx
    int ret = INLINE_SYSCALL(munmap, 2, addr, size);

    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
    f82e:	c1 f8 1f             	sar    $0x1f,%eax
    f831:	83 e0 fa             	and    $0xfffffffffffffffa,%eax
}
    f834:	5d                   	pop    %rbp
    f835:	c3                   	retq   
    f836:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    f83d:	00 00 00 

000000000000f840 <_DkSendHandle>:
};

/* _DkSendHandle for internal use. Send a Pal Handle over the given
   process handle. Return 1 if success else return negative error code */
int _DkSendHandle (PAL_HANDLE hdl, PAL_HANDLE cargo)
{
    f840:	55                   	push   %rbp
    struct hdl_header hdl_hdr;

    // ~ Check connection PAL_HANDLE - is of process type for sending handle
    // else fail
    if(__PAL_GET_TYPE(hdl) != pal_type_process)
        return -PAL_ERROR_BADHANDLE;
    f841:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
};

/* _DkSendHandle for internal use. Send a Pal Handle over the given
   process handle. Return 1 if success else return negative error code */
int _DkSendHandle (PAL_HANDLE hdl, PAL_HANDLE cargo)
{
    f846:	48 89 e5             	mov    %rsp,%rbp
    f849:	41 57                	push   %r15
    f84b:	41 56                	push   %r14
    f84d:	41 55                	push   %r13
    f84f:	41 54                	push   %r12
    f851:	53                   	push   %rbx
    f852:	48 81 ec c8 00 00 00 	sub    $0xc8,%rsp
    int msg_nfds = 0, fds[2];
    struct hdl_header hdl_hdr;

    // ~ Check connection PAL_HANDLE - is of process type for sending handle
    // else fail
    if(__PAL_GET_TYPE(hdl) != pal_type_process)
    f859:	83 3f 0c             	cmpl   $0xc,(%rdi)
/* _DkSendHandle for internal use. Send a Pal Handle over the given
   process handle. Return 1 if success else return negative error code */
int _DkSendHandle (PAL_HANDLE hdl, PAL_HANDLE cargo)
{
    // Variables to store information for the message
    char * msg_buf[2] = { NULL, NULL };
    f85c:	48 c7 85 40 ff ff ff 	movq   $0x0,-0xc0(%rbp)
    f863:	00 00 00 00 
    int msg_len[2] = { 0, 0 };
    f867:	c7 85 10 ff ff ff 00 	movl   $0x0,-0xf0(%rbp)
    f86e:	00 00 00 
    f871:	c7 85 14 ff ff ff 00 	movl   $0x0,-0xec(%rbp)
    f878:	00 00 00 
    int msg_nfds = 0, fds[2];
    struct hdl_header hdl_hdr;

    // ~ Check connection PAL_HANDLE - is of process type for sending handle
    // else fail
    if(__PAL_GET_TYPE(hdl) != pal_type_process)
    f87b:	0f 85 e9 00 00 00    	jne    f96a <_DkSendHandle+0x12a>

    // ~ Check cargo PAL_HANDLE - is allowed to be sent (White List checking
    // of cargo type)
    // ~ Also, Initialize common parameter formessage passing
    // Channel between parent and child
    switch(__PAL_GET_TYPE(cargo)) {
    f881:	8b 16                	mov    (%rsi),%edx
    f883:	83 fa 11             	cmp    $0x11,%edx
    f886:	0f 87 b4 03 00 00    	ja     fc40 <_DkSendHandle+0x400>
    f88c:	48 8d 05 c5 de 00 00 	lea    0xdec5(%rip),%rax        # 1d758 <slab_levels+0x44b8>
    f893:	89 d1                	mov    %edx,%ecx
    f895:	49 89 f7             	mov    %rsi,%r15
    f898:	49 89 fd             	mov    %rdi,%r13
    f89b:	48 63 0c 88          	movslq (%rax,%rcx,4),%rcx
    f89f:	48 01 c8             	add    %rcx,%rax
    f8a2:	ff e0                	jmpq   *%rax
    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    iov[1].iov_len = msg_len[0] ? : 0;

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    f8a4:	48 63 85 14 ff ff ff 	movslq -0xec(%rbp),%rax
    // Initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);

    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    f8ab:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
    f8b2:	00 
    iov[1].iov_len = msg_len[0] ? : 0;
    f8b3:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
    f8ba:	00 

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    f8bb:	85 c0                	test   %eax,%eax
    f8bd:	0f 84 bd 01 00 00    	je     fa80 <_DkSendHandle+0x240>
    f8c3:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
    iov[2].iov_len = msg_len[1] ? : 0;
    f8ca:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len[0] ? (msg_len[1] ? 3 : 2) : 1;
    f8ce:	b8 01 00 00 00       	mov    $0x1,%eax

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    iov[2].iov_len = msg_len[1] ? : 0;

    hdr.msg_iov = iov;
    f8d3:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    iov[1].iov_len = msg_len[0] ? : 0;

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    f8d7:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    iov[2].iov_len = msg_len[1] ? : 0;

    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len[0] ? (msg_len[1] ? 3 : 2) : 1;
    hdr.msg_control = cbuf; // Control Message Buffer
    hdr.msg_controllen = sizeof(struct cmsghdr) + sizeof(int) * msg_nfds;
    f8db:	49 63 d4             	movslq %r12d,%rdx
    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    iov[2].iov_len = msg_len[1] ? : 0;

    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len[0] ? (msg_len[1] ? 3 : 2) : 1;
    f8de:	89 45 88             	mov    %eax,-0x78(%rbp)
    hdr.msg_control = cbuf; // Control Message Buffer
    f8e1:	48 8d bd 50 ff ff ff 	lea    -0xb0(%rbp),%rdi
    hdr.msg_controllen = sizeof(struct cmsghdr) + sizeof(int) * msg_nfds;
    f8e8:	8d 04 95 0c 00 00 00 	lea    0xc(,%rdx,4),%eax
    chdr->cmsg_type = SCM_RIGHTS; // Protocol Specific Type
    // Length of control message = sizeof(struct cmsghdr) + nfds
    chdr->cmsg_len = CMSG_LEN(sizeof(int) * msg_nfds);

    // Copy the fds below control header
    memcpy(CMSG_DATA(chdr), fds, sizeof(int) * msg_nfds);
    f8ef:	48 8d b5 20 ff ff ff 	lea    -0xe0(%rbp),%rsi
    // Check hdr.msg_controllen >= sizeof(struct cmsghdr) to point to
    // cbuf, which is redundant based on the above code as we have
    // statically allocated memory.
    // or (struct cmsghdr*) cbuf
    chdr = CMSG_FIRSTHDR(&hdr); // Pointer to msg_control
    chdr->cmsg_level = SOL_SOCKET; // Originating Protocol
    f8f6:	c7 85 54 ff ff ff ff 	movl   $0xffff,-0xac(%rbp)
    f8fd:	ff 00 00 
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    iov[2].iov_len = msg_len[1] ? : 0;

    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len[0] ? (msg_len[1] ? 3 : 2) : 1;
    hdr.msg_control = cbuf; // Control Message Buffer
    f900:	48 89 7d 90          	mov    %rdi,-0x70(%rbp)
    chdr->cmsg_type = SCM_RIGHTS; // Protocol Specific Type
    // Length of control message = sizeof(struct cmsghdr) + nfds
    chdr->cmsg_len = CMSG_LEN(sizeof(int) * msg_nfds);

    // Copy the fds below control header
    memcpy(CMSG_DATA(chdr), fds, sizeof(int) * msg_nfds);
    f904:	48 83 c7 10          	add    $0x10,%rdi
    // cbuf, which is redundant based on the above code as we have
    // statically allocated memory.
    // or (struct cmsghdr*) cbuf
    chdr = CMSG_FIRSTHDR(&hdr); // Pointer to msg_control
    chdr->cmsg_level = SOL_SOCKET; // Originating Protocol
    chdr->cmsg_type = SCM_RIGHTS; // Protocol Specific Type
    f908:	c7 85 58 ff ff ff 01 	movl   $0x1,-0xa8(%rbp)
    f90f:	00 00 00 
    iov[2].iov_len = msg_len[1] ? : 0;

    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len[0] ? (msg_len[1] ? 3 : 2) : 1;
    hdr.msg_control = cbuf; // Control Message Buffer
    hdr.msg_controllen = sizeof(struct cmsghdr) + sizeof(int) * msg_nfds;
    f912:	89 45 98             	mov    %eax,-0x68(%rbp)
    // or (struct cmsghdr*) cbuf
    chdr = CMSG_FIRSTHDR(&hdr); // Pointer to msg_control
    chdr->cmsg_level = SOL_SOCKET; // Originating Protocol
    chdr->cmsg_type = SCM_RIGHTS; // Protocol Specific Type
    // Length of control message = sizeof(struct cmsghdr) + nfds
    chdr->cmsg_len = CMSG_LEN(sizeof(int) * msg_nfds);
    f915:	8d 04 95 10 00 00 00 	lea    0x10(,%rdx,4),%eax

    // Copy the fds below control header
    memcpy(CMSG_DATA(chdr), fds, sizeof(int) * msg_nfds);
    f91c:	48 c1 e2 02          	shl    $0x2,%rdx

    // Also, Update main header with control message length (duplicate)
    hdr.msg_controllen = chdr->cmsg_len;

    //  Send message
    ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, 0);
    f920:	bb 1c 00 00 00       	mov    $0x1c,%ebx
    // or (struct cmsghdr*) cbuf
    chdr = CMSG_FIRSTHDR(&hdr); // Pointer to msg_control
    chdr->cmsg_level = SOL_SOCKET; // Originating Protocol
    chdr->cmsg_type = SCM_RIGHTS; // Protocol Specific Type
    // Length of control message = sizeof(struct cmsghdr) + nfds
    chdr->cmsg_len = CMSG_LEN(sizeof(int) * msg_nfds);
    f925:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)

    // Copy the fds below control header
    memcpy(CMSG_DATA(chdr), fds, sizeof(int) * msg_nfds);
    f92b:	e8 50 69 00 00       	callq  16280 <memcpy>

    // Also, Update main header with control message length (duplicate)
    hdr.msg_controllen = chdr->cmsg_len;
    f930:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax

    //  Send message
    ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, 0);
    f936:	31 d2                	xor    %edx,%edx
    f938:	4c 89 f6             	mov    %r14,%rsi
    f93b:	4c 89 ef             	mov    %r13,%rdi

    // Copy the fds below control header
    memcpy(CMSG_DATA(chdr), fds, sizeof(int) * msg_nfds);

    // Also, Update main header with control message length (duplicate)
    hdr.msg_controllen = chdr->cmsg_len;
    f93e:	89 45 98             	mov    %eax,-0x68(%rbp)

    //  Send message
    ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, 0);
    f941:	89 d8                	mov    %ebx,%eax
    f943:	cd 80                	int    $0x80
    f945:	48 89 c2             	mov    %rax,%rdx
    f948:	bb 00 00 00 00       	mov    $0x0,%ebx
    f94d:	83 d3 00             	adc    $0x0,%ebx
    f950:	31 c9                	xor    %ecx,%ecx
    f952:	85 db                	test   %ebx,%ebx
    f954:	0f 95 c1             	setne  %cl
    f957:	48 89 c8             	mov    %rcx,%rax
    f95a:	48 f7 d8             	neg    %rax
    f95d:	48 31 d0             	xor    %rdx,%rax

    return IS_ERR(ret) ? -PAL_ERROR_DENIED : 0;
    f960:	01 c8                	add    %ecx,%eax
    f962:	0f 88 38 01 00 00    	js     faa0 <_DkSendHandle+0x260>
    f968:	31 c0                	xor    %eax,%eax
}
    f96a:	48 81 c4 c8 00 00 00 	add    $0xc8,%rsp
    f971:	5b                   	pop    %rbx
    f972:	41 5c                	pop    %r12
    f974:	41 5d                	pop    %r13
    f976:	41 5e                	pop    %r14
    f978:	41 5f                	pop    %r15
    f97a:	5d                   	pop    %rbp
    f97b:	c3                   	retq   
    f97c:	0f 1f 40 00          	nopl   0x0(%rax)
                nmsg++;
            }
            break;
        case pal_type_gipc:
            msg_nfds = 1;
            fds[0] = cargo->gipc.fd;
    f980:	8b 46 0c             	mov    0xc(%rsi),%eax
                msg_buf[nmsg] = cargo->sock.conn;
                nmsg++;
            }
            break;
        case pal_type_gipc:
            msg_nfds = 1;
    f983:	41 bc 01 00 00 00    	mov    $0x1,%r12d
            fds[0] = cargo->gipc.fd;
    f989:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%rbp)
            break;
    f98f:	31 c0                	xor    %eax,%eax
            return -PAL_ERROR_INVAL;
    }

    // ~ Initialize common parameter formessage passing
    // Channel between parent and child
    int ch = hdl->process.cargo;
    f991:	4d 63 6d 14          	movslq 0x14(%r13),%r13

    // Initialize header information
    // Common information for all the PAL_HANDLEs
    hdl_hdr.type = __PAL_GET_TYPE(cargo);
    hdl_hdr.body_size = msg_len[0] + msg_len[1];
    f995:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)

    iov[0].iov_base = &hdl_hdr;
    iov[0].iov_len = sizeof(struct hdl_header);
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = iov;
    f99b:	4c 8d 45 a0          	lea    -0x60(%rbp),%r8
    // Declare variables required for sending the message
    struct msghdr hdr; // message header
    struct cmsghdr * chdr; //control message header
    struct iovec iov[3]; // IO Vector

    iov[0].iov_base = &hdl_hdr;
    f99f:	48 8d 85 30 ff ff ff 	lea    -0xd0(%rbp),%rax
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, MSG_NOSIGNAL);
    f9a6:	4c 8d b5 70 ff ff ff 	lea    -0x90(%rbp),%r14
    f9ad:	bb 1c 00 00 00       	mov    $0x1c,%ebx
    // Channel between parent and child
    int ch = hdl->process.cargo;

    // Initialize header information
    // Common information for all the PAL_HANDLEs
    hdl_hdr.type = __PAL_GET_TYPE(cargo);
    f9b2:	89 95 30 ff ff ff    	mov    %edx,-0xd0(%rbp)
    hdl_hdr.body_size = msg_len[0] + msg_len[1];
    hdl_hdr.nfds = msg_nfds;
    f9b8:	44 89 a5 38 ff ff ff 	mov    %r12d,-0xc8(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, MSG_NOSIGNAL);
    f9bf:	ba 00 00 02 00       	mov    $0x20000,%edx
    // Declare variables required for sending the message
    struct msghdr hdr; // message header
    struct cmsghdr * chdr; //control message header
    struct iovec iov[3]; // IO Vector

    iov[0].iov_base = &hdl_hdr;
    f9c4:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    iov[0].iov_len = sizeof(struct hdl_header);
    f9c8:	48 c7 45 a8 0c 00 00 	movq   $0xc,-0x58(%rbp)
    f9cf:	00 
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, MSG_NOSIGNAL);
    f9d0:	4c 89 f6             	mov    %r14,%rsi
    struct cmsghdr * chdr; //control message header
    struct iovec iov[3]; // IO Vector

    iov[0].iov_base = &hdl_hdr;
    iov[0].iov_len = sizeof(struct hdl_header);
    hdr.msg_name = NULL;
    f9d3:	48 c7 85 70 ff ff ff 	movq   $0x0,-0x90(%rbp)
    f9da:	00 00 00 00 
    hdr.msg_namelen = 0;
    f9de:	c7 85 78 ff ff ff 00 	movl   $0x0,-0x88(%rbp)
    f9e5:	00 00 00 
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, MSG_NOSIGNAL);
    f9e8:	4c 89 ef             	mov    %r13,%rdi

    iov[0].iov_base = &hdl_hdr;
    iov[0].iov_len = sizeof(struct hdl_header);
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = iov;
    f9eb:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    hdr.msg_iovlen = 1;
    f9ef:	c7 45 88 01 00 00 00 	movl   $0x1,-0x78(%rbp)
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, MSG_NOSIGNAL);
    f9f6:	89 d8                	mov    %ebx,%eax
    iov[0].iov_len = sizeof(struct hdl_header);
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = iov;
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    f9f8:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
    f9ff:	00 
    hdr.msg_controllen = 0;
    fa00:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%rbp)
    hdr.msg_flags = 0;
    fa07:	c7 45 9c 00 00 00 00 	movl   $0x0,-0x64(%rbp)

    int ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, MSG_NOSIGNAL);
    fa0e:	cd 80                	int    $0x80
    fa10:	48 89 c1             	mov    %rax,%rcx
    fa13:	bb 00 00 00 00       	mov    $0x0,%ebx
    fa18:	83 d3 00             	adc    $0x0,%ebx
    fa1b:	31 d2                	xor    %edx,%edx
    fa1d:	85 db                	test   %ebx,%ebx
    fa1f:	0f 95 c2             	setne  %dl
    fa22:	48 89 d0             	mov    %rdx,%rax
    fa25:	48 f7 d8             	neg    %rax
    fa28:	48 31 c8             	xor    %rcx,%rax

    // Unlock is error
    if (IS_ERR(ret))
    fa2b:	01 d0                	add    %edx,%eax
    fa2d:	78 71                	js     faa0 <_DkSendHandle+0x260>
    // Initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);

    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    fa2f:	48 63 85 10 ff ff ff 	movslq -0xf0(%rbp),%rax
    // Control message buffer with added space for 2 fds (ie. max size
    // that it will have)
    char cbuf[sizeof(struct cmsghdr) + 2 * sizeof(int)];

    // Initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    fa36:	4c 89 7d a0          	mov    %r15,-0x60(%rbp)
    iov[0].iov_len = sizeof(union pal_handle);
    fa3a:	48 c7 45 a8 58 00 00 	movq   $0x58,-0x58(%rbp)
    fa41:	00 

    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    fa42:	85 c0                	test   %eax,%eax
    fa44:	0f 84 5a fe ff ff    	je     f8a4 <_DkSendHandle+0x64>
    iov[1].iov_len = msg_len[0] ? : 0;
    fa4a:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    fa4e:	48 63 85 14 ff ff ff 	movslq -0xec(%rbp),%rax
    // Initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);

    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    fa55:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
    iov[1].iov_len = msg_len[0] ? : 0;

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    fa5c:	85 c0                	test   %eax,%eax
    // Initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);

    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    fa5e:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
    iov[1].iov_len = msg_len[0] ? : 0;

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    fa62:	0f 84 e2 01 00 00    	je     fc4a <_DkSendHandle+0x40a>
    iov[2].iov_len = msg_len[1] ? : 0;
    fa68:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    iov[1].iov_len = msg_len[0] ? : 0;

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    fa6c:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    iov[2].iov_len = msg_len[1] ? : 0;

    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len[0] ? (msg_len[1] ? 3 : 2) : 1;
    fa70:	b8 03 00 00 00       	mov    $0x3,%eax

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    iov[2].iov_len = msg_len[1] ? : 0;

    hdr.msg_iov = iov;
    fa75:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    fa79:	e9 5d fe ff ff       	jmpq   f8db <_DkSendHandle+0x9b>
    fa7e:	66 90                	xchg   %ax,%ax
    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    iov[1].iov_len = msg_len[0] ? : 0;

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    fa80:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    fa87:	00 
    iov[2].iov_len = msg_len[1] ? : 0;
    fa88:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    fa8f:	00 

    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len[0] ? (msg_len[1] ? 3 : 2) : 1;
    fa90:	b8 01 00 00 00       	mov    $0x1,%eax

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    iov[2].iov_len = msg_len[1] ? : 0;

    hdr.msg_iov = iov;
    fa95:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    fa99:	e9 3d fe ff ff       	jmpq   f8db <_DkSendHandle+0x9b>
    fa9e:	66 90                	xchg   %ax,%ax

    int ret = INLINE_SYSCALL(sendmsg, 3, ch, &hdr, MSG_NOSIGNAL);

    // Unlock is error
    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;
    faa0:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    faa5:	e9 c0 fe ff ff       	jmpq   f96a <_DkSendHandle+0x12a>
    faaa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            msg_nfds = 1;
            fds[0] = cargo->pipe.fd;
            break;
        case pal_type_pipeprv:
            msg_nfds = 2;
            fds[0] = cargo->pipeprv.fds[0];
    fab0:	8b 46 0c             	mov    0xc(%rsi),%eax
        case pal_type_pipecli:
            msg_nfds = 1;
            fds[0] = cargo->pipe.fd;
            break;
        case pal_type_pipeprv:
            msg_nfds = 2;
    fab3:	41 bc 02 00 00 00    	mov    $0x2,%r12d
            fds[0] = cargo->pipeprv.fds[0];
    fab9:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%rbp)
            fds[1] = cargo->pipeprv.fds[1];
    fabf:	8b 46 10             	mov    0x10(%rsi),%eax
    fac2:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
            break;
    fac8:	31 c0                	xor    %eax,%eax
    faca:	e9 c2 fe ff ff       	jmpq   f991 <_DkSendHandle+0x151>
    facf:	90                   	nop    
        case pal_type_dev:
            if (cargo->dev.fd_in != PAL_IDX_POISON)
    fad0:	8b 4e 0c             	mov    0xc(%rsi),%ecx
int _DkSendHandle (PAL_HANDLE hdl, PAL_HANDLE cargo)
{
    // Variables to store information for the message
    char * msg_buf[2] = { NULL, NULL };
    int msg_len[2] = { 0, 0 };
    int msg_nfds = 0, fds[2];
    fad3:	31 c0                	xor    %eax,%eax
            msg_nfds = 2;
            fds[0] = cargo->pipeprv.fds[0];
            fds[1] = cargo->pipeprv.fds[1];
            break;
        case pal_type_dev:
            if (cargo->dev.fd_in != PAL_IDX_POISON)
    fad5:	83 f9 ff             	cmp    $0xffffffffffffffff,%ecx
    fad8:	74 08                	je     fae2 <_DkSendHandle+0x2a2>
                fds[msg_nfds++] = cargo->dev.fd_in;
    fada:	89 8d 20 ff ff ff    	mov    %ecx,-0xe0(%rbp)
    fae0:	b0 01                	mov    $0x1,%al
            if (cargo->dev.fd_out != PAL_IDX_POISON)
    fae2:	41 8b 4f 10          	mov    0x10(%r15),%ecx
    fae6:	41 89 c4             	mov    %eax,%r12d
    fae9:	83 f9 ff             	cmp    $0xffffffffffffffff,%ecx
    faec:	74 0d                	je     fafb <_DkSendHandle+0x2bb>
                fds[msg_nfds++] = cargo->dev.fd_out;
    faee:	48 98                	cltq   
    faf0:	41 83 c4 01          	add    $0x1,%r12d
    faf4:	89 8c 85 20 ff ff ff 	mov    %ecx,-0xe0(%rbp,%rax,4)
            if (cargo->dev.realpath) {
    fafb:	49 8b 7f 20          	mov    0x20(%r15),%rdi
    faff:	31 c0                	xor    %eax,%eax
    fb01:	48 85 ff             	test   %rdi,%rdi
    fb04:	0f 84 87 fe ff ff    	je     f991 <_DkSendHandle+0x151>
                msg_len[0] = strlen(cargo->dev.realpath) + 1;
    fb0a:	e8 91 6c 00 00       	callq  167a0 <strlen>
                msg_buf[0] = (char *) cargo->dev.realpath;
    fb0f:	49 8b 57 20          	mov    0x20(%r15),%rdx
            if (cargo->dev.fd_in != PAL_IDX_POISON)
                fds[msg_nfds++] = cargo->dev.fd_in;
            if (cargo->dev.fd_out != PAL_IDX_POISON)
                fds[msg_nfds++] = cargo->dev.fd_out;
            if (cargo->dev.realpath) {
                msg_len[0] = strlen(cargo->dev.realpath) + 1;
    fb13:	83 c0 01             	add    $0x1,%eax
    fb16:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
                msg_buf[0] = (char *) cargo->dev.realpath;
    fb1c:	48 89 95 40 ff ff ff 	mov    %rdx,-0xc0(%rbp)
    fb23:	41 8b 17             	mov    (%r15),%edx
    fb26:	e9 66 fe ff ff       	jmpq   f991 <_DkSendHandle+0x151>
    fb2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    // ~ Also, Initialize common parameter formessage passing
    // Channel between parent and child
    switch(__PAL_GET_TYPE(cargo)) {
        case pal_type_file:
            msg_nfds = 1;
            fds[0] = cargo->file.fd;
    fb30:	8b 46 0c             	mov    0xc(%rsi),%eax
            msg_len[0] = strlen(cargo->file.realpath) + 1;
    fb33:	48 8b 7e 20          	mov    0x20(%rsi),%rdi
    // of cargo type)
    // ~ Also, Initialize common parameter formessage passing
    // Channel between parent and child
    switch(__PAL_GET_TYPE(cargo)) {
        case pal_type_file:
            msg_nfds = 1;
    fb37:	41 bc 01 00 00 00    	mov    $0x1,%r12d
            fds[0] = cargo->file.fd;
    fb3d:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%rbp)
            msg_len[0] = strlen(cargo->file.realpath) + 1;
    fb43:	e8 58 6c 00 00       	callq  167a0 <strlen>
            msg_buf[0] = (char *) cargo->file.realpath;
    fb48:	49 8b 57 20          	mov    0x20(%r15),%rdx
    // Channel between parent and child
    switch(__PAL_GET_TYPE(cargo)) {
        case pal_type_file:
            msg_nfds = 1;
            fds[0] = cargo->file.fd;
            msg_len[0] = strlen(cargo->file.realpath) + 1;
    fb4c:	83 c0 01             	add    $0x1,%eax
    fb4f:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
            msg_buf[0] = (char *) cargo->file.realpath;
    fb55:	48 89 95 40 ff ff ff 	mov    %rdx,-0xc0(%rbp)
    fb5c:	41 8b 17             	mov    (%r15),%edx
            break;
    fb5f:	e9 2d fe ff ff       	jmpq   f991 <_DkSendHandle+0x151>
            }
            break;
        case pal_type_dir:
            msg_nfds = 1;
            fds[0] = cargo->dir.fd;
            if (cargo->dir.realpath) {
    fb64:	48 8b 7e 10          	mov    0x10(%rsi),%rdi
                msg_buf[0] = (char *) cargo->dev.realpath;
            }
            break;
        case pal_type_dir:
            msg_nfds = 1;
            fds[0] = cargo->dir.fd;
    fb68:	8b 46 0c             	mov    0xc(%rsi),%eax
            if (cargo->dir.realpath) {
    fb6b:	48 85 ff             	test   %rdi,%rdi
                msg_buf[0] = (char *) cargo->dev.realpath;
            }
            break;
        case pal_type_dir:
            msg_nfds = 1;
            fds[0] = cargo->dir.fd;
    fb6e:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%rbp)
            if (cargo->dir.realpath) {
    fb74:	0f 84 f6 00 00 00    	je     fc70 <_DkSendHandle+0x430>
                msg_len[0] = strlen(cargo->dir.realpath) + 1;
    fb7a:	e8 21 6c 00 00       	callq  167a0 <strlen>
                msg_buf[0] = (char *) cargo->dir.realpath;
    fb7f:	49 8b 57 10          	mov    0x10(%r15),%rdx
            break;
        case pal_type_dir:
            msg_nfds = 1;
            fds[0] = cargo->dir.fd;
            if (cargo->dir.realpath) {
                msg_len[0] = strlen(cargo->dir.realpath) + 1;
    fb83:	83 c0 01             	add    $0x1,%eax
                msg_len[0] = strlen(cargo->dev.realpath) + 1;
                msg_buf[0] = (char *) cargo->dev.realpath;
            }
            break;
        case pal_type_dir:
            msg_nfds = 1;
    fb86:	41 bc 01 00 00 00    	mov    $0x1,%r12d
            fds[0] = cargo->dir.fd;
            if (cargo->dir.realpath) {
                msg_len[0] = strlen(cargo->dir.realpath) + 1;
    fb8c:	89 85 10 ff ff ff    	mov    %eax,-0xf0(%rbp)
                msg_buf[0] = (char *) cargo->dir.realpath;
    fb92:	48 89 95 40 ff ff ff 	mov    %rdx,-0xc0(%rbp)
    fb99:	41 8b 17             	mov    (%r15),%edx
    fb9c:	e9 f0 fd ff ff       	jmpq   f991 <_DkSendHandle+0x151>
                _size = sizeof(struct sockaddr_in6); break; \
            default: break;                                 \
        } _size;                                            \
    })
            msg_nfds = 1;
            fds[0] = cargo->sock.fd;
    fba1:	8b 46 0c             	mov    0xc(%rsi),%eax
    fba4:	89 85 20 ff ff ff    	mov    %eax,-0xe0(%rbp)
            int nmsg = 0;
            if (cargo->sock.bind) {
    fbaa:	48 8b 46 10          	mov    0x10(%rsi),%rax
    fbae:	48 85 c0             	test   %rax,%rax
    fbb1:	0f 84 da 00 00 00    	je     fc91 <_DkSendHandle+0x451>
                msg_len[nmsg] = addr_size(cargo->sock.bind);
    fbb7:	0f b6 70 01          	movzbl 0x1(%rax),%esi
    fbbb:	b9 10 00 00 00       	mov    $0x10,%ecx
    fbc0:	40 80 fe 02          	cmp    $0x2,%sil
    fbc4:	74 0e                	je     fbd4 <_DkSendHandle+0x394>
    fbc6:	40 80 fe 1c          	cmp    $0x1c,%sil
    fbca:	b1 1c                	mov    $0x1c,%cl
    fbcc:	be 00 00 00 00       	mov    $0x0,%esi
    fbd1:	0f 45 ce             	cmovne %esi,%ecx
                msg_buf[nmsg] = cargo->sock.bind;
    fbd4:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
    })
            msg_nfds = 1;
            fds[0] = cargo->sock.fd;
            int nmsg = 0;
            if (cargo->sock.bind) {
                msg_len[nmsg] = addr_size(cargo->sock.bind);
    fbdb:	89 8d 10 ff ff ff    	mov    %ecx,-0xf0(%rbp)
                msg_buf[nmsg] = cargo->sock.bind;
                nmsg++;
    fbe1:	b8 01 00 00 00       	mov    $0x1,%eax
            }
            if (cargo->sock.conn) {
    fbe6:	49 8b 4f 18          	mov    0x18(%r15),%rcx
    fbea:	48 85 c9             	test   %rcx,%rcx
    fbed:	0f 84 8d 00 00 00    	je     fc80 <_DkSendHandle+0x440>
                msg_len[nmsg] = addr_size(cargo->sock.conn);
    fbf3:	0f b6 79 01          	movzbl 0x1(%rcx),%edi
    fbf7:	be 10 00 00 00       	mov    $0x10,%esi
    fbfc:	40 80 ff 02          	cmp    $0x2,%dil
    fc00:	74 0f                	je     fc11 <_DkSendHandle+0x3d1>
    fc02:	40 80 ff 1c          	cmp    $0x1c,%dil
    fc06:	40 b6 1c             	mov    $0x1c,%sil
    fc09:	bf 00 00 00 00       	mov    $0x0,%edi
    fc0e:	0f 45 f7             	cmovne %edi,%esi
    fc11:	89 b4 85 10 ff ff ff 	mov    %esi,-0xf0(%rbp,%rax,4)
                msg_buf[nmsg] = cargo->sock.conn;
    fc18:	48 89 8c c5 40 ff ff 	mov    %rcx,-0xc0(%rbp,%rax,8)
    fc1f:	ff 
            case AF_INET6:                                  \
                _size = sizeof(struct sockaddr_in6); break; \
            default: break;                                 \
        } _size;                                            \
    })
            msg_nfds = 1;
    fc20:	41 bc 01 00 00 00    	mov    $0x1,%r12d
    fc26:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
    fc2c:	03 85 10 ff ff ff    	add    -0xf0(%rbp),%eax
    fc32:	e9 5a fd ff ff       	jmpq   f991 <_DkSendHandle+0x151>
    fc37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    fc3e:	00 00 
        case pal_type_gipc:
            msg_nfds = 1;
            fds[0] = cargo->gipc.fd;
            break;
        default:
            return -PAL_ERROR_INVAL;
    fc40:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    fc45:	e9 20 fd ff ff       	jmpq   f96a <_DkSendHandle+0x12a>
    // Initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_len[0] ? msg_buf[0] : NULL;
    iov[1].iov_len = msg_len[0] ? : 0;

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    fc4a:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    fc51:	00 
    iov[2].iov_len = msg_len[1] ? : 0;
    fc52:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
    fc59:	00 

    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len[0] ? (msg_len[1] ? 3 : 2) : 1;
    fc5a:	b8 02 00 00 00       	mov    $0x2,%eax

    // Initialize iovec[2] for additional element with message buffer
    iov[2].iov_base = msg_len[1] ? msg_buf[0] : NULL;
    iov[2].iov_len = msg_len[1] ? : 0;

    hdr.msg_iov = iov;
    fc5f:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
    fc63:	e9 73 fc ff ff       	jmpq   f8db <_DkSendHandle+0x9b>
    fc68:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    fc6f:	00 
    fc70:	31 c0                	xor    %eax,%eax
                msg_len[0] = strlen(cargo->dev.realpath) + 1;
                msg_buf[0] = (char *) cargo->dev.realpath;
            }
            break;
        case pal_type_dir:
            msg_nfds = 1;
    fc72:	41 bc 01 00 00 00    	mov    $0x1,%r12d
    fc78:	e9 14 fd ff ff       	jmpq   f991 <_DkSendHandle+0x151>
    fc7d:	0f 1f 00             	nopl   (%rax)
    fc80:	8b 85 10 ff ff ff    	mov    -0xf0(%rbp),%eax
            case AF_INET6:                                  \
                _size = sizeof(struct sockaddr_in6); break; \
            default: break;                                 \
        } _size;                                            \
    })
            msg_nfds = 1;
    fc86:	41 bc 01 00 00 00    	mov    $0x1,%r12d
    fc8c:	e9 00 fd ff ff       	jmpq   f991 <_DkSendHandle+0x151>
            fds[0] = cargo->sock.fd;
            int nmsg = 0;
    fc91:	31 c0                	xor    %eax,%eax
    fc93:	e9 4e ff ff ff       	jmpq   fbe6 <_DkSendHandle+0x3a6>
    fc98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    fc9f:	00 

000000000000fca0 <_DkReceiveHandle>:
}

/* _DkRecvHandle for internal use. Receive and return a PAL_HANDLE over the
   given PAL_HANDLE else return negative value. */
int _DkReceiveHandle(PAL_HANDLE hdl, PAL_HANDLE cargo)
{
    fca0:	83 3f 0c             	cmpl   $0xc,(%rdi)
    fca3:	0f 85 27 04 00 00    	jne    100d0 <_DkReceiveHandle+0x430>
    fca9:	55                   	push   %rbp
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(recvmsg, 3, ch, &hdr, 0);
    fcaa:	31 d2                	xor    %edx,%edx
}

/* _DkRecvHandle for internal use. Receive and return a PAL_HANDLE over the
   given PAL_HANDLE else return negative value. */
int _DkReceiveHandle(PAL_HANDLE hdl, PAL_HANDLE cargo)
{
    fcac:	48 89 e5             	mov    %rsp,%rbp
    fcaf:	41 57                	push   %r15
    fcb1:	41 56                	push   %r14
    fcb3:	41 55                	push   %r13
    fcb5:	41 54                	push   %r12
    int ch = hdl->process.cargo;

    struct msghdr hdr;
    struct iovec iov[2];

    iov[0].iov_base = &hdl_hdr;
    fcb7:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
}

/* _DkRecvHandle for internal use. Receive and return a PAL_HANDLE over the
   given PAL_HANDLE else return negative value. */
int _DkReceiveHandle(PAL_HANDLE hdl, PAL_HANDLE cargo)
{
    fcbe:	53                   	push   %rbx

    iov[0].iov_base = &hdl_hdr;
    iov[0].iov_len = sizeof(struct hdl_header);
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = iov;
    fcbf:	4c 8d 45 80          	lea    -0x80(%rbp),%r8
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(recvmsg, 3, ch, &hdr, 0);
    fcc3:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
    fcc7:	bb 1b 00 00 00       	mov    $0x1b,%ebx
    fccc:	49 89 f5             	mov    %rsi,%r13
}

/* _DkRecvHandle for internal use. Receive and return a PAL_HANDLE over the
   given PAL_HANDLE else return negative value. */
int _DkReceiveHandle(PAL_HANDLE hdl, PAL_HANDLE cargo)
{
    fccf:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
    if (__PAL_GET_TYPE(hdl) != pal_type_process)
        return -PAL_ERROR_BADHANDLE;

    // ~ Initialize common parameter for message passing
    // Channel between parent and child
    int ch = hdl->process.cargo;
    fcd6:	4c 63 67 14          	movslq 0x14(%rdi),%r12

    struct msghdr hdr;
    struct iovec iov[2];

    iov[0].iov_base = &hdl_hdr;
    fcda:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    iov[0].iov_len = sizeof(struct hdl_header);
    fcde:	48 c7 45 88 0c 00 00 	movq   $0xc,-0x78(%rbp)
    fce5:	00 
    hdr.msg_name = NULL;
    fce6:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
    fced:	00 
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(recvmsg, 3, ch, &hdr, 0);
    fcee:	48 89 ce             	mov    %rcx,%rsi
    struct iovec iov[2];

    iov[0].iov_base = &hdl_hdr;
    iov[0].iov_len = sizeof(struct hdl_header);
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    fcf1:	c7 45 a8 00 00 00 00 	movl   $0x0,-0x58(%rbp)
    hdr.msg_iov = iov;
    fcf8:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    hdr.msg_iovlen = 1;
    hdr.msg_control = NULL;
    hdr.msg_controllen = 0;
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(recvmsg, 3, ch, &hdr, 0);
    fcfc:	89 d8                	mov    %ebx,%eax
    iov[0].iov_base = &hdl_hdr;
    iov[0].iov_len = sizeof(struct hdl_header);
    hdr.msg_name = NULL;
    hdr.msg_namelen = 0;
    hdr.msg_iov = iov;
    hdr.msg_iovlen = 1;
    fcfe:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
    hdr.msg_control = NULL;
    fd05:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
    fd0c:	00 
    hdr.msg_controllen = 0;
    fd0d:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%rbp)
    hdr.msg_flags = 0;
    fd14:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)

    int ret = INLINE_SYSCALL(recvmsg, 3, ch, &hdr, 0);
    fd1b:	4c 89 e7             	mov    %r12,%rdi
    fd1e:	cd 80                	int    $0x80
    fd20:	48 89 c2             	mov    %rax,%rdx
    fd23:	bb 00 00 00 00       	mov    $0x0,%ebx
    fd28:	83 d3 00             	adc    $0x0,%ebx
    fd2b:	31 ff                	xor    %edi,%edi
    fd2d:	85 db                	test   %ebx,%ebx
    fd2f:	40 0f 95 c7          	setne  %dil
    fd33:	48 89 f8             	mov    %rdi,%rax
    fd36:	48 f7 d8             	neg    %rax
    fd39:	48 31 d0             	xor    %rdx,%rax
    fd3c:	48 8d 14 38          	lea    (%rax,%rdi,1),%rdx

    if (IS_ERR(ret) || ret < sizeof(struct hdl_header)) {
    fd40:	83 fa 0b             	cmp    $0xb,%edx
    fd43:	7f 2b                	jg     fd70 <_DkReceiveHandle+0xd0>
        if (!IS_ERR(ret))
    fd45:	85 d2                	test   %edx,%edx
            return -PAL_ERROR_TRYAGAIN;
    fd47:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
    hdr.msg_flags = 0;

    int ret = INLINE_SYSCALL(recvmsg, 3, ch, &hdr, 0);

    if (IS_ERR(ret) || ret < sizeof(struct hdl_header)) {
        if (!IS_ERR(ret))
    fd4c:	79 0c                	jns    fd5a <_DkReceiveHandle+0xba>
            return -PAL_ERROR_TRYAGAIN;

        if (ERRNO(ret) != EINTR && ERRNO(ret) != ERESTART)
    fd4e:	83 fa ab             	cmp    $0xffffffffffffffab,%edx
    fd51:	74 1d                	je     fd70 <_DkReceiveHandle+0xd0>
    fd53:	83 fa fc             	cmp    $0xfffffffffffffffc,%edx
    fd56:	89 d0                	mov    %edx,%eax
    fd58:	74 16                	je     fd70 <_DkReceiveHandle+0xd0>
        default :
            return -PAL_ERROR_BADHANDLE;
    }

    return 0;
}
    fd5a:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    fd5e:	5b                   	pop    %rbx
    fd5f:	41 5c                	pop    %r12
    fd61:	41 5d                	pop    %r13
    fd63:	41 5e                	pop    %r14
    fd65:	41 5f                	pop    %r15
    fd67:	5d                   	pop    %rbp
    fd68:	c3                   	retq   
    fd69:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        if (ERRNO(ret) != EINTR && ERRNO(ret) != ERESTART)
            return -ERRNO(ret);
    }

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    fd70:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
    fd76:	44 8b bd 58 ff ff ff 	mov    -0xa8(%rbp),%r15d
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    fd7d:	85 c0                	test   %eax,%eax
        if (ERRNO(ret) != EINTR && ERRNO(ret) != ERESTART)
            return -ERRNO(ret);
    }

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    fd7f:	89 85 48 ff ff ff    	mov    %eax,-0xb8(%rbp)
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    fd85:	0f 85 05 01 00 00    	jne    fe90 <_DkReceiveHandle+0x1f0>
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fd8b:	49 63 df             	movslq %r15d,%rbx
    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;

    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));
    fd8e:	48 89 cf             	mov    %rcx,%rdi
    fd91:	ba 30 00 00 00       	mov    $0x30,%edx

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fd96:	48 8d 04 9d 1e 00 00 	lea    0x1e(,%rbx,4),%rax
    fd9d:	00 
    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;

    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));
    fd9e:	31 f6                	xor    %esi,%esi
    fda0:	4c 89 85 38 ff ff ff 	mov    %r8,-0xc8(%rbp)
    fda7:	48 89 8d 40 ff ff ff 	mov    %rcx,-0xc0(%rbp)

    // receive PAL_HANDLE contents in the body
    char cbuf[sizeof(struct cmsghdr) + 2 * sizeof(int)];

    // initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    fdae:	4c 89 6d 80          	mov    %r13,-0x80(%rbp)

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fdb2:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    // receive PAL_HANDLE contents in the body
    char cbuf[sizeof(struct cmsghdr) + 2 * sizeof(int)];

    // initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);
    fdb6:	48 c7 45 88 58 00 00 	movq   $0x58,-0x78(%rbp)
    fdbd:	00 

    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    fdbe:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
    fdc5:	00 

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fdc6:	48 29 c4             	sub    %rax,%rsp
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);

    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;
    fdc9:	48 c7 45 98 00 00 00 	movq   $0x0,-0x68(%rbp)
    fdd0:	00 

    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));
    fdd1:	e8 ca 63 00 00       	callq  161a0 <memset>

    // set message header values
    hdr.msg_iov = iov;
    fdd6:	4c 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%r8

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fddd:	4c 8d 74 24 0f       	lea    0xf(%rsp),%r14
    fde2:	48 8b 8d 40 ff ff ff 	mov    -0xc0(%rbp),%rcx
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);

    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;
    fde9:	45 31 c9             	xor    %r9d,%r9d
            return -ERRNO(ret);
    }

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    fdec:	45 31 d2             	xor    %r10d,%r10d
    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));

    // set message header values
    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len ? 2 : 1;
    fdef:	b8 01 00 00 00       	mov    $0x1,%eax

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fdf4:	49 83 e6 f0          	and    $0xfffffffffffffff0,%r14

    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));

    // set message header values
    hdr.msg_iov = iov;
    fdf8:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    hdr.msg_iovlen = msg_len ? 2 : 1;
    fdfc:	89 45 b8             	mov    %eax,-0x48(%rbp)
    hdr.msg_control = cbuf;
    fdff:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
    hdr.msg_controllen = sizeof(struct cmsghdr) + sizeof(int) *
                         msg_nfds;

    ret = INLINE_SYSCALL(recvmsg, 3, ch, &hdr, 0);
    fe06:	48 89 ce             	mov    %rcx,%rsi
    fe09:	b9 1b 00 00 00       	mov    $0x1b,%ecx
    fe0e:	31 d2                	xor    %edx,%edx
    fe10:	4c 89 e7             	mov    %r12,%rdi
    memset(&hdr, 0, sizeof(struct msghdr));

    // set message header values
    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len ? 2 : 1;
    hdr.msg_control = cbuf;
    fe13:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    hdr.msg_controllen = sizeof(struct cmsghdr) + sizeof(int) *
    fe17:	8d 04 9d 0c 00 00 00 	lea    0xc(,%rbx,4),%eax
    fe1e:	89 45 c8             	mov    %eax,-0x38(%rbp)
                         msg_nfds;

    ret = INLINE_SYSCALL(recvmsg, 3, ch, &hdr, 0);
    fe21:	89 c8                	mov    %ecx,%eax
    fe23:	cd 80                	int    $0x80
    fe25:	48 89 c1             	mov    %rax,%rcx
    fe28:	bb 00 00 00 00       	mov    $0x0,%ebx
    fe2d:	83 d3 00             	adc    $0x0,%ebx
    fe30:	31 d2                	xor    %edx,%edx
    fe32:	85 db                	test   %ebx,%ebx
    fe34:	0f 95 c2             	setne  %dl
    fe37:	48 89 d0             	mov    %rdx,%rax
    fe3a:	48 f7 d8             	neg    %rax
    fe3d:	48 31 c8             	xor    %rcx,%rax
    fe40:	48 01 d0             	add    %rdx,%rax

    if (!IS_ERR(ret)) {
    fe43:	85 c0                	test   %eax,%eax
    fe45:	0f 88 15 03 00 00    	js     10160 <_DkReceiveHandle+0x4c0>
        struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
    fe4b:	8b 45 c8             	mov    -0x38(%rbp),%eax
            chdr->cmsg_type == SCM_RIGHTS) {
            msg_nfds = (hdr.msg_controllen - sizeof(struct cmsghdr)) /
                       sizeof(int);
            memcpy(fds, CMSG_DATA(chdr), sizeof(int) * msg_nfds);
        } else {
            msg_nfds = 0;
    fe4e:	45 31 ff             	xor    %r15d,%r15d
                         msg_nfds;

    ret = INLINE_SYSCALL(recvmsg, 3, ch, &hdr, 0);

    if (!IS_ERR(ret)) {
        struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
    fe51:	83 f8 0b             	cmp    $0xb,%eax
    fe54:	76 13                	jbe    fe69 <_DkReceiveHandle+0x1c9>
    fe56:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
        if (chdr &&
    fe5a:	48 85 f6             	test   %rsi,%rsi
    fe5d:	74 0a                	je     fe69 <_DkReceiveHandle+0x1c9>
    fe5f:	83 7e 08 01          	cmpl   $0x1,0x8(%rsi)
    fe63:	0f 84 77 02 00 00    	je     100e0 <_DkReceiveHandle+0x440>
    // if error was returned
    if (IS_ERR(ret) && ERRNO(ret) != EINTR && ERRNO(ret) != ERESTART)
        return -ERRNO(ret);

    // recreate PAL_HANDLE based on type
    switch(hdl_hdr.type) {
    fe69:	83 bd 50 ff ff ff 11 	cmpl   $0x11,-0xb0(%rbp)
    fe70:	0f 87 aa 02 00 00    	ja     10120 <_DkReceiveHandle+0x480>
    fe76:	8b 95 50 ff ff ff    	mov    -0xb0(%rbp),%edx
    fe7c:	48 8d 05 1d d9 00 00 	lea    0xd91d(%rip),%rax        # 1d7a0 <slab_levels+0x4500>
    fe83:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
    fe87:	48 01 d0             	add    %rdx,%rax
    fe8a:	ff e0                	jmpq   *%rax
    fe8c:	0f 1f 40 00          	nopl   0x0(%rax)
            return -ERRNO(ret);
    }

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    fe90:	89 c7                	mov    %eax,%edi
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fe92:	49 63 df             	movslq %r15d,%rbx
    fe95:	4c 89 85 28 ff ff ff 	mov    %r8,-0xd8(%rbp)
    fe9c:	48 89 8d 40 ff ff ff 	mov    %rcx,-0xc0(%rbp)
            return -ERRNO(ret);
    }

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    fea3:	e8 58 8b ff ff       	callq  8a00 <malloc>
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);

    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;
    fea8:	4c 63 8d 48 ff ff ff 	movslq -0xb8(%rbp),%r9
            return -ERRNO(ret);
    }

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    feaf:	49 89 c2             	mov    %rax,%r10
    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;

    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));
    feb2:	48 8b 8d 40 ff ff ff 	mov    -0xc0(%rbp),%rcx

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    feb9:	48 8d 04 9d 1e 00 00 	lea    0x1e(,%rbx,4),%rax
    fec0:	00 
    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;

    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));
    fec1:	ba 30 00 00 00       	mov    $0x30,%edx
    fec6:	31 f6                	xor    %esi,%esi
    // initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);

    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    fec8:	4c 89 55 90          	mov    %r10,-0x70(%rbp)
    fecc:	4c 89 95 30 ff ff ff 	mov    %r10,-0xd0(%rbp)

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fed3:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;

    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));
    fed7:	48 89 cf             	mov    %rcx,%rdi

    // receive PAL_HANDLE contents in the body
    char cbuf[sizeof(struct cmsghdr) + 2 * sizeof(int)];

    // initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    feda:	4c 89 6d 80          	mov    %r13,-0x80(%rbp)

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fede:	48 29 c4             	sub    %rax,%rsp
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);

    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;
    fee1:	4c 89 4d 98          	mov    %r9,-0x68(%rbp)
    fee5:	4c 89 8d 38 ff ff ff 	mov    %r9,-0xc8(%rbp)
    // receive PAL_HANDLE contents in the body
    char cbuf[sizeof(struct cmsghdr) + 2 * sizeof(int)];

    // initialize iovec[0] with struct PAL_HANDLE
    iov[0].iov_base = cargo;
    iov[0].iov_len = sizeof(union pal_handle);
    feec:	48 c7 45 88 58 00 00 	movq   $0x58,-0x78(%rbp)
    fef3:	00 

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    fef4:	4c 8d 74 24 0f       	lea    0xf(%rsp),%r14
    // initialize iovec[1] for additional element with message buffer
    iov[1].iov_base = msg_buf;
    iov[1].iov_len = msg_len;

    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));
    fef9:	e8 a2 62 00 00       	callq  161a0 <memset>

    // set message header values
    hdr.msg_iov = iov;
    fefe:	4c 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%r8

    // initialize variables to get body
    int msg_len = hdl_hdr.body_size, msg_nfds = hdl_hdr.nfds;
    void * msg_buf = msg_len ? malloc(msg_len) : NULL;
    // make in stack
    int * fds = __alloca(sizeof(int) * msg_nfds);
    ff05:	49 83 e6 f0          	and    $0xfffffffffffffff0,%r14
    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));

    // set message header values
    hdr.msg_iov = iov;
    hdr.msg_iovlen = msg_len ? 2 : 1;
    ff09:	b8 02 00 00 00       	mov    $0x2,%eax
    ff0e:	4c 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%r10
    ff15:	4c 8b 8d 38 ff ff ff 	mov    -0xc8(%rbp),%r9
    ff1c:	48 8b 8d 40 ff ff ff 	mov    -0xc0(%rbp),%rcx

    // clear body memory
    memset(&hdr, 0, sizeof(struct msghdr));

    // set message header values
    hdr.msg_iov = iov;
    ff23:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
    ff27:	e9 d0 fe ff ff       	jmpq   fdfc <_DkReceiveHandle+0x15c>
    ff2c:	0f 1f 40 00          	nopl   0x0(%rax)
        }
        case pal_type_tcp:
        case pal_type_tcpsrv:
        case pal_type_udp: {
            void * addr = msg_buf;
            if (cargo->sock.bind) {
    ff30:	49 83 7d 10 00       	cmpq   $0x0,0x10(%r13)
    ff35:	0f 84 fc 01 00 00    	je     10137 <_DkReceiveHandle+0x497>
                int len = addr_size(addr);
    ff3b:	41 0f b6 52 01       	movzbl 0x1(%r10),%edx
    ff40:	80 fa 02             	cmp    $0x2,%dl
    ff43:	0f 84 f7 01 00 00    	je     10140 <_DkReceiveHandle+0x4a0>
    ff49:	80 fa 1c             	cmp    $0x1c,%dl
    ff4c:	b8 1c 00 00 00       	mov    $0x1c,%eax
    ff51:	bb 00 00 00 00       	mov    $0x0,%ebx
    ff56:	be 00 00 00 00       	mov    $0x0,%esi
    ff5b:	48 0f 44 d8          	cmove  %rax,%rbx
    ff5f:	0f 44 f0             	cmove  %eax,%esi
                if (addr + len > msg_buf + msg_len)
    ff62:	4b 8d 04 0a          	lea    (%r10,%r9,1),%rax
    ff66:	4c 01 d3             	add    %r10,%rbx
    ff69:	48 39 c3             	cmp    %rax,%rbx
    ff6c:	0f 87 0e 02 00 00    	ja     10180 <_DkReceiveHandle+0x4e0>
                    return -PAL_ERROR_OVERFLOW;
                cargo->sock.bind = remalloc(addr, len);
    ff72:	4c 89 d7             	mov    %r10,%rdi
    ff75:	4c 89 8d 40 ff ff ff 	mov    %r9,-0xc0(%rbp)
    ff7c:	4c 89 95 48 ff ff ff 	mov    %r10,-0xb8(%rbp)
    ff83:	e8 78 8c ff ff       	callq  8c00 <remalloc>
    ff88:	4c 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%r10
    ff8f:	4c 8b 8d 40 ff ff ff 	mov    -0xc0(%rbp),%r9
    ff96:	49 89 45 10          	mov    %rax,0x10(%r13)
                addr += len;
            }
            if (cargo->sock.conn) {
    ff9a:	49 83 7d 18 00       	cmpq   $0x0,0x18(%r13)
    ff9f:	74 4f                	je     fff0 <_DkReceiveHandle+0x350>
                int len = addr_size(addr);
    ffa1:	0f b6 53 01          	movzbl 0x1(%rbx),%edx
    ffa5:	80 fa 02             	cmp    $0x2,%dl
    ffa8:	0f 84 a2 01 00 00    	je     10150 <_DkReceiveHandle+0x4b0>
    ffae:	80 fa 1c             	cmp    $0x1c,%dl
    ffb1:	b9 00 00 00 00       	mov    $0x0,%ecx
    ffb6:	b8 1c 00 00 00       	mov    $0x1c,%eax
    ffbb:	be 00 00 00 00       	mov    $0x0,%esi
    ffc0:	ba 1c 00 00 00       	mov    $0x1c,%edx
    ffc5:	48 0f 45 c1          	cmovne %rcx,%rax
    ffc9:	0f 44 f2             	cmove  %edx,%esi
                if (addr + len > msg_buf + msg_len)
    ffcc:	48 01 d8             	add    %rbx,%rax
    ffcf:	4d 01 ca             	add    %r9,%r10
    ffd2:	4c 39 d0             	cmp    %r10,%rax
    ffd5:	0f 87 a5 01 00 00    	ja     10180 <_DkReceiveHandle+0x4e0>
                    return -PAL_ERROR_OVERFLOW;
                cargo->sock.conn = remalloc(addr, len);
    ffdb:	48 89 df             	mov    %rbx,%rdi
    ffde:	e8 1d 8c ff ff       	callq  8c00 <remalloc>
    ffe3:	49 89 45 18          	mov    %rax,0x18(%r13)
    ffe7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    ffee:	00 00 
            if (msg_nfds < 1)
                return -PAL_ERROR_BADHANDLE;
            cargo->sock.fd = fds[0];
            break;
        case pal_type_gipc:
            if (msg_nfds < 1)
    fff0:	45 85 ff             	test   %r15d,%r15d
    fff3:	0f 8e 27 01 00 00    	jle    10120 <_DkReceiveHandle+0x480>
                return -PAL_ERROR_BADHANDLE;
            cargo->gipc.fd = fds[0];
    fff9:	41 8b 06             	mov    (%r14),%eax
    fffc:	41 89 45 0c          	mov    %eax,0xc(%r13)
        default :
            return -PAL_ERROR_BADHANDLE;
    }

    return 0;
}
   10000:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
            break;
        default :
            return -PAL_ERROR_BADHANDLE;
    }

    return 0;
   10004:	31 c0                	xor    %eax,%eax
}
   10006:	5b                   	pop    %rbx
   10007:	41 5c                	pop    %r12
   10009:	41 5d                	pop    %r13
   1000b:	41 5e                	pop    %r14
   1000d:	41 5f                	pop    %r15
   1000f:	5d                   	pop    %rbp
   10010:	c3                   	retq   
            }
            cargo->file.realpath = remalloc(msg_buf, msg_len);;
            break;
        }
        case pal_type_dir: {
            if (msg_nfds < 1)
   10011:	45 85 ff             	test   %r15d,%r15d
   10014:	0f 8e 06 01 00 00    	jle    10120 <_DkReceiveHandle+0x480>
                return -PAL_ERROR_BADHANDLE;
            cargo->dir.fd = fds[0];
   1001a:	41 8b 06             	mov    (%r14),%eax
            cargo->dir.realpath = remalloc(msg_buf, msg_len);
   1001d:	8b b5 48 ff ff ff    	mov    -0xb8(%rbp),%esi
   10023:	4c 89 d7             	mov    %r10,%rdi
            break;
        }
        case pal_type_dir: {
            if (msg_nfds < 1)
                return -PAL_ERROR_BADHANDLE;
            cargo->dir.fd = fds[0];
   10026:	41 89 45 0c          	mov    %eax,0xc(%r13)
            cargo->dir.realpath = remalloc(msg_buf, msg_len);
   1002a:	e8 d1 8b ff ff       	callq  8c00 <remalloc>
   1002f:	49 89 45 10          	mov    %rax,0x10(%r13)
            break;
        default :
            return -PAL_ERROR_BADHANDLE;
    }

    return 0;
   10033:	31 c0                	xor    %eax,%eax
        case pal_type_dir: {
            if (msg_nfds < 1)
                return -PAL_ERROR_BADHANDLE;
            cargo->dir.fd = fds[0];
            cargo->dir.realpath = remalloc(msg_buf, msg_len);
            break;
   10035:	e9 20 fd ff ff       	jmpq   fd5a <_DkReceiveHandle+0xba>
   1003a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            cargo->pipeprv.fds[0] = fds[0];
            cargo->pipeprv.fds[1] = fds[1];
            break;
        case pal_type_dev: {
            int i = 0;
            if (cargo->dev.fd_in != PAL_IDX_POISON) {
   10040:	41 83 7d 0c ff       	cmpl   $0xffffffffffffffff,0xc(%r13)
   10045:	0f 84 e5 00 00 00    	je     10130 <_DkReceiveHandle+0x490>
                if (msg_nfds < 1)
   1004b:	45 85 ff             	test   %r15d,%r15d
   1004e:	0f 8e cc 00 00 00    	jle    10120 <_DkReceiveHandle+0x480>
                    return -PAL_ERROR_BADHANDLE;
                cargo->dev.fd_in = fds[i++];
   10054:	41 8b 06             	mov    (%r14),%eax
                msg_nfds--;
   10057:	41 83 ef 01          	sub    $0x1,%r15d
        case pal_type_dev: {
            int i = 0;
            if (cargo->dev.fd_in != PAL_IDX_POISON) {
                if (msg_nfds < 1)
                    return -PAL_ERROR_BADHANDLE;
                cargo->dev.fd_in = fds[i++];
   1005b:	41 89 45 0c          	mov    %eax,0xc(%r13)
   1005f:	b8 01 00 00 00       	mov    $0x1,%eax
                msg_nfds--;
            }
            if (cargo->dev.fd_out != PAL_IDX_POISON) {
   10064:	41 83 7d 10 ff       	cmpl   $0xffffffffffffffff,0x10(%r13)
   10069:	74 41                	je     100ac <_DkReceiveHandle+0x40c>
                if (msg_nfds < 1)
   1006b:	45 85 ff             	test   %r15d,%r15d
   1006e:	0f 8e ac 00 00 00    	jle    10120 <_DkReceiveHandle+0x480>
                    return -PAL_ERROR_BADHANDLE;
                cargo->dev.fd_out = fds[i++];
   10074:	41 8b 04 86          	mov    (%r14,%rax,4),%eax
   10078:	41 89 45 10          	mov    %eax,0x10(%r13)
   1007c:	eb 2e                	jmp    100ac <_DkReceiveHandle+0x40c>
   1007e:	66 90                	xchg   %ax,%ax
            if (msg_nfds < 1)
                return -PAL_ERROR_BADHANDLE;
            cargo->pipe.fd = fds[0];
            break;
        case pal_type_pipeprv:
            if (msg_nfds < 2)
   10080:	41 83 ff 01          	cmp    $0x1,%r15d
   10084:	0f 8e 96 00 00 00    	jle    10120 <_DkReceiveHandle+0x480>
                return -PAL_ERROR_BADHANDLE;
            cargo->pipeprv.fds[0] = fds[0];
   1008a:	41 8b 06             	mov    (%r14),%eax
   1008d:	41 89 45 0c          	mov    %eax,0xc(%r13)
            cargo->pipeprv.fds[1] = fds[1];
   10091:	41 8b 46 04          	mov    0x4(%r14),%eax
   10095:	41 89 45 10          	mov    %eax,0x10(%r13)
            break;
        default :
            return -PAL_ERROR_BADHANDLE;
    }

    return 0;
   10099:	31 c0                	xor    %eax,%eax
        case pal_type_pipeprv:
            if (msg_nfds < 2)
                return -PAL_ERROR_BADHANDLE;
            cargo->pipeprv.fds[0] = fds[0];
            cargo->pipeprv.fds[1] = fds[1];
            break;
   1009b:	e9 ba fc ff ff       	jmpq   fd5a <_DkReceiveHandle+0xba>
        return -ERRNO(ret);

    // recreate PAL_HANDLE based on type
    switch(hdl_hdr.type) {
        case pal_type_file: {
            if (msg_nfds < 1)
   100a0:	45 85 ff             	test   %r15d,%r15d
   100a3:	7e 7b                	jle    10120 <_DkReceiveHandle+0x480>
                return -PAL_ERROR_BADHANDLE;
            cargo->file.fd = fds[0];
   100a5:	41 8b 06             	mov    (%r14),%eax
   100a8:	41 89 45 0c          	mov    %eax,0xc(%r13)
                if (msg_nfds < 1)
                    return -PAL_ERROR_BADHANDLE;
                cargo->dev.fd_out = fds[i++];
                msg_nfds--;
            }
            cargo->file.realpath = remalloc(msg_buf, msg_len);;
   100ac:	8b b5 48 ff ff ff    	mov    -0xb8(%rbp),%esi
   100b2:	4c 89 d7             	mov    %r10,%rdi
   100b5:	e8 46 8b ff ff       	callq  8c00 <remalloc>
   100ba:	49 89 45 20          	mov    %rax,0x20(%r13)
        default :
            return -PAL_ERROR_BADHANDLE;
    }

    return 0;
}
   100be:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
            break;
        default :
            return -PAL_ERROR_BADHANDLE;
    }

    return 0;
   100c2:	31 c0                	xor    %eax,%eax
}
   100c4:	5b                   	pop    %rbx
   100c5:	41 5c                	pop    %r12
   100c7:	41 5d                	pop    %r13
   100c9:	41 5e                	pop    %r14
   100cb:	41 5f                	pop    %r15
   100cd:	5d                   	pop    %rbp
   100ce:	c3                   	retq   
   100cf:	90                   	nop    
    struct hdl_header hdl_hdr;

    // ~ Check connection PAL_HANDLE - is of process type for sending handle
    // else fail
    if (__PAL_GET_TYPE(hdl) != pal_type_process)
        return -PAL_ERROR_BADHANDLE;
   100d0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
        default :
            return -PAL_ERROR_BADHANDLE;
    }

    return 0;
}
   100d5:	c3                   	retq   
   100d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   100dd:	00 00 00 

    if (!IS_ERR(ret)) {
        struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
        if (chdr &&
            chdr->cmsg_type == SCM_RIGHTS) {
            msg_nfds = (hdr.msg_controllen - sizeof(struct cmsghdr)) /
   100e0:	48 83 e8 0c          	sub    $0xc,%rax
                       sizeof(int);
            memcpy(fds, CMSG_DATA(chdr), sizeof(int) * msg_nfds);
   100e4:	48 83 c6 10          	add    $0x10,%rsi
   100e8:	4c 89 f7             	mov    %r14,%rdi

    if (!IS_ERR(ret)) {
        struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
        if (chdr &&
            chdr->cmsg_type == SCM_RIGHTS) {
            msg_nfds = (hdr.msg_controllen - sizeof(struct cmsghdr)) /
   100eb:	48 c1 e8 02          	shr    $0x2,%rax
   100ef:	4c 89 8d 38 ff ff ff 	mov    %r9,-0xc8(%rbp)
   100f6:	4c 89 95 40 ff ff ff 	mov    %r10,-0xc0(%rbp)
                       sizeof(int);
            memcpy(fds, CMSG_DATA(chdr), sizeof(int) * msg_nfds);
   100fd:	48 8d 14 85 00 00 00 	lea    0x0(,%rax,4),%rdx
   10104:	00 

    if (!IS_ERR(ret)) {
        struct cmsghdr * chdr = CMSG_FIRSTHDR(&hdr);
        if (chdr &&
            chdr->cmsg_type == SCM_RIGHTS) {
            msg_nfds = (hdr.msg_controllen - sizeof(struct cmsghdr)) /
   10105:	41 89 c7             	mov    %eax,%r15d
                       sizeof(int);
            memcpy(fds, CMSG_DATA(chdr), sizeof(int) * msg_nfds);
   10108:	e8 73 61 00 00       	callq  16280 <memcpy>
   1010d:	4c 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%r10
   10114:	4c 8b 8d 38 ff ff ff 	mov    -0xc8(%rbp),%r9
   1011b:	e9 49 fd ff ff       	jmpq   fe69 <_DkReceiveHandle+0x1c9>
            if (msg_nfds < 1)
                return -PAL_ERROR_BADHANDLE;
            cargo->gipc.fd = fds[0];
            break;
        default :
            return -PAL_ERROR_BADHANDLE;
   10120:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   10125:	e9 30 fc ff ff       	jmpq   fd5a <_DkReceiveHandle+0xba>
   1012a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
                return -PAL_ERROR_BADHANDLE;
            cargo->pipeprv.fds[0] = fds[0];
            cargo->pipeprv.fds[1] = fds[1];
            break;
        case pal_type_dev: {
            int i = 0;
   10130:	31 c0                	xor    %eax,%eax
   10132:	e9 2d ff ff ff       	jmpq   10064 <_DkReceiveHandle+0x3c4>
   10137:	4c 89 d3             	mov    %r10,%rbx
   1013a:	e9 5b fe ff ff       	jmpq   ff9a <_DkReceiveHandle+0x2fa>
   1013f:	90                   	nop    
        case pal_type_tcp:
        case pal_type_tcpsrv:
        case pal_type_udp: {
            void * addr = msg_buf;
            if (cargo->sock.bind) {
                int len = addr_size(addr);
   10140:	bb 10 00 00 00       	mov    $0x10,%ebx
   10145:	be 10 00 00 00       	mov    $0x10,%esi
   1014a:	e9 13 fe ff ff       	jmpq   ff62 <_DkReceiveHandle+0x2c2>
   1014f:	90                   	nop    
                    return -PAL_ERROR_OVERFLOW;
                cargo->sock.bind = remalloc(addr, len);
                addr += len;
            }
            if (cargo->sock.conn) {
                int len = addr_size(addr);
   10150:	b8 10 00 00 00       	mov    $0x10,%eax
   10155:	be 10 00 00 00       	mov    $0x10,%esi
   1015a:	e9 6d fe ff ff       	jmpq   ffcc <_DkReceiveHandle+0x32c>
   1015f:	90                   	nop    
            msg_nfds = 0;
        }
    }

    // if error was returned
    if (IS_ERR(ret) && ERRNO(ret) != EINTR && ERRNO(ret) != ERESTART)
   10160:	83 f8 ab             	cmp    $0xffffffffffffffab,%eax
   10163:	0f 84 00 fd ff ff    	je     fe69 <_DkReceiveHandle+0x1c9>
   10169:	83 f8 fc             	cmp    $0xfffffffffffffffc,%eax
   1016c:	0f 85 e8 fb ff ff    	jne    fd5a <_DkReceiveHandle+0xba>
   10172:	e9 f2 fc ff ff       	jmpq   fe69 <_DkReceiveHandle+0x1c9>
   10177:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1017e:	00 00 
        case pal_type_udp: {
            void * addr = msg_buf;
            if (cargo->sock.bind) {
                int len = addr_size(addr);
                if (addr + len > msg_buf + msg_len)
                    return -PAL_ERROR_OVERFLOW;
   10180:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
   10185:	e9 d0 fb ff ff       	jmpq   fd5a <_DkReceiveHandle+0xba>
   1018a:	90                   	nop    
   1018b:	90                   	nop    
   1018c:	90                   	nop    
   1018d:	90                   	nop    
   1018e:	90                   	nop    
   1018f:	90                   	nop    

0000000000010190 <_DkVirtualMemoryAlloc>:

#include <sys/mman.h>

int _DkVirtualMemoryAlloc (void ** paddr, size_t size, int alloc_type,
                           int prot)
{
   10190:	89 d0                	mov    %edx,%eax
   10192:	55                   	push   %rbp
   10193:	41 89 cb             	mov    %ecx,%r11d

#define DEFAULT_BACKLOG     2048

static inline int HOST_FLAGS (int alloc_type, int prot)
{
    return ((alloc_type & PAL_ALLOC_32BIT) ? MAP_32BIT : 0) |
   10196:	83 e0 01             	and    $0x1,%eax
   10199:	83 f8 01             	cmp    $0x1,%eax
   1019c:	48 89 e5             	mov    %rsp,%rbp
           ((alloc_type & PAL_ALLOC_RESERVE) ? MAP_NORESERVE/*|MAP_UNINITIALIZED - not present in BSD*/ : 0) |
   1019f:	89 d0                	mov    %edx,%eax

#define DEFAULT_BACKLOG     2048

static inline int HOST_FLAGS (int alloc_type, int prot)
{
    return ((alloc_type & PAL_ALLOC_32BIT) ? MAP_32BIT : 0) |
   101a1:	45 19 c0             	sbb    %r8d,%r8d
   101a4:	41 54                	push   %r12
   101a6:	49 89 fc             	mov    %rdi,%r12
   101a9:	53                   	push   %rbx
   101aa:	41 81 e0 00 00 f8 ff 	and    $0xfff80000,%r8d
    void * addr = *paddr, * mem = addr;
   101b1:	48 8b 3f             	mov    (%rdi),%rdi
   101b4:	41 81 c0 02 00 08 00 	add    $0x80002,%r8d
           ((alloc_type & PAL_ALLOC_RESERVE) ? MAP_NORESERVE/*|MAP_UNINITIALIZED - not present in BSD*/ : 0) |
   101bb:	ba 40 00 00 00       	mov    $0x40,%edx
   101c0:	83 e0 02             	and    $0x2,%eax
   101c3:	0f 45 c2             	cmovne %edx,%eax
    int flags = HOST_FLAGS(alloc_type, prot|PAL_PROT_WRITECOPY);
    prot = HOST_PROT(prot);

    /* The memory should have MAP_PRIVATE and MAP_ANONYMOUS */
    flags |= MAP_ANONYMOUS|(addr ? MAP_FIXED : 0);
    mem = (void *) ARCH_MMAP(addr, size, prot, flags, -1, 0);
   101c6:	bb dd 01 00 00       	mov    $0x1dd,%ebx
   101cb:	44 89 da             	mov    %r11d,%edx

#define DEFAULT_BACKLOG     2048

static inline int HOST_FLAGS (int alloc_type, int prot)
{
    return ((alloc_type & PAL_ALLOC_32BIT) ? MAP_32BIT : 0) |
   101ce:	44 09 c0             	or     %r8d,%eax

    int flags = HOST_FLAGS(alloc_type, prot|PAL_PROT_WRITECOPY);
    prot = HOST_PROT(prot);

    /* The memory should have MAP_PRIVATE and MAP_ANONYMOUS */
    flags |= MAP_ANONYMOUS|(addr ? MAP_FIXED : 0);
   101d1:	48 83 ff 01          	cmp    $0x1,%rdi
    mem = (void *) ARCH_MMAP(addr, size, prot, flags, -1, 0);
   101d5:	49 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%r8
   101dc:	41 89 c2             	mov    %eax,%r10d

    int flags = HOST_FLAGS(alloc_type, prot|PAL_PROT_WRITECOPY);
    prot = HOST_PROT(prot);

    /* The memory should have MAP_PRIVATE and MAP_ANONYMOUS */
    flags |= MAP_ANONYMOUS|(addr ? MAP_FIXED : 0);
   101df:	19 c0                	sbb    %eax,%eax
    mem = (void *) ARCH_MMAP(addr, size, prot, flags, -1, 0);
   101e1:	45 31 c9             	xor    %r9d,%r9d

    int flags = HOST_FLAGS(alloc_type, prot|PAL_PROT_WRITECOPY);
    prot = HOST_PROT(prot);

    /* The memory should have MAP_PRIVATE and MAP_ANONYMOUS */
    flags |= MAP_ANONYMOUS|(addr ? MAP_FIXED : 0);
   101e4:	83 e0 f0             	and    $0xfffffffffffffff0,%eax
   101e7:	44 89 d1             	mov    %r10d,%ecx
    mem = (void *) ARCH_MMAP(addr, size, prot, flags, -1, 0);
   101ea:	83 e2 07             	and    $0x7,%edx

    int flags = HOST_FLAGS(alloc_type, prot|PAL_PROT_WRITECOPY);
    prot = HOST_PROT(prot);

    /* The memory should have MAP_PRIVATE and MAP_ANONYMOUS */
    flags |= MAP_ANONYMOUS|(addr ? MAP_FIXED : 0);
   101ed:	05 10 10 00 00       	add    $0x1010,%eax
   101f2:	09 c1                	or     %eax,%ecx
    mem = (void *) ARCH_MMAP(addr, size, prot, flags, -1, 0);
   101f4:	89 d8                	mov    %ebx,%eax
   101f6:	48 63 c9             	movslq %ecx,%rcx
   101f9:	cd 80                	int    $0x80
   101fb:	48 89 c1             	mov    %rax,%rcx
   101fe:	bb 00 00 00 00       	mov    $0x0,%ebx
   10203:	83 d3 00             	adc    $0x0,%ebx
   10206:	31 d2                	xor    %edx,%edx
   10208:	85 db                	test   %ebx,%ebx
   1020a:	0f 95 c2             	setne  %dl
   1020d:	48 89 d0             	mov    %rdx,%rax
   10210:	48 f7 d8             	neg    %rax
   10213:	48 31 c8             	xor    %rcx,%rax
   10216:	48 01 d0             	add    %rdx,%rax

    if (IS_ERR_P(mem))
   10219:	48 3d 00 f0 ff ff    	cmp    $0xfffffffffffff000,%rax
   1021f:	77 0f                	ja     10230 <_DkVirtualMemoryAlloc+0xa0>
        return unix_to_pal_error(ERRNO_P(mem));

    *paddr = mem;
   10221:	49 89 04 24          	mov    %rax,(%r12)
    return 0;
   10225:	31 c0                	xor    %eax,%eax
}
   10227:	5b                   	pop    %rbx
   10228:	41 5c                	pop    %r12
   1022a:	5d                   	pop    %rbp
   1022b:	c3                   	retq   
   1022c:	0f 1f 40 00          	nopl   0x0(%rax)
    /* The memory should have MAP_PRIVATE and MAP_ANONYMOUS */
    flags |= MAP_ANONYMOUS|(addr ? MAP_FIXED : 0);
    mem = (void *) ARCH_MMAP(addr, size, prot, flags, -1, 0);

    if (IS_ERR_P(mem))
        return unix_to_pal_error(ERRNO_P(mem));
   10230:	f7 d8                	neg    %eax
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   10232:	83 f8 6e             	cmp    $0x6e,%eax
   10235:	0f 87 c5 00 00 00    	ja     10300 <_DkVirtualMemoryAlloc+0x170>
   1023b:	48 8d 15 a6 d5 00 00 	lea    0xd5a6(%rip),%rdx        # 1d7e8 <slab_levels+0x4548>
   10242:	89 c0                	mov    %eax,%eax
   10244:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
   10248:	48 01 c2             	add    %rax,%rdx
   1024b:	ff e2                	jmpq   *%rdx
   1024d:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
   10250:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   10255:	eb d0                	jmp    10227 <_DkVirtualMemoryAlloc+0x97>
   10257:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1025e:	00 00 
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
   10260:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   10265:	eb c0                	jmp    10227 <_DkVirtualMemoryAlloc+0x97>
   10267:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1026e:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
   10270:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   10275:	eb b0                	jmp    10227 <_DkVirtualMemoryAlloc+0x97>
   10277:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1027e:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
   10280:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   10285:	eb a0                	jmp    10227 <_DkVirtualMemoryAlloc+0x97>
   10287:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1028e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
   10290:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   10295:	eb 90                	jmp    10227 <_DkVirtualMemoryAlloc+0x97>
   10297:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1029e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
   102a0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   102a5:	eb 80                	jmp    10227 <_DkVirtualMemoryAlloc+0x97>
   102a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   102ae:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
   102b0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   102b5:	e9 6d ff ff ff       	jmpq   10227 <_DkVirtualMemoryAlloc+0x97>
   102ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
   102c0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
   102c5:	e9 5d ff ff ff       	jmpq   10227 <_DkVirtualMemoryAlloc+0x97>
   102ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
   102d0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   102d5:	e9 4d ff ff ff       	jmpq   10227 <_DkVirtualMemoryAlloc+0x97>
   102da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
   102e0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   102e5:	e9 3d ff ff ff       	jmpq   10227 <_DkVirtualMemoryAlloc+0x97>
   102ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
   102f0:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   102f5:	e9 2d ff ff ff       	jmpq   10227 <_DkVirtualMemoryAlloc+0x97>
   102fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
   10300:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   10305:	e9 1d ff ff ff       	jmpq   10227 <_DkVirtualMemoryAlloc+0x97>
   1030a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000010310 <_DkVirtualMemoryFree>:
    *paddr = mem;
    return 0;
}

int _DkVirtualMemoryFree (void * addr, size_t size)
{
   10310:	55                   	push   %rbp
   10311:	48 89 e5             	mov    %rsp,%rbp
   10314:	53                   	push   %rbx
    int ret = INLINE_SYSCALL(munmap, 2, addr, size);
   10315:	bb 49 00 00 00       	mov    $0x49,%ebx
   1031a:	89 d8                	mov    %ebx,%eax
   1031c:	cd 80                	int    $0x80
   1031e:	48 89 c1             	mov    %rax,%rcx
   10321:	bb 00 00 00 00       	mov    $0x0,%ebx
   10326:	83 d3 00             	adc    $0x0,%ebx
   10329:	31 d2                	xor    %edx,%edx
   1032b:	85 db                	test   %ebx,%ebx
   1032d:	0f 95 c2             	setne  %dl
   10330:	48 89 d0             	mov    %rdx,%rax
   10333:	48 f7 d8             	neg    %rax
   10336:	48 31 c1             	xor    %rax,%rcx

    return IS_ERR(ret) ? unix_to_pal_error(ERRNO(ret)) : 0;
   10339:	31 c0                	xor    %eax,%eax
   1033b:	48 01 ca             	add    %rcx,%rdx
   1033e:	85 d2                	test   %edx,%edx
   10340:	78 03                	js     10345 <_DkVirtualMemoryFree+0x35>
}
   10342:	5b                   	pop    %rbx
   10343:	5d                   	pop    %rbp
   10344:	c3                   	retq   

int _DkVirtualMemoryFree (void * addr, size_t size)
{
    int ret = INLINE_SYSCALL(munmap, 2, addr, size);

    return IS_ERR(ret) ? unix_to_pal_error(ERRNO(ret)) : 0;
   10345:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   10347:	83 fa 6e             	cmp    $0x6e,%edx
   1034a:	0f 87 c0 00 00 00    	ja     10410 <_DkVirtualMemoryFree+0x100>
   10350:	48 8d 05 4d d6 00 00 	lea    0xd64d(%rip),%rax        # 1d9a4 <slab_levels+0x4704>
   10357:	89 d2                	mov    %edx,%edx
   10359:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
   1035d:	48 01 d0             	add    %rdx,%rax
   10360:	ff e0                	jmpq   *%rax
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
   10362:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   10367:	eb d9                	jmp    10342 <_DkVirtualMemoryFree+0x32>
   10369:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
   10370:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   10375:	eb cb                	jmp    10342 <_DkVirtualMemoryFree+0x32>
   10377:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1037e:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
   10380:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   10385:	eb bb                	jmp    10342 <_DkVirtualMemoryFree+0x32>
   10387:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1038e:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
   10390:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   10395:	eb ab                	jmp    10342 <_DkVirtualMemoryFree+0x32>
   10397:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1039e:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
   103a0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   103a5:	eb 9b                	jmp    10342 <_DkVirtualMemoryFree+0x32>
   103a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   103ae:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
   103b0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   103b5:	eb 8b                	jmp    10342 <_DkVirtualMemoryFree+0x32>
   103b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   103be:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
   103c0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   103c5:	e9 78 ff ff ff       	jmpq   10342 <_DkVirtualMemoryFree+0x32>
   103ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
   103d0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
   103d5:	e9 68 ff ff ff       	jmpq   10342 <_DkVirtualMemoryFree+0x32>
   103da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
   103e0:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   103e5:	e9 58 ff ff ff       	jmpq   10342 <_DkVirtualMemoryFree+0x32>
   103ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
   103f0:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   103f5:	e9 48 ff ff ff       	jmpq   10342 <_DkVirtualMemoryFree+0x32>
   103fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
   10400:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   10405:	e9 38 ff ff ff       	jmpq   10342 <_DkVirtualMemoryFree+0x32>
   1040a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
   10410:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   10415:	e9 28 ff ff ff       	jmpq   10342 <_DkVirtualMemoryFree+0x32>
   1041a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000010420 <_DkVirtualMemoryProtect>:
}

int _DkVirtualMemoryProtect (void * addr, size_t size, int prot)
{
   10420:	55                   	push   %rbp
    int ret = INLINE_SYSCALL(mprotect, 3, addr, size, HOST_PROT(prot));
   10421:	b9 4a 00 00 00       	mov    $0x4a,%ecx
   10426:	83 e2 07             	and    $0x7,%edx
   10429:	89 c8                	mov    %ecx,%eax

    return IS_ERR(ret) ? unix_to_pal_error(ERRNO(ret)) : 0;
}

int _DkVirtualMemoryProtect (void * addr, size_t size, int prot)
{
   1042b:	48 89 e5             	mov    %rsp,%rbp
   1042e:	53                   	push   %rbx
    int ret = INLINE_SYSCALL(mprotect, 3, addr, size, HOST_PROT(prot));
   1042f:	cd 80                	int    $0x80
   10431:	48 89 c1             	mov    %rax,%rcx
   10434:	bb 00 00 00 00       	mov    $0x0,%ebx
   10439:	83 d3 00             	adc    $0x0,%ebx
   1043c:	31 d2                	xor    %edx,%edx
   1043e:	85 db                	test   %ebx,%ebx
   10440:	0f 95 c2             	setne  %dl
   10443:	48 89 d0             	mov    %rdx,%rax
   10446:	48 f7 d8             	neg    %rax
   10449:	48 31 c8             	xor    %rcx,%rax
   1044c:	48 01 c2             	add    %rax,%rdx

    return IS_ERR(ret) ? unix_to_pal_error(ERRNO(ret)) : 0;
   1044f:	31 c0                	xor    %eax,%eax
   10451:	85 d2                	test   %edx,%edx
   10453:	78 0b                	js     10460 <_DkVirtualMemoryProtect+0x40>
}
   10455:	5b                   	pop    %rbx
   10456:	5d                   	pop    %rbp
   10457:	c3                   	retq   
   10458:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1045f:	00 

int _DkVirtualMemoryProtect (void * addr, size_t size, int prot)
{
    int ret = INLINE_SYSCALL(mprotect, 3, addr, size, HOST_PROT(prot));

    return IS_ERR(ret) ? unix_to_pal_error(ERRNO(ret)) : 0;
   10460:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   10462:	83 fa 6e             	cmp    $0x6e,%edx
   10465:	0f 87 c5 00 00 00    	ja     10530 <_DkVirtualMemoryProtect+0x110>
   1046b:	48 8d 05 ee d6 00 00 	lea    0xd6ee(%rip),%rax        # 1db60 <slab_levels+0x48c0>
   10472:	89 d2                	mov    %edx,%edx
   10474:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
   10478:	48 01 d0             	add    %rdx,%rax
   1047b:	ff e0                	jmpq   *%rax
   1047d:	0f 1f 00             	nopl   (%rax)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
   10480:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   10485:	eb ce                	jmp    10455 <_DkVirtualMemoryProtect+0x35>
   10487:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1048e:	00 00 
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
   10490:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   10495:	eb be                	jmp    10455 <_DkVirtualMemoryProtect+0x35>
   10497:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1049e:	00 00 
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
   104a0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   104a5:	eb ae                	jmp    10455 <_DkVirtualMemoryProtect+0x35>
   104a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   104ae:	00 00 
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
   104b0:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   104b5:	eb 9e                	jmp    10455 <_DkVirtualMemoryProtect+0x35>
   104b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   104be:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
   104c0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   104c5:	eb 8e                	jmp    10455 <_DkVirtualMemoryProtect+0x35>
   104c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   104ce:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
   104d0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   104d5:	e9 7b ff ff ff       	jmpq   10455 <_DkVirtualMemoryProtect+0x35>
   104da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
   104e0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   104e5:	e9 6b ff ff ff       	jmpq   10455 <_DkVirtualMemoryProtect+0x35>
   104ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
   104f0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
   104f5:	e9 5b ff ff ff       	jmpq   10455 <_DkVirtualMemoryProtect+0x35>
   104fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
   10500:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   10505:	e9 4b ff ff ff       	jmpq   10455 <_DkVirtualMemoryProtect+0x35>
   1050a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
   10510:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   10515:	e9 3b ff ff ff       	jmpq   10455 <_DkVirtualMemoryProtect+0x35>
   1051a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
   10520:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   10525:	e9 2b ff ff ff       	jmpq   10455 <_DkVirtualMemoryProtect+0x35>
   1052a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
   10530:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   10535:	e9 1b ff ff ff       	jmpq   10455 <_DkVirtualMemoryProtect+0x35>
   1053a:	90                   	nop    
   1053b:	90                   	nop    
   1053c:	90                   	nop    
   1053d:	90                   	nop    
   1053e:	90                   	nop    
   1053f:	90                   	nop    

0000000000010540 <_DkThreadPrivate>:

/* PAL call DkThreadPrivate: set up the thread private area for the
   current thread. if addr is 0, return the current thread private
   area. */
void * _DkThreadPrivate (void * addr)
{
   10540:	55                   	push   %rbp
    //No arch_set_fs etc in BSD, Linux specific only.
    // return NULL;
    
    int ret = 0;

    if ((void *) addr == 0) {
   10541:	48 85 ff             	test   %rdi,%rdi

/* PAL call DkThreadPrivate: set up the thread private area for the
   current thread. if addr is 0, return the current thread private
   area. */
void * _DkThreadPrivate (void * addr)
{
   10544:	48 89 fa             	mov    %rdi,%rdx
   10547:	48 89 e5             	mov    %rsp,%rbp
   1054a:	53                   	push   %rbx
    //No arch_set_fs etc in BSD, Linux specific only.
    // return NULL;
    
    int ret = 0;

    if ((void *) addr == 0) {
   1054b:	74 43                	je     10590 <_DkThreadPrivate+0x50>
        u_info->entry_number = -1;
        u_info->base_addr = (unsigned int) addr;

        ret = INLINE_SYSCALL(set_thread_area, 1, &u_info);
#else
        ret = INLINE_SYSCALL(sysarch, 2, AMD64_SET_FSBASE, addr);
   1054d:	bb a5 00 00 00       	mov    $0xa5,%ebx
   10552:	48 89 fe             	mov    %rdi,%rsi
   10555:	bf 81 00 00 00       	mov    $0x81,%edi
   1055a:	89 d8                	mov    %ebx,%eax
   1055c:	cd 80                	int    $0x80
   1055e:	48 89 c1             	mov    %rax,%rcx
   10561:	bb 00 00 00 00       	mov    $0x0,%ebx
   10566:	83 d3 00             	adc    $0x0,%ebx
   10569:	31 f6                	xor    %esi,%esi
   1056b:	85 db                	test   %ebx,%ebx
   1056d:	40 0f 95 c6          	setne  %sil
   10571:	48 89 f0             	mov    %rsi,%rax
   10574:	48 f7 d8             	neg    %rax
   10577:	48 31 c1             	xor    %rax,%rcx
#endif
        if (IS_ERR(ret))
   1057a:	89 c8                	mov    %ecx,%eax
   1057c:	01 f0                	add    %esi,%eax
   1057e:	b8 00 00 00 00       	mov    $0x0,%eax
   10583:	48 0f 49 c2          	cmovns %rdx,%rax
            return NULL;

        return addr;
    }
}
   10587:	5b                   	pop    %rbx
   10588:	5d                   	pop    %rbp
   10589:	c3                   	retq   
   1058a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

        void * thread_area = u_info->base_addr;
#else
        unsigned long ret_addr;

        ret = INLINE_SYSCALL(sysarch, 2, AMD64_GET_FSBASE, &ret_addr);
   10590:	bb a5 00 00 00       	mov    $0xa5,%ebx
   10595:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
   10599:	bf 80 00 00 00       	mov    $0x80,%edi
   1059e:	89 d8                	mov    %ebx,%eax
   105a0:	cd 80                	int    $0x80
   105a2:	48 89 c2             	mov    %rax,%rdx
   105a5:	bb 00 00 00 00       	mov    $0x0,%ebx
   105aa:	83 d3 00             	adc    $0x0,%ebx
   105ad:	31 c9                	xor    %ecx,%ecx
   105af:	85 db                	test   %ebx,%ebx
   105b1:	0f 95 c1             	setne  %cl
   105b4:	48 89 c8             	mov    %rcx,%rax
   105b7:	48 f7 d8             	neg    %rax
   105ba:	48 31 c2             	xor    %rax,%rdx

        if (IS_ERR(ret))
   105bd:	89 d0                	mov    %edx,%eax
   105bf:	01 c8                	add    %ecx,%eax
   105c1:	78 0d                	js     105d0 <_DkThreadPrivate+0x90>
            return NULL;

        void * thread_area = (void *) ret_addr;
   105c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
        if (IS_ERR(ret))
            return NULL;

        return addr;
    }
}
   105c7:	5b                   	pop    %rbx
   105c8:	5d                   	pop    %rbp
   105c9:	c3                   	retq   
   105ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        unsigned long ret_addr;

        ret = INLINE_SYSCALL(sysarch, 2, AMD64_GET_FSBASE, &ret_addr);

        if (IS_ERR(ret))
            return NULL;
   105d0:	31 c0                	xor    %eax,%eax
   105d2:	eb b3                	jmp    10587 <_DkThreadPrivate+0x47>
   105d4:	66 66 66 2e 0f 1f 84 	nopw   %cs:0x0(%rax,%rax,1)
   105db:	00 00 00 00 00 

00000000000105e0 <_DkThreadDelayExecution>:
        return addr;
    }
}

int _DkThreadDelayExecution (unsigned long * duration)
{
   105e0:	55                   	push   %rbp
    struct timespec sleeptime;
    struct timespec remainingtime;

    long sec = (unsigned long) *duration / 1000000;
   105e1:	48 ba db 34 b6 d7 82 	mov    $0x431bde82d7b634db,%rdx
   105e8:	de 1b 43 
        return addr;
    }
}

int _DkThreadDelayExecution (unsigned long * duration)
{
   105eb:	49 89 f8             	mov    %rdi,%r8
   105ee:	48 89 e5             	mov    %rsp,%rbp
   105f1:	53                   	push   %rbx
    long microsec = (unsigned long) *duration - (sec * 1000000);

    sleeptime.tv_sec = sec;
    sleeptime.tv_nsec = microsec * 1000;

    int ret = INLINE_SYSCALL(nanosleep, 2, &sleeptime, &remainingtime);
   105f2:	bb f0 00 00 00       	mov    $0xf0,%ebx
   105f7:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
        return addr;
    }
}

int _DkThreadDelayExecution (unsigned long * duration)
{
   105fb:	48 8b 0f             	mov    (%rdi),%rcx
    long microsec = (unsigned long) *duration - (sec * 1000000);

    sleeptime.tv_sec = sec;
    sleeptime.tv_nsec = microsec * 1000;

    int ret = INLINE_SYSCALL(nanosleep, 2, &sleeptime, &remainingtime);
   105fe:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
int _DkThreadDelayExecution (unsigned long * duration)
{
    struct timespec sleeptime;
    struct timespec remainingtime;

    long sec = (unsigned long) *duration / 1000000;
   10602:	48 89 c8             	mov    %rcx,%rax
   10605:	48 f7 e2             	mul    %rdx
    long microsec = (unsigned long) *duration - (sec * 1000000);

    sleeptime.tv_sec = sec;
    sleeptime.tv_nsec = microsec * 1000;

    int ret = INLINE_SYSCALL(nanosleep, 2, &sleeptime, &remainingtime);
   10608:	89 d8                	mov    %ebx,%eax
int _DkThreadDelayExecution (unsigned long * duration)
{
    struct timespec sleeptime;
    struct timespec remainingtime;

    long sec = (unsigned long) *duration / 1000000;
   1060a:	48 c1 ea 12          	shr    $0x12,%rdx
    long microsec = (unsigned long) *duration - (sec * 1000000);

    sleeptime.tv_sec = sec;
   1060e:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
{
    struct timespec sleeptime;
    struct timespec remainingtime;

    long sec = (unsigned long) *duration / 1000000;
    long microsec = (unsigned long) *duration - (sec * 1000000);
   10612:	48 69 d2 c0 bd f0 ff 	imul   $0xfffffffffff0bdc0,%rdx,%rdx
   10619:	48 01 ca             	add    %rcx,%rdx

    sleeptime.tv_sec = sec;
    sleeptime.tv_nsec = microsec * 1000;
   1061c:	48 69 d2 e8 03 00 00 	imul   $0x3e8,%rdx,%rdx
   10623:	48 89 55 d8          	mov    %rdx,-0x28(%rbp)

    int ret = INLINE_SYSCALL(nanosleep, 2, &sleeptime, &remainingtime);
   10627:	cd 80                	int    $0x80
   10629:	48 89 c2             	mov    %rax,%rdx
   1062c:	bb 00 00 00 00       	mov    $0x0,%ebx
   10631:	83 d3 00             	adc    $0x0,%ebx
   10634:	31 c9                	xor    %ecx,%ecx
   10636:	85 db                	test   %ebx,%ebx
   10638:	0f 95 c1             	setne  %cl
   1063b:	48 89 c8             	mov    %rcx,%rax
   1063e:	48 f7 d8             	neg    %rax
   10641:	48 31 c2             	xor    %rax,%rdx

    if (IS_ERR(ret)) {
   10644:	89 d0                	mov    %edx,%eax
   10646:	01 c8                	add    %ecx,%eax
   10648:	78 06                	js     10650 <_DkThreadDelayExecution+0x70>

        *duration -= remaining;
        return -PAL_ERROR_INTERRUPTED;
    }

    return 0;
   1064a:	31 c0                	xor    %eax,%eax
}
   1064c:	5b                   	pop    %rbx
   1064d:	5d                   	pop    %rbp
   1064e:	c3                   	retq   
   1064f:	90                   	nop    

    int ret = INLINE_SYSCALL(nanosleep, 2, &sleeptime, &remainingtime);

    if (IS_ERR(ret)) {
        PAL_NUM remaining = remainingtime.tv_sec * 1000000 +
                            remainingtime.tv_nsec / 1000;
   10650:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
   10654:	48 ba cf f7 53 e3 a5 	mov    $0x20c49ba5e353f7cf,%rdx
   1065b:	9b c4 20 
    sleeptime.tv_nsec = microsec * 1000;

    int ret = INLINE_SYSCALL(nanosleep, 2, &sleeptime, &remainingtime);

    if (IS_ERR(ret)) {
        PAL_NUM remaining = remainingtime.tv_sec * 1000000 +
   1065e:	48 69 75 e0 40 42 0f 	imul   $0xf4240,-0x20(%rbp),%rsi
   10665:	00 
                            remainingtime.tv_nsec / 1000;
   10666:	48 89 c8             	mov    %rcx,%rax
   10669:	48 c1 f9 3f          	sar    $0x3f,%rcx
   1066d:	48 f7 ea             	imul   %rdx
   10670:	48 c1 fa 07          	sar    $0x7,%rdx
   10674:	48 29 ca             	sub    %rcx,%rdx
    sleeptime.tv_nsec = microsec * 1000;

    int ret = INLINE_SYSCALL(nanosleep, 2, &sleeptime, &remainingtime);

    if (IS_ERR(ret)) {
        PAL_NUM remaining = remainingtime.tv_sec * 1000000 +
   10677:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
                            remainingtime.tv_nsec / 1000;

        *duration -= remaining;
   1067b:	49 29 00             	sub    %rax,(%r8)
        return -PAL_ERROR_INTERRUPTED;
   1067e:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   10683:	eb c7                	jmp    1064c <_DkThreadDelayExecution+0x6c>
   10685:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
   1068c:	00 00 00 00 

0000000000010690 <_DkThreadYieldExecution>:
}

/* PAL call DkThreadYieldExecution. Yield the execution
   of the current thread. */
void _DkThreadYieldExecution (void)
{
   10690:	55                   	push   %rbp
    INLINE_SYSCALL(sched_yield, 0);
   10691:	b8 4b 01 00 00       	mov    $0x14b,%eax
}

/* PAL call DkThreadYieldExecution. Yield the execution
   of the current thread. */
void _DkThreadYieldExecution (void)
{
   10696:	48 89 e5             	mov    %rsp,%rbp
   10699:	53                   	push   %rbx
    INLINE_SYSCALL(sched_yield, 0);
   1069a:	cd 80                	int    $0x80
   1069c:	bb 00 00 00 00       	mov    $0x0,%ebx
   106a1:	83 d3 00             	adc    $0x0,%ebx
}
   106a4:	5b                   	pop    %rbx
   106a5:	5d                   	pop    %rbp
   106a6:	c3                   	retq   
   106a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   106ae:	00 00 

00000000000106b0 <_DkThreadExit>:

/* _DkThreadExit for internal use: Thread exiting */
void _DkThreadExit (int exitcode)
{
   106b0:	55                   	push   %rbp
    INLINE_SYSCALL(exit, 1, 0);
   106b1:	31 ff                	xor    %edi,%edi
   106b3:	b8 01 00 00 00       	mov    $0x1,%eax
    INLINE_SYSCALL(sched_yield, 0);
}

/* _DkThreadExit for internal use: Thread exiting */
void _DkThreadExit (int exitcode)
{
   106b8:	48 89 e5             	mov    %rsp,%rbp
   106bb:	53                   	push   %rbx
    INLINE_SYSCALL(exit, 1, 0);
   106bc:	cd 80                	int    $0x80
   106be:	bb 00 00 00 00       	mov    $0x0,%ebx
   106c3:	83 d3 00             	adc    $0x0,%ebx
}
   106c6:	5b                   	pop    %rbx
   106c7:	5d                   	pop    %rbp
   106c8:	c3                   	retq   
   106c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

00000000000106d0 <_DkThreadCreate>:
/* _DkThreadCreate for internal use. Create an internal thread
   inside the current process. The arguments callback and param
   specify the starting function and parameters */
int _DkThreadCreate (PAL_HANDLE * handle, int (*callback) (void *),
                     const void * param, int flags)
{
   106d0:	55                   	push   %rbp
    // align child_stack to 16 
    child_stack = (void *) ((uintptr_t) child_stack & ~16);

    flags &= PAL_THREAD_MASK;
	*/
    printf("",param);//Just to stop the compiler from optimizing out param!!
   106d1:	31 c0                	xor    %eax,%eax
/* _DkThreadCreate for internal use. Create an internal thread
   inside the current process. The arguments callback and param
   specify the starting function and parameters */
int _DkThreadCreate (PAL_HANDLE * handle, int (*callback) (void *),
                     const void * param, int flags)
{
   106d3:	48 89 e5             	mov    %rsp,%rbp
   106d6:	41 56                	push   %r14
   106d8:	41 55                	push   %r13
   106da:	41 54                	push   %r12
   106dc:	49 89 fc             	mov    %rdi,%r12
   106df:	53                   	push   %rbx
    // align child_stack to 16 
    child_stack = (void *) ((uintptr_t) child_stack & ~16);

    flags &= PAL_THREAD_MASK;
	*/
    printf("",param);//Just to stop the compiler from optimizing out param!!
   106e0:	48 8d 3d 12 83 00 00 	lea    0x8312(%rip),%rdi        # 189f9 <handle_sizes.1924+0x279>
/* _DkThreadCreate for internal use. Create an internal thread
   inside the current process. The arguments callback and param
   specify the starting function and parameters */
int _DkThreadCreate (PAL_HANDLE * handle, int (*callback) (void *),
                     const void * param, int flags)
{
   106e7:	49 89 f5             	mov    %rsi,%r13
    // align child_stack to 16 
    child_stack = (void *) ((uintptr_t) child_stack & ~16);

    flags &= PAL_THREAD_MASK;
	*/
    printf("",param);//Just to stop the compiler from optimizing out param!!
   106ea:	48 89 d6             	mov    %rdx,%rsi
/* _DkThreadCreate for internal use. Create an internal thread
   inside the current process. The arguments callback and param
   specify the starting function and parameters */
int _DkThreadCreate (PAL_HANDLE * handle, int (*callback) (void *),
                     const void * param, int flags)
{
   106ed:	49 89 d6             	mov    %rdx,%r14
    // align child_stack to 16 
    child_stack = (void *) ((uintptr_t) child_stack & ~16);

    flags &= PAL_THREAD_MASK;
	*/
    printf("",param);//Just to stop the compiler from optimizing out param!!
   106f0:	e8 2b 87 ff ff       	callq  8e20 <pal_printf>
    int tid = 0;
    int ret = INLINE_SYSCALL(fork,0);
   106f5:	be 02 00 00 00       	mov    $0x2,%esi
   106fa:	89 f0                	mov    %esi,%eax
   106fc:	cd 80                	int    $0x80
   106fe:	48 89 c1             	mov    %rax,%rcx
   10701:	bb 00 00 00 00       	mov    $0x0,%ebx
   10706:	83 d3 00             	adc    $0x0,%ebx
   10709:	31 d2                	xor    %edx,%edx
   1070b:	85 db                	test   %ebx,%ebx
   1070d:	0f 95 c2             	setne  %dl
   10710:	48 89 d0             	mov    %rdx,%rax
   10713:	48 f7 d8             	neg    %rax
   10716:	48 31 c1             	xor    %rax,%rcx
   10719:	48 8d 1c 11          	lea    (%rcx,%rdx,1),%rbx
    //int ret = INLINE_SYSCALL(rfork,1, RFPROC|RFFDG|RFSIGSHARE|RFNOWAIT);
    if(ret == 0)
   1071d:	85 db                	test   %ebx,%ebx
   1071f:	74 3f                	je     10760 <_DkThreadCreate+0x90>
                      CLONE_PARENT_SETTID|flags,
                      param, &tid, NULL);

    */
    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;
   10721:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
                      CLONE_THREAD|CLONE_SIGHAND|CLONE_PTRACE|
                      CLONE_PARENT_SETTID|flags,
                      param, &tid, NULL);

    */
    if (IS_ERR(ret))
   10726:	78 27                	js     1074f <_DkThreadCreate+0x7f>
        return -PAL_ERROR_DENIED;
    
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(thread));
   10728:	bf 10 00 00 00       	mov    $0x10,%edi
   1072d:	e8 ce 82 ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, thread);
   10732:	c7 00 0e 00 00 00    	movl   $0xe,(%rax)
   10738:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
   1073f:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    hdl->thread.tid = tid;
   10746:	89 58 0c             	mov    %ebx,0xc(%rax)
    *handle = hdl;
   10749:	49 89 04 24          	mov    %rax,(%r12)

    /* _DkThreadAdd(tid); */

    return 0;
   1074d:	31 c0                	xor    %eax,%eax
}
   1074f:	5b                   	pop    %rbx
   10750:	41 5c                	pop    %r12
   10752:	41 5d                	pop    %r13
   10754:	41 5e                	pop    %r14
   10756:	5d                   	pop    %rbp
   10757:	c3                   	retq   
   10758:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1075f:	00 
    int tid = 0;
    int ret = INLINE_SYSCALL(fork,0);
    //int ret = INLINE_SYSCALL(rfork,1, RFPROC|RFFDG|RFSIGSHARE|RFNOWAIT);
    if(ret == 0)
    {
	int r = ((int (*) (const void *))callback) (param);
   10760:	4c 89 f7             	mov    %r14,%rdi
   10763:	41 ff d5             	callq  *%r13
	_DkThreadExit(r);
   10766:	89 c7                	mov    %eax,%edi
   10768:	e8 43 ff ff ff       	callq  106b0 <_DkThreadExit>
   1076d:	eb b9                	jmp    10728 <_DkThreadCreate+0x58>
   1076f:	90                   	nop    

0000000000010770 <_DkThreadResume>:
{
    INLINE_SYSCALL(exit, 1, 0);
}

int _DkThreadResume (PAL_HANDLE threadHandle)
{
   10770:	48 8b 05 e9 31 21 00 	mov    0x2131e9(%rip),%rax        # 223960 <_DYNAMIC+0x178>
   10777:	55                   	push   %rbp
    int ret = INLINE_SYSCALL(thr_kill2, 3, pal_linux_config.pid,\
   10778:	b9 e1 01 00 00       	mov    $0x1e1,%ecx
   1077d:	ba 13 00 00 00       	mov    $0x13,%edx
{
    INLINE_SYSCALL(exit, 1, 0);
}

int _DkThreadResume (PAL_HANDLE threadHandle)
{
   10782:	48 89 e5             	mov    %rsp,%rbp
   10785:	53                   	push   %rbx
    int ret = INLINE_SYSCALL(thr_kill2, 3, pal_linux_config.pid,\
   10786:	8b 77 0c             	mov    0xc(%rdi),%esi
   10789:	8b 38                	mov    (%rax),%edi
   1078b:	89 c8                	mov    %ecx,%eax
   1078d:	cd 80                	int    $0x80
   1078f:	48 89 c1             	mov    %rax,%rcx
   10792:	bb 00 00 00 00       	mov    $0x0,%ebx
   10797:	83 d3 00             	adc    $0x0,%ebx
   1079a:	31 d2                	xor    %edx,%edx
   1079c:	85 db                	test   %ebx,%ebx
   1079e:	0f 95 c2             	setne  %dl
   107a1:	48 89 d0             	mov    %rdx,%rax
   107a4:	48 f7 d8             	neg    %rax
   107a7:	48 31 c8             	xor    %rcx,%rax
   107aa:	48 01 d0             	add    %rdx,%rax
                             threadHandle->thread.tid, SIGCONT);//BSD specific syscall
    //int ret = INLINE_SYSCALL(kill, 2, threadHandle->thread.tid, SIGCONT);
    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
   107ad:	c1 f8 1f             	sar    $0x1f,%eax
   107b0:	83 e0 fa             	and    $0xfffffffffffffffa,%eax
}
   107b3:	5b                   	pop    %rbx
   107b4:	5d                   	pop    %rbp
   107b5:	c3                   	retq   
   107b6:	90                   	nop    
   107b7:	90                   	nop    
   107b8:	90                   	nop    
   107b9:	90                   	nop    
   107ba:	90                   	nop    
   107bb:	90                   	nop    
   107bc:	90                   	nop    
   107bd:	90                   	nop    
   107be:	90                   	nop    
   107bf:	90                   	nop    

00000000000107c0 <_DkSemaphoreCreate>:
    return dec;
}

int
_DkSemaphoreCreate (PAL_HANDLE handle, int initialCount, int maxCount)
{
   107c0:	48 63 c2             	movslq %edx,%rax
   107c3:	55                   	push   %rbp
     * 1. Allocate memory for db_sem (this includes a futex variable).
     * 2. Pack it into a PAL_HANDLE
     * 3. Set the semaphore object with the argument values (count, maxCount)
     */

    SET_HANDLE_TYPE(handle, semaphore);
   107c4:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%rdi)
    atomic_set(&handle->semaphore.nwaiters, 0);
    handle->semaphore.max_value = maxCount;

    /* optimization: if maxCount == 1, we make it into mutex */
    if (handle->semaphore.max_value == 1) {
   107cb:	48 83 f8 01          	cmp    $0x1,%rax
     * 1. Allocate memory for db_sem (this includes a futex variable).
     * 2. Pack it into a PAL_HANDLE
     * 3. Set the semaphore object with the argument values (count, maxCount)
     */

    SET_HANDLE_TYPE(handle, semaphore);
   107cf:	c7 07 0f 00 00 00    	movl   $0xf,(%rdi)
   107d5:	c7 47 08 00 00 00 00 	movl   $0x0,0x8(%rdi)
    return dec;
}

int
_DkSemaphoreCreate (PAL_HANDLE handle, int initialCount, int maxCount)
{
   107dc:	48 89 e5             	mov    %rsp,%rbp
    return v->counter;
}

static inline void atomic_set (struct atomic_int * v, int i)
{
    v->counter = i;
   107df:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)
     * 3. Set the semaphore object with the argument values (count, maxCount)
     */

    SET_HANDLE_TYPE(handle, semaphore);
    atomic_set(&handle->semaphore.nwaiters, 0);
    handle->semaphore.max_value = maxCount;
   107e6:	48 89 47 10          	mov    %rax,0x10(%rdi)

    /* optimization: if maxCount == 1, we make it into mutex */
    if (handle->semaphore.max_value == 1) {
   107ea:	74 09                	je     107f5 <_DkSemaphoreCreate+0x35>
        atomic_set(&handle->semaphore.value.mut.value, 1 - initialCount);
    } else {
        atomic_set(&handle->semaphore.value.i, maxCount - initialCount);
   107ec:	29 f2                	sub    %esi,%edx
    }

    return 0;
}
   107ee:	31 c0                	xor    %eax,%eax
   107f0:	89 57 18             	mov    %edx,0x18(%rdi)
   107f3:	5d                   	pop    %rbp
   107f4:	c3                   	retq   
    atomic_set(&handle->semaphore.nwaiters, 0);
    handle->semaphore.max_value = maxCount;

    /* optimization: if maxCount == 1, we make it into mutex */
    if (handle->semaphore.max_value == 1) {
        atomic_set(&handle->semaphore.value.mut.value, 1 - initialCount);
   107f5:	29 f0                	sub    %esi,%eax
   107f7:	89 47 18             	mov    %eax,0x18(%rdi)
    } else {
        atomic_set(&handle->semaphore.value.i, maxCount - initialCount);
    }

    return 0;
}
   107fa:	31 c0                	xor    %eax,%eax
   107fc:	5d                   	pop    %rbp
   107fd:	c3                   	retq   
   107fe:	66 90                	xchg   %ax,%ax

0000000000010800 <_DkSemaphoreDestroy>:

void _DkSemaphoreDestroy (PAL_HANDLE semaphoreHandle)
{
   10800:	55                   	push   %rbp
   10801:	48 89 e5             	mov    %rsp,%rbp
    free(semaphoreHandle);
}
   10804:	5d                   	pop    %rbp
    return 0;
}

void _DkSemaphoreDestroy (PAL_HANDLE semaphoreHandle)
{
    free(semaphoreHandle);
   10805:	e9 86 84 ff ff       	jmpq   8c90 <free>
   1080a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000010810 <_DkSemaphoreAcquire>:
}

int _DkMutexLockTimeout (struct mutex_handle * mut, int timeout);

int _DkSemaphoreAcquire (PAL_HANDLE sem, int count)
{
   10810:	55                   	push   %rbp
   10811:	48 89 e5             	mov    %rsp,%rbp
   10814:	41 55                	push   %r13
   10816:	41 54                	push   %r12
   10818:	53                   	push   %rbx
   10819:	49 89 fd             	mov    %rdi,%r13
   1081c:	48 83 ec 08          	sub    $0x8,%rsp
    /* optimization: use it as a mutex */
    if (sem->semaphore.max_value == 1) {
   10820:	48 8b 47 10          	mov    0x10(%rdi),%rax
   10824:	48 83 f8 01          	cmp    $0x1,%rax
   10828:	0f 84 fb 00 00 00    	je     10929 <_DkSemaphoreAcquire+0x119>
        struct mutex_handle * mut = &sem->semaphore.value.mut;
        _DkMutexLock(mut);
        return 0;
    }

    if (count > sem->semaphore.max_value)
   1082e:	48 63 d6             	movslq %esi,%rdx
   10831:	41 89 f2             	mov    %esi,%r10d
   10834:	48 39 d0             	cmp    %rdx,%rax
   10837:	0f 82 4f 01 00 00    	jb     1098c <_DkSemaphoreAcquire+0x17c>
    int c = 0;

    if (!value)
        return -PAL_ERROR_BADHANDLE;

    if (count == 1)
   1083d:	83 fe 01             	cmp    $0x1,%esi
    }

    if (count > sem->semaphore.max_value)
        return -PAL_ERROR_INVAL;

    struct atomic_int * value = &sem->semaphore.value.i;
   10840:	4c 8d 4f 18          	lea    0x18(%rdi),%r9
    int c = 0;

    if (!value)
        return -PAL_ERROR_BADHANDLE;

    if (count == 1)
   10844:	74 6a                	je     108b0 <_DkSemaphoreAcquire+0xa0>

/* Return 0 if the value drops below zero, 1 if >= 0 */
static inline int atomic_sub_and_test_nonnegative (int i, struct atomic_int * v)
{
    unsigned char c;
    asm volatile(LOCK_PREFIX "subl %2,%0; setns %1"
   10846:	f0 29 77 18          	lock sub %esi,0x18(%rdi)
   1084a:	0f 99 c0             	setns  %al
        c = atomic_dec_and_test_nonnegative (value);
    else
        c = atomic_sub_and_test_nonnegative (count, value);

    if (c)
   1084d:	84 c0                	test   %al,%al
   1084f:	75 6a                	jne    108bb <_DkSemaphoreAcquire+0xab>
    v->counter = i;
}

static inline void atomic_add (int i, struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "addl %1,%0"
   10851:	f0 01 77 18          	lock add %esi,0x18(%rdi)
}


static inline void atomic_inc (struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "incl %0"
   10855:	f0 41 ff 45 0c       	lock incl 0xc(%r13)
    int ret = 0;
    atomic_inc (&sem->semaphore.nwaiters);

    
        while (1) {
        ret = INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT, 0,
   1085a:	41 bc c6 01 00 00    	mov    $0x1c6,%r12d
   10860:	45 31 c0             	xor    %r8d,%r8d
   10863:	31 c9                	xor    %ecx,%ecx
   10865:	31 d2                	xor    %edx,%edx
   10867:	be 02 00 00 00       	mov    $0x2,%esi
   1086c:	4c 89 cf             	mov    %r9,%rdi
   1086f:	44 89 e0             	mov    %r12d,%eax
   10872:	cd 80                	int    $0x80
   10874:	48 89 c2             	mov    %rax,%rdx
   10877:	bb 00 00 00 00       	mov    $0x0,%ebx
   1087c:	83 d3 00             	adc    $0x0,%ebx
   1087f:	31 c9                	xor    %ecx,%ecx
   10881:	85 db                	test   %ebx,%ebx
   10883:	0f 95 c1             	setne  %cl
   10886:	48 89 c8             	mov    %rcx,%rax
   10889:	48 f7 d8             	neg    %rax
   1088c:	48 31 c2             	xor    %rax,%rdx
   1088f:	48 01 ca             	add    %rcx,%rdx
                             NULL, NULL);

        if (IS_ERR(ret)) {
   10892:	85 d2                	test   %edx,%edx
    int ret = 0;
    atomic_inc (&sem->semaphore.nwaiters);

    
        while (1) {
        ret = INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT, 0,
   10894:	89 d0                	mov    %edx,%eax
                             NULL, NULL);

        if (IS_ERR(ret)) {
   10896:	78 4c                	js     108e4 <_DkSemaphoreAcquire+0xd4>
                ret = unix_to_pal_error(ERRNO(ret));
                break;
            }
        }

        if (count == 1)
   10898:	41 83 fa 01          	cmp    $0x1,%r10d
   1089c:	74 32                	je     108d0 <_DkSemaphoreAcquire+0xc0>

/* Return 0 if the value drops below zero, 1 if >= 0 */
static inline int atomic_sub_and_test_nonnegative (int i, struct atomic_int * v)
{
    unsigned char c;
    asm volatile(LOCK_PREFIX "subl %2,%0; setns %1"
   1089e:	f0 45 29 11          	lock sub %r10d,(%r9)
   108a2:	0f 99 c2             	setns  %dl
            c = atomic_dec_and_test_nonnegative (value);
        else
            c = atomic_sub_and_test_nonnegative (count, value);

        if (c)
   108a5:	84 d2                	test   %dl,%dl
   108a7:	75 49                	jne    108f2 <_DkSemaphoreAcquire+0xe2>
    v->counter = i;
}

static inline void atomic_add (int i, struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "addl %1,%0"
   108a9:	f0 45 01 11          	lock add %r10d,(%r9)
   108ad:	eb b1                	jmp    10860 <_DkSemaphoreAcquire+0x50>
   108af:	90                   	nop    

/* Return 0 if the value drops below zero, 1 if >= 0 */
static inline int atomic_dec_and_test_nonnegative (struct atomic_int * v)
{
    unsigned char c;
    asm volatile(LOCK_PREFIX "decl %0; setns %1"
   108b0:	f0 ff 4f 18          	lock decl 0x18(%rdi)
   108b4:	0f 99 c0             	setns  %al
    if (count == 1)
        c = atomic_dec_and_test_nonnegative (value);
    else
        c = atomic_sub_and_test_nonnegative (count, value);

    if (c)
   108b7:	84 c0                	test   %al,%al
   108b9:	74 47                	je     10902 <_DkSemaphoreAcquire+0xf2>
        return 0;
   108bb:	31 c0                	xor    %eax,%eax
            atomic_add (count, value);
    }
	
    atomic_dec (&sem->semaphore.nwaiters);
    return ret;
}
   108bd:	48 83 c4 08          	add    $0x8,%rsp
   108c1:	5b                   	pop    %rbx
   108c2:	41 5c                	pop    %r12
   108c4:	41 5d                	pop    %r13
   108c6:	5d                   	pop    %rbp
   108c7:	c3                   	retq   
   108c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   108cf:	00 
   108d0:	f0 41 ff 09          	lock decl (%r9)
   108d4:	0f 99 c2             	setns  %dl
        if (count == 1)
            c = atomic_dec_and_test_nonnegative (value);
        else
            c = atomic_sub_and_test_nonnegative (count, value);

        if (c)
   108d7:	84 d2                	test   %dl,%dl
   108d9:	75 17                	jne    108f2 <_DkSemaphoreAcquire+0xe2>
}


static inline void atomic_inc (struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "incl %0"
   108db:	f0 41 ff 01          	lock incl (%r9)
   108df:	e9 7c ff ff ff       	jmpq   10860 <_DkSemaphoreAcquire+0x50>
        while (1) {
        ret = INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT, 0,
                             NULL, NULL);

        if (IS_ERR(ret)) {
            if (ERRNO(ret) == EWOULDBLOCK) {
   108e4:	83 fa dd             	cmp    $0xffffffffffffffdd,%edx
   108e7:	75 27                	jne    10910 <_DkSemaphoreAcquire+0x100>
                ret = 0;
   108e9:	31 c0                	xor    %eax,%eax
   108eb:	eb ab                	jmp    10898 <_DkSemaphoreAcquire+0x88>
   108ed:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    return c != 0;
}

static inline void atomic_dec (struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "decl %0"
   108f2:	f0 41 ff 4d 0c       	lock decl 0xc(%r13)
            atomic_add (count, value);
    }
	
    atomic_dec (&sem->semaphore.nwaiters);
    return ret;
}
   108f7:	48 83 c4 08          	add    $0x8,%rsp
   108fb:	5b                   	pop    %rbx
   108fc:	41 5c                	pop    %r12
   108fe:	41 5d                	pop    %r13
   10900:	5d                   	pop    %rbp
   10901:	c3                   	retq   
}


static inline void atomic_inc (struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "incl %0"
   10902:	f0 ff 47 18          	lock incl 0x18(%rdi)
   10906:	e9 4a ff ff ff       	jmpq   10855 <_DkSemaphoreAcquire+0x45>
   1090b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

        if (IS_ERR(ret)) {
            if (ERRNO(ret) == EWOULDBLOCK) {
                ret = 0;
            } else {
                ret = unix_to_pal_error(ERRNO(ret));
   10910:	f7 d8                	neg    %eax
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   10912:	83 f8 6e             	cmp    $0x6e,%eax
   10915:	77 d6                	ja     108ed <_DkSemaphoreAcquire+0xdd>
   10917:	48 8d 15 fe d3 00 00 	lea    0xd3fe(%rip),%rdx        # 1dd1c <slab_levels+0x4a7c>
   1091e:	89 c0                	mov    %eax,%eax
   10920:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
   10924:	48 01 c2             	add    %rax,%rdx
   10927:	ff e2                	jmpq   *%rdx

int _DkSemaphoreAcquire (PAL_HANDLE sem, int count)
{
    /* optimization: use it as a mutex */
    if (sem->semaphore.max_value == 1) {
        struct mutex_handle * mut = &sem->semaphore.value.mut;
   10929:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
        _DkMutexLock(mut);
   1092d:	e8 1e 03 00 00       	callq  10c50 <_DkMutexLock>
        return 0;
   10932:	31 c0                	xor    %eax,%eax
   10934:	eb 87                	jmp    108bd <_DkSemaphoreAcquire+0xad>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
   10936:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   1093b:	eb b5                	jmp    108f2 <_DkSemaphoreAcquire+0xe2>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
   1093d:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   10942:	eb ae                	jmp    108f2 <_DkSemaphoreAcquire+0xe2>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
   10944:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   10949:	eb a7                	jmp    108f2 <_DkSemaphoreAcquire+0xe2>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
   1094b:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   10950:	eb a0                	jmp    108f2 <_DkSemaphoreAcquire+0xe2>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
   10952:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   10957:	eb 99                	jmp    108f2 <_DkSemaphoreAcquire+0xe2>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
   10959:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   1095e:	eb 92                	jmp    108f2 <_DkSemaphoreAcquire+0xe2>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
   10960:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
   10965:	eb 8b                	jmp    108f2 <_DkSemaphoreAcquire+0xe2>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
   10967:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   1096c:	eb 84                	jmp    108f2 <_DkSemaphoreAcquire+0xe2>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
   1096e:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   10973:	e9 7a ff ff ff       	jmpq   108f2 <_DkSemaphoreAcquire+0xe2>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
   10978:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   1097d:	e9 70 ff ff ff       	jmpq   108f2 <_DkSemaphoreAcquire+0xe2>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
   10982:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   10987:	e9 66 ff ff ff       	jmpq   108f2 <_DkSemaphoreAcquire+0xe2>
    }

    if (count > sem->semaphore.max_value)
        return -PAL_ERROR_INVAL;
   1098c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   10991:	e9 27 ff ff ff       	jmpq   108bd <_DkSemaphoreAcquire+0xad>
   10996:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1099d:	00 00 00 

00000000000109a0 <_DkSemaphoreAcquireTimeout>:
    atomic_dec (&sem->semaphore.nwaiters);
    return ret;
}

int _DkSemaphoreAcquireTimeout (PAL_HANDLE sem, int count, int timeout)
{
   109a0:	55                   	push   %rbp
   109a1:	41 89 f2             	mov    %esi,%r10d
   109a4:	48 63 f2             	movslq %edx,%rsi
   109a7:	48 89 e5             	mov    %rsp,%rbp
   109aa:	41 56                	push   %r14
   109ac:	41 55                	push   %r13
   109ae:	41 54                	push   %r12
   109b0:	53                   	push   %rbx
   109b1:	49 89 fc             	mov    %rdi,%r12
   109b4:	48 83 ec 10          	sub    $0x10,%rsp
    /* Pass it up to the no-timeout version if no timeout requested */
    if (timeout == -1)
   109b8:	83 fe ff             	cmp    $0xffffffffffffffff,%esi
   109bb:	0f 84 5f 01 00 00    	je     10b20 <_DkSemaphoreAcquireTimeout+0x180>
        return _DkSemaphoreAcquire(sem, count);

    /* optimization: use it as a mutex */
    if (sem->semaphore.max_value == 1) {
   109c1:	48 8b 47 10          	mov    0x10(%rdi),%rax
   109c5:	48 83 f8 01          	cmp    $0x1,%rax
   109c9:	0f 84 61 01 00 00    	je     10b30 <_DkSemaphoreAcquireTimeout+0x190>
        struct mutex_handle * mut = & sem->semaphore.value.mut;
        _DkMutexLockTimeout(mut, timeout);
        return 0;
    }

    if (count > sem->semaphore.max_value)
   109cf:	49 63 d2             	movslq %r10d,%rdx
   109d2:	48 39 d0             	cmp    %rdx,%rax
   109d5:	0f 82 e8 01 00 00    	jb     10bc3 <_DkSemaphoreAcquireTimeout+0x223>
    int c = 0;

    if (!value)
        return -PAL_ERROR_BADHANDLE;

    if (count == 1)
   109db:	41 83 fa 01          	cmp    $0x1,%r10d
    }

    if (count > sem->semaphore.max_value)
        return -PAL_ERROR_INVAL;

    struct atomic_int * value = &sem->semaphore.value.i;
   109df:	4c 8d 4f 18          	lea    0x18(%rdi),%r9
    int c = 0;

    if (!value)
        return -PAL_ERROR_BADHANDLE;

    if (count == 1)
   109e3:	0f 84 e7 00 00 00    	je     10ad0 <_DkSemaphoreAcquireTimeout+0x130>

/* Return 0 if the value drops below zero, 1 if >= 0 */
static inline int atomic_sub_and_test_nonnegative (int i, struct atomic_int * v)
{
    unsigned char c;
    asm volatile(LOCK_PREFIX "subl %2,%0; setns %1"
   109e9:	f0 44 29 57 18       	lock sub %r10d,0x18(%rdi)
   109ee:	0f 99 c0             	setns  %al
        c = atomic_dec_and_test_nonnegative (value);
    else
        c = atomic_sub_and_test_nonnegative (count, value);

    if (c)
   109f1:	84 c0                	test   %al,%al
   109f3:	0f 85 e7 00 00 00    	jne    10ae0 <_DkSemaphoreAcquireTimeout+0x140>
    v->counter = i;
}

static inline void atomic_add (int i, struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "addl %1,%0"
   109f9:	f0 44 01 57 18       	lock add %r10d,0x18(%rdi)
    if (count == 1)
        atomic_inc (value);
    else
        atomic_add (count, value);

    if (!timeout)
   109fe:	85 f6                	test   %esi,%esi
   10a00:	0f 84 da 00 00 00    	je     10ae0 <_DkSemaphoreAcquireTimeout+0x140>
        return 0;

    struct timespec waittime;
    long sec = timeout / 1000000;
   10a06:	89 f0                	mov    %esi,%eax
   10a08:	b9 83 de 1b 43       	mov    $0x431bde83,%ecx
   10a0d:	f7 e9                	imul   %ecx
   10a0f:	89 f0                	mov    %esi,%eax
   10a11:	c1 f8 1f             	sar    $0x1f,%eax
   10a14:	89 d1                	mov    %edx,%ecx
   10a16:	c1 f9 12             	sar    $0x12,%ecx
   10a19:	29 c1                	sub    %eax,%ecx
   10a1b:	48 63 c9             	movslq %ecx,%rcx
    long microsec = timeout - (sec * 1000000);
    waittime.tv_sec = sec;
   10a1e:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    if (!timeout)
        return 0;

    struct timespec waittime;
    long sec = timeout / 1000000;
    long microsec = timeout - (sec * 1000000);
   10a22:	48 69 c9 c0 bd f0 ff 	imul   $0xfffffffffff0bdc0,%rcx,%rcx
   10a29:	48 01 f1             	add    %rsi,%rcx
    waittime.tv_sec = sec;
    waittime.tv_nsec = microsec * 1000;
   10a2c:	48 69 c9 e8 03 00 00 	imul   $0x3e8,%rcx,%rcx
   10a33:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
}


static inline void atomic_inc (struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "incl %0"
   10a37:	f0 41 ff 44 24 0c    	lock incl 0xc(%r12)
    atomic_inc (&sem->semaphore.nwaiters);


    
    while (1) {
        ret = INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT_UINT, 0,
   10a3d:	41 bd c6 01 00 00    	mov    $0x1c6,%r13d
   10a43:	4c 8d 75 d0          	lea    -0x30(%rbp),%r14
   10a47:	eb 15                	jmp    10a5e <_DkSemaphoreAcquireTimeout+0xbe>
   10a49:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

/* Return 0 if the value drops below zero, 1 if >= 0 */
static inline int atomic_sub_and_test_nonnegative (int i, struct atomic_int * v)
{
    unsigned char c;
    asm volatile(LOCK_PREFIX "subl %2,%0; setns %1"
   10a50:	f0 45 29 11          	lock sub %r10d,(%r9)
   10a54:	0f 99 c0             	setns  %al
                 : "+m" (v->counter), "=qm" (c)
                 : "ir" (i) : "memory");
    return c;
   10a57:	0f b6 c0             	movzbl %al,%eax
        if (count == 1)
            c = atomic_dec_and_test_nonnegative (value);
        else
            c = atomic_sub_and_test_nonnegative (count, value);

        if (c)
   10a5a:	85 c0                	test   %eax,%eax
   10a5c:	75 4d                	jne    10aab <_DkSemaphoreAcquireTimeout+0x10b>
    atomic_inc (&sem->semaphore.nwaiters);


    
    while (1) {
        ret = INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT_UINT, 0,
   10a5e:	4d 89 f0             	mov    %r14,%r8
   10a61:	31 c9                	xor    %ecx,%ecx
   10a63:	31 d2                	xor    %edx,%edx
   10a65:	be 0b 00 00 00       	mov    $0xb,%esi
   10a6a:	4c 89 cf             	mov    %r9,%rdi
   10a6d:	44 89 e8             	mov    %r13d,%eax
   10a70:	cd 80                	int    $0x80
   10a72:	48 89 c2             	mov    %rax,%rdx
   10a75:	bb 00 00 00 00       	mov    $0x0,%ebx
   10a7a:	83 d3 00             	adc    $0x0,%ebx
   10a7d:	31 c9                	xor    %ecx,%ecx
   10a7f:	85 db                	test   %ebx,%ebx
   10a81:	0f 95 c1             	setne  %cl
   10a84:	48 89 c8             	mov    %rcx,%rax
   10a87:	48 f7 d8             	neg    %rax
   10a8a:	48 31 c2             	xor    %rax,%rdx
   10a8d:	48 01 ca             	add    %rcx,%rdx
                             NULL, &waittime);

        if (ERRNO(ret) == EWOULDBLOCK) {
   10a90:	83 fa dd             	cmp    $0xffffffffffffffdd,%edx
    atomic_inc (&sem->semaphore.nwaiters);


    
    while (1) {
        ret = INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT_UINT, 0,
   10a93:	89 d0                	mov    %edx,%eax
                             NULL, &waittime);

        if (ERRNO(ret) == EWOULDBLOCK) {
   10a95:	75 69                	jne    10b00 <_DkSemaphoreAcquireTimeout+0x160>
        } else {
            ret = unix_to_pal_error(ERRNO(ret));
            break;
        }

        if (count == 1)
   10a97:	41 83 fa 01          	cmp    $0x1,%r10d
   10a9b:	75 b3                	jne    10a50 <_DkSemaphoreAcquireTimeout+0xb0>

/* Return 0 if the value drops below zero, 1 if >= 0 */
static inline int atomic_dec_and_test_nonnegative (struct atomic_int * v)
{
    unsigned char c;
    asm volatile(LOCK_PREFIX "decl %0; setns %1"
   10a9d:	f0 41 ff 09          	lock decl (%r9)
   10aa1:	0f 99 c0             	setns  %al
                 : "+m" (v->counter), "=qm" (c)
                 : : "memory");
    return c;
   10aa4:	0f b6 c0             	movzbl %al,%eax
            c = atomic_dec_and_test_nonnegative (value);
        else
            c = atomic_sub_and_test_nonnegative (count, value);

        if (c)
   10aa7:	85 c0                	test   %eax,%eax
   10aa9:	74 b3                	je     10a5e <_DkSemaphoreAcquireTimeout+0xbe>
    while (1) {
        ret = INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT_UINT, 0,
                             NULL, &waittime);

        if (ERRNO(ret) == EWOULDBLOCK) {
            ret = 0;
   10aab:	31 c0                	xor    %eax,%eax
        if (c)
            break;
    }

    /* We didn't get the lock.  Bump the count back up. */
    if (count == 1)
   10aad:	41 83 fa 01          	cmp    $0x1,%r10d
   10ab1:	0f 84 89 00 00 00    	je     10b40 <_DkSemaphoreAcquireTimeout+0x1a0>
    v->counter = i;
}

static inline void atomic_add (int i, struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "addl %1,%0"
   10ab7:	f0 45 01 54 24 18    	lock add %r10d,0x18(%r12)
    return c != 0;
}

static inline void atomic_dec (struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "decl %0"
   10abd:	f0 41 ff 4c 24 0c    	lock decl 0xc(%r12)
    else
        atomic_add (count, value);

    atomic_dec (&sem->semaphore.nwaiters);
    return ret;
}
   10ac3:	48 83 c4 10          	add    $0x10,%rsp
   10ac7:	5b                   	pop    %rbx
   10ac8:	41 5c                	pop    %r12
   10aca:	41 5d                	pop    %r13
   10acc:	41 5e                	pop    %r14
   10ace:	5d                   	pop    %rbp
   10acf:	c3                   	retq   

/* Return 0 if the value drops below zero, 1 if >= 0 */
static inline int atomic_dec_and_test_nonnegative (struct atomic_int * v)
{
    unsigned char c;
    asm volatile(LOCK_PREFIX "decl %0; setns %1"
   10ad0:	f0 ff 4f 18          	lock decl 0x18(%rdi)
   10ad4:	0f 99 c0             	setns  %al
    if (count == 1)
        c = atomic_dec_and_test_nonnegative (value);
    else
        c = atomic_sub_and_test_nonnegative (count, value);

    if (c)
   10ad7:	84 c0                	test   %al,%al
   10ad9:	74 15                	je     10af0 <_DkSemaphoreAcquireTimeout+0x150>
   10adb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        return 0;
   10ae0:	31 c0                	xor    %eax,%eax
    else
        atomic_add (count, value);

    atomic_dec (&sem->semaphore.nwaiters);
    return ret;
}
   10ae2:	48 83 c4 10          	add    $0x10,%rsp
   10ae6:	5b                   	pop    %rbx
   10ae7:	41 5c                	pop    %r12
   10ae9:	41 5d                	pop    %r13
   10aeb:	41 5e                	pop    %r14
   10aed:	5d                   	pop    %rbp
   10aee:	c3                   	retq   
   10aef:	90                   	nop    
}


static inline void atomic_inc (struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "incl %0"
   10af0:	f0 ff 47 18          	lock incl 0x18(%rdi)
   10af4:	e9 05 ff ff ff       	jmpq   109fe <_DkSemaphoreAcquireTimeout+0x5e>
   10af9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
                             NULL, &waittime);

        if (ERRNO(ret) == EWOULDBLOCK) {
            ret = 0;
        } else {
            ret = unix_to_pal_error(ERRNO(ret));
   10b00:	f7 d8                	neg    %eax
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   10b02:	83 f8 6e             	cmp    $0x6e,%eax
   10b05:	0f 87 ae 00 00 00    	ja     10bb9 <_DkSemaphoreAcquireTimeout+0x219>
   10b0b:	48 8d 15 c6 d3 00 00 	lea    0xd3c6(%rip),%rdx        # 1ded8 <slab_levels+0x4c38>
   10b12:	89 c0                	mov    %eax,%eax
   10b14:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
   10b18:	48 01 c2             	add    %rax,%rdx
   10b1b:	ff e2                	jmpq   *%rdx
   10b1d:	0f 1f 00             	nopl   (%rax)

int _DkSemaphoreAcquireTimeout (PAL_HANDLE sem, int count, int timeout)
{
    /* Pass it up to the no-timeout version if no timeout requested */
    if (timeout == -1)
        return _DkSemaphoreAcquire(sem, count);
   10b20:	44 89 d6             	mov    %r10d,%esi
   10b23:	e8 e8 fc ff ff       	callq  10810 <_DkSemaphoreAcquire>
   10b28:	eb b8                	jmp    10ae2 <_DkSemaphoreAcquireTimeout+0x142>
   10b2a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

    /* optimization: use it as a mutex */
    if (sem->semaphore.max_value == 1) {
        struct mutex_handle * mut = & sem->semaphore.value.mut;
   10b30:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
        _DkMutexLockTimeout(mut, timeout);
   10b34:	e8 17 02 00 00       	callq  10d50 <_DkMutexLockTimeout>
        return 0;
   10b39:	31 c0                	xor    %eax,%eax
   10b3b:	eb a5                	jmp    10ae2 <_DkSemaphoreAcquireTimeout+0x142>
   10b3d:	0f 1f 00             	nopl   (%rax)
   10b40:	f0 41 ff 44 24 18    	lock incl 0x18(%r12)
   10b46:	e9 72 ff ff ff       	jmpq   10abd <_DkSemaphoreAcquireTimeout+0x11d>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
   10b4b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   10b50:	e9 58 ff ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
   10b55:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   10b5a:	e9 4e ff ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
   10b5f:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   10b64:	e9 44 ff ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
   10b69:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   10b6e:	e9 3a ff ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
   10b73:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
   10b78:	e9 30 ff ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
   10b7d:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   10b82:	e9 26 ff ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
   10b87:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   10b8c:	e9 1c ff ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
   10b91:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   10b96:	e9 12 ff ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
   10b9b:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   10ba0:	e9 08 ff ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
   10ba5:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   10baa:	e9 fe fe ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
   10baf:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   10bb4:	e9 f4 fe ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
   10bb9:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   10bbe:	e9 ea fe ff ff       	jmpq   10aad <_DkSemaphoreAcquireTimeout+0x10d>
    }

    if (count > sem->semaphore.max_value)
        return -PAL_ERROR_INVAL;
   10bc3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   10bc8:	e9 15 ff ff ff       	jmpq   10ae2 <_DkSemaphoreAcquireTimeout+0x142>
   10bcd:	0f 1f 00             	nopl   (%rax)

0000000000010bd0 <_DkSemaphoreRelease>:
    atomic_dec (&sem->semaphore.nwaiters);
    return ret;
}

void _DkSemaphoreRelease (PAL_HANDLE sem, int count)
{
   10bd0:	48 89 f8             	mov    %rdi,%rax
    /* optimization: use it as a mutex */
    if (sem->semaphore.max_value == 1) {
        struct mutex_handle * mut =
   10bd3:	48 8d 7f 18          	lea    0x18(%rdi),%rdi
}

void _DkSemaphoreRelease (PAL_HANDLE sem, int count)
{
    /* optimization: use it as a mutex */
    if (sem->semaphore.max_value == 1) {
   10bd7:	48 83 78 10 01       	cmpq   $0x1,0x10(%rax)
   10bdc:	74 42                	je     10c20 <_DkSemaphoreRelease+0x50>
        return;
    }

    struct atomic_int * value = &sem->semaphore.value.i;

    if (count == 1)
   10bde:	83 fe 01             	cmp    $0x1,%esi
   10be1:	74 2e                	je     10c11 <_DkSemaphoreRelease+0x41>
    v->counter = i;
}

static inline void atomic_add (int i, struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "addl %1,%0"
   10be3:	f0 01 70 18          	lock add %esi,0x18(%rax)

#define ATOMIC_INIT(i)      { (i) }

static inline volatile int atomic_read (const struct atomic_int * v)
{
    return v->counter;
   10be7:	48 63 50 0c          	movslq 0xc(%rax),%rdx
    else
        atomic_add (count, value);

    int nwaiters = atomic_read (&sem->semaphore.nwaiters);

    if (nwaiters > 0)
   10beb:	85 d2                	test   %edx,%edx
   10bed:	7e 20                	jle    10c0f <_DkSemaphoreRelease+0x3f>
    atomic_dec (&sem->semaphore.nwaiters);
    return ret;
}

void _DkSemaphoreRelease (PAL_HANDLE sem, int count)
{
   10bef:	55                   	push   %rbp
        atomic_add (count, value);

    int nwaiters = atomic_read (&sem->semaphore.nwaiters);

    if (nwaiters > 0)
        INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT, nwaiters, NULL, NULL);
   10bf0:	45 31 c0             	xor    %r8d,%r8d
   10bf3:	31 c9                	xor    %ecx,%ecx
   10bf5:	be 02 00 00 00       	mov    $0x2,%esi
   10bfa:	b8 c6 01 00 00       	mov    $0x1c6,%eax
    atomic_dec (&sem->semaphore.nwaiters);
    return ret;
}

void _DkSemaphoreRelease (PAL_HANDLE sem, int count)
{
   10bff:	48 89 e5             	mov    %rsp,%rbp
   10c02:	53                   	push   %rbx
        atomic_add (count, value);

    int nwaiters = atomic_read (&sem->semaphore.nwaiters);

    if (nwaiters > 0)
        INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT, nwaiters, NULL, NULL);
   10c03:	cd 80                	int    $0x80
   10c05:	bb 00 00 00 00       	mov    $0x0,%ebx
   10c0a:	83 d3 00             	adc    $0x0,%ebx
}
   10c0d:	5b                   	pop    %rbx
   10c0e:	5d                   	pop    %rbp
   10c0f:	f3 c3                	repz retq 
}


static inline void atomic_inc (struct atomic_int * v)
{
    asm volatile(LOCK_PREFIX "incl %0"
   10c11:	f0 ff 40 18          	lock incl 0x18(%rax)
   10c15:	eb d0                	jmp    10be7 <_DkSemaphoreRelease+0x17>
   10c17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   10c1e:	00 00 
    /* optimization: use it as a mutex */
    if (sem->semaphore.max_value == 1) {
        struct mutex_handle * mut =
            &sem->semaphore.value.mut;

        _DkMutexUnlock(mut);
   10c20:	e9 9b 02 00 00       	jmpq   10ec0 <_DkMutexUnlock>
   10c25:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
   10c2c:	00 00 00 00 

0000000000010c30 <_DkSemaphoreGetCurrentCount>:
    if (nwaiters > 0)
        INLINE_SYSCALL(_umtx_op, 5, value, UMTX_OP_WAIT, nwaiters, NULL, NULL);
}

int _DkSemaphoreGetCurrentCount (PAL_HANDLE sem)
{
   10c30:	48 8b 47 10          	mov    0x10(%rdi),%rax
   10c34:	55                   	push   %rbp
   10c35:	48 89 e5             	mov    %rsp,%rbp
    if (sem->semaphore.max_value == 1) {
   10c38:	48 83 f8 01          	cmp    $0x1,%rax
   10c3c:	74 07                	je     10c45 <_DkSemaphoreGetCurrentCount+0x15>

#define ATOMIC_INIT(i)      { (i) }

static inline volatile int atomic_read (const struct atomic_int * v)
{
    return v->counter;
   10c3e:	8b 57 18             	mov    0x18(%rdi),%edx
        return atomic_read(&mut->value);
    }

    int c = atomic_read(&sem->semaphore.value.i);
    return sem->semaphore.max_value - c;
}
   10c41:	5d                   	pop    %rbp
            &sem->semaphore.value.mut;
        return atomic_read(&mut->value);
    }

    int c = atomic_read(&sem->semaphore.value.i);
    return sem->semaphore.max_value - c;
   10c42:	29 d0                	sub    %edx,%eax
}
   10c44:	c3                   	retq   
   10c45:	8b 47 18             	mov    0x18(%rdi),%eax
   10c48:	5d                   	pop    %rbp
   10c49:	c3                   	retq   
   10c4a:	90                   	nop    
   10c4b:	90                   	nop    
   10c4c:	90                   	nop    
   10c4d:	90                   	nop    
   10c4e:	90                   	nop    
   10c4f:	90                   	nop    

0000000000010c50 <_DkMutexLock>:
    ret = 0;
out:
    return ret;
}
int _DkMutexLock (struct mutex_handle * mut)
{
   10c50:	49 89 f9             	mov    %rdi,%r9
}

static inline int atomic_dec_and_test (struct atomic_int * v)
{
    unsigned char c;
    asm volatile(LOCK_PREFIX "decl %0; sete %1"
   10c53:	f0 ff 0f             	lock decl (%rdi)
   10c56:	0f 94 c2             	sete   %dl
    struct atomic_int * m = &mut->value;

    // Spin and try to take lock 
    for (i = 0; i < MUTEX_SPINLOCK_TIMES; i++) {
        c = atomic_dec_and_test(m);
        if (c)
   10c59:	84 d2                	test   %dl,%dl
   10c5b:	b8 14 00 00 00       	mov    $0x14,%eax
   10c60:	74 0d                	je     10c6f <_DkMutexLock+0x1f>
   10c62:	eb 70                	jmp    10cd4 <_DkMutexLock+0x84>
   10c64:	f0 41 ff 09          	lock decl (%r9)
   10c68:	0f 94 c2             	sete   %dl
   10c6b:	84 d2                	test   %dl,%dl
   10c6d:	75 65                	jne    10cd4 <_DkMutexLock+0x84>
            goto success;
        cpu_relax();
   10c6f:	f3 90                	pause  
    int i, c = 0;
    int ret;
    struct atomic_int * m = &mut->value;

    // Spin and try to take lock 
    for (i = 0; i < MUTEX_SPINLOCK_TIMES; i++) {
   10c71:	83 e8 01             	sub    $0x1,%eax
   10c74:	75 ee                	jne    10c64 <_DkMutexLock+0x14>
    ret = 0;
out:
    return ret;
}
int _DkMutexLock (struct mutex_handle * mut)
{
   10c76:	55                   	push   %rbp
    }

    // The lock is now contended 

    while (!c) {
        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAIT, 2, NULL, NULL);
   10c77:	41 ba c6 01 00 00    	mov    $0x1c6,%r10d
    ret = 0;
out:
    return ret;
}
int _DkMutexLock (struct mutex_handle * mut)
{
   10c7d:	48 89 e5             	mov    %rsp,%rbp
   10c80:	53                   	push   %rbx
    }

    // The lock is now contended 

    while (!c) {
        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAIT, 2, NULL, NULL);
   10c81:	45 31 c0             	xor    %r8d,%r8d
   10c84:	31 c9                	xor    %ecx,%ecx
   10c86:	ba 02 00 00 00       	mov    $0x2,%edx
   10c8b:	be 02 00 00 00       	mov    $0x2,%esi
   10c90:	4c 89 cf             	mov    %r9,%rdi
   10c93:	44 89 d0             	mov    %r10d,%eax
   10c96:	cd 80                	int    $0x80
   10c98:	48 89 c2             	mov    %rax,%rdx
   10c9b:	bb 00 00 00 00       	mov    $0x0,%ebx
   10ca0:	83 d3 00             	adc    $0x0,%ebx
   10ca3:	31 c9                	xor    %ecx,%ecx
   10ca5:	85 db                	test   %ebx,%ebx
   10ca7:	0f 95 c1             	setne  %cl
   10caa:	48 89 c8             	mov    %rcx,%rax
   10cad:	48 f7 d8             	neg    %rax
   10cb0:	48 31 c2             	xor    %rax,%rdx
   10cb3:	48 01 ca             	add    %rcx,%rdx

        if (IS_ERR(ret) && ERRNO(ret) != EWOULDBLOCK) {
   10cb6:	83 fa f5             	cmp    $0xfffffffffffffff5,%edx
    }

    // The lock is now contended 

    while (!c) {
        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAIT, 2, NULL, NULL);
   10cb9:	89 d0                	mov    %edx,%eax

        if (IS_ERR(ret) && ERRNO(ret) != EWOULDBLOCK) {
   10cbb:	74 07                	je     10cc4 <_DkMutexLock+0x74>
   10cbd:	c1 ea 1f             	shr    $0x1f,%edx
   10cc0:	84 d2                	test   %dl,%dl
   10cc2:	75 1c                	jne    10ce0 <_DkMutexLock+0x90>
   10cc4:	f0 41 ff 09          	lock decl (%r9)
   10cc8:	0f 94 c0             	sete   %al
        cpu_relax();
    }

    // The lock is now contended 

    while (!c) {
   10ccb:	84 c0                	test   %al,%al
   10ccd:	74 b2                	je     10c81 <_DkMutexLock+0x31>

success:
#ifdef DEBUG_MUTEX
    mut->owner = INLINE_SYSCALL(gettid, 0);
#endif
    ret = 0;
   10ccf:	31 c0                	xor    %eax,%eax
out:
    return ret;
}
   10cd1:	5b                   	pop    %rbx
   10cd2:	5d                   	pop    %rbp
   10cd3:	c3                   	retq   

success:
#ifdef DEBUG_MUTEX
    mut->owner = INLINE_SYSCALL(gettid, 0);
#endif
    ret = 0;
   10cd4:	31 c0                	xor    %eax,%eax
out:
    return ret;
}
   10cd6:	c3                   	retq   
   10cd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   10cde:	00 00 

    while (!c) {
        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAIT, 2, NULL, NULL);

        if (IS_ERR(ret) && ERRNO(ret) != EWOULDBLOCK) {
            ret = unix_to_pal_error(ERRNO(ret));
   10ce0:	f7 d8                	neg    %eax
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   10ce2:	83 f8 6e             	cmp    $0x6e,%eax
   10ce5:	77 5f                	ja     10d46 <_DkMutexLock+0xf6>
   10ce7:	48 8d 15 a6 d3 00 00 	lea    0xd3a6(%rip),%rdx        # 1e094 <slab_levels+0x4df4>
   10cee:	89 c0                	mov    %eax,%eax
   10cf0:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
   10cf4:	48 01 c2             	add    %rax,%rdx
   10cf7:	ff e2                	jmpq   *%rdx
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
   10cf9:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   10cfe:	eb d1                	jmp    10cd1 <_DkMutexLock+0x81>
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
   10d00:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   10d05:	eb ca                	jmp    10cd1 <_DkMutexLock+0x81>
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
   10d07:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   10d0c:	eb c3                	jmp    10cd1 <_DkMutexLock+0x81>
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
   10d0e:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   10d13:	eb bc                	jmp    10cd1 <_DkMutexLock+0x81>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
   10d15:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   10d1a:	eb b5                	jmp    10cd1 <_DkMutexLock+0x81>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
   10d1c:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   10d21:	eb ae                	jmp    10cd1 <_DkMutexLock+0x81>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
   10d23:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   10d28:	eb a7                	jmp    10cd1 <_DkMutexLock+0x81>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
   10d2a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
   10d2f:	eb a0                	jmp    10cd1 <_DkMutexLock+0x81>
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
   10d31:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   10d36:	eb 99                	jmp    10cd1 <_DkMutexLock+0x81>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
   10d38:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   10d3d:	eb 92                	jmp    10cd1 <_DkMutexLock+0x81>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
   10d3f:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   10d44:	eb 8b                	jmp    10cd1 <_DkMutexLock+0x81>
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
   10d46:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   10d4b:	eb 84                	jmp    10cd1 <_DkMutexLock+0x81>
   10d4d:	0f 1f 00             	nopl   (%rax)

0000000000010d50 <_DkMutexLockTimeout>:
#define	UMTX_OP_WAIT		2
#define	UMTX_OP_WAKE		3
#define	UMTX_OP_WAIT_UINT	11

int _DkMutexLockTimeout (struct mutex_handle * mut, int timeout)
{
   10d50:	55                   	push   %rbp
   10d51:	49 89 f9             	mov    %rdi,%r9
   10d54:	48 89 e5             	mov    %rsp,%rbp
   10d57:	41 56                	push   %r14
   10d59:	41 55                	push   %r13
   10d5b:	41 54                	push   %r12
   10d5d:	53                   	push   %rbx
   10d5e:	48 83 ec 10          	sub    $0x10,%rsp
    int i, c = 0;

    if (timeout == -1)
   10d62:	83 fe ff             	cmp    $0xffffffffffffffff,%esi
   10d65:	0f 84 f5 00 00 00    	je     10e60 <_DkMutexLockTimeout+0x110>
   10d6b:	f0 ff 0f             	lock decl (%rdi)
   10d6e:	0f 94 c0             	sete   %al

    // Spin and try to take lock 
    for (i = 0 ; i < MUTEX_SPINLOCK_TIMES ; i++)
    {
        c = atomic_dec_and_test(m);
        if (c)
   10d71:	84 c0                	test   %al,%al
   10d73:	ba 14 00 00 00       	mov    $0x14,%edx
   10d78:	74 15                	je     10d8f <_DkMutexLockTimeout+0x3f>
   10d7a:	e9 b7 00 00 00       	jmpq   10e36 <_DkMutexLockTimeout+0xe6>
   10d7f:	90                   	nop    
   10d80:	f0 41 ff 09          	lock decl (%r9)
   10d84:	0f 94 c1             	sete   %cl
   10d87:	84 c9                	test   %cl,%cl
   10d89:	0f 85 a7 00 00 00    	jne    10e36 <_DkMutexLockTimeout+0xe6>
            goto success;
        cpu_relax();
   10d8f:	f3 90                	pause  
        return -_DkMutexLock(mut);

    struct atomic_int * m = &mut->value;

    // Spin and try to take lock 
    for (i = 0 ; i < MUTEX_SPINLOCK_TIMES ; i++)
   10d91:	83 ea 01             	sub    $0x1,%edx
   10d94:	75 ea                	jne    10d80 <_DkMutexLockTimeout+0x30>

    //The lock is now contended 

    int ret;

    if (timeout == 0) {
   10d96:	85 f6                	test   %esi,%esi
        ret = c ? 0 : -PAL_ERROR_TRYAGAIN;
   10d98:	b8 ed ff ff ff       	mov    $0xffffffed,%eax

    //The lock is now contended 

    int ret;

    if (timeout == 0) {
   10d9d:	0f 84 95 00 00 00    	je     10e38 <_DkMutexLockTimeout+0xe8>
   10da3:	89 f0                	mov    %esi,%eax
   10da5:	ba 83 de 1b 43       	mov    $0x431bde83,%edx
   10daa:	4c 8d 75 d0          	lea    -0x30(%rbp),%r14
   10dae:	f7 ea                	imul   %edx
   10db0:	89 f0                	mov    %esi,%eax
   10db2:	48 63 f6             	movslq %esi,%rsi
   10db5:	c1 f8 1f             	sar    $0x1f,%eax
        long sec = timeout / 1000000;
        long microsec = timeout - (sec * 1000000);
        waittime.tv_sec = sec;
        waittime.tv_nsec = microsec * 1000;

        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAIT_UINT, 2, NULL, &waittime);
   10db8:	41 bd c6 01 00 00    	mov    $0x1c6,%r13d
   10dbe:	c1 fa 12             	sar    $0x12,%edx
   10dc1:	29 c2                	sub    %eax,%edx
   10dc3:	4c 63 d2             	movslq %edx,%r10
   10dc6:	4d 69 e2 c0 bd f0 ff 	imul   $0xfffffffffff0bdc0,%r10,%r12
   10dcd:	4c 01 e6             	add    %r12,%rsi
   10dd0:	4c 69 e6 e8 03 00 00 	imul   $0x3e8,%rsi,%r12
   10dd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   10dde:	00 00 
 
    while (!c) {
        struct timespec waittime;
        long sec = timeout / 1000000;
        long microsec = timeout - (sec * 1000000);
        waittime.tv_sec = sec;
   10de0:	4c 89 55 d0          	mov    %r10,-0x30(%rbp)
        waittime.tv_nsec = microsec * 1000;
   10de4:	4c 89 65 d8          	mov    %r12,-0x28(%rbp)

        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAIT_UINT, 2, NULL, &waittime);
   10de8:	4d 89 f0             	mov    %r14,%r8
   10deb:	31 c9                	xor    %ecx,%ecx
   10ded:	ba 02 00 00 00       	mov    $0x2,%edx
   10df2:	be 0b 00 00 00       	mov    $0xb,%esi
   10df7:	4c 89 cf             	mov    %r9,%rdi
   10dfa:	44 89 e8             	mov    %r13d,%eax
   10dfd:	cd 80                	int    $0x80
   10dff:	48 89 c2             	mov    %rax,%rdx
   10e02:	bb 00 00 00 00       	mov    $0x0,%ebx
   10e07:	83 d3 00             	adc    $0x0,%ebx
   10e0a:	31 c9                	xor    %ecx,%ecx
   10e0c:	85 db                	test   %ebx,%ebx
   10e0e:	0f 95 c1             	setne  %cl
   10e11:	48 89 c8             	mov    %rcx,%rax
   10e14:	48 f7 d8             	neg    %rax
   10e17:	48 31 c2             	xor    %rax,%rdx
   10e1a:	48 01 ca             	add    %rcx,%rdx

        if (IS_ERR(ret) && ERRNO(ret) != EWOULDBLOCK) {
   10e1d:	83 fa f5             	cmp    $0xfffffffffffffff5,%edx
        long sec = timeout / 1000000;
        long microsec = timeout - (sec * 1000000);
        waittime.tv_sec = sec;
        waittime.tv_nsec = microsec * 1000;

        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAIT_UINT, 2, NULL, &waittime);
   10e20:	89 d0                	mov    %edx,%eax

        if (IS_ERR(ret) && ERRNO(ret) != EWOULDBLOCK) {
   10e22:	74 07                	je     10e2b <_DkMutexLockTimeout+0xdb>
   10e24:	c1 ea 1f             	shr    $0x1f,%edx
   10e27:	84 d2                	test   %dl,%dl
   10e29:	75 1a                	jne    10e45 <_DkMutexLockTimeout+0xf5>
   10e2b:	f0 41 ff 09          	lock decl (%r9)
   10e2f:	0f 94 c0             	sete   %al
    if (timeout == 0) {
        ret = c ? 0 : -PAL_ERROR_TRYAGAIN;
        goto out;
    }
 
    while (!c) {
   10e32:	84 c0                	test   %al,%al
   10e34:	74 aa                	je     10de0 <_DkMutexLockTimeout+0x90>

success:
#ifdef DEBUG_MUTEX
    mut->owner = INLINE_SYSCALL(gettid, 0);
#endif
    ret = 0;
   10e36:	31 c0                	xor    %eax,%eax
out:
    return ret;
}
   10e38:	48 83 c4 10          	add    $0x10,%rsp
   10e3c:	5b                   	pop    %rbx
   10e3d:	41 5c                	pop    %r12
   10e3f:	41 5d                	pop    %r13
   10e41:	41 5e                	pop    %r14
   10e43:	5d                   	pop    %rbp
   10e44:	c3                   	retq   
        waittime.tv_nsec = microsec * 1000;

        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAIT_UINT, 2, NULL, &waittime);

        if (IS_ERR(ret) && ERRNO(ret) != EWOULDBLOCK) {
            ret = unix_to_pal_error(ERRNO(ret));
   10e45:	f7 d8                	neg    %eax
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   10e47:	83 f8 6e             	cmp    $0x6e,%eax
   10e4a:	77 6a                	ja     10eb6 <_DkMutexLockTimeout+0x166>
   10e4c:	48 8d 15 fd d3 00 00 	lea    0xd3fd(%rip),%rdx        # 1e250 <slab_levels+0x4fb0>
   10e53:	89 c0                	mov    %eax,%eax
   10e55:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
   10e59:	48 01 c2             	add    %rax,%rdx
   10e5c:	ff e2                	jmpq   *%rdx
   10e5e:	66 90                	xchg   %ax,%ax
int _DkMutexLockTimeout (struct mutex_handle * mut, int timeout)
{
    int i, c = 0;

    if (timeout == -1)
        return -_DkMutexLock(mut);
   10e60:	e8 eb fd ff ff       	callq  10c50 <_DkMutexLock>
   10e65:	f7 d8                	neg    %eax
   10e67:	eb cf                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
   10e69:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   10e6e:	eb c8                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
   10e70:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   10e75:	eb c1                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
   10e77:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   10e7c:	eb ba                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
   10e7e:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
   10e83:	eb b3                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
   10e85:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   10e8a:	eb ac                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
   10e8c:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   10e91:	eb a5                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
   10e93:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   10e98:	eb 9e                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
   10e9a:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   10e9f:	eb 97                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
   10ea1:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   10ea6:	eb 90                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
   10ea8:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   10ead:	eb 89                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
   10eaf:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   10eb4:	eb 82                	jmp    10e38 <_DkMutexLockTimeout+0xe8>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
   10eb6:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   10ebb:	e9 78 ff ff ff       	jmpq   10e38 <_DkMutexLockTimeout+0xe8>

0000000000010ec0 <_DkMutexUnlock>:
out:
    return ret;
}

int _DkMutexUnlock (struct mutex_handle * mut)
{
   10ec0:	8b 07                	mov    (%rdi),%eax
#ifdef DEBUG_MUTEX
    mut->owner = 0;
#endif

    // Unlock, and if not contended then exit. 
    if (atomic_read(m) < 0)
   10ec2:	85 c0                	test   %eax,%eax
   10ec4:	78 0a                	js     10ed0 <_DkMutexUnlock+0x10>
    return v->counter;
}

static inline void atomic_set (struct atomic_int * v, int i)
{
    v->counter = i;
   10ec6:	c7 07 01 00 00 00    	movl   $0x1,(%rdi)
    if (IS_ERR(ret)) {
        ret = -PAL_ERROR_TRYAGAIN;
        goto out;
    }

    ret = 0;
   10ecc:	31 c0                	xor    %eax,%eax
out:
    return ret;
}
   10ece:	c3                   	retq   
   10ecf:	90                   	nop    
out:
    return ret;
}

int _DkMutexUnlock (struct mutex_handle * mut)
{
   10ed0:	55                   	push   %rbp
   10ed1:	c7 07 01 00 00 00    	movl   $0x1,(%rdi)

    atomic_set(m, 1);

     if (must_wake) {
        // We need to wake someone up
        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAKE, 1, NULL, NULL);
   10ed7:	45 31 c0             	xor    %r8d,%r8d
   10eda:	31 c9                	xor    %ecx,%ecx
   10edc:	ba 01 00 00 00       	mov    $0x1,%edx
   10ee1:	be 03 00 00 00       	mov    $0x3,%esi
out:
    return ret;
}

int _DkMutexUnlock (struct mutex_handle * mut)
{
   10ee6:	48 89 e5             	mov    %rsp,%rbp
   10ee9:	53                   	push   %rbx

    atomic_set(m, 1);

     if (must_wake) {
        // We need to wake someone up
        ret = INLINE_SYSCALL(_umtx_op, 5, m, UMTX_OP_WAKE, 1, NULL, NULL);
   10eea:	bb c6 01 00 00       	mov    $0x1c6,%ebx
   10eef:	89 d8                	mov    %ebx,%eax
   10ef1:	cd 80                	int    $0x80
   10ef3:	48 89 c1             	mov    %rax,%rcx
   10ef6:	bb 00 00 00 00       	mov    $0x0,%ebx
   10efb:	83 d3 00             	adc    $0x0,%ebx
   10efe:	31 d2                	xor    %edx,%edx
   10f00:	85 db                	test   %ebx,%ebx
   10f02:	0f 95 c2             	setne  %dl
   10f05:	48 89 d0             	mov    %rdx,%rax
   10f08:	48 f7 d8             	neg    %rax
   10f0b:	48 31 c8             	xor    %rcx,%rax
   10f0e:	48 01 d0             	add    %rdx,%rax
    if (IS_ERR(ret)) {
        ret = -PAL_ERROR_TRYAGAIN;
        goto out;
    }

    ret = 0;
   10f11:	c1 f8 1f             	sar    $0x1f,%eax
   10f14:	83 e0 ed             	and    $0xffffffffffffffed,%eax
out:
    return ret;
}
   10f17:	5b                   	pop    %rbx
   10f18:	5d                   	pop    %rbp
   10f19:	c3                   	retq   
   10f1a:	90                   	nop    
   10f1b:	90                   	nop    
   10f1c:	90                   	nop    
   10f1d:	90                   	nop    
   10f1e:	90                   	nop    
   10f1f:	90                   	nop    

0000000000010f20 <_DkEventCreate>:
//#include <futex.h>
#include <asm-errno.h>
#include <sys/time.h>

int _DkEventCreate (PAL_HANDLE * event, bool initialState, bool isnotification)
{
   10f20:	55                   	push   %rbp
   10f21:	48 89 e5             	mov    %rsp,%rbp
   10f24:	41 55                	push   %r13
   10f26:	41 54                	push   %r12
   10f28:	53                   	push   %rbx
   10f29:	89 f3                	mov    %esi,%ebx
   10f2b:	49 89 fc             	mov    %rdi,%r12
   10f2e:	41 89 d5             	mov    %edx,%r13d
    PAL_HANDLE ev = malloc(HANDLE_SIZE(event));
    SET_HANDLE_TYPE(ev, event);
    ev->event.isnotification = isnotification;
    atomic_set(&ev->event.signaled, initialState ? 1 : 0);
   10f31:	0f b6 db             	movzbl %bl,%ebx
#include <asm-errno.h>
#include <sys/time.h>

int _DkEventCreate (PAL_HANDLE * event, bool initialState, bool isnotification)
{
    PAL_HANDLE ev = malloc(HANDLE_SIZE(event));
   10f34:	bf 18 00 00 00       	mov    $0x18,%edi
//#include <futex.h>
#include <asm-errno.h>
#include <sys/time.h>

int _DkEventCreate (PAL_HANDLE * event, bool initialState, bool isnotification)
{
   10f39:	48 83 ec 08          	sub    $0x8,%rsp
    PAL_HANDLE ev = malloc(HANDLE_SIZE(event));
   10f3d:	e8 be 7a ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(ev, event);
   10f42:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
   10f49:	c7 00 10 00 00 00    	movl   $0x10,(%rax)
   10f4f:	89 58 0c             	mov    %ebx,0xc(%rax)
   10f52:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    ev->event.isnotification = isnotification;
   10f59:	44 88 68 14          	mov    %r13b,0x14(%rax)
   10f5d:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%rax)
    atomic_set(&ev->event.signaled, initialState ? 1 : 0);
    atomic_set(&ev->event.nwaiters, 0);
    *event = ev;
   10f64:	49 89 04 24          	mov    %rax,(%r12)
    return 0;
}
   10f68:	48 83 c4 08          	add    $0x8,%rsp
   10f6c:	31 c0                	xor    %eax,%eax
   10f6e:	5b                   	pop    %rbx
   10f6f:	41 5c                	pop    %r12
   10f71:	41 5d                	pop    %r13
   10f73:	5d                   	pop    %rbp
   10f74:	c3                   	retq   
   10f75:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
   10f7c:	00 00 00 00 

0000000000010f80 <_DkEventDestroy>:

void _DkEventDestroy (PAL_HANDLE handle)
{
   10f80:	55                   	push   %rbp
   10f81:	48 89 e5             	mov    %rsp,%rbp
    free(handle);
}
   10f84:	5d                   	pop    %rbp
    return 0;
}

void _DkEventDestroy (PAL_HANDLE handle)
{
    free(handle);
   10f85:	e9 06 7d ff ff       	jmpq   8c90 <free>
   10f8a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000010f90 <_DkEventSet>:
}

int _DkEventSet (PAL_HANDLE event)
{
   10f90:	55                   	push   %rbp
        ret = INLINE_SYSCALL(futex, 6, &event->event.signaled, FUTEX_WAKE, 1,
                             NULL, NULL, 0);
    }

    return IS_ERR(ret) ? PAL_ERROR_TRYAGAIN : 0;*/
}
   10f91:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
    free(handle);
}

int _DkEventSet (PAL_HANDLE event)
{
   10f96:	48 89 e5             	mov    %rsp,%rbp
        ret = INLINE_SYSCALL(futex, 6, &event->event.signaled, FUTEX_WAKE, 1,
                             NULL, NULL, 0);
    }

    return IS_ERR(ret) ? PAL_ERROR_TRYAGAIN : 0;*/
}
   10f99:	5d                   	pop    %rbp
   10f9a:	c3                   	retq   
   10f9b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000010fa0 <_DkEventWaitTimeout>:

int _DkEventWaitTimeout (PAL_HANDLE event, int timeout)
{
   10fa0:	55                   	push   %rbp

        atomic_dec(&event->event.nwaiters);
    }

    return ret;*/
}
   10fa1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

    return IS_ERR(ret) ? PAL_ERROR_TRYAGAIN : 0;*/
}

int _DkEventWaitTimeout (PAL_HANDLE event, int timeout)
{
   10fa6:	48 89 e5             	mov    %rsp,%rbp

        atomic_dec(&event->event.nwaiters);
    }

    return ret;*/
}
   10fa9:	5d                   	pop    %rbp
   10faa:	c3                   	retq   
   10fab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000010fb0 <_DkEventWait>:

int _DkEventWait (PAL_HANDLE event)
{
   10fb0:	55                   	push   %rbp

        atomic_dec(&event->event.nwaiters);
    }

    return ret;*/
}
   10fb1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

    return ret;*/
}

int _DkEventWait (PAL_HANDLE event)
{
   10fb6:	48 89 e5             	mov    %rsp,%rbp

        atomic_dec(&event->event.nwaiters);
    }

    return ret;*/
}
   10fb9:	5d                   	pop    %rbp
   10fba:	c3                   	retq   
   10fbb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000010fc0 <_DkEventClear>:

int _DkEventClear (PAL_HANDLE event)
{
   10fc0:	55                   	push   %rbp
    atomic_set(&event->event.signaled, 0);
    return 0;
}
   10fc1:	31 c0                	xor    %eax,%eax
   10fc3:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%rdi)

    return ret;*/
}

int _DkEventClear (PAL_HANDLE event)
{
   10fca:	48 89 e5             	mov    %rsp,%rbp
    atomic_set(&event->event.signaled, 0);
    return 0;
}
   10fcd:	5d                   	pop    %rbp
   10fce:	c3                   	retq   
   10fcf:	90                   	nop    

0000000000010fd0 <proc_read>:
    return set_graphene_task(manifest, flags);
}

static int proc_read (PAL_HANDLE handle, int offset, int count,
                          void * buffer)
{
   10fd0:	55                   	push   %rbp
    int bytes = INLINE_SYSCALL(read, 3, handle->process.stream_in, buffer,
   10fd1:	48 63 d2             	movslq %edx,%rdx
   10fd4:	48 89 ce             	mov    %rcx,%rsi
    return set_graphene_task(manifest, flags);
}

static int proc_read (PAL_HANDLE handle, int offset, int count,
                          void * buffer)
{
   10fd7:	48 89 e5             	mov    %rsp,%rbp
   10fda:	53                   	push   %rbx
    int bytes = INLINE_SYSCALL(read, 3, handle->process.stream_in, buffer,
   10fdb:	bb 03 00 00 00       	mov    $0x3,%ebx
   10fe0:	8b 7f 0c             	mov    0xc(%rdi),%edi
   10fe3:	89 d8                	mov    %ebx,%eax
   10fe5:	cd 80                	int    $0x80
   10fe7:	48 89 c2             	mov    %rax,%rdx
   10fea:	bb 00 00 00 00       	mov    $0x0,%ebx
   10fef:	83 d3 00             	adc    $0x0,%ebx
   10ff2:	31 c9                	xor    %ecx,%ecx
   10ff4:	85 db                	test   %ebx,%ebx
   10ff6:	0f 95 c1             	setne  %cl
   10ff9:	48 89 c8             	mov    %rcx,%rax
   10ffc:	48 f7 d8             	neg    %rax
   10fff:	48 31 d0             	xor    %rdx,%rax
   11002:	48 8d 14 08          	lea    (%rax,%rcx,1),%rdx
                               count);

    if (IS_ERR(bytes))
   11006:	85 d2                	test   %edx,%edx
   11008:	89 d0                	mov    %edx,%eax
   1100a:	78 04                	js     11010 <proc_read+0x40>
            default:
                return -PAL_ERROR_DENIED;
        }

    return bytes;
}
   1100c:	5b                   	pop    %rbx
   1100d:	5d                   	pop    %rbp
   1100e:	c3                   	retq   
   1100f:	90                   	nop    
{
    int bytes = INLINE_SYSCALL(read, 3, handle->process.stream_in, buffer,
                               count);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
   11010:	f7 da                	neg    %edx
            case EWOULDBLOCK:
                return-PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
   11012:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
{
    int bytes = INLINE_SYSCALL(read, 3, handle->process.stream_in, buffer,
                               count);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
   11017:	83 fa 04             	cmp    $0x4,%edx
   1101a:	74 f0                	je     1100c <proc_read+0x3c>
            case EWOULDBLOCK:
                return-PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
            default:
                return -PAL_ERROR_DENIED;
   1101c:	83 fa 0b             	cmp    $0xb,%edx
   1101f:	b0 ed                	mov    $0xed,%al
   11021:	ba fa ff ff ff       	mov    $0xfffffffa,%edx
   11026:	0f 45 c2             	cmovne %edx,%eax
        }

    return bytes;
}
   11029:	5b                   	pop    %rbx
   1102a:	5d                   	pop    %rbp
   1102b:	c3                   	retq   
   1102c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000011030 <proc_write>:

static int proc_write (PAL_HANDLE handle, int offset, int count,
                       const void * buffer)
{
   11030:	55                   	push   %rbp
   11031:	49 89 f8             	mov    %rdi,%r8
   11034:	48 63 d2             	movslq %edx,%rdx
    int bytes = INLINE_SYSCALL(write, 3, handle->process.stream_out, buffer,
   11037:	48 89 ce             	mov    %rcx,%rsi
    return bytes;
}

static int proc_write (PAL_HANDLE handle, int offset, int count,
                       const void * buffer)
{
   1103a:	48 89 e5             	mov    %rsp,%rbp
   1103d:	53                   	push   %rbx
    int bytes = INLINE_SYSCALL(write, 3, handle->process.stream_out, buffer,
   1103e:	bb 04 00 00 00       	mov    $0x4,%ebx
   11043:	8b 7f 10             	mov    0x10(%rdi),%edi
   11046:	89 d8                	mov    %ebx,%eax
   11048:	cd 80                	int    $0x80
   1104a:	48 89 c6             	mov    %rax,%rsi
   1104d:	bb 00 00 00 00       	mov    $0x0,%ebx
   11052:	83 d3 00             	adc    $0x0,%ebx
   11055:	31 c9                	xor    %ecx,%ecx
   11057:	85 db                	test   %ebx,%ebx
   11059:	0f 95 c1             	setne  %cl
   1105c:	48 89 c8             	mov    %rcx,%rax
   1105f:	48 f7 d8             	neg    %rax
   11062:	48 31 f0             	xor    %rsi,%rax
   11065:	48 01 c8             	add    %rcx,%rax
                               count);

    if (IS_ERR(bytes))
   11068:	85 c0                	test   %eax,%eax
   1106a:	78 14                	js     11080 <proc_write+0x50>
                return -PAL_ERROR_INTERRUPTED;
            default:
                return -PAL_ERROR_DENIED;
        }

    if (bytes == count)
   1106c:	39 d0                	cmp    %edx,%eax
   1106e:	74 34                	je     110a4 <proc_write+0x74>
        handle->__in.flags |= WRITEABLE(1);
    else
        handle->__in.flags &= ~WRITEABLE(1);
   11070:	41 81 60 08 7f ff ff 	andl   $0xffffff7f,0x8(%r8)
   11077:	ff 

    return bytes;
}
   11078:	5b                   	pop    %rbx
   11079:	5d                   	pop    %rbp
   1107a:	c3                   	retq   
   1107b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
{
    int bytes = INLINE_SYSCALL(write, 3, handle->process.stream_out, buffer,
                               count);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
   11080:	89 c2                	mov    %eax,%edx
            case EWOULDBLOCK:
                handle->__in.flags &= ~WRITEABLE(1);
                return-PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
   11082:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
{
    int bytes = INLINE_SYSCALL(write, 3, handle->process.stream_out, buffer,
                               count);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
   11087:	f7 da                	neg    %edx
   11089:	83 fa 04             	cmp    $0x4,%edx
   1108c:	74 ea                	je     11078 <proc_write+0x48>
   1108e:	83 fa 0b             	cmp    $0xb,%edx
                handle->__in.flags &= ~WRITEABLE(1);
                return-PAL_ERROR_TRYAGAIN;
            case EINTR:
                return -PAL_ERROR_INTERRUPTED;
            default:
                return -PAL_ERROR_DENIED;
   11091:	b0 fa                	mov    $0xfa,%al
{
    int bytes = INLINE_SYSCALL(write, 3, handle->process.stream_out, buffer,
                               count);

    if (IS_ERR(bytes))
        switch(ERRNO(bytes)) {
   11093:	75 e3                	jne    11078 <proc_write+0x48>
            case EWOULDBLOCK:
                handle->__in.flags &= ~WRITEABLE(1);
   11095:	41 81 60 08 7f ff ff 	andl   $0xffffff7f,0x8(%r8)
   1109c:	ff 
                return-PAL_ERROR_TRYAGAIN;
   1109d:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   110a2:	eb d4                	jmp    11078 <proc_write+0x48>
        handle->__in.flags |= WRITEABLE(1);
    else
        handle->__in.flags &= ~WRITEABLE(1);

    return bytes;
}
   110a4:	5b                   	pop    %rbx
            default:
                return -PAL_ERROR_DENIED;
        }

    if (bytes == count)
        handle->__in.flags |= WRITEABLE(1);
   110a5:	41 81 48 08 80 00 00 	orl    $0x80,0x8(%r8)
   110ac:	00 
    else
        handle->__in.flags &= ~WRITEABLE(1);

    return bytes;
}
   110ad:	5d                   	pop    %rbp
   110ae:	c3                   	retq   
   110af:	90                   	nop    

00000000000110b0 <proc_close>:

static int proc_close (PAL_HANDLE handle)
{
   110b0:	55                   	push   %rbp
   110b1:	48 89 fa             	mov    %rdi,%rdx
   110b4:	48 89 e5             	mov    %rsp,%rbp
   110b7:	53                   	push   %rbx
    if (handle->process.stream_in != PAL_IDX_POISON) {
   110b8:	8b 7f 0c             	mov    0xc(%rdi),%edi
   110bb:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   110be:	74 16                	je     110d6 <proc_close+0x26>
        INLINE_SYSCALL(close, 1, handle->process.stream_in);
   110c0:	b8 06 00 00 00       	mov    $0x6,%eax
   110c5:	cd 80                	int    $0x80
   110c7:	bb 00 00 00 00       	mov    $0x0,%ebx
   110cc:	83 d3 00             	adc    $0x0,%ebx
        handle->process.stream_in = PAL_IDX_POISON;
   110cf:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rdx)
    }

    if (handle->process.stream_out != PAL_IDX_POISON) {
   110d6:	8b 7a 10             	mov    0x10(%rdx),%edi
   110d9:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   110dc:	74 16                	je     110f4 <proc_close+0x44>
        INLINE_SYSCALL(close, 1, handle->process.stream_out);
   110de:	b8 06 00 00 00       	mov    $0x6,%eax
   110e3:	cd 80                	int    $0x80
   110e5:	bb 00 00 00 00       	mov    $0x0,%ebx
   110ea:	83 d3 00             	adc    $0x0,%ebx
        handle->process.stream_out = PAL_IDX_POISON;
   110ed:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rdx)
    }

    if (handle->process.cargo != PAL_IDX_POISON) {
   110f4:	8b 7a 14             	mov    0x14(%rdx),%edi
   110f7:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   110fa:	74 16                	je     11112 <proc_close+0x62>
        INLINE_SYSCALL(close, 1, handle->process.cargo);
   110fc:	b8 06 00 00 00       	mov    $0x6,%eax
   11101:	cd 80                	int    $0x80
   11103:	bb 00 00 00 00       	mov    $0x0,%ebx
   11108:	83 d3 00             	adc    $0x0,%ebx
        handle->process.cargo = PAL_IDX_POISON;
   1110b:	c7 42 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rdx)
    }

    return 0;
}
   11112:	31 c0                	xor    %eax,%eax
   11114:	5b                   	pop    %rbx
   11115:	5d                   	pop    %rbp
   11116:	c3                   	retq   
   11117:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1111e:	00 00 

0000000000011120 <proc_delete>:

static int proc_delete (PAL_HANDLE handle, int access)
{
   11120:	55                   	push   %rbp
    int shutdown;
    switch (access) {
   11121:	83 fe 01             	cmp    $0x1,%esi

    return 0;
}

static int proc_delete (PAL_HANDLE handle, int access)
{
   11124:	48 89 fa             	mov    %rdi,%rdx
   11127:	48 89 e5             	mov    %rsp,%rbp
   1112a:	53                   	push   %rbx
    int shutdown;
    switch (access) {
   1112b:	74 13                	je     11140 <proc_delete+0x20>
   1112d:	83 fe 02             	cmp    $0x2,%esi
   11130:	74 7f                	je     111b1 <proc_delete+0x91>
   11132:	85 f6                	test   %esi,%esi
            break;
        case PAL_DELETE_WR:
            shutdown = SHUT_WR;
            break;
        default:
            return -PAL_ERROR_INVAL;
   11134:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
}

static int proc_delete (PAL_HANDLE handle, int access)
{
    int shutdown;
    switch (access) {
   11139:	74 67                	je     111a2 <proc_delete+0x82>

    if (handle->process.cargo != PAL_IDX_POISON)
        INLINE_SYSCALL(shutdown, 2, handle->process.cargo, shutdown);

    return 0;
}
   1113b:	5b                   	pop    %rbx
   1113c:	5d                   	pop    %rbp
   1113d:	c3                   	retq   
   1113e:	66 90                	xchg   %ax,%ax
        default:
            return -PAL_ERROR_INVAL;
    }

    if (access != PAL_DELETE_WR &&
        handle->process.stream_in != PAL_IDX_POISON) {
   11140:	8b 7f 0c             	mov    0xc(%rdi),%edi
    switch (access) {
        case 0:
            shutdown = SHUT_RDWR;
            break;
        case PAL_DELETE_RD:
            shutdown = SHUT_RD;
   11143:	31 c9                	xor    %ecx,%ecx
            break;
        default:
            return -PAL_ERROR_INVAL;
    }

    if (access != PAL_DELETE_WR &&
   11145:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   11148:	74 39                	je     11183 <proc_delete+0x63>
        handle->process.stream_in != PAL_IDX_POISON) {
        INLINE_SYSCALL(close, 1, handle->process.stream_in);
   1114a:	b8 06 00 00 00       	mov    $0x6,%eax
   1114f:	cd 80                	int    $0x80
   11151:	bb 00 00 00 00       	mov    $0x0,%ebx
   11156:	83 d3 00             	adc    $0x0,%ebx
        handle->process.stream_in = PAL_IDX_POISON;
    }

    if (access != PAL_DELETE_RD &&
   11159:	83 fe 01             	cmp    $0x1,%esi
    }

    if (access != PAL_DELETE_WR &&
        handle->process.stream_in != PAL_IDX_POISON) {
        INLINE_SYSCALL(close, 1, handle->process.stream_in);
        handle->process.stream_in = PAL_IDX_POISON;
   1115c:	c7 42 0c ff ff ff ff 	movl   $0xffffffff,0xc(%rdx)
    }

    if (access != PAL_DELETE_RD &&
   11163:	74 1e                	je     11183 <proc_delete+0x63>
        handle->process.stream_out != PAL_IDX_POISON) {
   11165:	8b 7a 10             	mov    0x10(%rdx),%edi
        handle->process.stream_in != PAL_IDX_POISON) {
        INLINE_SYSCALL(close, 1, handle->process.stream_in);
        handle->process.stream_in = PAL_IDX_POISON;
    }

    if (access != PAL_DELETE_RD &&
   11168:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   1116b:	74 16                	je     11183 <proc_delete+0x63>
        handle->process.stream_out != PAL_IDX_POISON) {
        INLINE_SYSCALL(close, 1, handle->process.stream_out);
   1116d:	b8 06 00 00 00       	mov    $0x6,%eax
   11172:	cd 80                	int    $0x80
   11174:	bb 00 00 00 00       	mov    $0x0,%ebx
   11179:	83 d3 00             	adc    $0x0,%ebx
        handle->process.stream_out = PAL_IDX_POISON;
   1117c:	c7 42 10 ff ff ff ff 	movl   $0xffffffff,0x10(%rdx)
    }

    if (handle->process.cargo != PAL_IDX_POISON)
   11183:	8b 7a 14             	mov    0x14(%rdx),%edi
   11186:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   11189:	74 35                	je     111c0 <proc_delete+0xa0>
        INLINE_SYSCALL(shutdown, 2, handle->process.cargo, shutdown);
   1118b:	48 63 f1             	movslq %ecx,%rsi
   1118e:	b8 86 00 00 00       	mov    $0x86,%eax
   11193:	cd 80                	int    $0x80
   11195:	bb 00 00 00 00       	mov    $0x0,%ebx
   1119a:	83 d3 00             	adc    $0x0,%ebx

    return 0;
   1119d:	31 c0                	xor    %eax,%eax
}
   1119f:	5b                   	pop    %rbx
   111a0:	5d                   	pop    %rbp
   111a1:	c3                   	retq   
        default:
            return -PAL_ERROR_INVAL;
    }

    if (access != PAL_DELETE_WR &&
        handle->process.stream_in != PAL_IDX_POISON) {
   111a2:	8b 7f 0c             	mov    0xc(%rdi),%edi
static int proc_delete (PAL_HANDLE handle, int access)
{
    int shutdown;
    switch (access) {
        case 0:
            shutdown = SHUT_RDWR;
   111a5:	b9 02 00 00 00       	mov    $0x2,%ecx
            break;
        default:
            return -PAL_ERROR_INVAL;
    }

    if (access != PAL_DELETE_WR &&
   111aa:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   111ad:	75 9b                	jne    1114a <proc_delete+0x2a>
   111af:	eb b4                	jmp    11165 <proc_delete+0x45>
            break;
        case PAL_DELETE_RD:
            shutdown = SHUT_RD;
            break;
        case PAL_DELETE_WR:
            shutdown = SHUT_WR;
   111b1:	b9 01 00 00 00       	mov    $0x1,%ecx
   111b6:	eb ad                	jmp    11165 <proc_delete+0x45>
   111b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   111bf:	00 
    }

    if (handle->process.cargo != PAL_IDX_POISON)
        INLINE_SYSCALL(shutdown, 2, handle->process.cargo, shutdown);

    return 0;
   111c0:	31 c0                	xor    %eax,%eax
}
   111c2:	5b                   	pop    %rbx
   111c3:	5d                   	pop    %rbp
   111c4:	c3                   	retq   
   111c5:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
   111cc:	00 00 00 00 

00000000000111d0 <proc_attrsetbyhdl>:
    attr->nonblocking = handle->process.nonblocking;
    return 0;
}

static int proc_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
   111d0:	49 89 f8             	mov    %rdi,%r8
    if (handle->process.stream_in == PAL_IDX_POISON)
   111d3:	8b 7f 0c             	mov    0xc(%rdi),%edi
   111d6:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   111d9:	0f 84 41 01 00 00    	je     11320 <proc_attrsetbyhdl+0x150>
        return -PAL_ERROR_BADHANDLE;

    int ret;
    if (attr->nonblocking != handle->process.nonblocking) {
   111df:	41 0f b6 40 1c       	movzbl 0x1c(%r8),%eax
   111e4:	49 89 f1             	mov    %rsi,%r9
   111e7:	38 46 38             	cmp    %al,0x38(%rsi)
   111ea:	74 54                	je     11240 <proc_attrsetbyhdl+0x70>
        ret = INLINE_SYSCALL(fcntl, 3, handle->process.stream_in, F_SETFL,
   111ec:	3c 01                	cmp    $0x1,%al
    attr->nonblocking = handle->process.nonblocking;
    return 0;
}

static int proc_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
   111ee:	55                   	push   %rbp
    if (handle->process.stream_in == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    int ret;
    if (attr->nonblocking != handle->process.nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->process.stream_in, F_SETFL,
   111ef:	b9 5c 00 00 00       	mov    $0x5c,%ecx
   111f4:	48 19 d2             	sbb    %rdx,%rdx
   111f7:	be 04 00 00 00       	mov    $0x4,%esi
   111fc:	89 c8                	mov    %ecx,%eax
   111fe:	48 f7 d2             	not    %rdx
    attr->nonblocking = handle->process.nonblocking;
    return 0;
}

static int proc_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
   11201:	48 89 e5             	mov    %rsp,%rbp
   11204:	53                   	push   %rbx
    if (handle->process.stream_in == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    int ret;
    if (attr->nonblocking != handle->process.nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->process.stream_in, F_SETFL,
   11205:	83 e2 04             	and    $0x4,%edx
   11208:	cd 80                	int    $0x80
   1120a:	48 89 c1             	mov    %rax,%rcx
   1120d:	bb 00 00 00 00       	mov    $0x0,%ebx
   11212:	83 d3 00             	adc    $0x0,%ebx
   11215:	31 d2                	xor    %edx,%edx
   11217:	85 db                	test   %ebx,%ebx
   11219:	0f 95 c2             	setne  %dl
   1121c:	48 89 d0             	mov    %rdx,%rax
   1121f:	48 f7 d8             	neg    %rax
   11222:	48 31 c8             	xor    %rcx,%rax
   11225:	48 01 c2             	add    %rax,%rdx
                             handle->process.nonblocking ? O_NONBLOCK : 0);

        if (IS_ERR(ret))
   11228:	85 d2                	test   %edx,%edx
   1122a:	78 17                	js     11243 <proc_attrsetbyhdl+0x73>
            return unix_to_pal_error(ERRNO(ret));

        handle->process.nonblocking = attr->nonblocking;
   1122c:	41 0f b6 41 38       	movzbl 0x38(%r9),%eax
   11231:	41 88 40 1c          	mov    %al,0x1c(%r8)
    }

    return 0;
   11235:	31 c0                	xor    %eax,%eax
}
   11237:	5b                   	pop    %rbx
   11238:	5d                   	pop    %rbp
   11239:	c3                   	retq   
   1123a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return unix_to_pal_error(ERRNO(ret));

        handle->process.nonblocking = attr->nonblocking;
    }

    return 0;
   11240:	31 c0                	xor    %eax,%eax
   11242:	c3                   	retq   
    if (attr->nonblocking != handle->process.nonblocking) {
        ret = INLINE_SYSCALL(fcntl, 3, handle->process.stream_in, F_SETFL,
                             handle->process.nonblocking ? O_NONBLOCK : 0);

        if (IS_ERR(ret))
            return unix_to_pal_error(ERRNO(ret));
   11243:	f7 da                	neg    %edx
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   11245:	83 fa 6e             	cmp    $0x6e,%edx
   11248:	0f 87 c2 00 00 00    	ja     11310 <proc_attrsetbyhdl+0x140>
   1124e:	48 8d 05 b7 d1 00 00 	lea    0xd1b7(%rip),%rax        # 1e40c <slab_levels+0x516c>
   11255:	89 d2                	mov    %edx,%edx
   11257:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
   1125b:	48 01 d0             	add    %rdx,%rax
   1125e:	ff e0                	jmpq   *%rax
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
   11260:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   11265:	eb d0                	jmp    11237 <proc_attrsetbyhdl+0x67>
   11267:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1126e:	00 00 
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
   11270:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   11275:	eb c0                	jmp    11237 <proc_attrsetbyhdl+0x67>
   11277:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1127e:	00 00 
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
   11280:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   11285:	eb b0                	jmp    11237 <proc_attrsetbyhdl+0x67>
   11287:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1128e:	00 00 
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
   11290:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   11295:	eb a0                	jmp    11237 <proc_attrsetbyhdl+0x67>
   11297:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1129e:	00 00 
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
   112a0:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
   112a5:	eb 90                	jmp    11237 <proc_attrsetbyhdl+0x67>
   112a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   112ae:	00 00 
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
   112b0:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   112b5:	eb 80                	jmp    11237 <proc_attrsetbyhdl+0x67>
   112b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   112be:	00 00 
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
   112c0:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   112c5:	e9 6d ff ff ff       	jmpq   11237 <proc_attrsetbyhdl+0x67>
   112ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
   112d0:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   112d5:	e9 5d ff ff ff       	jmpq   11237 <proc_attrsetbyhdl+0x67>
   112da:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
   112e0:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
   112e5:	e9 4d ff ff ff       	jmpq   11237 <proc_attrsetbyhdl+0x67>
   112ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
   112f0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   112f5:	e9 3d ff ff ff       	jmpq   11237 <proc_attrsetbyhdl+0x67>
   112fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
{
    switch(unix_errno) {
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
   11300:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   11305:	e9 2d ff ff ff       	jmpq   11237 <proc_attrsetbyhdl+0x67>
   1130a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
   11310:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   11315:	e9 1d ff ff ff       	jmpq   11237 <proc_attrsetbyhdl+0x67>
   1131a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
}

static int proc_attrsetbyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    if (handle->process.stream_in == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
   11320:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax

        handle->process.nonblocking = attr->nonblocking;
    }

    return 0;
}
   11325:	c3                   	retq   
   11326:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1132d:	00 00 00 

0000000000011330 <proc_attrquerybyhdl>:
#ifndef FIONREAD
# define FIONREAD 0x541B
#endif

static int proc_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
   11330:	83 7f 0c ff          	cmpl   $0xffffffffffffffff,0xc(%rdi)
   11334:	0f 84 a6 00 00 00    	je     113e0 <proc_attrquerybyhdl+0xb0>
   1133a:	55                   	push   %rbp
    int ret, val;

    if (handle->process.stream_in == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
   1133b:	ba 70 00 00 00       	mov    $0x70,%edx
#ifndef FIONREAD
# define FIONREAD 0x541B
#endif

static int proc_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
   11340:	48 89 e5             	mov    %rsp,%rbp
   11343:	41 55                	push   %r13
   11345:	41 54                	push   %r12
   11347:	53                   	push   %rbx
   11348:	49 89 f4             	mov    %rsi,%r12
   1134b:	49 89 fd             	mov    %rdi,%r13
    int ret, val;

    if (handle->process.stream_in == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
   1134e:	31 f6                	xor    %esi,%esi
   11350:	4c 89 e7             	mov    %r12,%rdi

    ret = INLINE_SYSCALL(ioctl, 3, handle->process.stream_in, FIONREAD, &val);
   11353:	bb 36 00 00 00       	mov    $0x36,%ebx
#ifndef FIONREAD
# define FIONREAD 0x541B
#endif

static int proc_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
   11358:	48 83 ec 18          	sub    $0x18,%rsp
    int ret, val;

    if (handle->process.stream_in == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;

    memset(attr, 0, sizeof(PAL_STREAM_ATTR));
   1135c:	e8 3f 4e 00 00       	callq  161a0 <memset>

    ret = INLINE_SYSCALL(ioctl, 3, handle->process.stream_in, FIONREAD, &val);
   11361:	41 8b 7d 0c          	mov    0xc(%r13),%edi
   11365:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
   11369:	be 7f 66 04 40       	mov    $0x4004667f,%esi
   1136e:	89 d8                	mov    %ebx,%eax
   11370:	cd 80                	int    $0x80
   11372:	48 89 c2             	mov    %rax,%rdx
   11375:	bb 00 00 00 00       	mov    $0x0,%ebx
   1137a:	83 d3 00             	adc    $0x0,%ebx
   1137d:	31 c9                	xor    %ecx,%ecx
   1137f:	85 db                	test   %ebx,%ebx
   11381:	0f 95 c1             	setne  %cl
   11384:	48 89 c8             	mov    %rcx,%rax
   11387:	48 f7 d8             	neg    %rax
   1138a:	48 31 d0             	xor    %rdx,%rax
    if (!IS_ERR(ret))
   1138d:	01 c8                	add    %ecx,%eax
   1138f:	78 41                	js     113d2 <proc_attrquerybyhdl+0xa2>
        attr->size = val;
   11391:	48 63 55 dc          	movslq -0x24(%rbp),%rdx
   11395:	49 89 54 24 10       	mov    %rdx,0x10(%r12)

    attr->disconnected = handle->__in.flags & (ERROR(0)|ERROR(1));
   1139a:	41 8b 45 08          	mov    0x8(%r13),%eax
   1139e:	f6 c4 06             	test   $0x6,%ah
   113a1:	41 0f 95 44 24 30    	setne  0x30(%r12)
    attr->readable = (attr->size > 0);
   113a7:	48 85 d2             	test   %rdx,%rdx
   113aa:	41 0f 95 44 24 31    	setne  0x31(%r12)
    attr->writeable = handle->__in.flags & WRITEABLE(1);
   113b0:	c1 e8 07             	shr    $0x7,%eax
   113b3:	83 e0 01             	and    $0x1,%eax
   113b6:	41 88 44 24 32       	mov    %al,0x32(%r12)
    attr->nonblocking = handle->process.nonblocking;
   113bb:	41 0f b6 45 1c       	movzbl 0x1c(%r13),%eax
   113c0:	41 88 44 24 38       	mov    %al,0x38(%r12)
    return 0;
}
   113c5:	48 83 c4 18          	add    $0x18,%rsp

    attr->disconnected = handle->__in.flags & (ERROR(0)|ERROR(1));
    attr->readable = (attr->size > 0);
    attr->writeable = handle->__in.flags & WRITEABLE(1);
    attr->nonblocking = handle->process.nonblocking;
    return 0;
   113c9:	31 c0                	xor    %eax,%eax
}
   113cb:	5b                   	pop    %rbx
   113cc:	41 5c                	pop    %r12
   113ce:	41 5d                	pop    %r13
   113d0:	5d                   	pop    %rbp
   113d1:	c3                   	retq   
   113d2:	49 8b 54 24 10       	mov    0x10(%r12),%rdx
   113d7:	eb c1                	jmp    1139a <proc_attrquerybyhdl+0x6a>
   113d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
static int proc_attrquerybyhdl (PAL_HANDLE handle, PAL_STREAM_ATTR * attr)
{
    int ret, val;

    if (handle->process.stream_in == PAL_IDX_POISON)
        return -PAL_ERROR_BADHANDLE;
   113e0:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   113e5:	c3                   	retq   
   113e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   113ed:	00 00 00 

00000000000113f0 <set_graphene_task>:

int ioctl_set_graphene (struct config_store * config, int ndefault,
                        const struct graphene_user_policy * default_policies);

static int set_graphene_task (const char * uri, int flags)
{
   113f0:	55                   	push   %rbp
    PAL_HANDLE handle = NULL;
    int ret;

    if ((ret = _DkStreamOpen(&handle, uri, PAL_ACCESS_RDONLY, 0, 0, 0)) < 0)
   113f1:	45 31 c9             	xor    %r9d,%r9d
   113f4:	45 31 c0             	xor    %r8d,%r8d
   113f7:	31 c9                	xor    %ecx,%ecx
   113f9:	31 d2                	xor    %edx,%edx

int ioctl_set_graphene (struct config_store * config, int ndefault,
                        const struct graphene_user_policy * default_policies);

static int set_graphene_task (const char * uri, int flags)
{
   113fb:	48 89 e5             	mov    %rsp,%rbp
   113fe:	41 57                	push   %r15
   11400:	41 56                	push   %r14
   11402:	41 55                	push   %r13
   11404:	41 54                	push   %r12
   11406:	41 89 f4             	mov    %esi,%r12d
   11409:	53                   	push   %rbx
   1140a:	48 89 fb             	mov    %rdi,%rbx
    PAL_HANDLE handle = NULL;
    int ret;

    if ((ret = _DkStreamOpen(&handle, uri, PAL_ACCESS_RDONLY, 0, 0, 0)) < 0)
   1140d:	48 8d bd 20 fe ff ff 	lea    -0x1e0(%rbp),%rdi
   11414:	48 89 de             	mov    %rbx,%rsi

int ioctl_set_graphene (struct config_store * config, int ndefault,
                        const struct graphene_user_policy * default_policies);

static int set_graphene_task (const char * uri, int flags)
{
   11417:	48 81 ec e8 01 00 00 	sub    $0x1e8,%rsp
    PAL_HANDLE handle = NULL;
   1141e:	48 c7 85 20 fe ff ff 	movq   $0x0,-0x1e0(%rbp)
   11425:	00 00 00 00 
    int ret;

    if ((ret = _DkStreamOpen(&handle, uri, PAL_ACCESS_RDONLY, 0, 0, 0)) < 0)
   11429:	e8 02 25 ff ff       	callq  3930 <_DkStreamOpen>
   1142e:	85 c0                	test   %eax,%eax
   11430:	0f 88 2c 03 00 00    	js     11762 <set_graphene_task+0x372>
        return ret;

    PAL_STREAM_ATTR attr;

    if ((ret = _DkStreamAttributesQuerybyHandle(handle, &attr)) < 0)
   11436:	48 8b bd 20 fe ff ff 	mov    -0x1e0(%rbp),%rdi
   1143d:	48 8d b5 60 ff ff ff 	lea    -0xa0(%rbp),%rsi
   11444:	e8 e7 2c ff ff       	callq  4130 <_DkStreamAttributesQuerybyHandle>
   11449:	85 c0                	test   %eax,%eax
   1144b:	41 89 c7             	mov    %eax,%r15d
   1144e:	0f 88 ff 02 00 00    	js     11753 <set_graphene_task+0x363>
        goto out;

    void * addr = NULL;
    size_t size = attr.size;

    if ((ret = _DkStreamMap(handle, &addr, PAL_PROT_READ, 0,
   11454:	48 8b 05 35 25 21 00 	mov    0x212535(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>

    if ((ret = _DkStreamAttributesQuerybyHandle(handle, &attr)) < 0)
        goto out;

    void * addr = NULL;
    size_t size = attr.size;
   1145b:	4c 8b ad 70 ff ff ff 	mov    -0x90(%rbp),%r13
    PAL_STREAM_ATTR attr;

    if ((ret = _DkStreamAttributesQuerybyHandle(handle, &attr)) < 0)
        goto out;

    void * addr = NULL;
   11462:	48 c7 85 28 fe ff ff 	movq   $0x0,-0x1d8(%rbp)
   11469:	00 00 00 00 
    size_t size = attr.size;

    if ((ret = _DkStreamMap(handle, &addr, PAL_PROT_READ, 0,
   1146d:	48 83 38 00          	cmpq   $0x0,(%rax)
   11471:	4d 89 e8             	mov    %r13,%r8
   11474:	74 14                	je     1148a <set_graphene_task+0x9a>
                            ALLOC_ALIGNUP(size))) < 0)
   11476:	48 8b 05 cb 26 21 00 	mov    0x2126cb(%rip),%rax        # 223b48 <_DYNAMIC+0x360>
   1147d:	4c 03 00             	add    (%rax),%r8
   11480:	48 8b 05 71 26 21 00 	mov    0x212671(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
        goto out;

    void * addr = NULL;
    size_t size = attr.size;

    if ((ret = _DkStreamMap(handle, &addr, PAL_PROT_READ, 0,
   11487:	4c 23 00             	and    (%rax),%r8
   1148a:	48 8b bd 20 fe ff ff 	mov    -0x1e0(%rbp),%rdi
   11491:	48 8d b5 28 fe ff ff 	lea    -0x1d8(%rbp),%rsi
   11498:	31 c9                	xor    %ecx,%ecx
   1149a:	ba 01 00 00 00       	mov    $0x1,%edx
   1149f:	e8 fc 2d ff ff       	callq  42a0 <_DkStreamMap>
   114a4:	85 c0                	test   %eax,%eax
   114a6:	41 89 c7             	mov    %eax,%r15d
   114a9:	0f 88 a4 02 00 00    	js     11753 <set_graphene_task+0x363>
                            ALLOC_ALIGNUP(size))) < 0)
        goto out;

    struct config_store cfg;
    cfg.raw_data = addr;
   114af:	48 8b 85 28 fe ff ff 	mov    -0x1d8(%rbp),%rax
    cfg.raw_size = size;
    cfg.malloc = malloc;
    cfg.free = free;

    if ((ret = read_config(&cfg, NULL, NULL)) < 0)
   114b6:	4c 8d b5 70 fe ff ff 	lea    -0x190(%rbp),%r14
   114bd:	31 d2                	xor    %edx,%edx
   114bf:	31 f6                	xor    %esi,%esi
                            ALLOC_ALIGNUP(size))) < 0)
        goto out;

    struct config_store cfg;
    cfg.raw_data = addr;
    cfg.raw_size = size;
   114c1:	4c 89 ad 98 fe ff ff 	mov    %r13,-0x168(%rbp)
    cfg.malloc = malloc;
    cfg.free = free;

    if ((ret = read_config(&cfg, NULL, NULL)) < 0)
   114c8:	4c 89 f7             	mov    %r14,%rdi
    if ((ret = _DkStreamMap(handle, &addr, PAL_PROT_READ, 0,
                            ALLOC_ALIGNUP(size))) < 0)
        goto out;

    struct config_store cfg;
    cfg.raw_data = addr;
   114cb:	48 89 85 90 fe ff ff 	mov    %rax,-0x170(%rbp)
    cfg.raw_size = size;
    cfg.malloc = malloc;
   114d2:	48 8b 05 f7 24 21 00 	mov    0x2124f7(%rip),%rax        # 2239d0 <_DYNAMIC+0x1e8>
   114d9:	48 89 85 a0 fe ff ff 	mov    %rax,-0x160(%rbp)
    cfg.free = free;
   114e0:	48 8b 05 b1 26 21 00 	mov    0x2126b1(%rip),%rax        # 223b98 <_DYNAMIC+0x3b0>
   114e7:	48 89 85 a8 fe ff ff 	mov    %rax,-0x158(%rbp)

    if ((ret = read_config(&cfg, NULL, NULL)) < 0)
   114ee:	e8 0d 6c 00 00       	callq  18100 <read_config>
   114f3:	85 c0                	test   %eax,%eax
   114f5:	41 89 c7             	mov    %eax,%r15d
   114f8:	0f 88 21 02 00 00    	js     1171f <set_graphene_task+0x32f>
        goto out_mem;

    const char * manifest = uri;

    struct graphene_user_policy manifest_policy;
    if (!memcmp(manifest, "file:", 5)) {
   114fe:	48 8d 35 b9 78 00 00 	lea    0x78b9(%rip),%rsi        # 18dbe <handle_sizes.1924+0x63e>
   11505:	ba 05 00 00 00       	mov    $0x5,%edx
   1150a:	48 89 df             	mov    %rbx,%rdi
        manifest_policy.type = GRAPHENE_FS_PATH | GRAPHENE_FS_READ;
        manifest_policy.value = manifest + 5;
    } else {
        manifest_policy.type = 0;
   1150d:	45 31 ff             	xor    %r15d,%r15d
        goto out_mem;

    const char * manifest = uri;

    struct graphene_user_policy manifest_policy;
    if (!memcmp(manifest, "file:", 5)) {
   11510:	e8 fb 4d 00 00       	callq  16310 <memcmp>
   11515:	85 c0                	test   %eax,%eax
   11517:	75 0e                	jne    11527 <set_graphene_task+0x137>
        manifest_policy.type = GRAPHENE_FS_PATH | GRAPHENE_FS_READ;
        manifest_policy.value = manifest + 5;
   11519:	48 8d 43 05          	lea    0x5(%rbx),%rax

    const char * manifest = uri;

    struct graphene_user_policy manifest_policy;
    if (!memcmp(manifest, "file:", 5)) {
        manifest_policy.type = GRAPHENE_FS_PATH | GRAPHENE_FS_READ;
   1151d:	41 b7 16             	mov    $0x16,%r15b
        manifest_policy.value = manifest + 5;
   11520:	48 89 85 00 fe ff ff 	mov    %rax,-0x200(%rbp)
    } else {
        manifest_policy.type = 0;
    }

    if (flags & PAL_SANDBOX_PIPE) {
   11527:	41 83 e4 01          	and    $0x1,%r12d
   1152b:	0f 84 43 02 00 00    	je     11774 <set_graphene_task+0x384>
   11531:	4c 8b 25 70 25 21 00 	mov    0x212570(%rip),%r12        # 223aa8 <_DYNAMIC+0x2c0>
        do {
            getrand(&pal_sec_info.mcast_port, sizeof(unsigned short));
   11538:	4d 8d 6c 24 1c       	lea    0x1c(%r12),%r13
   1153d:	0f 1f 00             	nopl   (%rax)
   11540:	be 02 00 00 00       	mov    $0x2,%esi
   11545:	4c 89 ef             	mov    %r13,%rdi
   11548:	e8 c3 4f ff ff       	callq  6510 <getrand>
        } while (pal_sec_info.mcast_port < 1024);
   1154d:	66 41 81 7c 24 1c ff 	cmpw   $0x3ff,0x1c(%r12)
   11554:	03 
   11555:	76 e9                	jbe    11540 <set_graphene_task+0x150>
    }

    struct graphene_net_policy mcast_rules[2];
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);
   11557:	4c 8d ad 00 ff ff ff 	lea    -0x100(%rbp),%r13
   1155e:	31 f6                	xor    %esi,%esi
   11560:	ba 58 00 00 00       	mov    $0x58,%edx
   11565:	4c 89 ef             	mov    %r13,%rdi
   11568:	e8 33 4c 00 00       	callq  161a0 <memset>

    mcast_rules[0].family = AF_INET;
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
   1156d:	41 0f b7 44 24 1c    	movzwl 0x1c(%r12),%eax
    mcast_rules[0].peer.port_end = 65535;

    mcast_rules[1].family = AF_INET;
    mcast_rules[1].local.port_begin = 0;
    mcast_rules[1].local.port_end = 65535;
    inet_pton(AF_INET, MCAST_GROUP, &mcast_rules[1].peer.addr);
   11573:	49 8d 55 44          	lea    0x44(%r13),%rdx
   11577:	48 8d 35 46 9b 00 00 	lea    0x9b46(%rip),%rsi        # 1b0c4 <slab_levels+0x1e24>
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);

    mcast_rules[0].family = AF_INET;
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
    mcast_rules[0].peer.port_begin = 0;
   1157e:	45 31 d2             	xor    %r10d,%r10d
    mcast_rules[0].peer.port_end = 65535;
   11581:	41 bb ff ff ff ff    	mov    $0xffffffff,%r11d
    }

    struct graphene_net_policy mcast_rules[2];
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);

    mcast_rules[0].family = AF_INET;
   11587:	41 b9 02 00 00 00    	mov    $0x2,%r9d
    mcast_rules[0].peer.port_end = 65535;

    mcast_rules[1].family = AF_INET;
    mcast_rules[1].local.port_begin = 0;
    mcast_rules[1].local.port_end = 65535;
    inet_pton(AF_INET, MCAST_GROUP, &mcast_rules[1].peer.addr);
   1158d:	bf 02 00 00 00       	mov    $0x2,%edi
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);

    mcast_rules[0].family = AF_INET;
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
    mcast_rules[0].peer.port_begin = 0;
   11592:	66 44 89 95 28 ff ff 	mov    %r10w,-0xd8(%rbp)
   11599:	ff 
    mcast_rules[0].peer.port_end = 65535;
   1159a:	66 44 89 9d 2a ff ff 	mov    %r11w,-0xd6(%rbp)
   115a1:	ff 
    }

    struct graphene_net_policy mcast_rules[2];
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);

    mcast_rules[0].family = AF_INET;
   115a2:	66 44 89 8d 00 ff ff 	mov    %r9w,-0x100(%rbp)
   115a9:	ff 
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
   115aa:	66 89 85 14 ff ff ff 	mov    %ax,-0xec(%rbp)
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
   115b1:	66 89 85 16 ff ff ff 	mov    %ax,-0xea(%rbp)
    mcast_rules[0].peer.port_begin = 0;
    mcast_rules[0].peer.port_end = 65535;

    mcast_rules[1].family = AF_INET;
   115b8:	b8 02 00 00 00       	mov    $0x2,%eax
   115bd:	66 89 85 2c ff ff ff 	mov    %ax,-0xd4(%rbp)
    mcast_rules[1].local.port_begin = 0;
   115c4:	31 c0                	xor    %eax,%eax
   115c6:	66 89 85 40 ff ff ff 	mov    %ax,-0xc0(%rbp)
    mcast_rules[1].local.port_end = 65535;
   115cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   115d2:	66 89 85 42 ff ff ff 	mov    %ax,-0xbe(%rbp)
    inet_pton(AF_INET, MCAST_GROUP, &mcast_rules[1].peer.addr);
   115d9:	e8 52 5d 00 00       	callq  17330 <__inet_pton>
    mcast_rules[1].peer.port_begin = pal_sec_info.mcast_port;
   115de:	41 0f b7 44 24 1c    	movzwl 0x1c(%r12),%eax
    if (flags & PAL_SANDBOX_PIPE) {
        char pipe_root[GRAPHENE_PIPEDIR_LEN + 20];
        char pipe_prefix[9];
        int sandboxid;

        snprintf(pipe_root,
   115e4:	4c 8d 8d 40 fe ff ff 	lea    -0x1c0(%rbp),%r9
   115eb:	41 8b 4c 24 08       	mov    0x8(%r12),%ecx
   115f0:	48 8d 15 d1 cf 00 00 	lea    0xcfd1(%rip),%rdx        # 1e5c8 <slab_levels+0x5328>
   115f7:	be 27 00 00 00       	mov    $0x27,%esi
   115fc:	4c 89 cf             	mov    %r9,%rdi
   115ff:	4c 89 8d f8 fd ff ff 	mov    %r9,-0x208(%rbp)

    mcast_rules[1].family = AF_INET;
    mcast_rules[1].local.port_begin = 0;
    mcast_rules[1].local.port_end = 65535;
    inet_pton(AF_INET, MCAST_GROUP, &mcast_rules[1].peer.addr);
    mcast_rules[1].peer.port_begin = pal_sec_info.mcast_port;
   11606:	66 89 85 54 ff ff ff 	mov    %ax,-0xac(%rbp)
    mcast_rules[1].peer.port_end = pal_sec_info.mcast_port;
   1160d:	66 89 85 56 ff ff ff 	mov    %ax,-0xaa(%rbp)
    if (flags & PAL_SANDBOX_PIPE) {
        char pipe_root[GRAPHENE_PIPEDIR_LEN + 20];
        char pipe_prefix[9];
        int sandboxid;

        snprintf(pipe_root,
   11614:	31 c0                	xor    %eax,%eax
   11616:	e8 95 78 ff ff       	callq  8eb0 <pal_snprintf>
                 GRAPHENE_PIPEDIR_LEN + 20, GRAPHENE_PIPEDIR "/%08x",
                 pal_sec_info.domain_id);

        getrand(&sandboxid, sizeof(int));
   1161b:	48 8d bd 1c fe ff ff 	lea    -0x1e4(%rbp),%rdi
   11622:	be 04 00 00 00       	mov    $0x4,%esi
   11627:	e8 e4 4e ff ff       	callq  6510 <getrand>
        snprintf(pipe_prefix, 9, "%08x", sandboxid);
   1162c:	48 8d 85 30 fe ff ff 	lea    -0x1d0(%rbp),%rax
   11633:	8b 8d 1c fe ff ff    	mov    -0x1e4(%rbp),%ecx
   11639:	48 8d 15 9c cf 00 00 	lea    0xcf9c(%rip),%rdx        # 1e5dc <slab_levels+0x533c>
   11640:	be 09 00 00 00       	mov    $0x9,%esi
   11645:	48 89 c7             	mov    %rax,%rdi
   11648:	48 89 85 08 fe ff ff 	mov    %rax,-0x1f8(%rbp)
   1164f:	31 c0                	xor    %eax,%eax
   11651:	e8 5a 78 ff ff       	callq  8eb0 <pal_snprintf>

        struct graphene_user_policy default_policies[] = {
   11656:	48 8b 85 08 fe ff ff 	mov    -0x1f8(%rbp),%rax
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[0], },
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[1], },
            manifest_policy,
        };

        ret = ioctl_set_graphene(&cfg, manifest_policy.type ? 5 : 4,
   1165d:	41 83 ff 01          	cmp    $0x1,%r15d
                 pal_sec_info.domain_id);

        getrand(&sandboxid, sizeof(int));
        snprintf(pipe_prefix, 9, "%08x", sandboxid);

        struct graphene_user_policy default_policies[] = {
   11661:	4c 8b 8d f8 fd ff ff 	mov    -0x208(%rbp),%r9
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[0], },
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[1], },
            manifest_policy,
        };

        ret = ioctl_set_graphene(&cfg, manifest_policy.type ? 5 : 4,
   11668:	19 f6                	sbb    %esi,%esi
                 pal_sec_info.domain_id);

        getrand(&sandboxid, sizeof(int));
        snprintf(pipe_prefix, 9, "%08x", sandboxid);

        struct graphene_user_policy default_policies[] = {
   1166a:	4d 8d 45 2c          	lea    0x2c(%r13),%r8
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[0], },
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[1], },
            manifest_policy,
        };

        ret = ioctl_set_graphene(&cfg, manifest_policy.type ? 5 : 4,
   1166e:	48 8d 95 b0 fe ff ff 	lea    -0x150(%rbp),%rdx
   11675:	83 c6 05             	add    $0x5,%esi
   11678:	4c 89 f7             	mov    %r14,%rdi
                 pal_sec_info.domain_id);

        getrand(&sandboxid, sizeof(int));
        snprintf(pipe_prefix, 9, "%08x", sandboxid);

        struct graphene_user_policy default_policies[] = {
   1167b:	44 89 bd f0 fe ff ff 	mov    %r15d,-0x110(%rbp)
   11682:	48 89 85 c8 fe ff ff 	mov    %rax,-0x138(%rbp)
   11689:	48 8b 85 00 fe ff ff 	mov    -0x200(%rbp),%rax
   11690:	c7 85 b0 fe ff ff 03 	movl   $0x3,-0x150(%rbp)
   11697:	00 00 00 
   1169a:	4c 89 8d b8 fe ff ff 	mov    %r9,-0x148(%rbp)
   116a1:	c7 85 c0 fe ff ff 04 	movl   $0x4,-0x140(%rbp)
   116a8:	00 00 00 
   116ab:	c7 85 d0 fe ff ff 05 	movl   $0x5,-0x130(%rbp)
   116b2:	00 00 00 
   116b5:	4c 89 ad d8 fe ff ff 	mov    %r13,-0x128(%rbp)
   116bc:	c7 85 e0 fe ff ff 05 	movl   $0x5,-0x120(%rbp)
   116c3:	00 00 00 
   116c6:	4c 89 85 e8 fe ff ff 	mov    %r8,-0x118(%rbp)
   116cd:	48 89 85 f8 fe ff ff 	mov    %rax,-0x108(%rbp)
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[0], },
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[1], },
            manifest_policy,
        };

        ret = ioctl_set_graphene(&cfg, manifest_policy.type ? 5 : 4,
   116d4:	e8 67 46 00 00       	callq  15d40 <ioctl_set_graphene>
                                 default_policies);
        if (ret < 0)
   116d9:	85 c0                	test   %eax,%eax
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[0], },
            { .type = GRAPHENE_NET_RULE,     .value = &mcast_rules[1], },
            manifest_policy,
        };

        ret = ioctl_set_graphene(&cfg, manifest_policy.type ? 5 : 4,
   116db:	41 89 c7             	mov    %eax,%r15d
                                 default_policies);
        if (ret < 0)
   116de:	78 3f                	js     1171f <set_graphene_task+0x32f>
            goto out_mem;

        pal_sec_info.pipe_prefix = remalloc(pipe_prefix, 9);
   116e0:	48 8b bd 08 fe ff ff 	mov    -0x1f8(%rbp),%rdi
   116e7:	be 09 00 00 00       	mov    $0x9,%esi
   116ec:	e8 0f 75 ff ff       	callq  8c00 <remalloc>
   116f1:	49 89 44 24 10       	mov    %rax,0x10(%r12)
                                 default_policies);
        if (ret < 0)
            goto out_mem;
    }

    pal_config.manifest = manifest;
   116f6:	4c 8b 25 23 23 21 00 	mov    0x212323(%rip),%r12        # 223a20 <_DYNAMIC+0x238>
    _DkObjectClose(pal_config.manifest_handle);
   116fd:	49 8b 7c 24 10       	mov    0x10(%r12),%rdi
                                 default_policies);
        if (ret < 0)
            goto out_mem;
    }

    pal_config.manifest = manifest;
   11702:	49 89 1c 24          	mov    %rbx,(%r12)
    _DkObjectClose(pal_config.manifest_handle);
   11706:	e8 35 41 ff ff       	callq  5840 <_DkObjectClose>
    pal_config.manifest_handle = handle;
   1170b:	48 8b 85 20 fe ff ff 	mov    -0x1e0(%rbp),%rax

    free_config(&cfg);
   11712:	4c 89 f7             	mov    %r14,%rdi
            goto out_mem;
    }

    pal_config.manifest = manifest;
    _DkObjectClose(pal_config.manifest_handle);
    pal_config.manifest_handle = handle;
   11715:	49 89 44 24 10       	mov    %rax,0x10(%r12)

    free_config(&cfg);
   1171a:	e8 61 6d 00 00       	callq  18480 <free_config>
out_mem:
    _DkStreamUnmap(cfg.raw_data, ALLOC_ALIGNUP(cfg.raw_size));
   1171f:	48 8b 05 6a 22 21 00 	mov    0x21226a(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
   11726:	48 8b b5 98 fe ff ff 	mov    -0x168(%rbp),%rsi
   1172d:	48 83 38 00          	cmpq   $0x0,(%rax)
   11731:	74 14                	je     11747 <set_graphene_task+0x357>
   11733:	48 8b 05 0e 24 21 00 	mov    0x21240e(%rip),%rax        # 223b48 <_DYNAMIC+0x360>
   1173a:	48 03 30             	add    (%rax),%rsi
   1173d:	48 8b 05 b4 23 21 00 	mov    0x2123b4(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
   11744:	48 23 30             	and    (%rax),%rsi
   11747:	48 8b bd 90 fe ff ff 	mov    -0x170(%rbp),%rdi
   1174e:	e8 ad e0 ff ff       	callq  f800 <_DkStreamUnmap>
out:
    DkObjectClose(handle);
   11753:	48 8b bd 20 fe ff ff 	mov    -0x1e0(%rbp),%rdi
   1175a:	e8 11 1a ff ff       	callq  3170 <DkObjectClose@plt>
    return ret;
   1175f:	44 89 f8             	mov    %r15d,%eax
}
   11762:	48 81 c4 e8 01 00 00 	add    $0x1e8,%rsp
   11769:	5b                   	pop    %rbx
   1176a:	41 5c                	pop    %r12
   1176c:	41 5d                	pop    %r13
   1176e:	41 5e                	pop    %r14
   11770:	41 5f                	pop    %r15
   11772:	5d                   	pop    %rbp
   11773:	c3                   	retq   
            getrand(&pal_sec_info.mcast_port, sizeof(unsigned short));
        } while (pal_sec_info.mcast_port < 1024);
    }

    struct graphene_net_policy mcast_rules[2];
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);
   11774:	4c 8d a5 00 ff ff ff 	lea    -0x100(%rbp),%r12
   1177b:	31 f6                	xor    %esi,%esi
   1177d:	ba 58 00 00 00       	mov    $0x58,%edx
   11782:	4c 89 e7             	mov    %r12,%rdi
   11785:	e8 16 4a 00 00       	callq  161a0 <memset>

    mcast_rules[0].family = AF_INET;
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
   1178a:	4c 8b 2d 17 23 21 00 	mov    0x212317(%rip),%r13        # 223aa8 <_DYNAMIC+0x2c0>
    }

    struct graphene_net_policy mcast_rules[2];
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);

    mcast_rules[0].family = AF_INET;
   11791:	b8 02 00 00 00       	mov    $0x2,%eax
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
    mcast_rules[0].peer.port_begin = 0;
   11796:	31 d2                	xor    %edx,%edx
    }

    struct graphene_net_policy mcast_rules[2];
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);

    mcast_rules[0].family = AF_INET;
   11798:	66 89 85 00 ff ff ff 	mov    %ax,-0x100(%rbp)
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
    mcast_rules[0].peer.port_begin = 0;
    mcast_rules[0].peer.port_end = 65535;

    mcast_rules[1].family = AF_INET;
   1179f:	be 02 00 00 00       	mov    $0x2,%esi
    mcast_rules[1].local.port_begin = 0;
   117a4:	31 ff                	xor    %edi,%edi
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);

    mcast_rules[0].family = AF_INET;
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
    mcast_rules[0].peer.port_begin = 0;
   117a6:	66 89 95 28 ff ff ff 	mov    %dx,-0xd8(%rbp)
    mcast_rules[0].peer.port_end = 65535;

    mcast_rules[1].family = AF_INET;
   117ad:	66 89 b5 2c ff ff ff 	mov    %si,-0xd4(%rbp)
    mcast_rules[1].local.port_begin = 0;
    mcast_rules[1].local.port_end = 65535;
    inet_pton(AF_INET, MCAST_GROUP, &mcast_rules[1].peer.addr);
   117b4:	49 8d 54 24 44       	lea    0x44(%r12),%rdx

    struct graphene_net_policy mcast_rules[2];
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);

    mcast_rules[0].family = AF_INET;
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
   117b9:	41 0f b7 45 1c       	movzwl 0x1c(%r13),%eax
    mcast_rules[0].peer.port_end = 65535;

    mcast_rules[1].family = AF_INET;
    mcast_rules[1].local.port_begin = 0;
    mcast_rules[1].local.port_end = 65535;
    inet_pton(AF_INET, MCAST_GROUP, &mcast_rules[1].peer.addr);
   117be:	48 8d 35 ff 98 00 00 	lea    0x98ff(%rip),%rsi        # 1b0c4 <slab_levels+0x1e24>

    mcast_rules[0].family = AF_INET;
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
    mcast_rules[0].peer.port_begin = 0;
    mcast_rules[0].peer.port_end = 65535;
   117c5:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx

    mcast_rules[1].family = AF_INET;
    mcast_rules[1].local.port_begin = 0;
    mcast_rules[1].local.port_end = 65535;
   117ca:	41 b8 ff ff ff ff    	mov    $0xffffffff,%r8d
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
    mcast_rules[0].peer.port_begin = 0;
    mcast_rules[0].peer.port_end = 65535;

    mcast_rules[1].family = AF_INET;
    mcast_rules[1].local.port_begin = 0;
   117d0:	66 89 bd 40 ff ff ff 	mov    %di,-0xc0(%rbp)
    mcast_rules[1].local.port_end = 65535;
    inet_pton(AF_INET, MCAST_GROUP, &mcast_rules[1].peer.addr);
   117d7:	bf 02 00 00 00       	mov    $0x2,%edi

    mcast_rules[0].family = AF_INET;
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
    mcast_rules[0].peer.port_begin = 0;
    mcast_rules[0].peer.port_end = 65535;
   117dc:	66 89 8d 2a ff ff ff 	mov    %cx,-0xd6(%rbp)

    mcast_rules[1].family = AF_INET;
    mcast_rules[1].local.port_begin = 0;
    mcast_rules[1].local.port_end = 65535;
   117e3:	66 44 89 85 42 ff ff 	mov    %r8w,-0xbe(%rbp)
   117ea:	ff 

    struct graphene_net_policy mcast_rules[2];
    memset(mcast_rules, 0, sizeof(struct graphene_net_policy) * 2);

    mcast_rules[0].family = AF_INET;
    mcast_rules[0].local.port_begin = pal_sec_info.mcast_port;
   117eb:	66 89 85 14 ff ff ff 	mov    %ax,-0xec(%rbp)
    mcast_rules[0].local.port_end = pal_sec_info.mcast_port;
   117f2:	66 89 85 16 ff ff ff 	mov    %ax,-0xea(%rbp)
    mcast_rules[0].peer.port_end = 65535;

    mcast_rules[1].family = AF_INET;
    mcast_rules[1].local.port_begin = 0;
    mcast_rules[1].local.port_end = 65535;
    inet_pton(AF_INET, MCAST_GROUP, &mcast_rules[1].peer.addr);
   117f9:	e8 32 5b 00 00       	callq  17330 <__inet_pton>
    mcast_rules[1].peer.port_begin = pal_sec_info.mcast_port;
   117fe:	41 0f b7 45 1c       	movzwl 0x1c(%r13),%eax
        if (ret < 0)
            goto out_mem;

        pal_sec_info.pipe_prefix = remalloc(pipe_prefix, 9);
    } else {
        const struct graphene_user_policy default_policies[] = {
   11803:	4c 89 a5 b8 fe ff ff 	mov    %r12,-0x148(%rbp)
   1180a:	49 83 c4 2c          	add    $0x2c,%r12
            { .type = GRAPHENE_NET_RULE,    .value = &mcast_rules[0], },
            { .type = GRAPHENE_NET_RULE,    .value = &mcast_rules[1], },
            manifest_policy,
        };

        ret = ioctl_set_graphene(&cfg, manifest_policy.type ? 3 : 2,
   1180e:	41 83 ff 01          	cmp    $0x1,%r15d
   11812:	48 8d 95 b0 fe ff ff 	lea    -0x150(%rbp),%rdx
   11819:	4c 89 f7             	mov    %r14,%rdi
   1181c:	19 f6                	sbb    %esi,%esi
        if (ret < 0)
            goto out_mem;

        pal_sec_info.pipe_prefix = remalloc(pipe_prefix, 9);
    } else {
        const struct graphene_user_policy default_policies[] = {
   1181e:	44 89 bd d0 fe ff ff 	mov    %r15d,-0x130(%rbp)
   11825:	c7 85 b0 fe ff ff 05 	movl   $0x5,-0x150(%rbp)
   1182c:	00 00 00 
            { .type = GRAPHENE_NET_RULE,    .value = &mcast_rules[0], },
            { .type = GRAPHENE_NET_RULE,    .value = &mcast_rules[1], },
            manifest_policy,
        };

        ret = ioctl_set_graphene(&cfg, manifest_policy.type ? 3 : 2,
   1182f:	83 c6 03             	add    $0x3,%esi
        if (ret < 0)
            goto out_mem;

        pal_sec_info.pipe_prefix = remalloc(pipe_prefix, 9);
    } else {
        const struct graphene_user_policy default_policies[] = {
   11832:	c7 85 c0 fe ff ff 05 	movl   $0x5,-0x140(%rbp)
   11839:	00 00 00 
   1183c:	4c 89 a5 c8 fe ff ff 	mov    %r12,-0x138(%rbp)

    mcast_rules[1].family = AF_INET;
    mcast_rules[1].local.port_begin = 0;
    mcast_rules[1].local.port_end = 65535;
    inet_pton(AF_INET, MCAST_GROUP, &mcast_rules[1].peer.addr);
    mcast_rules[1].peer.port_begin = pal_sec_info.mcast_port;
   11843:	66 89 85 54 ff ff ff 	mov    %ax,-0xac(%rbp)
    mcast_rules[1].peer.port_end = pal_sec_info.mcast_port;
   1184a:	66 89 85 56 ff ff ff 	mov    %ax,-0xaa(%rbp)
        if (ret < 0)
            goto out_mem;

        pal_sec_info.pipe_prefix = remalloc(pipe_prefix, 9);
    } else {
        const struct graphene_user_policy default_policies[] = {
   11851:	48 8b 85 00 fe ff ff 	mov    -0x200(%rbp),%rax
   11858:	48 89 85 d8 fe ff ff 	mov    %rax,-0x128(%rbp)
            { .type = GRAPHENE_NET_RULE,    .value = &mcast_rules[0], },
            { .type = GRAPHENE_NET_RULE,    .value = &mcast_rules[1], },
            manifest_policy,
        };

        ret = ioctl_set_graphene(&cfg, manifest_policy.type ? 3 : 2,
   1185f:	e8 dc 44 00 00       	callq  15d40 <ioctl_set_graphene>
                                 default_policies);
        if (ret < 0)
   11864:	85 c0                	test   %eax,%eax
            { .type = GRAPHENE_NET_RULE,    .value = &mcast_rules[0], },
            { .type = GRAPHENE_NET_RULE,    .value = &mcast_rules[1], },
            manifest_policy,
        };

        ret = ioctl_set_graphene(&cfg, manifest_policy.type ? 3 : 2,
   11866:	41 89 c7             	mov    %eax,%r15d
                                 default_policies);
        if (ret < 0)
   11869:	0f 89 87 fe ff ff    	jns    116f6 <set_graphene_task+0x306>
   1186f:	e9 ab fe ff ff       	jmpq   1171f <set_graphene_task+0x32f>
   11874:	66 66 66 2e 0f 1f 84 	nopw   %cs:0x0(%rax,%rax,1)
   1187b:	00 00 00 00 00 

0000000000011880 <read_child_args.constprop.0>:
    }

    return ret;
}

static void read_child_args (const char * val, int vlen,
   11880:	55                   	push   %rbp
   11881:	48 89 e5             	mov    %rsp,%rbp
   11884:	41 57                	push   %r15
   11886:	41 56                	push   %r14
   11888:	41 55                	push   %r13
   1188a:	41 54                	push   %r12
                             void * arg3, bool isnum3,
                             void * arg4, bool isnum4)
{
    const char * v1 = val, * v2 = v1, * end = val + vlen;
    void * arg[4] = { arg1, arg2, arg3, arg4 };
    bool isnum[4] = { isnum1, isnum2, isnum3, isnum4 };
   1188c:	49 89 d6             	mov    %rdx,%r14
    }

    return ret;
}

static void read_child_args (const char * val, int vlen,
   1188f:	53                   	push   %rbx
                             void * arg1, bool isnum1,
                             void * arg2, bool isnum2,
                             void * arg3, bool isnum3,
                             void * arg4, bool isnum4)
{
    const char * v1 = val, * v2 = v1, * end = val + vlen;
   11890:	4c 63 e6             	movslq %esi,%r12
    void * arg[4] = { arg1, arg2, arg3, arg4 };
    bool isnum[4] = { isnum1, isnum2, isnum3, isnum4 };
   11893:	45 31 ed             	xor    %r13d,%r13d
                             void * arg1, bool isnum1,
                             void * arg2, bool isnum2,
                             void * arg3, bool isnum3,
                             void * arg4, bool isnum4)
{
    const char * v1 = val, * v2 = v1, * end = val + vlen;
   11896:	49 01 fc             	add    %rdi,%r12
   11899:	48 89 fb             	mov    %rdi,%rbx
    }

    return ret;
}

static void read_child_args (const char * val, int vlen,
   1189c:	48 83 ec 38          	sub    $0x38,%rsp
                             void * arg2, bool isnum2,
                             void * arg3, bool isnum3,
                             void * arg4, bool isnum4)
{
    const char * v1 = val, * v2 = v1, * end = val + vlen;
    void * arg[4] = { arg1, arg2, arg3, arg4 };
   118a0:	48 8b 45 18          	mov    0x18(%rbp),%rax
    bool isnum[4] = { isnum1, isnum2, isnum3, isnum4 };

    for (int i = 0 ; i < 4 ; i++) {
        if (!arg[i])
   118a4:	4d 85 f6             	test   %r14,%r14
                             void * arg2, bool isnum2,
                             void * arg3, bool isnum3,
                             void * arg4, bool isnum4)
{
    const char * v1 = val, * v2 = v1, * end = val + vlen;
    void * arg[4] = { arg1, arg2, arg3, arg4 };
   118a7:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
   118ab:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
   118af:	4c 89 4d c0          	mov    %r9,-0x40(%rbp)
    bool isnum[4] = { isnum1, isnum2, isnum3, isnum4 };
   118b3:	c6 45 a0 01          	movb   $0x1,-0x60(%rbp)
                             void * arg2, bool isnum2,
                             void * arg3, bool isnum3,
                             void * arg4, bool isnum4)
{
    const char * v1 = val, * v2 = v1, * end = val + vlen;
    void * arg[4] = { arg1, arg2, arg3, arg4 };
   118b7:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    bool isnum[4] = { isnum1, isnum2, isnum3, isnum4 };
   118bb:	8b 45 10             	mov    0x10(%rbp),%eax
   118be:	44 88 45 a1          	mov    %r8b,-0x5f(%rbp)
   118c2:	88 45 a2             	mov    %al,-0x5e(%rbp)
   118c5:	8b 45 20             	mov    0x20(%rbp),%eax
   118c8:	88 45 a3             	mov    %al,-0x5d(%rbp)

    for (int i = 0 ; i < 4 ; i++) {
        if (!arg[i])
   118cb:	74 53                	je     11920 <read_child_args.constprop.0+0xa0>
            return;

        while (v2 < end && *v2 != ',')
   118cd:	49 39 dc             	cmp    %rbx,%r12
   118d0:	77 0b                	ja     118dd <read_child_args.constprop.0+0x5d>
   118d2:	eb 0e                	jmp    118e2 <read_child_args.constprop.0+0x62>
            v2++;
   118d4:	48 83 c3 01          	add    $0x1,%rbx

    for (int i = 0 ; i < 4 ; i++) {
        if (!arg[i])
            return;

        while (v2 < end && *v2 != ',')
   118d8:	4c 39 e3             	cmp    %r12,%rbx
   118db:	74 05                	je     118e2 <read_child_args.constprop.0+0x62>
   118dd:	80 3b 2c             	cmpb   $0x2c,(%rbx)
   118e0:	75 f2                	jne    118d4 <read_child_args.constprop.0+0x54>
            v2++;

        if (v1 >= end || v2 <= v1) {
   118e2:	48 39 fb             	cmp    %rdi,%rbx
   118e5:	76 49                	jbe    11930 <read_child_args.constprop.0+0xb0>
   118e7:	49 39 fc             	cmp    %rdi,%r12
   118ea:	76 44                	jbe    11930 <read_child_args.constprop.0+0xb0>
            else
                ((char *) arg[i])[0] = 0;
            continue;
        }

        if (isnum[i]) {
   118ec:	42 80 7c 2d a0 00    	cmpb   $0x0,-0x60(%rbp,%r13,1)
   118f2:	74 4d                	je     11941 <read_child_args.constprop.0+0xc1>
            *(int *) arg[i] = atoi(v1);
   118f4:	e8 f7 4f 00 00       	callq  168f0 <atoi>
   118f9:	41 89 06             	mov    %eax,(%r14)
        } else {
            memcpy((char *) arg[i], v1, v2 - v1);
            ((char *) arg[i])[v2 - v1] = 0;
        }

        v2 = v1 = v2 + 1;
   118fc:	48 8d 7b 01          	lea    0x1(%rbx),%rdi
   11900:	48 89 fb             	mov    %rdi,%rbx
   11903:	49 83 c5 01          	add    $0x1,%r13
{
    const char * v1 = val, * v2 = v1, * end = val + vlen;
    void * arg[4] = { arg1, arg2, arg3, arg4 };
    bool isnum[4] = { isnum1, isnum2, isnum3, isnum4 };

    for (int i = 0 ; i < 4 ; i++) {
   11907:	49 83 fd 04          	cmp    $0x4,%r13
   1190b:	74 13                	je     11920 <read_child_args.constprop.0+0xa0>
   1190d:	4e 8b 74 ed b0       	mov    -0x50(%rbp,%r13,8),%r14
        if (!arg[i])
   11912:	4d 85 f6             	test   %r14,%r14
   11915:	75 b6                	jne    118cd <read_child_args.constprop.0+0x4d>
   11917:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1191e:	00 00 
            ((char *) arg[i])[v2 - v1] = 0;
        }

        v2 = v1 = v2 + 1;
    }
}
   11920:	48 83 c4 38          	add    $0x38,%rsp
   11924:	5b                   	pop    %rbx
   11925:	41 5c                	pop    %r12
   11927:	41 5d                	pop    %r13
   11929:	41 5e                	pop    %r14
   1192b:	41 5f                	pop    %r15
   1192d:	5d                   	pop    %rbp
   1192e:	c3                   	retq   
   1192f:	90                   	nop    

        while (v2 < end && *v2 != ',')
            v2++;

        if (v1 >= end || v2 <= v1) {
            if (isnum[i])
   11930:	42 80 7c 2d a0 00    	cmpb   $0x0,-0x60(%rbp,%r13,1)
   11936:	74 29                	je     11961 <read_child_args.constprop.0+0xe1>
                *(int *) arg[i] = 0;
   11938:	41 c7 06 00 00 00 00 	movl   $0x0,(%r14)
   1193f:	eb c2                	jmp    11903 <read_child_args.constprop.0+0x83>
        }

        if (isnum[i]) {
            *(int *) arg[i] = atoi(v1);
        } else {
            memcpy((char *) arg[i], v1, v2 - v1);
   11941:	49 89 df             	mov    %rbx,%r15
   11944:	48 89 fe             	mov    %rdi,%rsi
   11947:	49 29 ff             	sub    %rdi,%r15
   1194a:	4c 89 f7             	mov    %r14,%rdi
   1194d:	4c 89 fa             	mov    %r15,%rdx
   11950:	e8 2b 49 00 00       	callq  16280 <memcpy>
            ((char *) arg[i])[v2 - v1] = 0;
   11955:	4a 8b 44 ed b0       	mov    -0x50(%rbp,%r13,8),%rax
   1195a:	42 c6 04 38 00       	movb   $0x0,(%rax,%r15,1)
   1195f:	eb 9b                	jmp    118fc <read_child_args.constprop.0+0x7c>

        if (v1 >= end || v2 <= v1) {
            if (isnum[i])
                *(int *) arg[i] = 0;
            else
                ((char *) arg[i])[0] = 0;
   11961:	41 c6 06 00          	movb   $0x0,(%r14)
   11965:	eb 9c                	jmp    11903 <read_child_args.constprop.0+0x83>
   11967:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1196e:	00 00 

0000000000011970 <read_child_handle>:

#define STRARG_SIZE     256

static void read_child_handle (const char * val, int vlen,
                               PAL_HANDLE * handle, const char ** uri)
{
   11970:	55                   	push   %rbp
    int fd;
    char buf[STRARG_SIZE];
    read_child_args(val, vlen, &fd, true, buf, false,
   11971:	45 31 c9             	xor    %r9d,%r9d
   11974:	45 31 c0             	xor    %r8d,%r8d

#define STRARG_SIZE     256

static void read_child_handle (const char * val, int vlen,
                               PAL_HANDLE * handle, const char ** uri)
{
   11977:	48 89 e5             	mov    %rsp,%rbp
   1197a:	41 57                	push   %r15
   1197c:	41 56                	push   %r14
   1197e:	41 55                	push   %r13
   11980:	41 54                	push   %r12
    int fd;
    char buf[STRARG_SIZE];
    read_child_args(val, vlen, &fd, true, buf, false,
   11982:	4c 8d a5 d0 fe ff ff 	lea    -0x130(%rbp),%r12

#define STRARG_SIZE     256

static void read_child_handle (const char * val, int vlen,
                               PAL_HANDLE * handle, const char ** uri)
{
   11989:	53                   	push   %rbx
   1198a:	49 89 d6             	mov    %rdx,%r14
    int fd;
    char buf[STRARG_SIZE];
    read_child_args(val, vlen, &fd, true, buf, false,
   1198d:	48 8d 95 cc fe ff ff 	lea    -0x134(%rbp),%rdx

#define STRARG_SIZE     256

static void read_child_handle (const char * val, int vlen,
                               PAL_HANDLE * handle, const char ** uri)
{
   11994:	49 89 cd             	mov    %rcx,%r13
    int fd;
    char buf[STRARG_SIZE];
    read_child_args(val, vlen, &fd, true, buf, false,
   11997:	4c 89 e1             	mov    %r12,%rcx

#define STRARG_SIZE     256

static void read_child_handle (const char * val, int vlen,
                               PAL_HANDLE * handle, const char ** uri)
{
   1199a:	48 81 ec 30 01 00 00 	sub    $0x130,%rsp
    int fd;
    char buf[STRARG_SIZE];
    read_child_args(val, vlen, &fd, true, buf, false,
   119a1:	6a 00                	pushq  $0x0
   119a3:	6a 00                	pushq  $0x0
   119a5:	6a 00                	pushq  $0x0
   119a7:	e8 d4 fe ff ff       	callq  11880 <read_child_args.constprop.0>
                    NULL, false, NULL, false);

    if (!fd || !set_fd_cloexec(fd)) {
   119ac:	48 63 bd cc fe ff ff 	movslq -0x134(%rbp),%rdi
   119b3:	48 83 c4 20          	add    $0x20,%rsp
   119b7:	85 ff                	test   %edi,%edi
   119b9:	0f 84 b1 00 00 00    	je     11a70 <read_child_handle+0x100>
    }
}

static inline bool set_fd_cloexec (int fd)
{
    return !(IS_ERR(INLINE_SYSCALL(fcntl, 3, fd, F_SETFD, FD_CLOEXEC)));
   119bf:	bb 5c 00 00 00       	mov    $0x5c,%ebx
   119c4:	ba 01 00 00 00       	mov    $0x1,%edx
   119c9:	be 02 00 00 00       	mov    $0x2,%esi
   119ce:	89 d8                	mov    %ebx,%eax
   119d0:	cd 80                	int    $0x80
   119d2:	48 89 c2             	mov    %rax,%rdx
   119d5:	bb 00 00 00 00       	mov    $0x0,%ebx
   119da:	83 d3 00             	adc    $0x0,%ebx
   119dd:	31 c9                	xor    %ecx,%ecx
   119df:	85 db                	test   %ebx,%ebx
   119e1:	0f 95 c1             	setne  %cl
   119e4:	48 89 c8             	mov    %rcx,%rax
   119e7:	48 f7 d8             	neg    %rax
   119ea:	48 31 d0             	xor    %rdx,%rax
    int fd;
    char buf[STRARG_SIZE];
    read_child_args(val, vlen, &fd, true, buf, false,
                    NULL, false, NULL, false);

    if (!fd || !set_fd_cloexec(fd)) {
   119ed:	48 01 c8             	add    %rcx,%rax
   119f0:	78 7e                	js     11a70 <read_child_handle+0x100>
        *handle = NULL;
        *uri = NULL;
        return;
    }

    INLINE_SYSCALL(lseek, 3, fd, 0, SEEK_SET);
   119f2:	48 63 bd cc fe ff ff 	movslq -0x134(%rbp),%rdi
   119f9:	31 d2                	xor    %edx,%edx
   119fb:	40 30 f6             	xor    %sil,%sil
   119fe:	b8 de 01 00 00       	mov    $0x1de,%eax
   11a03:	cd 80                	int    $0x80
   11a05:	bb 00 00 00 00       	mov    $0x0,%ebx
   11a0a:	83 d3 00             	adc    $0x0,%ebx

    int len = strlen(buf);
   11a0d:	4c 89 e7             	mov    %r12,%rdi
   11a10:	e8 8b 4d 00 00       	callq  167a0 <strlen>
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + (len > 4 ? len - 4 : 0));
   11a15:	83 f8 04             	cmp    $0x4,%eax
        return;
    }

    INLINE_SYSCALL(lseek, 3, fd, 0, SEEK_SET);

    int len = strlen(buf);
   11a18:	48 89 c3             	mov    %rax,%rbx
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + (len > 4 ? len - 4 : 0));
   11a1b:	7f 73                	jg     11a90 <read_child_handle+0x120>
   11a1d:	bf 28 00 00 00       	mov    $0x28,%edi
   11a22:	e8 d9 6f ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, file);
   11a27:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    hdl->file.fd = fd;
   11a2d:	8b 95 cc fe ff ff    	mov    -0x134(%rbp),%edx
        hdl->file.realpath = path;
    } else {
        hdl->file.realpath = NULL;
    }
    *handle = hdl;
    *uri = len ? remalloc(buf, len + 1) : NULL;
   11a33:	85 db                	test   %ebx,%ebx

    INLINE_SYSCALL(lseek, 3, fd, 0, SEEK_SET);

    int len = strlen(buf);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + (len > 4 ? len - 4 : 0));
    SET_HANDLE_TYPE(hdl, file);
   11a35:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
   11a3c:	c7 40 08 49 00 00 00 	movl   $0x49,0x8(%rax)
    if (len > 4) {
        char * path = (void *) hdl + HANDLE_SIZE(file);
        memcpy(path, buf + 5, len - 4);
        hdl->file.realpath = path;
    } else {
        hdl->file.realpath = NULL;
   11a43:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
   11a4a:	00 

    int len = strlen(buf);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + (len > 4 ? len - 4 : 0));
    SET_HANDLE_TYPE(hdl, file);
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    hdl->file.fd = fd;
   11a4b:	89 50 0c             	mov    %edx,0xc(%rax)
        memcpy(path, buf + 5, len - 4);
        hdl->file.realpath = path;
    } else {
        hdl->file.realpath = NULL;
    }
    *handle = hdl;
   11a4e:	49 89 06             	mov    %rax,(%r14)
    *uri = len ? remalloc(buf, len + 1) : NULL;
   11a51:	0f 85 98 00 00 00    	jne    11aef <read_child_handle+0x17f>
   11a57:	31 c0                	xor    %eax,%eax
   11a59:	49 89 45 00          	mov    %rax,0x0(%r13)
}
   11a5d:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   11a61:	5b                   	pop    %rbx
   11a62:	41 5c                	pop    %r12
   11a64:	41 5d                	pop    %r13
   11a66:	41 5e                	pop    %r14
   11a68:	41 5f                	pop    %r15
   11a6a:	5d                   	pop    %rbp
   11a6b:	c3                   	retq   
   11a6c:	0f 1f 40 00          	nopl   0x0(%rax)
    char buf[STRARG_SIZE];
    read_child_args(val, vlen, &fd, true, buf, false,
                    NULL, false, NULL, false);

    if (!fd || !set_fd_cloexec(fd)) {
        *handle = NULL;
   11a70:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
        *uri = NULL;
   11a77:	49 c7 45 00 00 00 00 	movq   $0x0,0x0(%r13)
   11a7e:	00 
    } else {
        hdl->file.realpath = NULL;
    }
    *handle = hdl;
    *uri = len ? remalloc(buf, len + 1) : NULL;
}
   11a7f:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   11a83:	5b                   	pop    %rbx
   11a84:	41 5c                	pop    %r12
   11a86:	41 5d                	pop    %r13
   11a88:	41 5e                	pop    %r14
   11a8a:	41 5f                	pop    %r15
   11a8c:	5d                   	pop    %rbp
   11a8d:	c3                   	retq   
   11a8e:	66 90                	xchg   %ax,%ax
    }

    INLINE_SYSCALL(lseek, 3, fd, 0, SEEK_SET);

    int len = strlen(buf);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + (len > 4 ? len - 4 : 0));
   11a90:	8d 40 fc             	lea    -0x4(%rax),%eax
   11a93:	8d 7b 24             	lea    0x24(%rbx),%edi
   11a96:	89 85 b8 fe ff ff    	mov    %eax,-0x148(%rbp)
   11a9c:	e8 5f 6f ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, file);
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    hdl->file.fd = fd;
    if (len > 4) {
        char * path = (void *) hdl + HANDLE_SIZE(file);
        memcpy(path, buf + 5, len - 4);
   11aa1:	48 63 95 b8 fe ff ff 	movslq -0x148(%rbp),%rdx
    }

    INLINE_SYSCALL(lseek, 3, fd, 0, SEEK_SET);

    int len = strlen(buf);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + (len > 4 ? len - 4 : 0));
   11aa8:	49 89 c7             	mov    %rax,%r15
    SET_HANDLE_TYPE(hdl, file);
   11aab:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
   11ab1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
   11ab8:	c7 40 08 49 00 00 00 	movl   $0x49,0x8(%rax)
    hdl->file.fd = fd;
    if (len > 4) {
        char * path = (void *) hdl + HANDLE_SIZE(file);
   11abf:	4d 8d 47 28          	lea    0x28(%r15),%r8

    int len = strlen(buf);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + (len > 4 ? len - 4 : 0));
    SET_HANDLE_TYPE(hdl, file);
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    hdl->file.fd = fd;
   11ac3:	8b 85 cc fe ff ff    	mov    -0x134(%rbp),%eax
    if (len > 4) {
        char * path = (void *) hdl + HANDLE_SIZE(file);
        memcpy(path, buf + 5, len - 4);
   11ac9:	49 8d 74 24 05       	lea    0x5(%r12),%rsi
   11ace:	4c 89 c7             	mov    %r8,%rdi
   11ad1:	4c 89 85 b8 fe ff ff 	mov    %r8,-0x148(%rbp)

    int len = strlen(buf);
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(file) + (len > 4 ? len - 4 : 0));
    SET_HANDLE_TYPE(hdl, file);
    hdl->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    hdl->file.fd = fd;
   11ad8:	41 89 47 0c          	mov    %eax,0xc(%r15)
    if (len > 4) {
        char * path = (void *) hdl + HANDLE_SIZE(file);
        memcpy(path, buf + 5, len - 4);
   11adc:	e8 9f 47 00 00       	callq  16280 <memcpy>
        hdl->file.realpath = path;
   11ae1:	4c 8b 85 b8 fe ff ff 	mov    -0x148(%rbp),%r8
   11ae8:	4d 89 47 20          	mov    %r8,0x20(%r15)
    } else {
        hdl->file.realpath = NULL;
    }
    *handle = hdl;
   11aec:	4d 89 3e             	mov    %r15,(%r14)
    *uri = len ? remalloc(buf, len + 1) : NULL;
   11aef:	8d 73 01             	lea    0x1(%rbx),%esi
   11af2:	4c 89 e7             	mov    %r12,%rdi
   11af5:	e8 06 71 ff ff       	callq  8c00 <remalloc>
   11afa:	e9 5a ff ff ff       	jmpq   11a59 <read_child_handle+0xe9>
   11aff:	90                   	nop    

0000000000011b00 <_DkProcessCreate>:
# define SEEK_SET 0
#endif

int _DkProcessCreate (PAL_HANDLE * handle, const char * uri,
                      int flags, const char ** args)
{
   11b00:	55                   	push   %rbp
   11b01:	48 89 e5             	mov    %rsp,%rbp
   11b04:	41 57                	push   %r15
   11b06:	41 56                	push   %r14
   11b08:	41 55                	push   %r13
   11b0a:	41 54                	push   %r12
   11b0c:	49 89 cd             	mov    %rcx,%r13
   11b0f:	53                   	push   %rbx
   11b10:	49 89 f4             	mov    %rsi,%r12
   11b13:	48 81 ec 88 00 00 00 	sub    $0x88,%rsp
    int ret, rete = 0;

    const char * manifest_uri   = pal_config.manifest;
   11b1a:	48 8b 05 ff 1e 21 00 	mov    0x211eff(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
    PAL_HANDLE   manifest       = pal_config.manifest_handle;
    const char * exec_uri       = NULL;
    PAL_HANDLE   exec           = NULL;
    bool         noexec         = false;

    if (uri) {
   11b21:	48 85 f6             	test   %rsi,%rsi
# define SEEK_SET 0
#endif

int _DkProcessCreate (PAL_HANDLE * handle, const char * uri,
                      int flags, const char ** args)
{
   11b24:	48 89 bd 70 ff ff ff 	mov    %rdi,-0x90(%rbp)
    int ret, rete = 0;

    const char * manifest_uri   = pal_config.manifest;
    PAL_HANDLE   manifest       = pal_config.manifest_handle;
    const char * exec_uri       = NULL;
    PAL_HANDLE   exec           = NULL;
   11b2b:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
   11b32:	00 
int _DkProcessCreate (PAL_HANDLE * handle, const char * uri,
                      int flags, const char ** args)
{
    int ret, rete = 0;

    const char * manifest_uri   = pal_config.manifest;
   11b33:	4c 8b 38             	mov    (%rax),%r15
    PAL_HANDLE   manifest       = pal_config.manifest_handle;
   11b36:	4c 8b 70 10          	mov    0x10(%rax),%r14
    const char * exec_uri       = NULL;
    PAL_HANDLE   exec           = NULL;
    bool         noexec         = false;

    if (uri) {
   11b3a:	0f 84 b0 04 00 00    	je     11ff0 <_DkProcessCreate+0x4f0>
        exec_uri = uri;
        if ((ret = _DkStreamOpen(&exec, uri, PAL_ACCESS_RDONLY, 0, 0, 0)) < 0)
   11b40:	48 8d 7d 88          	lea    -0x78(%rbp),%rdi
   11b44:	45 31 c9             	xor    %r9d,%r9d
   11b47:	45 31 c0             	xor    %r8d,%r8d
   11b4a:	31 c9                	xor    %ecx,%ecx
   11b4c:	31 d2                	xor    %edx,%edx
   11b4e:	e8 dd 1d ff ff       	callq  3930 <_DkStreamOpen>
   11b53:	85 c0                	test   %eax,%eax
   11b55:	0f 88 30 04 00 00    	js     11f8b <_DkProcessCreate+0x48b>
            return ret;

        if (check_elf_object(exec) < 0) {
   11b5b:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
   11b5f:	e8 cc 5b ff ff       	callq  7730 <check_elf_object>
   11b64:	85 c0                	test   %eax,%eax

    const char * manifest_uri   = pal_config.manifest;
    PAL_HANDLE   manifest       = pal_config.manifest_handle;
    const char * exec_uri       = NULL;
    PAL_HANDLE   exec           = NULL;
    bool         noexec         = false;
   11b66:	c6 85 6f ff ff ff 00 	movb   $0x0,-0x91(%rbp)
    if (uri) {
        exec_uri = uri;
        if ((ret = _DkStreamOpen(&exec, uri, PAL_ACCESS_RDONLY, 0, 0, 0)) < 0)
            return ret;

        if (check_elf_object(exec) < 0) {
   11b6d:	0f 88 3d 05 00 00    	js     120b0 <_DkProcessCreate+0x5b0>
        noexec = true;
    }

    int fds[6] = { -1, -1, -1, -1, -1, -1 };

    if (IS_ERR((ret = INLINE_SYSCALL(pipe2, 2, &fds[0], 0))) ||
   11b73:	ba 1e 02 00 00       	mov    $0x21e,%edx
        }
    } else {
        noexec = true;
    }

    int fds[6] = { -1, -1, -1, -1, -1, -1 };
   11b78:	c7 45 90 ff ff ff ff 	movl   $0xffffffff,-0x70(%rbp)
   11b7f:	c7 45 94 ff ff ff ff 	movl   $0xffffffff,-0x6c(%rbp)
   11b86:	c7 45 98 ff ff ff ff 	movl   $0xffffffff,-0x68(%rbp)
   11b8d:	c7 45 9c ff ff ff ff 	movl   $0xffffffff,-0x64(%rbp)

    if (IS_ERR((ret = INLINE_SYSCALL(pipe2, 2, &fds[0], 0))) ||
   11b94:	31 f6                	xor    %esi,%esi
        }
    } else {
        noexec = true;
    }

    int fds[6] = { -1, -1, -1, -1, -1, -1 };
   11b96:	c7 45 a0 ff ff ff ff 	movl   $0xffffffff,-0x60(%rbp)
   11b9d:	c7 45 a4 ff ff ff ff 	movl   $0xffffffff,-0x5c(%rbp)

    if (IS_ERR((ret = INLINE_SYSCALL(pipe2, 2, &fds[0], 0))) ||
   11ba4:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
   11ba8:	89 d0                	mov    %edx,%eax
   11baa:	cd 80                	int    $0x80
   11bac:	48 89 c1             	mov    %rax,%rcx
   11baf:	bb 00 00 00 00       	mov    $0x0,%ebx
   11bb4:	83 d3 00             	adc    $0x0,%ebx
   11bb7:	31 c0                	xor    %eax,%eax
   11bb9:	85 db                	test   %ebx,%ebx
   11bbb:	0f 95 c0             	setne  %al
   11bbe:	48 89 c6             	mov    %rax,%rsi
   11bc1:	48 f7 de             	neg    %rsi
   11bc4:	48 31 f1             	xor    %rsi,%rcx
   11bc7:	89 cb                	mov    %ecx,%ebx
   11bc9:	01 c3                	add    %eax,%ebx
   11bcb:	0f 88 cf 03 00 00    	js     11fa0 <_DkProcessCreate+0x4a0>
        IS_ERR((ret = INLINE_SYSCALL(pipe2, 2, &fds[2], 0))) ||
   11bd1:	48 8d 45 90          	lea    -0x70(%rbp),%rax
   11bd5:	31 f6                	xor    %esi,%esi
   11bd7:	49 89 c1             	mov    %rax,%r9
   11bda:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
   11be1:	48 8d 78 08          	lea    0x8(%rax),%rdi
   11be5:	89 d0                	mov    %edx,%eax
   11be7:	cd 80                	int    $0x80
   11be9:	48 89 c2             	mov    %rax,%rdx
   11bec:	bb 00 00 00 00       	mov    $0x0,%ebx
   11bf1:	83 d3 00             	adc    $0x0,%ebx
   11bf4:	31 c0                	xor    %eax,%eax
   11bf6:	85 db                	test   %ebx,%ebx
   11bf8:	0f 95 c0             	setne  %al
   11bfb:	48 89 c1             	mov    %rax,%rcx
   11bfe:	48 f7 d9             	neg    %rcx
   11c01:	48 31 ca             	xor    %rcx,%rdx
        noexec = true;
    }

    int fds[6] = { -1, -1, -1, -1, -1, -1 };

    if (IS_ERR((ret = INLINE_SYSCALL(pipe2, 2, &fds[0], 0))) ||
   11c04:	89 d3                	mov    %edx,%ebx
   11c06:	01 c3                	add    %eax,%ebx
   11c08:	0f 88 99 03 00 00    	js     11fa7 <_DkProcessCreate+0x4a7>
        IS_ERR((ret = INLINE_SYSCALL(pipe2, 2, &fds[2], 0))) ||
        IS_ERR((ret = INLINE_SYSCALL(socketpair, 4, AF_UNIX, SOCK_STREAM,
   11c0e:	bb 87 00 00 00       	mov    $0x87,%ebx
   11c13:	49 8d 49 10          	lea    0x10(%r9),%rcx
   11c17:	31 d2                	xor    %edx,%edx
   11c19:	40 b6 01             	mov    $0x1,%sil
   11c1c:	bf 01 00 00 00       	mov    $0x1,%edi
   11c21:	89 d8                	mov    %ebx,%eax
   11c23:	cd 80                	int    $0x80
   11c25:	48 89 c2             	mov    %rax,%rdx
   11c28:	bb 00 00 00 00       	mov    $0x0,%ebx
   11c2d:	83 d3 00             	adc    $0x0,%ebx
   11c30:	31 c9                	xor    %ecx,%ecx
   11c32:	85 db                	test   %ebx,%ebx
   11c34:	0f 95 c1             	setne  %cl
   11c37:	48 89 c8             	mov    %rcx,%rax
   11c3a:	48 f7 d8             	neg    %rax
   11c3d:	48 31 d0             	xor    %rdx,%rax
    }

    int fds[6] = { -1, -1, -1, -1, -1, -1 };

    if (IS_ERR((ret = INLINE_SYSCALL(pipe2, 2, &fds[0], 0))) ||
        IS_ERR((ret = INLINE_SYSCALL(pipe2, 2, &fds[2], 0))) ||
   11c40:	01 c8                	add    %ecx,%eax
   11c42:	0f 88 5f 03 00 00    	js     11fa7 <_DkProcessCreate+0x4a7>
                                     0, &fds[4])))) {
        ret = -PAL_ERROR_DENIED;
        goto out;
    }

    int proc_fds[2][3] = {
   11c48:	8b 45 90             	mov    -0x70(%rbp),%eax
        { fds[0], fds[3], fds[4] },
        { fds[2], fds[1], fds[5] },
    };

    int nargs = 0;
    if (args) {
   11c4b:	4d 85 ed             	test   %r13,%r13
                                     0, &fds[4])))) {
        ret = -PAL_ERROR_DENIED;
        goto out;
    }

    int proc_fds[2][3] = {
   11c4e:	89 45 b0             	mov    %eax,-0x50(%rbp)
   11c51:	8b 45 9c             	mov    -0x64(%rbp),%eax
   11c54:	89 45 b4             	mov    %eax,-0x4c(%rbp)
   11c57:	8b 45 a0             	mov    -0x60(%rbp),%eax
   11c5a:	89 45 b8             	mov    %eax,-0x48(%rbp)
   11c5d:	8b 45 98             	mov    -0x68(%rbp),%eax
   11c60:	89 45 bc             	mov    %eax,-0x44(%rbp)
   11c63:	8b 45 94             	mov    -0x6c(%rbp),%eax
   11c66:	89 45 c0             	mov    %eax,-0x40(%rbp)
   11c69:	8b 45 a4             	mov    -0x5c(%rbp),%eax
   11c6c:	89 45 c4             	mov    %eax,-0x3c(%rbp)
        { fds[0], fds[3], fds[4] },
        { fds[2], fds[1], fds[5] },
    };

    int nargs = 0;
    if (args) {
   11c6f:	0f 84 9d 04 00 00    	je     12112 <_DkProcessCreate+0x612>
        const char ** p = args;
        while (*p) {
   11c75:	49 83 7d 00 00       	cmpq   $0x0,0x0(%r13)
   11c7a:	0f 84 0f 05 00 00    	je     1218f <_DkProcessCreate+0x68f>
   11c80:	4c 89 e8             	mov    %r13,%rax
   11c83:	31 d2                	xor    %edx,%edx
            p++;
   11c85:	48 83 c0 08          	add    $0x8,%rax
            nargs++;
   11c89:	83 c2 01             	add    $0x1,%edx
    };

    int nargs = 0;
    if (args) {
        const char ** p = args;
        while (*p) {
   11c8c:	48 83 38 00          	cmpq   $0x0,(%rax)
   11c90:	75 f3                	jne    11c85 <_DkProcessCreate+0x185>
   11c92:	48 63 d2             	movslq %edx,%rdx
   11c95:	48 c1 e2 03          	shl    $0x3,%rdx
   11c99:	48 8d 42 18          	lea    0x18(%rdx),%rax
   11c9d:	48 8d 4a 10          	lea    0x10(%rdx),%rcx
        }
    }

# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
   11ca1:	48 83 c0 1e          	add    $0x1e,%rax
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
    new_args[0] = pal_config.lib_name;
    new_args[1] = argbuf;
    if (args)
        memcpy(new_args + 2, args, sizeof(const char *) * nargs);
   11ca5:	4c 89 ee             	mov    %r13,%rsi
   11ca8:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
        }
    }

# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
   11caf:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
   11cb3:	48 29 c4             	sub    %rax,%rsp
   11cb6:	48 8d 44 24 0f       	lea    0xf(%rsp),%rax
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
   11cbb:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
   11cc2:	4c 8d 54 24 0f       	lea    0xf(%rsp),%r10
        }
    }

# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
   11cc7:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
   11ccb:	48 89 c7             	mov    %rax,%rdi
   11cce:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
    new_args[0] = pal_config.lib_name;
   11cd5:	48 8b 05 44 1d 21 00 	mov    0x211d44(%rip),%rax        # 223a20 <_DYNAMIC+0x238>

# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
   11cdc:	4c 89 d3             	mov    %r10,%rbx
    new_args[0] = pal_config.lib_name;
    new_args[1] = argbuf;
    if (args)
        memcpy(new_args + 2, args, sizeof(const char *) * nargs);
   11cdf:	48 83 c7 10          	add    $0x10,%rdi

# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
   11ce3:	48 83 e3 f0          	and    $0xfffffffffffffff0,%rbx
    new_args[0] = pal_config.lib_name;
   11ce7:	48 8b 40 28          	mov    0x28(%rax),%rax
    new_args[1] = argbuf;
   11ceb:	48 89 5f f8          	mov    %rbx,-0x8(%rdi)
# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
    new_args[0] = pal_config.lib_name;
   11cef:	48 89 47 f0          	mov    %rax,-0x10(%rdi)
    new_args[1] = argbuf;
    if (args)
        memcpy(new_args + 2, args, sizeof(const char *) * nargs);
   11cf3:	e8 88 45 00 00       	callq  16280 <memcpy>
   11cf8:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
    new_args[nargs + 2] = NULL;
   11cff:	48 8b 85 60 ff ff ff 	mov    -0xa0(%rbp),%rax
        int _len = snprintf(argbuf, bufsize, __VA_ARGS__);  \
        argbuf += _len;                                     \
        bufsize -= _len;                                    \
    } while (0);

    write_arg(":domain=%08x;", pal_sec_info.domain_id);
   11d06:	48 8d 15 d4 c8 00 00 	lea    0xc8d4(%rip),%rdx        # 1e5e1 <slab_levels+0x5341>
   11d0d:	be 00 01 00 00       	mov    $0x100,%esi
   11d12:	48 89 df             	mov    %rbx,%rdi

    int manifest_fd = -1;
   11d15:	41 bd ff ff ff ff    	mov    $0xffffffff,%r13d
    char * argbuf = __alloca(STRARG_SIZE);
    new_args[0] = pal_config.lib_name;
    new_args[1] = argbuf;
    if (args)
        memcpy(new_args + 2, args, sizeof(const char *) * nargs);
    new_args[nargs + 2] = NULL;
   11d1b:	48 c7 04 08 00 00 00 	movq   $0x0,(%rax,%rcx,1)
   11d22:	00 
        int _len = snprintf(argbuf, bufsize, __VA_ARGS__);  \
        argbuf += _len;                                     \
        bufsize -= _len;                                    \
    } while (0);

    write_arg(":domain=%08x;", pal_sec_info.domain_id);
   11d23:	48 8b 05 7e 1d 21 00 	mov    0x211d7e(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
   11d2a:	8b 48 08             	mov    0x8(%rax),%ecx
   11d2d:	31 c0                	xor    %eax,%eax
   11d2f:	e8 7c 71 ff ff       	callq  8eb0 <pal_snprintf>
   11d34:	be 00 01 00 00       	mov    $0x100,%esi
   11d39:	4c 63 d0             	movslq %eax,%r10
   11d3c:	29 c6                	sub    %eax,%esi
   11d3e:	49 01 da             	add    %rbx,%r10

    int manifest_fd = -1;

    if (manifest) {
   11d41:	4d 85 f6             	test   %r14,%r14
        int _len = snprintf(argbuf, bufsize, __VA_ARGS__);  \
        argbuf += _len;                                     \
        bufsize -= _len;                                    \
    } while (0);

    write_arg(":domain=%08x;", pal_sec_info.domain_id);
   11d44:	89 f1                	mov    %esi,%ecx
   11d46:	89 f3                	mov    %esi,%ebx

    int manifest_fd = -1;

    if (manifest) {
   11d48:	74 71                	je     11dbb <_DkProcessCreate+0x2bb>
        manifest_fd = manifest->file.fd;
   11d4a:	49 63 7e 0c          	movslq 0xc(%r14),%rdi
        INLINE_SYSCALL(fcntl, 3, manifest_fd, F_SETFD, 0);
   11d4e:	31 d2                	xor    %edx,%edx
   11d50:	be 02 00 00 00       	mov    $0x2,%esi
   11d55:	b8 5c 00 00 00       	mov    $0x5c,%eax
    write_arg(":domain=%08x;", pal_sec_info.domain_id);

    int manifest_fd = -1;

    if (manifest) {
        manifest_fd = manifest->file.fd;
   11d5a:	49 89 fd             	mov    %rdi,%r13
        INLINE_SYSCALL(fcntl, 3, manifest_fd, F_SETFD, 0);
   11d5d:	cd 80                	int    $0x80
   11d5f:	bb 00 00 00 00       	mov    $0x0,%ebx
   11d64:	83 d3 00             	adc    $0x0,%ebx
        write_arg("manifest=%d,%s;", manifest_fd, manifest_uri ? : "");
   11d67:	4c 8d 05 8b 6c 00 00 	lea    0x6c8b(%rip),%r8        # 189f9 <handle_sizes.1924+0x279>
   11d6e:	4d 85 ff             	test   %r15,%r15
   11d71:	48 8d 15 77 c8 00 00 	lea    0xc877(%rip),%rdx        # 1e5ef <slab_levels+0x534f>
   11d78:	89 cb                	mov    %ecx,%ebx
   11d7a:	48 63 f1             	movslq %ecx,%rsi
   11d7d:	89 f9                	mov    %edi,%ecx
   11d7f:	4d 0f 45 c7          	cmovne %r15,%r8
   11d83:	4c 89 d7             	mov    %r10,%rdi
   11d86:	31 c0                	xor    %eax,%eax
   11d88:	4c 89 95 58 ff ff ff 	mov    %r10,-0xa8(%rbp)
   11d8f:	e8 1c 71 ff ff       	callq  8eb0 <pal_snprintf>
   11d94:	89 de                	mov    %ebx,%esi
   11d96:	48 63 d0             	movslq %eax,%rdx
   11d99:	4c 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%r10
   11da0:	29 c6                	sub    %eax,%esi

        if (manifest != pal_config.manifest_handle)
            manifest_fd = -1;
   11da2:	48 8b 05 77 1c 21 00 	mov    0x211c77(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
    int manifest_fd = -1;

    if (manifest) {
        manifest_fd = manifest->file.fd;
        INLINE_SYSCALL(fcntl, 3, manifest_fd, F_SETFD, 0);
        write_arg("manifest=%d,%s;", manifest_fd, manifest_uri ? : "");
   11da9:	89 f3                	mov    %esi,%ebx
   11dab:	49 01 d2             	add    %rdx,%r10

        if (manifest != pal_config.manifest_handle)
            manifest_fd = -1;
   11dae:	4c 39 70 10          	cmp    %r14,0x10(%rax)
   11db2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
   11db7:	44 0f 45 e8          	cmovne %eax,%r13d
    }

    write_arg("proc=%d,%d,%d,%d;",
   11dbb:	48 8b 05 9e 1b 21 00 	mov    0x211b9e(%rip),%rax        # 223960 <_DYNAMIC+0x178>
   11dc2:	48 83 ec 08          	sub    $0x8,%rsp
   11dc6:	8b 4d b0             	mov    -0x50(%rbp),%ecx
   11dc9:	44 8b 4d b8          	mov    -0x48(%rbp),%r9d
   11dcd:	44 8b 45 b4          	mov    -0x4c(%rbp),%r8d
   11dd1:	48 8d 15 27 c8 00 00 	lea    0xc827(%rip),%rdx        # 1e5ff <slab_levels+0x535f>
   11dd8:	4c 89 d7             	mov    %r10,%rdi
   11ddb:	41 89 df             	mov    %ebx,%r15d
   11dde:	48 63 f3             	movslq %ebx,%rsi
   11de1:	8b 00                	mov    (%rax),%eax
   11de3:	4c 89 95 58 ff ff ff 	mov    %r10,-0xa8(%rbp)
   11dea:	50                   	push   %rax
   11deb:	31 c0                	xor    %eax,%eax
   11ded:	e8 be 70 ff ff       	callq  8eb0 <pal_snprintf>
   11df2:	4c 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%r10
   11df9:	4c 63 f0             	movslq %eax,%r14
   11dfc:	41 29 c7             	sub    %eax,%r15d
              proc_fds[0][0], proc_fds[0][1], proc_fds[0][2],
              pal_linux_config.pid);

    if (exec) {
   11dff:	48 8b 45 88          	mov    -0x78(%rbp),%rax
   11e03:	5a                   	pop    %rdx

        if (manifest != pal_config.manifest_handle)
            manifest_fd = -1;
    }

    write_arg("proc=%d,%d,%d,%d;",
   11e04:	4d 01 d6             	add    %r10,%r14
              proc_fds[0][0], proc_fds[0][1], proc_fds[0][2],
              pal_linux_config.pid);

    if (exec) {
   11e07:	48 85 c0             	test   %rax,%rax
   11e0a:	59                   	pop    %rcx
   11e0b:	0f 84 4f 03 00 00    	je     12160 <_DkProcessCreate+0x660>
        int exec_fd = exec->file.fd;
   11e11:	48 63 78 0c          	movslq 0xc(%rax),%rdi
        INLINE_SYSCALL(fcntl, 3, exec_fd, F_SETFD, 0);
   11e15:	31 d2                	xor    %edx,%edx
   11e17:	be 02 00 00 00       	mov    $0x2,%esi
   11e1c:	b8 5c 00 00 00       	mov    $0x5c,%eax
    write_arg("proc=%d,%d,%d,%d;",
              proc_fds[0][0], proc_fds[0][1], proc_fds[0][2],
              pal_linux_config.pid);

    if (exec) {
        int exec_fd = exec->file.fd;
   11e21:	48 89 f9             	mov    %rdi,%rcx
        INLINE_SYSCALL(fcntl, 3, exec_fd, F_SETFD, 0);
   11e24:	cd 80                	int    $0x80
   11e26:	bb 00 00 00 00       	mov    $0x0,%ebx
   11e2b:	83 d3 00             	adc    $0x0,%ebx
        write_arg("exec=%d,%s;", exec_fd, exec_uri ? : "");
   11e2e:	4c 8d 05 c4 6b 00 00 	lea    0x6bc4(%rip),%r8        # 189f9 <handle_sizes.1924+0x279>
   11e35:	4d 85 e4             	test   %r12,%r12
   11e38:	48 8d 15 d2 c7 00 00 	lea    0xc7d2(%rip),%rdx        # 1e611 <slab_levels+0x5371>
   11e3f:	49 63 f7             	movslq %r15d,%rsi
   11e42:	4c 89 f7             	mov    %r14,%rdi
   11e45:	4d 0f 45 c4          	cmovne %r12,%r8
   11e49:	31 c0                	xor    %eax,%eax
   11e4b:	e8 60 70 ff ff       	callq  8eb0 <pal_snprintf>
   11e50:	48 63 d0             	movslq %eax,%rdx
   11e53:	41 29 c7             	sub    %eax,%r15d
   11e56:	49 01 d6             	add    %rdx,%r14
    } else if (noexec) {
        write_arg("noexec;");
    }

    if (pal_sec_info.pipe_prefix)
   11e59:	48 8b 05 48 1c 21 00 	mov    0x211c48(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
   11e60:	48 8b 48 10          	mov    0x10(%rax),%rcx
   11e64:	48 85 c9             	test   %rcx,%rcx
   11e67:	74 1d                	je     11e86 <_DkProcessCreate+0x386>
        write_arg("pipe=%s;", pal_sec_info.pipe_prefix);
   11e69:	48 8d 15 b5 c7 00 00 	lea    0xc7b5(%rip),%rdx        # 1e625 <slab_levels+0x5385>
   11e70:	49 63 f7             	movslq %r15d,%rsi
   11e73:	4c 89 f7             	mov    %r14,%rdi
   11e76:	31 c0                	xor    %eax,%eax
   11e78:	e8 33 70 ff ff       	callq  8eb0 <pal_snprintf>
   11e7d:	48 63 d0             	movslq %eax,%rdx
   11e80:	41 29 c7             	sub    %eax,%r15d
   11e83:	49 01 d6             	add    %rdx,%r14

    if (pal_config.heap_base)
   11e86:	48 8b 05 93 1b 21 00 	mov    0x211b93(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
   11e8d:	48 8b 48 50          	mov    0x50(%rax),%rcx
   11e91:	48 85 c9             	test   %rcx,%rcx
   11e94:	74 1d                	je     11eb3 <_DkProcessCreate+0x3b3>
        write_arg("heap=%lx;", pal_config.heap_base);
   11e96:	48 8d 15 91 c7 00 00 	lea    0xc791(%rip),%rdx        # 1e62e <slab_levels+0x538e>
   11e9d:	49 63 f7             	movslq %r15d,%rsi
   11ea0:	4c 89 f7             	mov    %r14,%rdi
   11ea3:	31 c0                	xor    %eax,%eax
   11ea5:	e8 06 70 ff ff       	callq  8eb0 <pal_snprintf>
   11eaa:	48 63 d0             	movslq %eax,%rdx
   11ead:	41 29 c7             	sub    %eax,%r15d
   11eb0:	49 01 d6             	add    %rdx,%r14

    if (pal_sec_info.rand_gen)
   11eb3:	48 8b 05 ee 1b 21 00 	mov    0x211bee(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
   11eba:	8b 48 18             	mov    0x18(%rax),%ecx
   11ebd:	85 c9                	test   %ecx,%ecx
   11ebf:	0f 85 2b 02 00 00    	jne    120f0 <_DkProcessCreate+0x5f0>
        write_arg("rand=%d;", pal_sec_info.rand_gen);

    if (pal_sec_info.mcast_port)
   11ec5:	48 8b 05 dc 1b 21 00 	mov    0x211bdc(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
   11ecc:	0f b7 48 1c          	movzwl 0x1c(%rax),%ecx
   11ed0:	66 85 c9             	test   %cx,%cx
   11ed3:	0f 85 f7 01 00 00    	jne    120d0 <_DkProcessCreate+0x5d0>
        write_arg("mcast=%u;", pal_sec_info.mcast_port);

    ret = ARCH_VFORK();
   11ed9:	bb 42 00 00 00       	mov    $0x42,%ebx
   11ede:	89 d8                	mov    %ebx,%eax
   11ee0:	cd 80                	int    $0x80
   11ee2:	48 89 c2             	mov    %rax,%rdx
   11ee5:	bb 00 00 00 00       	mov    $0x0,%ebx
   11eea:	83 d3 00             	adc    $0x0,%ebx
   11eed:	45 31 e4             	xor    %r12d,%r12d
   11ef0:	85 db                	test   %ebx,%ebx
   11ef2:	41 0f 95 c4          	setne  %r12b
   11ef6:	4c 89 e0             	mov    %r12,%rax
   11ef9:	48 f7 d8             	neg    %rax
   11efc:	48 31 c2             	xor    %rax,%rdx
   11eff:	49 01 d4             	add    %rdx,%r12

    if (IS_ERR(ret)) {
   11f02:	45 85 e4             	test   %r12d,%r12d
   11f05:	0f 88 9c 00 00 00    	js     11fa7 <_DkProcessCreate+0x4a7>
        ret = -PAL_ERROR_DENIED;
        goto out;
    }

    if (!ret) {
   11f0b:	0f 85 ef 00 00 00    	jne    12000 <_DkProcessCreate+0x500>
   11f11:	48 8d 55 b0          	lea    -0x50(%rbp),%rdx
        for (int i = 0 ; i < 3 ; i++)
            INLINE_SYSCALL(close, 1, proc_fds[1][i]);
   11f15:	b9 06 00 00 00       	mov    $0x6,%ecx
   11f1a:	48 8d 72 0c          	lea    0xc(%rdx),%rsi
   11f1e:	48 63 7a 0c          	movslq 0xc(%rdx),%rdi
   11f22:	89 c8                	mov    %ecx,%eax
   11f24:	cd 80                	int    $0x80
   11f26:	bb 00 00 00 00       	mov    $0x0,%ebx
   11f2b:	83 d3 00             	adc    $0x0,%ebx
   11f2e:	48 83 c2 04          	add    $0x4,%rdx
        ret = -PAL_ERROR_DENIED;
        goto out;
    }

    if (!ret) {
        for (int i = 0 ; i < 3 ; i++)
   11f32:	48 39 f2             	cmp    %rsi,%rdx
   11f35:	75 e7                	jne    11f1e <_DkProcessCreate+0x41e>
            INLINE_SYSCALL(close, 1, proc_fds[1][i]);

        if (manifest_fd >= 0)
   11f37:	45 85 ed             	test   %r13d,%r13d
   11f3a:	78 19                	js     11f55 <_DkProcessCreate+0x455>
            INLINE_SYSCALL(fcntl, 3, manifest_fd, F_SETFD, 0);
   11f3c:	31 d2                	xor    %edx,%edx
   11f3e:	be 02 00 00 00       	mov    $0x2,%esi
   11f43:	49 63 fd             	movslq %r13d,%rdi
   11f46:	b8 5c 00 00 00       	mov    $0x5c,%eax
   11f4b:	cd 80                	int    $0x80
   11f4d:	bb 00 00 00 00       	mov    $0x0,%ebx
   11f52:	83 d3 00             	adc    $0x0,%ebx

        rete = INLINE_SYSCALL(execve, 3, pal_config.lib_name, new_args,
   11f55:	48 8b 05 c4 1a 21 00 	mov    0x211ac4(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
   11f5c:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
   11f63:	48 8b 78 28          	mov    0x28(%rax),%rdi
   11f67:	48 8b 50 30          	mov    0x30(%rax),%rdx
   11f6b:	b8 3b 00 00 00       	mov    $0x3b,%eax
   11f70:	cd 80                	int    $0x80
   11f72:	bb 00 00 00 00       	mov    $0x0,%ebx
   11f77:	83 d3 00             	adc    $0x0,%ebx
                              pal_config.environments);

        /* shouldn't get to here */
        printf("unexpected failure of new process\n");
   11f7a:	48 8d 3d ef c6 00 00 	lea    0xc6ef(%rip),%rdi        # 1e670 <slab_levels+0x53d0>
   11f81:	31 c0                	xor    %eax,%eax
   11f83:	e8 98 6e ff ff       	callq  8e20 <pal_printf>
        asm("hlt");
   11f88:	f4                   	hlt    
        return 0;
   11f89:	31 c0                	xor    %eax,%eax
            if (fds[i] >= 0)
                INLINE_SYSCALL(close, 1, fds[i]);
    }

    return ret;
}
   11f8b:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   11f8f:	5b                   	pop    %rbx
   11f90:	41 5c                	pop    %r12
   11f92:	41 5d                	pop    %r13
   11f94:	41 5e                	pop    %r14
   11f96:	41 5f                	pop    %r15
   11f98:	5d                   	pop    %rbp
   11f99:	c3                   	retq   
   11f9a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
   11fa0:	48 89 bd 78 ff ff ff 	mov    %rdi,-0x88(%rbp)
   11fa7:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
    ret = 0;
out:
    if (ret < 0) {
        for (int i = 0 ; i < 6 ; i++)
            if (fds[i] >= 0)
                INLINE_SYSCALL(close, 1, fds[i]);
   11fae:	be 06 00 00 00       	mov    $0x6,%esi
   11fb3:	48 8d 4a 18          	lea    0x18(%rdx),%rcx
    *handle = hdl;
    ret = 0;
out:
    if (ret < 0) {
        for (int i = 0 ; i < 6 ; i++)
            if (fds[i] >= 0)
   11fb7:	48 63 3a             	movslq (%rdx),%rdi
   11fba:	85 ff                	test   %edi,%edi
   11fbc:	78 0c                	js     11fca <_DkProcessCreate+0x4ca>
                INLINE_SYSCALL(close, 1, fds[i]);
   11fbe:	89 f0                	mov    %esi,%eax
   11fc0:	cd 80                	int    $0x80
   11fc2:	bb 00 00 00 00       	mov    $0x0,%ebx
   11fc7:	83 d3 00             	adc    $0x0,%ebx
   11fca:	48 83 c2 04          	add    $0x4,%rdx
    hdl->process.nonblocking = PAL_FALSE;
    *handle = hdl;
    ret = 0;
out:
    if (ret < 0) {
        for (int i = 0 ; i < 6 ; i++)
   11fce:	48 39 ca             	cmp    %rcx,%rdx
   11fd1:	75 e4                	jne    11fb7 <_DkProcessCreate+0x4b7>
            if (fds[i] >= 0)
                INLINE_SYSCALL(close, 1, fds[i]);
    }

    return ret;
}
   11fd3:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   11fd7:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   11fdc:	5b                   	pop    %rbx
   11fdd:	41 5c                	pop    %r12
   11fdf:	41 5d                	pop    %r13
   11fe1:	41 5e                	pop    %r14
   11fe3:	41 5f                	pop    %r15
   11fe5:	5d                   	pop    %rbp
   11fe6:	c3                   	retq   
   11fe7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   11fee:	00 00 
            manifest_uri = uri;
            exec = NULL;
            exec_uri = NULL;
        }
    } else {
        noexec = true;
   11ff0:	c6 85 6f ff ff ff 01 	movb   $0x1,-0x91(%rbp)
   11ff7:	e9 77 fb ff ff       	jmpq   11b73 <_DkProcessCreate+0x73>
   11ffc:	0f 1f 40 00          	nopl   0x0(%rax)
   12000:	48 8d 4d b0          	lea    -0x50(%rbp),%rcx
   12004:	31 d2                	xor    %edx,%edx
        ret = -PAL_ERROR_DENIED;
        goto out;
    }

    for (int i = 0 ; i < 3 ; i++)
        INLINE_SYSCALL(close, 1, proc_fds[0][i]);
   12006:	be 06 00 00 00       	mov    $0x6,%esi
   1200b:	48 63 3c 11          	movslq (%rcx,%rdx,1),%rdi
   1200f:	89 f0                	mov    %esi,%eax
   12011:	cd 80                	int    $0x80
   12013:	bb 00 00 00 00       	mov    $0x0,%ebx
   12018:	83 d3 00             	adc    $0x0,%ebx
   1201b:	48 83 c2 04          	add    $0x4,%rdx
    if (IS_ERR(rete)) {
        ret = -PAL_ERROR_DENIED;
        goto out;
    }

    for (int i = 0 ; i < 3 ; i++)
   1201f:	48 83 fa 0c          	cmp    $0xc,%rdx
   12023:	75 e6                	jne    1200b <_DkProcessCreate+0x50b>
   12025:	4c 8d 49 0c          	lea    0xc(%rcx),%r9
        INLINE_SYSCALL(close, 1, proc_fds[0][i]);

    for (int i = 0 ; i < 3 ; i++)
        INLINE_SYSCALL(fcntl, 3, proc_fds[1][i], F_SETFD, FD_CLOEXEC);
   12029:	41 b8 5c 00 00 00    	mov    $0x5c,%r8d
   1202f:	48 63 79 0c          	movslq 0xc(%rcx),%rdi
   12033:	ba 01 00 00 00       	mov    $0x1,%edx
   12038:	be 02 00 00 00       	mov    $0x2,%esi
   1203d:	44 89 c0             	mov    %r8d,%eax
   12040:	cd 80                	int    $0x80
   12042:	bb 00 00 00 00       	mov    $0x0,%ebx
   12047:	83 d3 00             	adc    $0x0,%ebx
   1204a:	48 83 c1 04          	add    $0x4,%rcx
    }

    for (int i = 0 ; i < 3 ; i++)
        INLINE_SYSCALL(close, 1, proc_fds[0][i]);

    for (int i = 0 ; i < 3 ; i++)
   1204e:	4c 39 c9             	cmp    %r9,%rcx
   12051:	75 dc                	jne    1202f <_DkProcessCreate+0x52f>
        INLINE_SYSCALL(fcntl, 3, proc_fds[1][i], F_SETFD, FD_CLOEXEC);

    int pid = ret;
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(process));
   12053:	bf 20 00 00 00       	mov    $0x20,%edi
   12058:	e8 a3 69 ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, process);
    hdl->__in.flags |= RFD(0)|WFD(1)|RFD(2)|WFD(2)|WRITEABLE(1)|WRITEABLE(2);
    hdl->process.stream_in  = proc_fds[1][0];
   1205d:	8b 55 bc             	mov    -0x44(%rbp),%edx
    hdl->process.stream_out = proc_fds[1][1];
    hdl->process.cargo      = proc_fds[1][2];
    hdl->process.pid = pid;
    hdl->process.nonblocking = PAL_FALSE;
    *handle = hdl;
   12060:	48 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%rbx
    for (int i = 0 ; i < 3 ; i++)
        INLINE_SYSCALL(fcntl, 3, proc_fds[1][i], F_SETFD, FD_CLOEXEC);

    int pid = ret;
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(process));
    SET_HANDLE_TYPE(hdl, process);
   12067:	c7 00 0c 00 00 00    	movl   $0xc,(%rax)
   1206d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    hdl->__in.flags |= RFD(0)|WFD(1)|RFD(2)|WFD(2)|WRITEABLE(1)|WRITEABLE(2);
   12074:	c7 40 08 b5 01 00 00 	movl   $0x1b5,0x8(%rax)
    hdl->process.stream_in  = proc_fds[1][0];
    hdl->process.stream_out = proc_fds[1][1];
    hdl->process.cargo      = proc_fds[1][2];
    hdl->process.pid = pid;
   1207b:	44 89 60 18          	mov    %r12d,0x18(%rax)

    int pid = ret;
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(process));
    SET_HANDLE_TYPE(hdl, process);
    hdl->__in.flags |= RFD(0)|WFD(1)|RFD(2)|WFD(2)|WRITEABLE(1)|WRITEABLE(2);
    hdl->process.stream_in  = proc_fds[1][0];
   1207f:	89 50 0c             	mov    %edx,0xc(%rax)
    hdl->process.stream_out = proc_fds[1][1];
   12082:	8b 55 c0             	mov    -0x40(%rbp),%edx
    hdl->process.cargo      = proc_fds[1][2];
    hdl->process.pid = pid;
    hdl->process.nonblocking = PAL_FALSE;
   12085:	c6 40 1c 00          	movb   $0x0,0x1c(%rax)
    int pid = ret;
    PAL_HANDLE hdl = malloc(HANDLE_SIZE(process));
    SET_HANDLE_TYPE(hdl, process);
    hdl->__in.flags |= RFD(0)|WFD(1)|RFD(2)|WFD(2)|WRITEABLE(1)|WRITEABLE(2);
    hdl->process.stream_in  = proc_fds[1][0];
    hdl->process.stream_out = proc_fds[1][1];
   12089:	89 50 10             	mov    %edx,0x10(%rax)
    hdl->process.cargo      = proc_fds[1][2];
   1208c:	8b 55 c4             	mov    -0x3c(%rbp),%edx
   1208f:	89 50 14             	mov    %edx,0x14(%rax)
    hdl->process.pid = pid;
    hdl->process.nonblocking = PAL_FALSE;
    *handle = hdl;
   12092:	48 89 03             	mov    %rax,(%rbx)
            if (fds[i] >= 0)
                INLINE_SYSCALL(close, 1, fds[i]);
    }

    return ret;
}
   12095:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    hdl->process.stream_in  = proc_fds[1][0];
    hdl->process.stream_out = proc_fds[1][1];
    hdl->process.cargo      = proc_fds[1][2];
    hdl->process.pid = pid;
    hdl->process.nonblocking = PAL_FALSE;
    *handle = hdl;
   12099:	31 c0                	xor    %eax,%eax
            if (fds[i] >= 0)
                INLINE_SYSCALL(close, 1, fds[i]);
    }

    return ret;
}
   1209b:	5b                   	pop    %rbx
   1209c:	41 5c                	pop    %r12
   1209e:	41 5d                	pop    %r13
   120a0:	41 5e                	pop    %r14
   120a2:	41 5f                	pop    %r15
   120a4:	5d                   	pop    %rbp
   120a5:	c3                   	retq   
   120a6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   120ad:	00 00 00 
        exec_uri = uri;
        if ((ret = _DkStreamOpen(&exec, uri, PAL_ACCESS_RDONLY, 0, 0, 0)) < 0)
            return ret;

        if (check_elf_object(exec) < 0) {
            manifest = exec;
   120b0:	4c 8b 75 88          	mov    -0x78(%rbp),%r14
            manifest_uri = uri;
            exec = NULL;
   120b4:	4d 89 e7             	mov    %r12,%r15
   120b7:	48 c7 45 88 00 00 00 	movq   $0x0,-0x78(%rbp)
   120be:	00 
            exec_uri = NULL;
   120bf:	45 31 e4             	xor    %r12d,%r12d
   120c2:	e9 ac fa ff ff       	jmpq   11b73 <_DkProcessCreate+0x73>
   120c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   120ce:	00 00 

    if (pal_sec_info.rand_gen)
        write_arg("rand=%d;", pal_sec_info.rand_gen);

    if (pal_sec_info.mcast_port)
        write_arg("mcast=%u;", pal_sec_info.mcast_port);
   120d0:	48 8d 15 6a c5 00 00 	lea    0xc56a(%rip),%rdx        # 1e641 <slab_levels+0x53a1>
   120d7:	49 63 f7             	movslq %r15d,%rsi
   120da:	4c 89 f7             	mov    %r14,%rdi
   120dd:	31 c0                	xor    %eax,%eax
   120df:	e8 cc 6d ff ff       	callq  8eb0 <pal_snprintf>
   120e4:	e9 f0 fd ff ff       	jmpq   11ed9 <_DkProcessCreate+0x3d9>
   120e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

    if (pal_config.heap_base)
        write_arg("heap=%lx;", pal_config.heap_base);

    if (pal_sec_info.rand_gen)
        write_arg("rand=%d;", pal_sec_info.rand_gen);
   120f0:	48 8d 15 41 c5 00 00 	lea    0xc541(%rip),%rdx        # 1e638 <slab_levels+0x5398>
   120f7:	49 63 f7             	movslq %r15d,%rsi
   120fa:	4c 89 f7             	mov    %r14,%rdi
   120fd:	31 c0                	xor    %eax,%eax
   120ff:	e8 ac 6d ff ff       	callq  8eb0 <pal_snprintf>
   12104:	48 63 d0             	movslq %eax,%rdx
   12107:	41 29 c7             	sub    %eax,%r15d
   1210a:	49 01 d6             	add    %rdx,%r14
   1210d:	e9 b3 fd ff ff       	jmpq   11ec5 <_DkProcessCreate+0x3c5>
        }
    }

# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
   12112:	48 83 ec 30          	sub    $0x30,%rsp
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
    new_args[0] = pal_config.lib_name;
    new_args[1] = argbuf;
   12116:	b9 10 00 00 00       	mov    $0x10,%ecx
        }
    }

# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
   1211b:	48 8d 44 24 0f       	lea    0xf(%rsp),%rax
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
   12120:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
   12127:	4c 8d 54 24 0f       	lea    0xf(%rsp),%r10
        }
    }

# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
   1212c:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
   12130:	48 89 c6             	mov    %rax,%rsi
   12133:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
    new_args[0] = pal_config.lib_name;
   1213a:	48 8b 05 df 18 21 00 	mov    0x2118df(%rip),%rax        # 223a20 <_DYNAMIC+0x238>

# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
   12141:	4c 89 d3             	mov    %r10,%rbx
   12144:	48 83 e3 f0          	and    $0xfffffffffffffff0,%rbx
    new_args[0] = pal_config.lib_name;
   12148:	48 8b 40 28          	mov    0x28(%rax),%rax
    new_args[1] = argbuf;
   1214c:	48 89 5e 08          	mov    %rbx,0x8(%rsi)
# define STRARG_SIZE    256

    const char ** new_args = __alloca(sizeof(const char *) * (nargs + 3));
    int bufsize = STRARG_SIZE;
    char * argbuf = __alloca(STRARG_SIZE);
    new_args[0] = pal_config.lib_name;
   12150:	48 89 06             	mov    %rax,(%rsi)
   12153:	e9 a7 fb ff ff       	jmpq   11cff <_DkProcessCreate+0x1ff>
   12158:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1215f:	00 

    if (exec) {
        int exec_fd = exec->file.fd;
        INLINE_SYSCALL(fcntl, 3, exec_fd, F_SETFD, 0);
        write_arg("exec=%d,%s;", exec_fd, exec_uri ? : "");
    } else if (noexec) {
   12160:	80 bd 6f ff ff ff 00 	cmpb   $0x0,-0x91(%rbp)
   12167:	0f 84 ec fc ff ff    	je     11e59 <_DkProcessCreate+0x359>
        write_arg("noexec;");
   1216d:	48 8d 15 a9 c4 00 00 	lea    0xc4a9(%rip),%rdx        # 1e61d <slab_levels+0x537d>
   12174:	49 63 f7             	movslq %r15d,%rsi
   12177:	4c 89 f7             	mov    %r14,%rdi
   1217a:	31 c0                	xor    %eax,%eax
   1217c:	e8 2f 6d ff ff       	callq  8eb0 <pal_snprintf>
   12181:	48 63 d0             	movslq %eax,%rdx
   12184:	41 29 c7             	sub    %eax,%r15d
   12187:	49 01 d6             	add    %rdx,%r14
   1218a:	e9 ca fc ff ff       	jmpq   11e59 <_DkProcessCreate+0x359>
    };

    int nargs = 0;
    if (args) {
        const char ** p = args;
        while (*p) {
   1218f:	b9 10 00 00 00       	mov    $0x10,%ecx
   12194:	b8 18 00 00 00       	mov    $0x18,%eax
   12199:	31 d2                	xor    %edx,%edx
   1219b:	e9 01 fb ff ff       	jmpq   11ca1 <_DkProcessCreate+0x1a1>

00000000000121a0 <init_child_process>:
    *handle = hdl;
    *uri = len ? remalloc(buf, len + 1) : NULL;
}

int init_child_process (const char * proc_args)
{
   121a0:	55                   	push   %rbp
   121a1:	48 89 e5             	mov    %rsp,%rbp
   121a4:	41 57                	push   %r15
   121a6:	41 56                	push   %r14
                read_child_handle(val, vlen, &pal_config.exec_handle,
                                  &pal_config.exec);
            } else if (!memcmp(key, "proc", 4)) {
                /* format: proc=fd,pid */
                int fds[3], pid;
                read_child_args(val, vlen,
   121a8:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
    *handle = hdl;
    *uri = len ? remalloc(buf, len + 1) : NULL;
}

int init_child_process (const char * proc_args)
{
   121ac:	41 55                	push   %r13
   121ae:	41 54                	push   %r12
   121b0:	53                   	push   %rbx
   121b1:	49 89 fe             	mov    %rdi,%r14
                read_child_handle(val, vlen, &pal_config.exec_handle,
                                  &pal_config.exec);
            } else if (!memcmp(key, "proc", 4)) {
                /* format: proc=fd,pid */
                int fds[3], pid;
                read_child_args(val, vlen,
   121b4:	48 8d 48 08          	lea    0x8(%rax),%rcx
    *handle = hdl;
    *uri = len ? remalloc(buf, len + 1) : NULL;
}

int init_child_process (const char * proc_args)
{
   121b8:	48 83 ec 48          	sub    $0x48,%rsp
                read_child_handle(val, vlen, &pal_config.exec_handle,
                                  &pal_config.exec);
            } else if (!memcmp(key, "proc", 4)) {
                /* format: proc=fd,pid */
                int fds[3], pid;
                read_child_args(val, vlen,
   121bc:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
   121c0:	48 83 c0 04          	add    $0x4,%rax
   121c4:	48 89 45 98          	mov    %rax,-0x68(%rbp)
   121c8:	48 8d 45 bc          	lea    -0x44(%rbp),%rax
   121cc:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
   121d0:	48 89 45 90          	mov    %rax,-0x70(%rbp)

int init_child_process (const char * proc_args)
{
    const char * c = proc_args;

    while (*c) {
   121d4:	41 0f b6 06          	movzbl (%r14),%eax
   121d8:	84 c0                	test   %al,%al
   121da:	0f 84 c5 00 00 00    	je     122a5 <init_child_process+0x105>
        const char * key = c, * val;
        int klen, vlen;

        while (*c && *c != '=' && *c != ';')
   121e0:	8d 50 c5             	lea    -0x3b(%rax),%edx
   121e3:	4d 89 f2             	mov    %r14,%r10
   121e6:	81 e2 fd 00 00 00    	and    $0xfd,%edx
   121ec:	75 09                	jne    121f7 <init_child_process+0x57>
   121ee:	e9 c8 02 00 00       	jmpq   124bb <init_child_process+0x31b>
   121f3:	84 c0                	test   %al,%al
   121f5:	74 13                	je     1220a <init_child_process+0x6a>
            c++;
   121f7:	49 83 c2 01          	add    $0x1,%r10

    while (*c) {
        const char * key = c, * val;
        int klen, vlen;

        while (*c && *c != '=' && *c != ';')
   121fb:	41 0f b6 02          	movzbl (%r10),%eax
   121ff:	8d 50 c5             	lea    -0x3b(%rax),%edx
   12202:	81 e2 fd 00 00 00    	and    $0xfd,%edx
   12208:	75 e9                	jne    121f3 <init_child_process+0x53>
            c++;

        klen = c - key;
   1220a:	4c 89 d2             	mov    %r10,%rdx
   1220d:	4d 89 d5             	mov    %r10,%r13
   12210:	4c 29 f2             	sub    %r14,%rdx
        if (klen == 6 && !memcmp(key, "noexec", 6))
   12213:	83 fa 06             	cmp    $0x6,%edx
        int klen, vlen;

        while (*c && *c != '=' && *c != ';')
            c++;

        klen = c - key;
   12216:	41 89 d7             	mov    %edx,%r15d
        if (klen == 6 && !memcmp(key, "noexec", 6))
   12219:	0f 84 a7 00 00 00    	je     122c6 <init_child_process+0x126>
            /* format: noexec */
            pal_linux_config.noexec = true;

        if (!*c)
   1221f:	84 c0                	test   %al,%al
   12221:	0f 84 7e 00 00 00    	je     122a5 <init_child_process+0x105>
            break;
        if (*c == ';') {
   12227:	3c 3b                	cmp    $0x3b,%al
   12229:	0f 84 91 00 00 00    	je     122c0 <init_child_process+0x120>
            c++;
            continue;
        }

        val = (++c);
        while (*c && *c != ';')
   1222f:	41 0f b6 45 01       	movzbl 0x1(%r13),%eax
        if (*c == ';') {
            c++;
            continue;
        }

        val = (++c);
   12234:	49 8d 5d 01          	lea    0x1(%r13),%rbx
        while (*c && *c != ';')
   12238:	49 89 dd             	mov    %rbx,%r13
   1223b:	3c 3b                	cmp    $0x3b,%al
   1223d:	0f 84 59 01 00 00    	je     1239c <init_child_process+0x1fc>
   12243:	84 c0                	test   %al,%al
   12245:	75 0d                	jne    12254 <init_child_process+0xb4>
   12247:	e9 50 01 00 00       	jmpq   1239c <init_child_process+0x1fc>
   1224c:	0f 1f 40 00          	nopl   0x0(%rax)
   12250:	84 c0                	test   %al,%al
   12252:	74 0d                	je     12261 <init_child_process+0xc1>
            c++;
   12254:	49 83 c5 01          	add    $0x1,%r13
            c++;
            continue;
        }

        val = (++c);
        while (*c && *c != ';')
   12258:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
   1225d:	3c 3b                	cmp    $0x3b,%al
   1225f:	75 ef                	jne    12250 <init_child_process+0xb0>
   12261:	45 89 ec             	mov    %r13d,%r12d
   12264:	41 29 dc             	sub    %ebx,%r12d
            c++;
        vlen = c - val;
        if (*c == ';')
            c++;
   12267:	3c 3b                	cmp    $0x3b,%al
   12269:	0f 94 c0             	sete   %al
   1226c:	0f b6 c0             	movzbl %al,%eax
   1226f:	49 01 c5             	add    %rax,%r13

        if (klen == 4) {
   12272:	41 83 ff 04          	cmp    $0x4,%r15d
   12276:	74 7b                	je     122f3 <init_child_process+0x153>
                pal_sec_info.rand_gen = atoi(val);
            } else if (!memcmp(key, "heap", 4)) {
                /* format: heap=addr (hex) */
                pal_config.heap_base = (void *) strtol(val, NULL, 16);
            }
        } else if (klen == 5) {
   12278:	41 83 ff 05          	cmp    $0x5,%r15d
   1227c:	0f 84 ac 00 00 00    	je     1232e <init_child_process+0x18e>
            if (!memcmp(key, "mcast", 5)) {
                /* format: mcast=port */
                pal_sec_info.mcast_port = atoi(val);
            }
        } else if (klen == 6) {
   12282:	41 83 ff 06          	cmp    $0x6,%r15d
   12286:	0f 84 d6 00 00 00    	je     12362 <init_child_process+0x1c2>
            if (!memcmp(key, "domain", 6)) {
                /* format: domain=id */
                pal_sec_info.domain_id = strtol(val, NULL, 16);
            }
        } else if (klen == 8) {
   1228c:	41 83 ff 08          	cmp    $0x8,%r15d
   12290:	0f 84 0e 01 00 00    	je     123a4 <init_child_process+0x204>
            c++;
            continue;
        }

        val = (++c);
        while (*c && *c != ';')
   12296:	4d 89 ee             	mov    %r13,%r14

int init_child_process (const char * proc_args)
{
    const char * c = proc_args;

    while (*c) {
   12299:	41 0f b6 06          	movzbl (%r14),%eax
   1229d:	84 c0                	test   %al,%al
   1229f:	0f 85 3b ff ff ff    	jne    121e0 <init_child_process+0x40>
            }
        }
    }

    return 0;
}
   122a5:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   122a9:	31 c0                	xor    %eax,%eax
   122ab:	5b                   	pop    %rbx
   122ac:	41 5c                	pop    %r12
   122ae:	41 5d                	pop    %r13
   122b0:	41 5e                	pop    %r14
   122b2:	41 5f                	pop    %r15
   122b4:	5d                   	pop    %rbp
   122b5:	c3                   	retq   
   122b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   122bd:	00 00 00 
            pal_linux_config.noexec = true;

        if (!*c)
            break;
        if (*c == ';') {
            c++;
   122c0:	49 83 c5 01          	add    $0x1,%r13
            continue;
   122c4:	eb d0                	jmp    12296 <init_child_process+0xf6>

        while (*c && *c != '=' && *c != ';')
            c++;

        klen = c - key;
        if (klen == 6 && !memcmp(key, "noexec", 6))
   122c6:	48 8d 35 7e c3 00 00 	lea    0xc37e(%rip),%rsi        # 1e64b <slab_levels+0x53ab>
   122cd:	ba 06 00 00 00       	mov    $0x6,%edx
   122d2:	4c 89 f7             	mov    %r14,%rdi
   122d5:	e8 36 40 00 00       	callq  16310 <memcmp>
   122da:	85 c0                	test   %eax,%eax
   122dc:	75 0b                	jne    122e9 <init_child_process+0x149>
            /* format: noexec */
            pal_linux_config.noexec = true;
   122de:	48 8b 05 7b 16 21 00 	mov    0x21167b(%rip),%rax        # 223960 <_DYNAMIC+0x178>
   122e5:	c6 40 18 01          	movb   $0x1,0x18(%rax)
   122e9:	41 0f b6 45 00       	movzbl 0x0(%r13),%eax
   122ee:	e9 2c ff ff ff       	jmpq   1221f <init_child_process+0x7f>
        vlen = c - val;
        if (*c == ';')
            c++;

        if (klen == 4) {
            if (!memcmp(key, "exec", 4)) {
   122f3:	48 8d 35 fe c7 00 00 	lea    0xc7fe(%rip),%rsi        # 1eaf8 <slab_levels+0x5858>
   122fa:	ba 04 00 00 00       	mov    $0x4,%edx
   122ff:	4c 89 f7             	mov    %r14,%rdi
   12302:	e8 09 40 00 00       	callq  16310 <memcmp>
   12307:	85 c0                	test   %eax,%eax
   12309:	0f 85 cf 00 00 00    	jne    123de <init_child_process+0x23e>
                /* format: exec=fd,uri */
                read_child_handle(val, vlen, &pal_config.exec_handle,
   1230f:	48 8b 05 0a 17 21 00 	mov    0x21170a(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
   12316:	44 89 e6             	mov    %r12d,%esi
   12319:	48 89 df             	mov    %rbx,%rdi
   1231c:	48 8d 48 08          	lea    0x8(%rax),%rcx
   12320:	48 8d 50 18          	lea    0x18(%rax),%rdx
   12324:	e8 47 f6 ff ff       	callq  11970 <read_child_handle>
   12329:	e9 68 ff ff ff       	jmpq   12296 <init_child_process+0xf6>
            } else if (!memcmp(key, "heap", 4)) {
                /* format: heap=addr (hex) */
                pal_config.heap_base = (void *) strtol(val, NULL, 16);
            }
        } else if (klen == 5) {
            if (!memcmp(key, "mcast", 5)) {
   1232e:	48 8d 35 2c c3 00 00 	lea    0xc32c(%rip),%rsi        # 1e661 <slab_levels+0x53c1>
   12335:	ba 05 00 00 00       	mov    $0x5,%edx
   1233a:	4c 89 f7             	mov    %r14,%rdi
   1233d:	e8 ce 3f 00 00       	callq  16310 <memcmp>
   12342:	85 c0                	test   %eax,%eax
   12344:	0f 85 4c ff ff ff    	jne    12296 <init_child_process+0xf6>
                /* format: mcast=port */
                pal_sec_info.mcast_port = atoi(val);
   1234a:	48 89 df             	mov    %rbx,%rdi
   1234d:	e8 9e 45 00 00       	callq  168f0 <atoi>
   12352:	48 8b 15 4f 17 21 00 	mov    0x21174f(%rip),%rdx        # 223aa8 <_DYNAMIC+0x2c0>
   12359:	66 89 42 1c          	mov    %ax,0x1c(%rdx)
   1235d:	e9 34 ff ff ff       	jmpq   12296 <init_child_process+0xf6>
            }
        } else if (klen == 6) {
            if (!memcmp(key, "domain", 6)) {
   12362:	48 8d 35 fe c2 00 00 	lea    0xc2fe(%rip),%rsi        # 1e667 <slab_levels+0x53c7>
   12369:	ba 06 00 00 00       	mov    $0x6,%edx
   1236e:	4c 89 f7             	mov    %r14,%rdi
   12371:	e8 9a 3f 00 00       	callq  16310 <memcmp>
   12376:	85 c0                	test   %eax,%eax
   12378:	0f 85 18 ff ff ff    	jne    12296 <init_child_process+0xf6>
                /* format: domain=id */
                pal_sec_info.domain_id = strtol(val, NULL, 16);
   1237e:	ba 10 00 00 00       	mov    $0x10,%edx
   12383:	31 f6                	xor    %esi,%esi
   12385:	48 89 df             	mov    %rbx,%rdi
   12388:	e8 33 44 00 00       	callq  167c0 <strtol>
   1238d:	48 8b 15 14 17 21 00 	mov    0x211714(%rip),%rdx        # 223aa8 <_DYNAMIC+0x2c0>
   12394:	89 42 08             	mov    %eax,0x8(%rdx)
   12397:	e9 fa fe ff ff       	jmpq   12296 <init_child_process+0xf6>
            c++;
            continue;
        }

        val = (++c);
        while (*c && *c != ';')
   1239c:	45 31 e4             	xor    %r12d,%r12d
   1239f:	e9 c3 fe ff ff       	jmpq   12267 <init_child_process+0xc7>
            if (!memcmp(key, "domain", 6)) {
                /* format: domain=id */
                pal_sec_info.domain_id = strtol(val, NULL, 16);
            }
        } else if (klen == 8) {
            if (!memcmp(key, "manifest", 8)) {
   123a4:	48 8d 35 16 c7 00 00 	lea    0xc716(%rip),%rsi        # 1eac1 <slab_levels+0x5821>
   123ab:	ba 08 00 00 00       	mov    $0x8,%edx
   123b0:	4c 89 f7             	mov    %r14,%rdi
   123b3:	e8 58 3f 00 00       	callq  16310 <memcmp>
   123b8:	85 c0                	test   %eax,%eax
   123ba:	0f 85 d6 fe ff ff    	jne    12296 <init_child_process+0xf6>
                /* format: manifest=fd,uri */
                read_child_handle(val, vlen, &pal_config.manifest_handle,
   123c0:	48 8b 05 59 16 21 00 	mov    0x211659(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
   123c7:	44 89 e6             	mov    %r12d,%esi
   123ca:	48 89 df             	mov    %rbx,%rdi
   123cd:	48 8d 50 10          	lea    0x10(%rax),%rdx
   123d1:	48 89 c1             	mov    %rax,%rcx
   123d4:	e8 97 f5 ff ff       	callq  11970 <read_child_handle>
   123d9:	e9 b8 fe ff ff       	jmpq   12296 <init_child_process+0xf6>
        if (klen == 4) {
            if (!memcmp(key, "exec", 4)) {
                /* format: exec=fd,uri */
                read_child_handle(val, vlen, &pal_config.exec_handle,
                                  &pal_config.exec);
            } else if (!memcmp(key, "proc", 4)) {
   123de:	48 8d 35 6d c2 00 00 	lea    0xc26d(%rip),%rsi        # 1e652 <slab_levels+0x53b2>
   123e5:	ba 04 00 00 00       	mov    $0x4,%edx
   123ea:	4c 89 f7             	mov    %r14,%rdi
   123ed:	e8 1e 3f 00 00       	callq  16310 <memcmp>
   123f2:	85 c0                	test   %eax,%eax
   123f4:	0f 85 cc 00 00 00    	jne    124c6 <init_child_process+0x326>
                /* format: proc=fd,pid */
                int fds[3], pid;
                read_child_args(val, vlen,
   123fa:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
   123fe:	48 83 ec 08          	sub    $0x8,%rsp
   12402:	4c 8b 4d a0          	mov    -0x60(%rbp),%r9
   12406:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
   1240a:	6a 01                	pushq  $0x1
   1240c:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   12412:	ff 75 90             	pushq  -0x70(%rbp)
   12415:	6a 01                	pushq  $0x1
   12417:	44 89 e6             	mov    %r12d,%esi
   1241a:	4c 89 fa             	mov    %r15,%rdx
   1241d:	48 89 df             	mov    %rbx,%rdi
   12420:	e8 5b f4 ff ff       	callq  11880 <read_child_args.constprop.0>
   12425:	4d 8d 4f 0c          	lea    0xc(%r15),%r9
   12429:	4c 89 f9             	mov    %r15,%rcx
   1242c:	48 83 c4 20          	add    $0x20,%rsp
    }
}

static inline bool set_fd_cloexec (int fd)
{
    return !(IS_ERR(INLINE_SYSCALL(fcntl, 3, fd, F_SETFD, FD_CLOEXEC)));
   12430:	41 b8 5c 00 00 00    	mov    $0x5c,%r8d
   12436:	48 63 39             	movslq (%rcx),%rdi
   12439:	ba 01 00 00 00       	mov    $0x1,%edx
   1243e:	be 02 00 00 00       	mov    $0x2,%esi
   12443:	44 89 c0             	mov    %r8d,%eax
   12446:	cd 80                	int    $0x80
   12448:	48 89 c2             	mov    %rax,%rdx
   1244b:	bb 00 00 00 00       	mov    $0x0,%ebx
   12450:	83 d3 00             	adc    $0x0,%ebx
   12453:	31 c0                	xor    %eax,%eax
   12455:	85 db                	test   %ebx,%ebx
   12457:	0f 95 c0             	setne  %al
   1245a:	48 89 c6             	mov    %rax,%rsi
   1245d:	48 f7 de             	neg    %rsi
   12460:	48 31 f2             	xor    %rsi,%rdx
                read_child_args(val, vlen,
                                &fds[0], true, &fds[1], true, &fds[2], true,
                                &pid, true);

                for (int i = 0 ; i < 3 ; i++)
                    if (!set_fd_cloexec(fds[i]))
   12463:	48 01 c2             	add    %rax,%rdx
   12466:	0f 88 a1 00 00 00    	js     1250d <init_child_process+0x36d>
   1246c:	48 83 c1 04          	add    $0x4,%rcx
                int fds[3], pid;
                read_child_args(val, vlen,
                                &fds[0], true, &fds[1], true, &fds[2], true,
                                &pid, true);

                for (int i = 0 ; i < 3 ; i++)
   12470:	4c 39 c9             	cmp    %r9,%rcx
   12473:	75 c1                	jne    12436 <init_child_process+0x296>
                    if (!set_fd_cloexec(fds[i]))
                        fds[i] = PAL_IDX_POISON;

                PAL_HANDLE proc = malloc(HANDLE_SIZE(process));
   12475:	bf 20 00 00 00       	mov    $0x20,%edi
   1247a:	e8 81 65 ff ff       	callq  8a00 <malloc>
                SET_HANDLE_TYPE(proc, process);
   1247f:	c7 00 0c 00 00 00    	movl   $0xc,(%rax)
   12485:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
                proc->__in.flags |= RFD(0)|WFD(1)|RFD(2)|WFD(2)|WRITEABLE(1)|WRITEABLE(2);
   1248c:	c7 40 08 b5 01 00 00 	movl   $0x1b5,0x8(%rax)
                proc->process.stream_in  = fds[0];
   12493:	8b 55 c0             	mov    -0x40(%rbp),%edx
   12496:	89 50 0c             	mov    %edx,0xc(%rax)
                proc->process.stream_out = fds[1];
   12499:	8b 55 c4             	mov    -0x3c(%rbp),%edx
   1249c:	89 50 10             	mov    %edx,0x10(%rax)
                proc->process.cargo      = fds[2];
   1249f:	8b 55 c8             	mov    -0x38(%rbp),%edx
   124a2:	89 50 14             	mov    %edx,0x14(%rax)
                proc->process.pid = pid;
   124a5:	8b 55 bc             	mov    -0x44(%rbp),%edx
   124a8:	89 50 18             	mov    %edx,0x18(%rax)
                __pal_control.parent_process = proc;
   124ab:	48 8b 15 c6 16 21 00 	mov    0x2116c6(%rip),%rdx        # 223b78 <_DYNAMIC+0x390>
   124b2:	48 89 42 40          	mov    %rax,0x40(%rdx)
   124b6:	e9 db fd ff ff       	jmpq   12296 <init_child_process+0xf6>

    while (*c) {
        const char * key = c, * val;
        int klen, vlen;

        while (*c && *c != '=' && *c != ';')
   124bb:	4d 89 f5             	mov    %r14,%r13
            c++;

        klen = c - key;
   124be:	45 31 ff             	xor    %r15d,%r15d
   124c1:	e9 61 fd ff ff       	jmpq   12227 <init_child_process+0x87>
                proc->process.stream_in  = fds[0];
                proc->process.stream_out = fds[1];
                proc->process.cargo      = fds[2];
                proc->process.pid = pid;
                __pal_control.parent_process = proc;
            } else if (!memcmp(key, "pipe", 4)) {
   124c6:	48 8d 35 a2 ce 00 00 	lea    0xcea2(%rip),%rsi        # 1f36f <sys_nerr_internal+0x233>
   124cd:	ba 04 00 00 00       	mov    $0x4,%edx
   124d2:	4c 89 f7             	mov    %r14,%rdi
   124d5:	e8 36 3e 00 00       	callq  16310 <memcmp>
   124da:	85 c0                	test   %eax,%eax
   124dc:	74 3a                	je     12518 <init_child_process+0x378>
                /* format: pipe=prefix */
                char * prefix = remalloc(val, vlen + 1);
                prefix[vlen] = 0;
                pal_sec_info.pipe_prefix = prefix;
            } else if (!memcmp(key, "rand", 4)) {
   124de:	48 8d 35 72 c1 00 00 	lea    0xc172(%rip),%rsi        # 1e657 <slab_levels+0x53b7>
   124e5:	ba 04 00 00 00       	mov    $0x4,%edx
   124ea:	4c 89 f7             	mov    %r14,%rdi
   124ed:	e8 1e 3e 00 00       	callq  16310 <memcmp>
   124f2:	85 c0                	test   %eax,%eax
   124f4:	75 47                	jne    1253d <init_child_process+0x39d>
                /* format: rand=fd */
                pal_sec_info.rand_gen = atoi(val);
   124f6:	48 89 df             	mov    %rbx,%rdi
   124f9:	e8 f2 43 00 00       	callq  168f0 <atoi>
   124fe:	48 8b 15 a3 15 21 00 	mov    0x2115a3(%rip),%rdx        # 223aa8 <_DYNAMIC+0x2c0>
   12505:	89 42 18             	mov    %eax,0x18(%rdx)
   12508:	e9 89 fd ff ff       	jmpq   12296 <init_child_process+0xf6>
                                &fds[0], true, &fds[1], true, &fds[2], true,
                                &pid, true);

                for (int i = 0 ; i < 3 ; i++)
                    if (!set_fd_cloexec(fds[i]))
                        fds[i] = PAL_IDX_POISON;
   1250d:	c7 01 ff ff ff ff    	movl   $0xffffffff,(%rcx)
   12513:	e9 54 ff ff ff       	jmpq   1246c <init_child_process+0x2cc>
                proc->process.cargo      = fds[2];
                proc->process.pid = pid;
                __pal_control.parent_process = proc;
            } else if (!memcmp(key, "pipe", 4)) {
                /* format: pipe=prefix */
                char * prefix = remalloc(val, vlen + 1);
   12518:	41 8d 74 24 01       	lea    0x1(%r12),%esi
   1251d:	48 89 df             	mov    %rbx,%rdi
   12520:	e8 db 66 ff ff       	callq  8c00 <remalloc>
                prefix[vlen] = 0;
                pal_sec_info.pipe_prefix = prefix;
   12525:	48 8b 15 7c 15 21 00 	mov    0x21157c(%rip),%rdx        # 223aa8 <_DYNAMIC+0x2c0>
                proc->process.pid = pid;
                __pal_control.parent_process = proc;
            } else if (!memcmp(key, "pipe", 4)) {
                /* format: pipe=prefix */
                char * prefix = remalloc(val, vlen + 1);
                prefix[vlen] = 0;
   1252c:	4d 63 dc             	movslq %r12d,%r11
   1252f:	42 c6 04 18 00       	movb   $0x0,(%rax,%r11,1)
                pal_sec_info.pipe_prefix = prefix;
   12534:	48 89 42 10          	mov    %rax,0x10(%rdx)
   12538:	e9 59 fd ff ff       	jmpq   12296 <init_child_process+0xf6>
            } else if (!memcmp(key, "rand", 4)) {
                /* format: rand=fd */
                pal_sec_info.rand_gen = atoi(val);
            } else if (!memcmp(key, "heap", 4)) {
   1253d:	48 8d 35 18 c1 00 00 	lea    0xc118(%rip),%rsi        # 1e65c <slab_levels+0x53bc>
   12544:	ba 04 00 00 00       	mov    $0x4,%edx
   12549:	4c 89 f7             	mov    %r14,%rdi
   1254c:	e8 bf 3d 00 00       	callq  16310 <memcmp>
   12551:	85 c0                	test   %eax,%eax
   12553:	0f 85 3d fd ff ff    	jne    12296 <init_child_process+0xf6>
                /* format: heap=addr (hex) */
                pal_config.heap_base = (void *) strtol(val, NULL, 16);
   12559:	ba 10 00 00 00       	mov    $0x10,%edx
   1255e:	31 f6                	xor    %esi,%esi
   12560:	48 89 df             	mov    %rbx,%rdi
   12563:	e8 58 42 00 00       	callq  167c0 <strtol>
   12568:	48 8b 15 b1 14 21 00 	mov    0x2114b1(%rip),%rdx        # 223a20 <_DYNAMIC+0x238>
   1256f:	48 89 42 50          	mov    %rax,0x50(%rdx)
   12573:	e9 1e fd ff ff       	jmpq   12296 <init_child_process+0xf6>
   12578:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1257f:	00 

0000000000012580 <_DkProcessExit>:

    return 0;
}

void _DkProcessExit (int exitcode)
{
   12580:	55                   	push   %rbp
   12581:	48 89 e5             	mov    %rsp,%rbp
   12584:	41 54                	push   %r12
   12586:	53                   	push   %rbx
    if (__pal_control.parent_process)
   12587:	48 8b 1d ea 15 21 00 	mov    0x2115ea(%rip),%rbx        # 223b78 <_DYNAMIC+0x390>

    return 0;
}

void _DkProcessExit (int exitcode)
{
   1258e:	41 89 fc             	mov    %edi,%r12d
    if (__pal_control.parent_process)
   12591:	48 8b 7b 40          	mov    0x40(%rbx),%rdi
   12595:	48 85 ff             	test   %rdi,%rdi
   12598:	74 05                	je     1259f <_DkProcessExit+0x1f>
        _DkObjectClose(__pal_control.parent_process);
   1259a:	e8 a1 32 ff ff       	callq  5840 <_DkObjectClose>

    if (__pal_control.manifest_handle)
   1259f:	48 8b 3b             	mov    (%rbx),%rdi
   125a2:	48 85 ff             	test   %rdi,%rdi
   125a5:	74 05                	je     125ac <_DkProcessExit+0x2c>
        _DkObjectClose(__pal_control.manifest_handle);
   125a7:	e8 94 32 ff ff       	callq  5840 <_DkObjectClose>

    //INLINE_SYSCALL(exit_group, 1, exitcode); -> No exit group in BSD. alternative?
    INLINE_SYSCALL(exit, 1, exitcode);
   125ac:	49 63 fc             	movslq %r12d,%rdi
   125af:	b8 01 00 00 00       	mov    $0x1,%eax
   125b4:	cd 80                	int    $0x80
   125b6:	bb 00 00 00 00       	mov    $0x0,%ebx
   125bb:	83 d3 00             	adc    $0x0,%ebx
}
   125be:	5b                   	pop    %rbx
   125bf:	41 5c                	pop    %r12
   125c1:	5d                   	pop    %rbp
   125c2:	c3                   	retq   
   125c3:	66 66 66 66 2e 0f 1f 	nopw   %cs:0x0(%rax,%rax,1)
   125ca:	84 00 00 00 00 00 

00000000000125d0 <_DkProcessSandboxCreate>:
    DkObjectClose(handle);
    return ret;
}

int _DkProcessSandboxCreate (const char * manifest, int flags)
{
   125d0:	55                   	push   %rbp
   125d1:	48 89 e5             	mov    %rsp,%rbp
    return set_graphene_task(manifest, flags);
}
   125d4:	5d                   	pop    %rbp
    return ret;
}

int _DkProcessSandboxCreate (const char * manifest, int flags)
{
    return set_graphene_task(manifest, flags);
   125d5:	e9 16 ee ff ff       	jmpq   113f0 <set_graphene_task>
   125da:	90                   	nop    
   125db:	90                   	nop    
   125dc:	90                   	nop    
   125dd:	90                   	nop    
   125de:	90                   	nop    
   125df:	90                   	nop    

00000000000125e0 <_DkObjectsWaitAny>:

/* _DkObjectsWaitAny for internal use. The function wait for any of the handle
   in the handle array. timeout can be set for the wait. */
int _DkObjectsWaitAny (int count, PAL_HANDLE * handleArray, int timeout,
                       PAL_HANDLE * polled)
{
   125e0:	55                   	push   %rbp
   125e1:	48 89 e5             	mov    %rsp,%rbp
   125e4:	41 57                	push   %r15
   125e6:	41 56                	push   %r14
   125e8:	41 55                	push   %r13
   125ea:	41 54                	push   %r12
   125ec:	53                   	push   %rbx
   125ed:	48 83 ec 58          	sub    $0x58,%rsp
    if (count <= 0)
   125f1:	85 ff                	test   %edi,%edi

/* _DkObjectsWaitAny for internal use. The function wait for any of the handle
   in the handle array. timeout can be set for the wait. */
int _DkObjectsWaitAny (int count, PAL_HANDLE * handleArray, int timeout,
                       PAL_HANDLE * polled)
{
   125f3:	89 55 94             	mov    %edx,-0x6c(%rbp)
   125f6:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
    if (count <= 0)
   125fa:	0f 8e 2e 02 00 00    	jle    1282e <_DkObjectsWaitAny+0x24e>
   12600:	45 31 c9             	xor    %r9d,%r9d
   12603:	45 31 db             	xor    %r11d,%r11d
        return 0;

    if (count == 1) {
   12606:	83 ff 01             	cmp    $0x1,%edi
   12609:	0f 84 1f 03 00 00    	je     1292e <_DkObjectsWaitAny+0x34e>
   1260f:	90                   	nop    

    /* we are not gonna to allow any polling on muliple synchronous
       objects, doing this is simply violating the division of
       labor between PAL and library OS */
    for (i = 0 ; i < count ; i++) {
        PAL_HANDLE hdl = handleArray[i];
   12610:	4a 8b 0c ce          	mov    (%rsi,%r9,8),%rcx
   12614:	45 89 c8             	mov    %r9d,%r8d

        if (!hdl)
   12617:	48 85 c9             	test   %rcx,%rcx
   1261a:	74 60                	je     1267c <_DkObjectsWaitAny+0x9c>
            continue;

        if (!(hdl->__in.flags & HAS_FDS))
   1261c:	44 8b 51 08          	mov    0x8(%rcx),%r10d
   12620:	41 f6 c2 3f          	test   $0x3f,%r10b
   12624:	0f 84 ad 02 00 00    	je     128d7 <_DkObjectsWaitAny+0x2f7>
            return -PAL_ERROR_NOTSUPPORT;

        /* eliminate repeated entries */
        for (j = 0 ; j < i ; j++)
   1262a:	45 85 c9             	test   %r9d,%r9d
   1262d:	0f 84 0c 02 00 00    	je     1283f <_DkObjectsWaitAny+0x25f>
            if (hdl == handleArray[j])
   12633:	48 39 0e             	cmp    %rcx,(%rsi)
   12636:	0f 84 03 02 00 00    	je     1283f <_DkObjectsWaitAny+0x25f>
   1263c:	48 8d 56 08          	lea    0x8(%rsi),%rdx
   12640:	31 c0                	xor    %eax,%eax
   12642:	eb 0a                	jmp    1264e <_DkObjectsWaitAny+0x6e>
   12644:	48 83 c2 08          	add    $0x8,%rdx
   12648:	48 39 4a f8          	cmp    %rcx,-0x8(%rdx)
   1264c:	74 2e                	je     1267c <_DkObjectsWaitAny+0x9c>

        if (!(hdl->__in.flags & HAS_FDS))
            return -PAL_ERROR_NOTSUPPORT;

        /* eliminate repeated entries */
        for (j = 0 ; j < i ; j++)
   1264e:	83 c0 01             	add    $0x1,%eax
   12651:	44 39 c0             	cmp    %r8d,%eax
   12654:	75 ee                	jne    12644 <_DkObjectsWaitAny+0x64>
            if (hdl == handleArray[j])
                break;
        if (j == i) {
            for (j = 0 ; j < MAX_FDS ; j++)
                if (hdl->__in.flags & (RFD(j)|WFD(j)))
   12656:	44 89 d0             	mov    %r10d,%eax
   12659:	83 e0 09             	and    $0x9,%eax
                    maxfds++;
   1265c:	83 f8 01             	cmp    $0x1,%eax
        for (j = 0 ; j < i ; j++)
            if (hdl == handleArray[j])
                break;
        if (j == i) {
            for (j = 0 ; j < MAX_FDS ; j++)
                if (hdl->__in.flags & (RFD(j)|WFD(j)))
   1265f:	44 89 d0             	mov    %r10d,%eax
                    maxfds++;
   12662:	41 83 db ff          	sbb    $0xffffffffffffffff,%r11d
        for (j = 0 ; j < i ; j++)
            if (hdl == handleArray[j])
                break;
        if (j == i) {
            for (j = 0 ; j < MAX_FDS ; j++)
                if (hdl->__in.flags & (RFD(j)|WFD(j)))
   12666:	83 e0 12             	and    $0x12,%eax
                    maxfds++;
   12669:	83 f8 01             	cmp    $0x1,%eax
   1266c:	41 83 db ff          	sbb    $0xffffffffffffffff,%r11d
        for (j = 0 ; j < i ; j++)
            if (hdl == handleArray[j])
                break;
        if (j == i) {
            for (j = 0 ; j < MAX_FDS ; j++)
                if (hdl->__in.flags & (RFD(j)|WFD(j)))
   12670:	41 83 e2 24          	and    $0x24,%r10d
                    maxfds++;
   12674:	41 83 fa 01          	cmp    $0x1,%r10d
   12678:	41 83 db ff          	sbb    $0xffffffffffffffff,%r11d
   1267c:	49 83 c1 01          	add    $0x1,%r9
    int i, j, ret, maxfds = 0, nfds = 0;

    /* we are not gonna to allow any polling on muliple synchronous
       objects, doing this is simply violating the division of
       labor between PAL and library OS */
    for (i = 0 ; i < count ; i++) {
   12680:	44 39 cf             	cmp    %r9d,%edi
   12683:	7f 8b                	jg     12610 <_DkObjectsWaitAny+0x30>
                if (hdl->__in.flags & (RFD(j)|WFD(j)))
                    maxfds++;
        }
    }

    struct pollfd * fds = __alloca(sizeof(struct pollfd) * maxfds);
   12685:	4d 63 db             	movslq %r11d,%r11
    PAL_HANDLE * hdls = __alloca(sizeof(PAL_HANDLE) * maxfds);
   12688:	45 31 c0             	xor    %r8d,%r8d
    if (count == 1) {
        *polled = handleArray[0];
        return _DkObjectWaitOne(handleArray[0], timeout);
    }

    int i, j, ret, maxfds = 0, nfds = 0;
   1268b:	45 31 d2             	xor    %r10d,%r10d
                if (hdl->__in.flags & (RFD(j)|WFD(j)))
                    maxfds++;
        }
    }

    struct pollfd * fds = __alloca(sizeof(struct pollfd) * maxfds);
   1268e:	4a 8d 04 dd 1e 00 00 	lea    0x1e(,%r11,8),%rax
   12695:	00 
            continue;

        for (j = 0 ; j < MAX_FDS ; j++) {
            int events = 0;

            if ((hdl->__in.flags & RFD(j)) &&
   12696:	41 be 01 00 00 00    	mov    $0x1,%r14d
                !(hdl->__in.flags & ERROR(j)))
                events |= POLLIN;

            if ((hdl->__in.flags & WFD(j)) &&
   1269c:	41 bd 08 00 00 00    	mov    $0x8,%r13d
                if (hdl->__in.flags & (RFD(j)|WFD(j)))
                    maxfds++;
        }
    }

    struct pollfd * fds = __alloca(sizeof(struct pollfd) * maxfds);
   126a2:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
   126a6:	48 29 c4             	sub    %rax,%rsp
   126a9:	4c 8d 64 24 0f       	lea    0xf(%rsp),%r12
    PAL_HANDLE * hdls = __alloca(sizeof(PAL_HANDLE) * maxfds);
   126ae:	48 29 c4             	sub    %rax,%rsp
   126b1:	48 8d 44 24 0f       	lea    0xf(%rsp),%rax
                if (hdl->__in.flags & (RFD(j)|WFD(j)))
                    maxfds++;
        }
    }

    struct pollfd * fds = __alloca(sizeof(struct pollfd) * maxfds);
   126b6:	49 83 e4 f0          	and    $0xfffffffffffffff0,%r12
    PAL_HANDLE * hdls = __alloca(sizeof(PAL_HANDLE) * maxfds);
   126ba:	48 83 e0 f0          	and    $0xfffffffffffffff0,%rax
   126be:	48 89 45 98          	mov    %rax,-0x68(%rbp)

    for (i = 0 ; i < count ; i++) {
        PAL_HANDLE hdl = handleArray[i];
   126c2:	4a 8b 04 c6          	mov    (%rsi,%r8,8),%rax

        if (!hdl)
   126c6:	48 85 c0             	test   %rax,%rax
   126c9:	0f 84 af 00 00 00    	je     1277e <_DkObjectsWaitAny+0x19e>
            continue;

        for (j = 0 ; j < i ; j++)
   126cf:	45 85 c0             	test   %r8d,%r8d
   126d2:	74 2f                	je     12703 <_DkObjectsWaitAny+0x123>
            if (hdl == handleArray[j])
   126d4:	48 39 06             	cmp    %rax,(%rsi)
   126d7:	0f 84 a1 00 00 00    	je     1277e <_DkObjectsWaitAny+0x19e>
   126dd:	41 8d 48 ff          	lea    -0x1(%r8),%ecx
   126e1:	48 8d 56 08          	lea    0x8(%rsi),%rdx
   126e5:	48 8d 4c ce 08       	lea    0x8(%rsi,%rcx,8),%rcx
   126ea:	eb 12                	jmp    126fe <_DkObjectsWaitAny+0x11e>
   126ec:	0f 1f 40 00          	nopl   0x0(%rax)
   126f0:	48 83 c2 08          	add    $0x8,%rdx
   126f4:	48 39 42 f8          	cmp    %rax,-0x8(%rdx)
   126f8:	0f 84 80 00 00 00    	je     1277e <_DkObjectsWaitAny+0x19e>
        PAL_HANDLE hdl = handleArray[i];

        if (!hdl)
            continue;

        for (j = 0 ; j < i ; j++)
   126fe:	48 39 ca             	cmp    %rcx,%rdx
   12701:	75 ed                	jne    126f0 <_DkObjectsWaitAny+0x110>
   12703:	44 8b 48 08          	mov    0x8(%rax),%r9d
    if (count == 1) {
        *polled = handleArray[0];
        return _DkObjectWaitOne(handleArray[0], timeout);
    }

    int i, j, ret, maxfds = 0, nfds = 0;
   12707:	31 d2                	xor    %edx,%edx
            continue;

        for (j = 0 ; j < MAX_FDS ; j++) {
            int events = 0;

            if ((hdl->__in.flags & RFD(j)) &&
   12709:	44 89 f3             	mov    %r14d,%ebx
   1270c:	89 d1                	mov    %edx,%ecx
   1270e:	41 89 d3             	mov    %edx,%r11d
   12711:	d3 e3                	shl    %cl,%ebx
   12713:	44 85 cb             	test   %r9d,%ebx
   12716:	0f 84 34 01 00 00    	je     12850 <_DkObjectsWaitAny+0x270>
                !(hdl->__in.flags & ERROR(j)))
   1271c:	bb 00 02 00 00       	mov    $0x200,%ebx
   12721:	89 d1                	mov    %edx,%ecx
   12723:	d3 e3                	shl    %cl,%ebx
            continue;

        for (j = 0 ; j < MAX_FDS ; j++) {
            int events = 0;

            if ((hdl->__in.flags & RFD(j)) &&
   12725:	44 85 cb             	test   %r9d,%ebx
   12728:	0f 85 22 01 00 00    	jne    12850 <_DkObjectsWaitAny+0x270>
                !(hdl->__in.flags & ERROR(j)))
                events |= POLLIN;

            if ((hdl->__in.flags & WFD(j)) &&
   1272e:	45 89 ef             	mov    %r13d,%r15d
   12731:	89 d1                	mov    %edx,%ecx
   12733:	41 d3 e7             	shl    %cl,%r15d
   12736:	45 85 cf             	test   %r9d,%r15d
   12739:	0f 85 42 01 00 00    	jne    12881 <_DkObjectsWaitAny+0x2a1>
        for (j = 0 ; j < MAX_FDS ; j++) {
            int events = 0;

            if ((hdl->__in.flags & RFD(j)) &&
                !(hdl->__in.flags & ERROR(j)))
                events |= POLLIN;
   1273f:	b9 01 00 00 00       	mov    $0x1,%ecx
            if ((hdl->__in.flags & WFD(j)) &&
                !(hdl->__in.flags & WRITEABLE(j)) &&
                !(hdl->__in.flags & ERROR(j)))
                events |= POLLOUT;

            if (events && hdl->__in.fds[j] != PAL_IDX_POISON) {
   12744:	44 8b 7c 90 0c       	mov    0xc(%rax,%rdx,4),%r15d
   12749:	41 83 ff ff          	cmp    $0xffffffffffffffff,%r15d
   1274d:	74 25                	je     12774 <_DkObjectsWaitAny+0x194>
                fds[nfds].fd = hdl->__in.fds[j];
   1274f:	49 63 da             	movslq %r10d,%rbx
                fds[nfds].events = events|POLLHUP|POLLERR;
   12752:	83 c9 18             	or     $0x18,%ecx
                fds[nfds].revents = 0;
                hdls[nfds] = hdl;
                nfds++;
   12755:	41 83 c2 01          	add    $0x1,%r10d
                !(hdl->__in.flags & WRITEABLE(j)) &&
                !(hdl->__in.flags & ERROR(j)))
                events |= POLLOUT;

            if (events && hdl->__in.fds[j] != PAL_IDX_POISON) {
                fds[nfds].fd = hdl->__in.fds[j];
   12759:	4d 8d 1c dc          	lea    (%r12,%rbx,8),%r11
                fds[nfds].events = events|POLLHUP|POLLERR;
   1275d:	66 41 89 4b 04       	mov    %cx,0x4(%r11)
                fds[nfds].revents = 0;
   12762:	31 c9                	xor    %ecx,%ecx
                !(hdl->__in.flags & WRITEABLE(j)) &&
                !(hdl->__in.flags & ERROR(j)))
                events |= POLLOUT;

            if (events && hdl->__in.fds[j] != PAL_IDX_POISON) {
                fds[nfds].fd = hdl->__in.fds[j];
   12764:	45 89 3b             	mov    %r15d,(%r11)
                fds[nfds].events = events|POLLHUP|POLLERR;
                fds[nfds].revents = 0;
   12767:	66 41 89 4b 06       	mov    %cx,0x6(%r11)
                hdls[nfds] = hdl;
   1276c:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
   12770:	48 89 04 d9          	mov    %rax,(%rcx,%rbx,8)
   12774:	48 83 c2 01          	add    $0x1,%rdx
            if (hdl == handleArray[j])
                break;
        if (j < i)
            continue;

        for (j = 0 ; j < MAX_FDS ; j++) {
   12778:	48 83 fa 03          	cmp    $0x3,%rdx
   1277c:	75 8b                	jne    12709 <_DkObjectsWaitAny+0x129>
   1277e:	49 83 c0 01          	add    $0x1,%r8
    }

    struct pollfd * fds = __alloca(sizeof(struct pollfd) * maxfds);
    PAL_HANDLE * hdls = __alloca(sizeof(PAL_HANDLE) * maxfds);

    for (i = 0 ; i < count ; i++) {
   12782:	44 39 c7             	cmp    %r8d,%edi
   12785:	0f 8f 37 ff ff ff    	jg     126c2 <_DkObjectsWaitAny+0xe2>
                nfds++;
            }
        }
    }

    if (!nfds)
   1278b:	45 85 d2             	test   %r10d,%r10d
   1278e:	0f 84 57 01 00 00    	je     128eb <_DkObjectsWaitAny+0x30b>
/*#ifdef SYS_ppoll
    ret = INLINE_SYSCALL(ppoll, 5, fds, nfds,
                         timeout >= 0 ? &timeout_ts : NULL,
                         NULL, 0);
#else*/    
	ret = INLINE_SYSCALL(poll, 3, fds, nfds,
   12794:	bb d1 00 00 00       	mov    $0xd1,%ebx
   12799:	48 63 55 94          	movslq -0x6c(%rbp),%rdx
   1279d:	49 63 f2             	movslq %r10d,%rsi
   127a0:	4c 89 e7             	mov    %r12,%rdi
   127a3:	89 d8                	mov    %ebx,%eax
   127a5:	cd 80                	int    $0x80
   127a7:	48 89 c1             	mov    %rax,%rcx
   127aa:	bb 00 00 00 00       	mov    $0x0,%ebx
   127af:	83 d3 00             	adc    $0x0,%ebx
   127b2:	31 d2                	xor    %edx,%edx
   127b4:	85 db                	test   %ebx,%ebx
   127b6:	0f 95 c2             	setne  %dl
   127b9:	48 89 d0             	mov    %rdx,%rax
   127bc:	48 f7 d8             	neg    %rax
   127bf:	48 31 c8             	xor    %rcx,%rax
   127c2:	48 01 c2             	add    %rax,%rdx
	                  timeout);
//#endif

    if (IS_ERR(ret))
   127c5:	85 d2                	test   %edx,%edx
   127c7:	0f 88 32 01 00 00    	js     128ff <_DkObjectsWaitAny+0x31f>
                return -PAL_ERROR_INTERRUPTED;
            default:
                return unix_to_pal_error(ERRNO(ret));
        }

    if (!ret)
   127cd:	0f 84 18 01 00 00    	je     128eb <_DkObjectsWaitAny+0x30b>
   127d3:	31 c0                	xor    %eax,%eax
   127d5:	45 31 c0             	xor    %r8d,%r8d
        } else {
            polled_hdl = hdl;
        }

        for (j = 0 ; j < MAX_FDS ; j++)
            if ((hdl->__in.flags & (RFD(j)|WFD(j))) &&
   127d8:	bb 08 00 00 00       	mov    $0x8,%ebx
   127dd:	41 bb 01 00 00 00    	mov    $0x1,%r11d
            continue;

        if (fds[i].revents & POLLOUT)
            hdl->__in.flags |= WRITEABLE(j);
        if (fds[i].revents & (POLLHUP|POLLERR))
            hdl->__in.flags |= ERROR(j);
   127e3:	41 be 00 02 00 00    	mov    $0x200,%r14d

        if (j == MAX_FDS)
            continue;

        if (fds[i].revents & POLLOUT)
            hdl->__in.flags |= WRITEABLE(j);
   127e9:	41 bf 40 00 00 00    	mov    $0x40,%r15d
   127ef:	90                   	nop    
        return -PAL_ERROR_TRYAGAIN;

    PAL_HANDLE polled_hdl = NULL;

    for (i = 0 ; i < nfds ; i++) {
        if (!fds[i].revents)
   127f0:	41 0f b7 54 c4 06    	movzwl 0x6(%r12,%rax,8),%edx
   127f6:	66 85 d2             	test   %dx,%dx
   127f9:	74 1a                	je     12815 <_DkObjectsWaitAny+0x235>
            continue;

        PAL_HANDLE hdl = hdls[i];
   127fb:	48 8b 7d 98          	mov    -0x68(%rbp),%rdi

        if (polled_hdl) {
   127ff:	4d 85 c0             	test   %r8,%r8

    for (i = 0 ; i < nfds ; i++) {
        if (!fds[i].revents)
            continue;

        PAL_HANDLE hdl = hdls[i];
   12802:	48 8b 3c c7          	mov    (%rdi,%rax,8),%rdi

        if (polled_hdl) {
   12806:	0f 84 96 00 00 00    	je     128a2 <_DkObjectsWaitAny+0x2c2>
            if (hdl != polled_hdl)
   1280c:	4c 39 c7             	cmp    %r8,%rdi
   1280f:	0f 84 90 00 00 00    	je     128a5 <_DkObjectsWaitAny+0x2c5>
   12815:	48 83 c0 01          	add    $0x1,%rax
    if (!ret)
        return -PAL_ERROR_TRYAGAIN;

    PAL_HANDLE polled_hdl = NULL;

    for (i = 0 ; i < nfds ; i++) {
   12819:	41 39 c2             	cmp    %eax,%r10d
   1281c:	7f d2                	jg     127f0 <_DkObjectsWaitAny+0x210>
            hdl->__in.flags |= WRITEABLE(j);
        if (fds[i].revents & (POLLHUP|POLLERR))
            hdl->__in.flags |= ERROR(j);
    }

    *polled = polled_hdl;
   1281e:	48 8b 45 88          	mov    -0x78(%rbp),%rax
    return polled_hdl ? 0 : -PAL_ERROR_TRYAGAIN;
   12822:	4d 85 c0             	test   %r8,%r8
            hdl->__in.flags |= WRITEABLE(j);
        if (fds[i].revents & (POLLHUP|POLLERR))
            hdl->__in.flags |= ERROR(j);
    }

    *polled = polled_hdl;
   12825:	4c 89 00             	mov    %r8,(%rax)
    return polled_hdl ? 0 : -PAL_ERROR_TRYAGAIN;
   12828:	0f 84 bd 00 00 00    	je     128eb <_DkObjectsWaitAny+0x30b>
                handle->__in.flags |= WRITEABLE(off[i]);
            if (fds[i].revents & (POLLHUP|POLLERR))
                handle->__in.flags |= ERROR(off[i]);
        }

        return 0;
   1282e:	31 c0                	xor    %eax,%eax
            hdl->__in.flags |= ERROR(j);
    }

    *polled = polled_hdl;
    return polled_hdl ? 0 : -PAL_ERROR_TRYAGAIN;
}
   12830:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   12834:	5b                   	pop    %rbx
   12835:	41 5c                	pop    %r12
   12837:	41 5d                	pop    %r13
   12839:	41 5e                	pop    %r14
   1283b:	41 5f                	pop    %r15
   1283d:	5d                   	pop    %rbp
   1283e:	c3                   	retq   

        /* eliminate repeated entries */
        for (j = 0 ; j < i ; j++)
            if (hdl == handleArray[j])
                break;
        if (j == i) {
   1283f:	4d 85 c9             	test   %r9,%r9
   12842:	0f 85 34 fe ff ff    	jne    1267c <_DkObjectsWaitAny+0x9c>
   12848:	e9 09 fe ff ff       	jmpq   12656 <_DkObjectsWaitAny+0x76>
   1284d:	0f 1f 00             	nopl   (%rax)

            if ((hdl->__in.flags & RFD(j)) &&
                !(hdl->__in.flags & ERROR(j)))
                events |= POLLIN;

            if ((hdl->__in.flags & WFD(j)) &&
   12850:	44 89 eb             	mov    %r13d,%ebx
   12853:	44 89 d9             	mov    %r11d,%ecx
   12856:	d3 e3                	shl    %cl,%ebx
   12858:	44 85 cb             	test   %r9d,%ebx
   1285b:	0f 84 13 ff ff ff    	je     12774 <_DkObjectsWaitAny+0x194>
                !(hdl->__in.flags & WRITEABLE(j)) &&
   12861:	bb 40 00 00 00       	mov    $0x40,%ebx
   12866:	44 89 d9             	mov    %r11d,%ecx
   12869:	80 cf 02             	or     $0x2,%bh
   1286c:	d3 e3                	shl    %cl,%ebx
   1286e:	44 85 cb             	test   %r9d,%ebx
   12871:	0f 85 fd fe ff ff    	jne    12774 <_DkObjectsWaitAny+0x194>
   12877:	b9 04 00 00 00       	mov    $0x4,%ecx
   1287c:	e9 c3 fe ff ff       	jmpq   12744 <_DkObjectsWaitAny+0x164>
   12881:	89 d1                	mov    %edx,%ecx
   12883:	41 bf 40 00 00 00    	mov    $0x40,%r15d
   12889:	41 d3 e7             	shl    %cl,%r15d
   1288c:	44 09 fb             	or     %r15d,%ebx
   1288f:	44 21 cb             	and    %r9d,%ebx
        for (j = 0 ; j < MAX_FDS ; j++) {
            int events = 0;

            if ((hdl->__in.flags & RFD(j)) &&
                !(hdl->__in.flags & ERROR(j)))
                events |= POLLIN;
   12892:	83 fb 01             	cmp    $0x1,%ebx
   12895:	19 c9                	sbb    %ecx,%ecx
   12897:	83 e1 04             	and    $0x4,%ecx
   1289a:	83 c1 01             	add    $0x1,%ecx
   1289d:	e9 a2 fe ff ff       	jmpq   12744 <_DkObjectsWaitAny+0x164>

    for (i = 0 ; i < nfds ; i++) {
        if (!fds[i].revents)
            continue;

        PAL_HANDLE hdl = hdls[i];
   128a2:	49 89 f8             	mov    %rdi,%r8
   128a5:	44 8b 4f 08          	mov    0x8(%rdi),%r9d
   128a9:	31 c9                	xor    %ecx,%ecx
        } else {
            polled_hdl = hdl;
        }

        for (j = 0 ; j < MAX_FDS ; j++)
            if ((hdl->__in.flags & (RFD(j)|WFD(j))) &&
   128ab:	44 89 de             	mov    %r11d,%esi
   128ae:	41 89 cd             	mov    %ecx,%r13d
   128b1:	09 de                	or     %ebx,%esi
   128b3:	d3 e6                	shl    %cl,%esi
   128b5:	44 85 ce             	test   %r9d,%esi
   128b8:	74 0e                	je     128c8 <_DkObjectsWaitAny+0x2e8>
   128ba:	41 8b 34 c4          	mov    (%r12,%rax,8),%esi
   128be:	39 74 8f 0c          	cmp    %esi,0xc(%rdi,%rcx,4)
   128c2:	0f 84 6c 02 00 00    	je     12b34 <_DkObjectsWaitAny+0x554>
   128c8:	48 83 c1 01          	add    $0x1,%rcx
                continue;
        } else {
            polled_hdl = hdl;
        }

        for (j = 0 ; j < MAX_FDS ; j++)
   128cc:	48 83 f9 03          	cmp    $0x3,%rcx
   128d0:	75 d9                	jne    128ab <_DkObjectsWaitAny+0x2cb>
   128d2:	e9 3e ff ff ff       	jmpq   12815 <_DkObjectsWaitAny+0x235>
            hdl->__in.flags |= ERROR(j);
    }

    *polled = polled_hdl;
    return polled_hdl ? 0 : -PAL_ERROR_TRYAGAIN;
}
   128d7:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
    }

    const struct handle_ops * ops = HANDLE_OPS(handle);

    if (!ops->wait)
        return -PAL_ERROR_NOTSUPPORT;
   128db:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
            hdl->__in.flags |= ERROR(j);
    }

    *polled = polled_hdl;
    return polled_hdl ? 0 : -PAL_ERROR_TRYAGAIN;
}
   128e0:	5b                   	pop    %rbx
   128e1:	41 5c                	pop    %r12
   128e3:	41 5d                	pop    %r13
   128e5:	41 5e                	pop    %r14
   128e7:	41 5f                	pop    %r15
   128e9:	5d                   	pop    %rbp
   128ea:	c3                   	retq   
   128eb:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
        if (fds[i].revents & (POLLHUP|POLLERR))
            hdl->__in.flags |= ERROR(j);
    }

    *polled = polled_hdl;
    return polled_hdl ? 0 : -PAL_ERROR_TRYAGAIN;
   128ef:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
}
   128f4:	5b                   	pop    %rbx
   128f5:	41 5c                	pop    %r12
   128f7:	41 5d                	pop    %r13
   128f9:	41 5e                	pop    %r14
   128fb:	41 5f                	pop    %r15
   128fd:	5d                   	pop    %rbp
   128fe:	c3                   	retq   
	ret = INLINE_SYSCALL(poll, 3, fds, nfds,
	                  timeout);
//#endif

    if (IS_ERR(ret))
        switch (ERRNO(ret)) {
   128ff:	f7 da                	neg    %edx
   12901:	83 fa 04             	cmp    $0x4,%edx
   12904:	0f 84 83 01 00 00    	je     12a8d <_DkObjectsWaitAny+0x4ad>
   1290a:	83 fa 55             	cmp    $0x55,%edx
   1290d:	0f 84 7a 01 00 00    	je     12a8d <_DkObjectsWaitAny+0x4ad>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   12913:	83 fa 6e             	cmp    $0x6e,%edx
   12916:	0f 87 85 01 00 00    	ja     12aa1 <_DkObjectsWaitAny+0x4c1>
   1291c:	48 8d 05 71 bd 00 00 	lea    0xbd71(%rip),%rax        # 1e694 <slab_levels+0x53f4>
   12923:	89 d2                	mov    %edx,%edx
   12925:	48 63 14 90          	movslq (%rax,%rdx,4),%rdx
   12929:	48 01 d0             	add    %rdx,%rax
   1292c:	ff e0                	jmpq   *%rax
{
    if (count <= 0)
        return 0;

    if (count == 1) {
        *polled = handleArray[0];
   1292e:	48 8b 06             	mov    (%rsi),%rax
   12931:	48 8b 7d 88          	mov    -0x78(%rbp),%rdi
   12935:	48 89 07             	mov    %rax,(%rdi)
        return _DkObjectWaitOne(handleArray[0], timeout);
   12938:	4c 8b 06             	mov    (%rsi),%r8
   on events and semaphores */
static int _DkObjectWaitOne (PAL_HANDLE handle, int timeout)
{
    /* only for all these handle which has a file descriptor, or
       a eventfd. events and semaphores will skip this part */
    if (handle->__in.flags & HAS_FDS) {
   1293b:	41 8b 70 08          	mov    0x8(%r8),%esi
   1293f:	40 f6 c6 3f          	test   $0x3f,%sil
   12943:	0f 84 0d 01 00 00    	je     12a56 <_DkObjectsWaitAny+0x476>
   12949:	31 d2                	xor    %edx,%edx
        int off[MAX_FDS];
        int nfds = 0;
        for (int i = 0 ; i < MAX_FDS ; i++) {
            int events = 0;

            if ((handle->__in.flags & RFD(i)) &&
   1294b:	41 bc 01 00 00 00    	mov    $0x1,%r12d
                !(handle->__in.flags & ERROR(i)))
                events |= POLLIN;

            if ((handle->__in.flags & WFD(i)) &&
   12951:	bb 08 00 00 00       	mov    $0x8,%ebx
                !(handle->__in.flags & WRITEABLE(i)) &&
                !(handle->__in.flags & ERROR(i)))
   12956:	66 41 bb 00 02       	mov    $0x200,%r11w
            if ((handle->__in.flags & RFD(i)) &&
                !(handle->__in.flags & ERROR(i)))
                events |= POLLIN;

            if ((handle->__in.flags & WFD(i)) &&
                !(handle->__in.flags & WRITEABLE(i)) &&
   1295b:	41 ba 40 00 00 00    	mov    $0x40,%r10d
        int off[MAX_FDS];
        int nfds = 0;
        for (int i = 0 ; i < MAX_FDS ; i++) {
            int events = 0;

            if ((handle->__in.flags & RFD(i)) &&
   12961:	44 89 e0             	mov    %r12d,%eax
   12964:	89 d1                	mov    %edx,%ecx
   12966:	89 d7                	mov    %edx,%edi
   12968:	d3 e0                	shl    %cl,%eax
   1296a:	85 f0                	test   %esi,%eax
   1296c:	0f 84 8e 01 00 00    	je     12b00 <_DkObjectsWaitAny+0x520>
                !(handle->__in.flags & ERROR(i)))
   12972:	44 89 d8             	mov    %r11d,%eax
   12975:	d3 e0                	shl    %cl,%eax
        int off[MAX_FDS];
        int nfds = 0;
        for (int i = 0 ; i < MAX_FDS ; i++) {
            int events = 0;

            if ((handle->__in.flags & RFD(i)) &&
   12977:	85 f0                	test   %esi,%eax
   12979:	0f 85 81 01 00 00    	jne    12b00 <_DkObjectsWaitAny+0x520>
                !(handle->__in.flags & ERROR(i)))
                events |= POLLIN;

            if ((handle->__in.flags & WFD(i)) &&
   1297f:	41 89 de             	mov    %ebx,%r14d
   12982:	89 d1                	mov    %edx,%ecx
   12984:	41 d3 e6             	shl    %cl,%r14d
   12987:	41 85 f6             	test   %esi,%r14d
   1298a:	0f 85 d1 01 00 00    	jne    12b61 <_DkObjectsWaitAny+0x581>
   12990:	b8 19 00 00 00       	mov    $0x19,%eax
                !(handle->__in.flags & WRITEABLE(i)) &&
                !(handle->__in.flags & ERROR(i)))
                events |= POLLOUT;

            if (events) {
                fds[nfds].fd = handle->__in.fds[i];
   12995:	45 8b 6c 90 0c       	mov    0xc(%r8,%rdx,4),%r13d
   1299a:	49 63 c9             	movslq %r9d,%rcx
                fds[nfds].events = events|POLLHUP|POLLERR;
                fds[nfds].revents = 0;
                off[nfds] = i;
                nfds++;
   1299d:	41 83 c1 01          	add    $0x1,%r9d
                !(handle->__in.flags & ERROR(i)))
                events |= POLLOUT;

            if (events) {
                fds[nfds].fd = handle->__in.fds[i];
                fds[nfds].events = events|POLLHUP|POLLERR;
   129a1:	66 89 44 cd b4       	mov    %ax,-0x4c(%rbp,%rcx,8)
                fds[nfds].revents = 0;
                off[nfds] = i;
   129a6:	89 7c 8d a0          	mov    %edi,-0x60(%rbp,%rcx,4)
                !(handle->__in.flags & WRITEABLE(i)) &&
                !(handle->__in.flags & ERROR(i)))
                events |= POLLOUT;

            if (events) {
                fds[nfds].fd = handle->__in.fds[i];
   129aa:	44 89 6c cd b0       	mov    %r13d,-0x50(%rbp,%rcx,8)
                fds[nfds].events = events|POLLHUP|POLLERR;
                fds[nfds].revents = 0;
   129af:	45 31 ed             	xor    %r13d,%r13d
   129b2:	66 44 89 6c cd b6    	mov    %r13w,-0x4a(%rbp,%rcx,8)
   129b8:	48 83 c2 01          	add    $0x1,%rdx
         } */

        struct pollfd fds[MAX_FDS];
        int off[MAX_FDS];
        int nfds = 0;
        for (int i = 0 ; i < MAX_FDS ; i++) {
   129bc:	48 83 fa 03          	cmp    $0x3,%rdx
   129c0:	75 9f                	jne    12961 <_DkObjectsWaitAny+0x381>
                off[nfds] = i;
                nfds++;
            }
        }

        if (!nfds)
   129c2:	45 85 c9             	test   %r9d,%r9d
   129c5:	0f 84 20 ff ff ff    	je     128eb <_DkObjectsWaitAny+0x30b>
        //No ppoll in FREEBSD
	/*int ret = INLINE_SYSCALL(ppoll, 5, &fds, nfds,
                                 timeout >= 0 ? &timeout_ts : NULL,
                                 NULL, 0);*/
	
	int ret = INLINE_SYSCALL(poll, 3, &fds, nfds,timeout);
   129cb:	bb d1 00 00 00       	mov    $0xd1,%ebx
   129d0:	48 63 55 94          	movslq -0x6c(%rbp),%rdx
   129d4:	49 63 f1             	movslq %r9d,%rsi
   129d7:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
   129db:	89 d8                	mov    %ebx,%eax
   129dd:	cd 80                	int    $0x80
   129df:	48 89 c1             	mov    %rax,%rcx
   129e2:	bb 00 00 00 00       	mov    $0x0,%ebx
   129e7:	83 d3 00             	adc    $0x0,%ebx
   129ea:	31 d2                	xor    %edx,%edx
   129ec:	85 db                	test   %ebx,%ebx
   129ee:	0f 95 c2             	setne  %dl
   129f1:	48 89 d0             	mov    %rdx,%rax
   129f4:	48 f7 d8             	neg    %rax
   129f7:	48 31 c8             	xor    %rcx,%rax
   129fa:	48 01 d0             	add    %rdx,%rax

        if (IS_ERR(ret))
   129fd:	85 c0                	test   %eax,%eax
   129ff:	0f 88 79 01 00 00    	js     12b7e <_DkObjectsWaitAny+0x59e>
                    return -PAL_ERROR_INTERRUPTED;
                default:
                    return unix_to_pal_error(ERRNO(ret));
            }

        if (!ret)
   12a05:	0f 84 e0 fe ff ff    	je     128eb <_DkObjectsWaitAny+0x30b>
   12a0b:	4c 8d 55 b0          	lea    -0x50(%rbp),%r10
   12a0f:	31 c0                	xor    %eax,%eax
            if (!fds[i].revents)
                continue;
            if (fds[i].revents & POLLOUT)
                handle->__in.flags |= WRITEABLE(off[i]);
            if (fds[i].revents & (POLLHUP|POLLERR))
                handle->__in.flags |= ERROR(off[i]);
   12a11:	bf 00 02 00 00       	mov    $0x200,%edi

        for (int i = 0 ; i < nfds ; i++) {
            if (!fds[i].revents)
                continue;
            if (fds[i].revents & POLLOUT)
                handle->__in.flags |= WRITEABLE(off[i]);
   12a16:	be 40 00 00 00       	mov    $0x40,%esi

        if (!ret)
            return -PAL_ERROR_TRYAGAIN;

        for (int i = 0 ; i < nfds ; i++) {
            if (!fds[i].revents)
   12a1b:	41 0f b7 54 c2 06    	movzwl 0x6(%r10,%rax,8),%edx
   12a21:	66 85 d2             	test   %dx,%dx
   12a24:	74 22                	je     12a48 <_DkObjectsWaitAny+0x468>
                continue;
            if (fds[i].revents & POLLOUT)
   12a26:	f6 c2 04             	test   $0x4,%dl
   12a29:	74 0c                	je     12a37 <_DkObjectsWaitAny+0x457>
                handle->__in.flags |= WRITEABLE(off[i]);
   12a2b:	8b 4c 85 a0          	mov    -0x60(%rbp,%rax,4),%ecx
   12a2f:	89 f3                	mov    %esi,%ebx
   12a31:	d3 e3                	shl    %cl,%ebx
   12a33:	41 09 58 08          	or     %ebx,0x8(%r8)
            if (fds[i].revents & (POLLHUP|POLLERR))
   12a37:	83 e2 18             	and    $0x18,%edx
   12a3a:	74 0c                	je     12a48 <_DkObjectsWaitAny+0x468>
                handle->__in.flags |= ERROR(off[i]);
   12a3c:	8b 4c 85 a0          	mov    -0x60(%rbp,%rax,4),%ecx
   12a40:	89 fa                	mov    %edi,%edx
   12a42:	d3 e2                	shl    %cl,%edx
   12a44:	41 09 50 08          	or     %edx,0x8(%r8)
   12a48:	48 83 c0 01          	add    $0x1,%rax
            }

        if (!ret)
            return -PAL_ERROR_TRYAGAIN;

        for (int i = 0 ; i < nfds ; i++) {
   12a4c:	41 39 c1             	cmp    %eax,%r9d
   12a4f:	7f ca                	jg     12a1b <_DkObjectsWaitAny+0x43b>
   12a51:	e9 d8 fd ff ff       	jmpq   1282e <_DkObjectsWaitAny+0x24e>
        }

        return 0;
    }

    const struct handle_ops * ops = HANDLE_OPS(handle);
   12a56:	49 63 00             	movslq (%r8),%rax
   12a59:	8d 50 ff             	lea    -0x1(%rax),%edx
   12a5c:	83 fa 10             	cmp    $0x10,%edx
   12a5f:	0f 87 c5 00 00 00    	ja     12b2a <_DkObjectsWaitAny+0x54a>

    if (!ops->wait)
   12a65:	48 8b 15 94 0f 21 00 	mov    0x210f94(%rip),%rdx        # 223a00 <_DYNAMIC+0x218>
   12a6c:	48 8b 04 c2          	mov    (%rdx,%rax,8),%rax
   12a70:	48 8b 80 80 00 00 00 	mov    0x80(%rax),%rax
   12a77:	48 85 c0             	test   %rax,%rax
   12a7a:	0f 84 57 fe ff ff    	je     128d7 <_DkObjectsWaitAny+0x2f7>
   12a80:	8b 75 94             	mov    -0x6c(%rbp),%esi
        return -PAL_ERROR_NOTSUPPORT;

    return ops->wait(handle, timeout);
   12a83:	4c 89 c7             	mov    %r8,%rdi
   12a86:	ff d0                	callq  *%rax
   12a88:	e9 a3 fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>

    if (IS_ERR(ret))
        switch (ERRNO(ret)) {
            case EINTR:
            case ERESTART:
                return -PAL_ERROR_INTERRUPTED;
   12a8d:	b8 f3 ff ff ff       	mov    $0xfffffff3,%eax
   12a92:	e9 99 fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
   12a97:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
   12a9c:	e9 8f fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
        default:
            return -PAL_ERROR_DENIED;
   12aa1:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   12aa6:	e9 85 fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
   12aab:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
   12ab0:	e9 7b fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
        case EFAULT:
            return -PAL_ERROR_BADADDR;
   12ab5:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
   12aba:	e9 71 fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
            return -PAL_ERROR_BADHANDLE;
        case ETIMEDOUT:
        case EAGAIN:
            return -PAL_ERROR_TRYAGAIN;
        case ENOMEM:
            return -PAL_ERROR_NOMEM;
   12abf:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
   12ac4:	e9 67 fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
        case ENOENT:
            return -PAL_ERROR_STREAMNOTEXIST;
        case EINTR:
            return -PAL_ERROR_INTERRUPTED;
        case EBADF:
            return -PAL_ERROR_BADHANDLE;
   12ac9:	b8 f9 ff ff ff       	mov    $0xfffffff9,%eax
   12ace:	e9 5d fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
   12ad3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
   12ad8:	e9 53 fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
        case EINVAL:
            return -PAL_ERROR_INVAL;
   12add:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   12ae2:	e9 49 fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
        case ENAMETOOLONG:
            return -PAL_ERROR_TOOLONG;
        case EISDIR:
            return -PAL_ERROR_STREAMISDIR;
   12ae7:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
   12aec:	e9 3f fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
        case EFAULT:
            return -PAL_ERROR_BADADDR;
        case EEXIST:
            return -PAL_ERROR_STREAMEXIST;
        case ENOTDIR:
            return -PAL_ERROR_STREAMISFILE;
   12af1:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
   12af6:	e9 35 fd ff ff       	jmpq   12830 <_DkObjectsWaitAny+0x250>
   12afb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

            if ((handle->__in.flags & RFD(i)) &&
                !(handle->__in.flags & ERROR(i)))
                events |= POLLIN;

            if ((handle->__in.flags & WFD(i)) &&
   12b00:	89 d8                	mov    %ebx,%eax
   12b02:	89 f9                	mov    %edi,%ecx
   12b04:	d3 e0                	shl    %cl,%eax
   12b06:	85 f0                	test   %esi,%eax
   12b08:	0f 84 aa fe ff ff    	je     129b8 <_DkObjectsWaitAny+0x3d8>
                !(handle->__in.flags & WRITEABLE(i)) &&
   12b0e:	44 89 d0             	mov    %r10d,%eax
   12b11:	89 f9                	mov    %edi,%ecx
   12b13:	44 09 d8             	or     %r11d,%eax
   12b16:	d3 e0                	shl    %cl,%eax
   12b18:	85 f0                	test   %esi,%eax
   12b1a:	0f 85 98 fe ff ff    	jne    129b8 <_DkObjectsWaitAny+0x3d8>
   12b20:	b8 1c 00 00 00       	mov    $0x1c,%eax
   12b25:	e9 6b fe ff ff       	jmpq   12995 <_DkObjectsWaitAny+0x3b5>
        return 0;
    }

    const struct handle_ops * ops = HANDLE_OPS(handle);

    if (!ops->wait)
   12b2a:	48 8b 04 25 80 00 00 	mov    0x80,%rax
   12b31:	00 
   12b32:	0f 0b                	ud2a   
                break;

        if (j == MAX_FDS)
            continue;

        if (fds[i].revents & POLLOUT)
   12b34:	f6 c2 04             	test   $0x4,%dl
   12b37:	74 0f                	je     12b48 <_DkObjectsWaitAny+0x568>
            hdl->__in.flags |= WRITEABLE(j);
   12b39:	44 89 fe             	mov    %r15d,%esi
   12b3c:	44 89 e9             	mov    %r13d,%ecx
   12b3f:	d3 e6                	shl    %cl,%esi
   12b41:	41 09 f1             	or     %esi,%r9d
   12b44:	44 89 4f 08          	mov    %r9d,0x8(%rdi)
        if (fds[i].revents & (POLLHUP|POLLERR))
   12b48:	83 e2 18             	and    $0x18,%edx
   12b4b:	0f 84 c4 fc ff ff    	je     12815 <_DkObjectsWaitAny+0x235>
            hdl->__in.flags |= ERROR(j);
   12b51:	44 89 f2             	mov    %r14d,%edx
   12b54:	44 89 e9             	mov    %r13d,%ecx
   12b57:	d3 e2                	shl    %cl,%edx
   12b59:	09 57 08             	or     %edx,0x8(%rdi)
   12b5c:	e9 b4 fc ff ff       	jmpq   12815 <_DkObjectsWaitAny+0x235>
            if ((handle->__in.flags & RFD(i)) &&
                !(handle->__in.flags & ERROR(i)))
                events |= POLLIN;

            if ((handle->__in.flags & WFD(i)) &&
                !(handle->__in.flags & WRITEABLE(i)) &&
   12b61:	45 89 d6             	mov    %r10d,%r14d
   12b64:	89 d1                	mov    %edx,%ecx
   12b66:	41 d3 e6             	shl    %cl,%r14d
   12b69:	44 09 f0             	or     %r14d,%eax
   12b6c:	21 f0                	and    %esi,%eax
   12b6e:	83 f8 01             	cmp    $0x1,%eax
   12b71:	19 c0                	sbb    %eax,%eax
   12b73:	83 e0 04             	and    $0x4,%eax
   12b76:	83 c0 19             	add    $0x19,%eax
   12b79:	e9 17 fe ff ff       	jmpq   12995 <_DkObjectsWaitAny+0x3b5>
                                 NULL, 0);*/
	
	int ret = INLINE_SYSCALL(poll, 3, &fds, nfds,timeout);

        if (IS_ERR(ret))
            switch (ERRNO(ret)) {
   12b7e:	f7 d8                	neg    %eax
   12b80:	83 f8 04             	cmp    $0x4,%eax
   12b83:	0f 84 04 ff ff ff    	je     12a8d <_DkObjectsWaitAny+0x4ad>
   12b89:	83 f8 55             	cmp    $0x55,%eax
   12b8c:	0f 84 fb fe ff ff    	je     12a8d <_DkObjectsWaitAny+0x4ad>
# include <asm-errno.h>

static inline __attribute__((unused))
int unix_to_pal_error (int unix_errno)
{
    switch(unix_errno) {
   12b92:	83 f8 6e             	cmp    $0x6e,%eax
   12b95:	0f 87 06 ff ff ff    	ja     12aa1 <_DkObjectsWaitAny+0x4c1>
   12b9b:	48 8d 15 ae bc 00 00 	lea    0xbcae(%rip),%rdx        # 1e850 <slab_levels+0x55b0>
   12ba2:	89 c0                	mov    %eax,%eax
   12ba4:	48 63 04 82          	movslq (%rdx,%rax,4),%rax
   12ba8:	48 01 c2             	add    %rax,%rdx
   12bab:	ff e2                	jmpq   *%rdx
   12bad:	90                   	nop    
   12bae:	90                   	nop    
   12baf:	90                   	nop    

0000000000012bb0 <pal_start>:
   12bb0:	48 89 e7             	mov    %rsp,%rdi
   12bb3:	e8 68 03 00 00       	callq  12f20 <pal_linux_main>
   12bb8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   12bbf:	00 

0000000000012bc0 <loader_filter>:
#if USE_VDSO_GETTIME == 1
void setup_vdso_map (ElfW(Addr) addr);
#endif

static int loader_filter (const char * key, int len)
{
   12bc0:	55                   	push   %rbp
    return memcmp(key, "loader.", 7);
   12bc1:	48 8d 35 44 be 00 00 	lea    0xbe44(%rip),%rsi        # 1ea0c <slab_levels+0x576c>
   12bc8:	ba 07 00 00 00       	mov    $0x7,%edx
#if USE_VDSO_GETTIME == 1
void setup_vdso_map (ElfW(Addr) addr);
#endif

static int loader_filter (const char * key, int len)
{
   12bcd:	48 89 e5             	mov    %rsp,%rbp
    return memcmp(key, "loader.", 7);
}
   12bd0:	5d                   	pop    %rbp
void setup_vdso_map (ElfW(Addr) addr);
#endif

static int loader_filter (const char * key, int len)
{
    return memcmp(key, "loader.", 7);
   12bd1:	e9 3a 37 00 00       	jmpq   16310 <memcmp>
   12bd6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   12bdd:	00 00 00 

0000000000012be0 <try_open_runnable>:
    return pagesz;
}

static PAL_HANDLE try_open_runnable (const char * name, bool try_path,
                                     const char ** uri)
{
   12be0:	55                   	push   %rbp
    PAL_HANDLE handle = NULL;
    /* Try to open the manifest file specified by the first argument */
    if (_DkStreamOpen(&handle, name, PAL_ACCESS_RDONLY, 0, 0, 0) == 0) {
   12be1:	45 31 c9             	xor    %r9d,%r9d
   12be4:	45 31 c0             	xor    %r8d,%r8d
   12be7:	31 c9                	xor    %ecx,%ecx
    return pagesz;
}

static PAL_HANDLE try_open_runnable (const char * name, bool try_path,
                                     const char ** uri)
{
   12be9:	48 89 e5             	mov    %rsp,%rbp
   12bec:	41 57                	push   %r15
   12bee:	41 56                	push   %r14
   12bf0:	41 55                	push   %r13
   12bf2:	41 54                	push   %r12
   12bf4:	49 89 fc             	mov    %rdi,%r12
   12bf7:	53                   	push   %rbx
    PAL_HANDLE handle = NULL;
    /* Try to open the manifest file specified by the first argument */
    if (_DkStreamOpen(&handle, name, PAL_ACCESS_RDONLY, 0, 0, 0) == 0) {
   12bf8:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    return pagesz;
}

static PAL_HANDLE try_open_runnable (const char * name, bool try_path,
                                     const char ** uri)
{
   12bfc:	89 f3                	mov    %esi,%ebx
   12bfe:	49 89 d5             	mov    %rdx,%r13
    PAL_HANDLE handle = NULL;
    /* Try to open the manifest file specified by the first argument */
    if (_DkStreamOpen(&handle, name, PAL_ACCESS_RDONLY, 0, 0, 0) == 0) {
   12c01:	4c 89 e6             	mov    %r12,%rsi
   12c04:	31 d2                	xor    %edx,%edx
    return pagesz;
}

static PAL_HANDLE try_open_runnable (const char * name, bool try_path,
                                     const char ** uri)
{
   12c06:	48 83 ec 18          	sub    $0x18,%rsp
    PAL_HANDLE handle = NULL;
   12c0a:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
   12c11:	00 
    /* Try to open the manifest file specified by the first argument */
    if (_DkStreamOpen(&handle, name, PAL_ACCESS_RDONLY, 0, 0, 0) == 0) {
   12c12:	e8 19 0d ff ff       	callq  3930 <_DkStreamOpen>
   12c17:	85 c0                	test   %eax,%eax
   12c19:	75 25                	jne    12c40 <try_open_runnable+0x60>
        if (uri)
   12c1b:	4d 85 ed             	test   %r13,%r13
   12c1e:	74 04                	je     12c24 <try_open_runnable+0x44>
            *uri = name;
   12c20:	4d 89 65 00          	mov    %r12,0x0(%r13)
   12c24:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
        memcpy(new_uri + 5, name, len + 1);
        *uri = new_uri;
    }

    return handle;
}
   12c28:	48 83 c4 18          	add    $0x18,%rsp
   12c2c:	5b                   	pop    %rbx
   12c2d:	41 5c                	pop    %r12
   12c2f:	41 5d                	pop    %r13
   12c31:	41 5e                	pop    %r14
   12c33:	41 5f                	pop    %r15
   12c35:	5d                   	pop    %rbp
   12c36:	c3                   	retq   
   12c37:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   12c3e:	00 00 
        if (uri)
            *uri = name;
        return handle;
    }

    if (!try_path)
   12c40:	84 db                	test   %bl,%bl
   12c42:	0f 84 c8 00 00 00    	je     12d10 <try_open_runnable+0x130>
        return NULL;

    /* might be a real path, let's try open it */
    int fd = INLINE_SYSCALL(open, 3, name, O_RDONLY|O_CLOEXEC, 0);
   12c48:	b9 05 00 00 00       	mov    $0x5,%ecx
   12c4d:	31 d2                	xor    %edx,%edx
   12c4f:	be 00 00 10 00       	mov    $0x100000,%esi
   12c54:	4c 89 e7             	mov    %r12,%rdi
   12c57:	89 c8                	mov    %ecx,%eax
   12c59:	cd 80                	int    $0x80
   12c5b:	48 89 c2             	mov    %rax,%rdx
   12c5e:	bb 00 00 00 00       	mov    $0x0,%ebx
   12c63:	83 d3 00             	adc    $0x0,%ebx
   12c66:	31 c9                	xor    %ecx,%ecx
   12c68:	85 db                	test   %ebx,%ebx
   12c6a:	0f 95 c1             	setne  %cl
   12c6d:	48 89 c8             	mov    %rcx,%rax
   12c70:	48 f7 d8             	neg    %rax
   12c73:	48 31 d0             	xor    %rdx,%rax
   12c76:	48 8d 1c 08          	lea    (%rax,%rcx,1),%rbx

    if (IS_ERR(fd))
   12c7a:	85 db                	test   %ebx,%ebx
   12c7c:	0f 88 8e 00 00 00    	js     12d10 <try_open_runnable+0x130>
        return NULL;

    int len = strlen(name);
   12c82:	e8 19 3b 00 00       	callq  167a0 <strlen>
   12c87:	49 89 c6             	mov    %rax,%r14
    handle = malloc(HANDLE_SIZE(file) + len + 1);
   12c8a:	8d 78 29             	lea    0x29(%rax),%edi
    SET_HANDLE_TYPE(handle, file);
    handle->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    handle->file.fd = fd;
    char * path = (void *) handle + HANDLE_SIZE(file);
    memcpy(path, name, len + 1);
   12c8d:	45 8d 7e 01          	lea    0x1(%r14),%r15d

    if (IS_ERR(fd))
        return NULL;

    int len = strlen(name);
    handle = malloc(HANDLE_SIZE(file) + len + 1);
   12c91:	e8 6a 5d ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(handle, file);
    handle->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    handle->file.fd = fd;
   12c96:	89 58 0c             	mov    %ebx,0xc(%rax)
    char * path = (void *) handle + HANDLE_SIZE(file);
   12c99:	48 8d 58 28          	lea    0x28(%rax),%rbx
    memcpy(path, name, len + 1);
   12c9d:	4d 63 ff             	movslq %r15d,%r15

    if (IS_ERR(fd))
        return NULL;

    int len = strlen(name);
    handle = malloc(HANDLE_SIZE(file) + len + 1);
   12ca0:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    SET_HANDLE_TYPE(handle, file);
    handle->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
   12ca4:	c7 40 08 49 00 00 00 	movl   $0x49,0x8(%rax)
    handle->file.fd = fd;
    char * path = (void *) handle + HANDLE_SIZE(file);
    memcpy(path, name, len + 1);
   12cab:	4c 89 fa             	mov    %r15,%rdx
    if (IS_ERR(fd))
        return NULL;

    int len = strlen(name);
    handle = malloc(HANDLE_SIZE(file) + len + 1);
    SET_HANDLE_TYPE(handle, file);
   12cae:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
   12cb4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
    handle->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    handle->file.fd = fd;
    char * path = (void *) handle + HANDLE_SIZE(file);
    memcpy(path, name, len + 1);
   12cbb:	4c 89 e6             	mov    %r12,%rsi
   12cbe:	48 89 df             	mov    %rbx,%rdi
   12cc1:	e8 ba 35 00 00       	callq  16280 <memcpy>
    handle->file.realpath = path;
   12cc6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax

    if (uri) {
   12cca:	4d 85 ed             	test   %r13,%r13
    SET_HANDLE_TYPE(handle, file);
    handle->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    handle->file.fd = fd;
    char * path = (void *) handle + HANDLE_SIZE(file);
    memcpy(path, name, len + 1);
    handle->file.realpath = path;
   12ccd:	48 89 58 20          	mov    %rbx,0x20(%rax)

    if (uri) {
   12cd1:	0f 84 51 ff ff ff    	je     12c28 <try_open_runnable+0x48>
        char * new_uri = malloc(len + 6);
   12cd7:	41 8d 7e 06          	lea    0x6(%r14),%edi
   12cdb:	e8 20 5d ff ff       	callq  8a00 <malloc>
        memcpy(new_uri, "file:", 5);
   12ce0:	48 8d 35 d7 60 00 00 	lea    0x60d7(%rip),%rsi        # 18dbe <handle_sizes.1924+0x63e>
    char * path = (void *) handle + HANDLE_SIZE(file);
    memcpy(path, name, len + 1);
    handle->file.realpath = path;

    if (uri) {
        char * new_uri = malloc(len + 6);
   12ce7:	48 89 c3             	mov    %rax,%rbx
        memcpy(new_uri, "file:", 5);
   12cea:	ba 05 00 00 00       	mov    $0x5,%edx
   12cef:	48 89 c7             	mov    %rax,%rdi
   12cf2:	e8 89 35 00 00       	callq  16280 <memcpy>
        memcpy(new_uri + 5, name, len + 1);
   12cf7:	48 8d 7b 05          	lea    0x5(%rbx),%rdi
   12cfb:	4c 89 fa             	mov    %r15,%rdx
   12cfe:	4c 89 e6             	mov    %r12,%rsi
   12d01:	e8 7a 35 00 00       	callq  16280 <memcpy>
        *uri = new_uri;
   12d06:	49 89 5d 00          	mov    %rbx,0x0(%r13)
   12d0a:	e9 15 ff ff ff       	jmpq   12c24 <try_open_runnable+0x44>
   12d0f:	90                   	nop    
            *uri = name;
        return handle;
    }

    if (!try_path)
        return NULL;
   12d10:	31 c0                	xor    %eax,%eax
   12d12:	e9 11 ff ff ff       	jmpq   12c28 <try_open_runnable+0x48>
   12d17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   12d1e:	00 00 

0000000000012d20 <_DkGetPagesize>:
    *penvp = envp;
    
}

unsigned long _DkGetPagesize (void)
{
   12d20:	55                   	push   %rbp
    return pagesz;
}
   12d21:	48 8b 05 28 19 21 00 	mov    0x211928(%rip),%rax        # 224650 <pagesz>
    *penvp = envp;
    
}

unsigned long _DkGetPagesize (void)
{
   12d28:	48 89 e5             	mov    %rsp,%rbp
    return pagesz;
}
   12d2b:	5d                   	pop    %rbp
   12d2c:	c3                   	retq   
   12d2d:	0f 1f 00             	nopl   (%rax)

0000000000012d30 <_DkGetAllocationAlignment>:

unsigned long _DkGetAllocationAlignment (void)
{
   12d30:	55                   	push   %rbp
    return pagesz;
}
   12d31:	48 8b 05 18 19 21 00 	mov    0x211918(%rip),%rax        # 224650 <pagesz>
{
    return pagesz;
}

unsigned long _DkGetAllocationAlignment (void)
{
   12d38:	48 89 e5             	mov    %rsp,%rbp
    return pagesz;
}
   12d3b:	5d                   	pop    %rbp
   12d3c:	c3                   	retq   
   12d3d:	0f 1f 00             	nopl   (%rax)

0000000000012d40 <read_shebang>:

    return handle;
}

int read_shebang (const char ** argv)
{
   12d40:	55                   	push   %rbp
    /* must be a shebang */
    int fd = INLINE_SYSCALL(open, 3, *argv, O_RDONLY|O_CLOEXEC, 0);
   12d41:	b9 05 00 00 00       	mov    $0x5,%ecx
   12d46:	31 d2                	xor    %edx,%edx
   12d48:	be 00 00 10 00       	mov    $0x100000,%esi
   12d4d:	89 c8                	mov    %ecx,%eax

    return handle;
}

int read_shebang (const char ** argv)
{
   12d4f:	48 89 e5             	mov    %rsp,%rbp
   12d52:	41 57                	push   %r15
   12d54:	41 56                	push   %r14
   12d56:	41 55                	push   %r13
   12d58:	41 54                	push   %r12
   12d5a:	49 89 fd             	mov    %rdi,%r13
   12d5d:	53                   	push   %rbx
   12d5e:	48 83 ec 58          	sub    $0x58,%rsp
    /* must be a shebang */
    int fd = INLINE_SYSCALL(open, 3, *argv, O_RDONLY|O_CLOEXEC, 0);
   12d62:	48 8b 3f             	mov    (%rdi),%rdi
   12d65:	cd 80                	int    $0x80
   12d67:	48 89 c2             	mov    %rax,%rdx
   12d6a:	bb 00 00 00 00       	mov    $0x0,%ebx
   12d6f:	83 d3 00             	adc    $0x0,%ebx
   12d72:	31 c9                	xor    %ecx,%ecx
   12d74:	85 db                	test   %ebx,%ebx
   12d76:	0f 95 c1             	setne  %cl
   12d79:	48 89 c8             	mov    %rcx,%rax
   12d7c:	48 f7 d8             	neg    %rax
   12d7f:	48 31 d0             	xor    %rdx,%rax
   12d82:	4c 8d 24 08          	lea    (%rax,%rcx,1),%r12

    if (IS_ERR(fd)) {
   12d86:	45 85 e4             	test   %r12d,%r12d
   12d89:	0f 88 82 01 00 00    	js     12f11 <read_shebang+0x1d1>
        return -PAL_ERROR_INVAL;
    }

    /* the maximun length for shebang path is 80 chars */
    char buffer[80];
    int bytes = INLINE_SYSCALL(read, 3, fd, buffer, 80);
   12d8f:	4d 63 c4             	movslq %r12d,%r8
   12d92:	b9 03 00 00 00       	mov    $0x3,%ecx
   12d97:	ba 50 00 00 00       	mov    $0x50,%edx
   12d9c:	48 8d 75 80          	lea    -0x80(%rbp),%rsi
   12da0:	4c 89 c7             	mov    %r8,%rdi
   12da3:	89 c8                	mov    %ecx,%eax
   12da5:	cd 80                	int    $0x80
   12da7:	48 89 c2             	mov    %rax,%rdx
   12daa:	bb 00 00 00 00       	mov    $0x0,%ebx
   12daf:	83 d3 00             	adc    $0x0,%ebx
   12db2:	31 c9                	xor    %ecx,%ecx
   12db4:	85 db                	test   %ebx,%ebx
   12db6:	0f 95 c1             	setne  %cl
   12db9:	48 89 c8             	mov    %rcx,%rax
   12dbc:	48 f7 d8             	neg    %rax
   12dbf:	48 31 d0             	xor    %rdx,%rax
    if (IS_ERR(bytes))
   12dc2:	01 c8                	add    %ecx,%eax
   12dc4:	0f 88 e6 00 00 00    	js     12eb0 <read_shebang+0x170>
        goto bad_shebang;

    /* the format of shebang should be '#!/absoulte/path/of/pal' */
    if (buffer[0] != '#' || buffer[1] != '!')
   12dca:	80 7d 80 23          	cmpb   $0x23,-0x80(%rbp)
   12dce:	0f 85 dc 00 00 00    	jne    12eb0 <read_shebang+0x170>
   12dd4:	80 7d 81 21          	cmpb   $0x21,-0x7f(%rbp)
   12dd8:	0f 85 d2 00 00 00    	jne    12eb0 <read_shebang+0x170>
   12dde:	0f b6 55 82          	movzbl -0x7e(%rbp),%edx
   12de2:	80 fa 0a             	cmp    $0xa,%dl
   12de5:	0f 95 c1             	setne  %cl
   12de8:	80 fa 0d             	cmp    $0xd,%dl
   12deb:	0f 95 c0             	setne  %al
   12dee:	21 c8                	and    %ecx,%eax
   12df0:	81 e2 df 00 00 00    	and    $0xdf,%edx
   12df6:	0f 95 c2             	setne  %dl
   12df9:	21 d0                	and    %edx,%eax
   12dfb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        goto bad_shebang;

    char * p = &buffer[2];
    while (*p && *p != ' ' && *p != '\r' && *p != '\n');
   12e00:	84 c0                	test   %al,%al
   12e02:	75 fc                	jne    12e00 <read_shebang+0xc0>
    p++;

    if (!libname) {
   12e04:	48 83 3d ec 1c 21 00 	cmpq   $0x0,0x211cec(%rip)        # 224af8 <libname>
   12e0b:	00 
   12e0c:	0f 84 d5 00 00 00    	je     12ee7 <read_shebang+0x1a7>
        char * name = malloc(p - buffer - 1);
        memcpy(name, &buffer[2], p - buffer - 2);
        libname = name;
    }

    int len = strlen(*argv);
   12e12:	49 8b 7d 00          	mov    0x0(%r13),%rdi
   12e16:	e8 85 39 00 00       	callq  167a0 <strlen>
    PAL_HANDLE manifest = malloc(HANDLE_SIZE(file) + len + 1);
   12e1b:	8d 78 29             	lea    0x29(%rax),%edi
        char * name = malloc(p - buffer - 1);
        memcpy(name, &buffer[2], p - buffer - 2);
        libname = name;
    }

    int len = strlen(*argv);
   12e1e:	49 89 c6             	mov    %rax,%r14
    PAL_HANDLE manifest = malloc(HANDLE_SIZE(file) + len + 1);
   12e21:	e8 da 5b ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(manifest, file);
    manifest->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    manifest->file.fd = fd;
   12e26:	44 89 60 0c          	mov    %r12d,0xc(%rax)
    char * path = (void *) manifest + HANDLE_SIZE(file);
    memcpy(path, *argv, len + 1);
   12e2a:	45 8d 66 01          	lea    0x1(%r14),%r12d
    int len = strlen(*argv);
    PAL_HANDLE manifest = malloc(HANDLE_SIZE(file) + len + 1);
    SET_HANDLE_TYPE(manifest, file);
    manifest->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    manifest->file.fd = fd;
    char * path = (void *) manifest + HANDLE_SIZE(file);
   12e2e:	4c 8d 78 28          	lea    0x28(%rax),%r15
        libname = name;
    }

    int len = strlen(*argv);
    PAL_HANDLE manifest = malloc(HANDLE_SIZE(file) + len + 1);
    SET_HANDLE_TYPE(manifest, file);
   12e32:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
   12e38:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
        memcpy(name, &buffer[2], p - buffer - 2);
        libname = name;
    }

    int len = strlen(*argv);
    PAL_HANDLE manifest = malloc(HANDLE_SIZE(file) + len + 1);
   12e3f:	48 89 c3             	mov    %rax,%rbx
    SET_HANDLE_TYPE(manifest, file);
    manifest->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
   12e42:	c7 40 08 49 00 00 00 	movl   $0x49,0x8(%rax)
    manifest->file.fd = fd;
    char * path = (void *) manifest + HANDLE_SIZE(file);
    memcpy(path, *argv, len + 1);
   12e49:	49 8b 75 00          	mov    0x0(%r13),%rsi
   12e4d:	4d 63 e4             	movslq %r12d,%r12
   12e50:	4c 89 e2             	mov    %r12,%rdx
   12e53:	4c 89 ff             	mov    %r15,%rdi
   12e56:	e8 25 34 00 00       	callq  16280 <memcpy>
    manifest->file.realpath = path;
    char * uri = malloc(len + 6);
   12e5b:	41 8d 7e 06          	lea    0x6(%r14),%edi
    SET_HANDLE_TYPE(manifest, file);
    manifest->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    manifest->file.fd = fd;
    char * path = (void *) manifest + HANDLE_SIZE(file);
    memcpy(path, *argv, len + 1);
    manifest->file.realpath = path;
   12e5f:	4c 89 7b 20          	mov    %r15,0x20(%rbx)
    char * uri = malloc(len + 6);
   12e63:	e8 98 5b ff ff       	callq  8a00 <malloc>
    memcpy(uri, "file:", 5);
   12e68:	48 8d 35 4f 5f 00 00 	lea    0x5f4f(%rip),%rsi        # 18dbe <handle_sizes.1924+0x63e>
   12e6f:	ba 05 00 00 00       	mov    $0x5,%edx
   12e74:	48 89 c7             	mov    %rax,%rdi
    manifest->__in.flags |= RFD(0)|WFD(0)|WRITEABLE(0);
    manifest->file.fd = fd;
    char * path = (void *) manifest + HANDLE_SIZE(file);
    memcpy(path, *argv, len + 1);
    manifest->file.realpath = path;
    char * uri = malloc(len + 6);
   12e77:	49 89 c6             	mov    %rax,%r14
    memcpy(uri, "file:", 5);
   12e7a:	e8 01 34 00 00       	callq  16280 <memcpy>
    memcpy(uri + 5, *argv, len + 1);
   12e7f:	49 8b 75 00          	mov    0x0(%r13),%rsi
   12e83:	49 8d 7e 05          	lea    0x5(%r14),%rdi
   12e87:	4c 89 e2             	mov    %r12,%rdx
   12e8a:	e8 f1 33 00 00       	callq  16280 <memcpy>
    pal_config.manifest = uri;
   12e8f:	48 8b 05 8a 0b 21 00 	mov    0x210b8a(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
   12e96:	4c 89 30             	mov    %r14,(%rax)
    pal_config.manifest_handle = manifest;
   12e99:	48 89 58 10          	mov    %rbx,0x10(%rax)

    return 0;
}
   12e9d:	48 83 c4 58          	add    $0x58,%rsp
   12ea1:	5b                   	pop    %rbx
    memcpy(uri, "file:", 5);
    memcpy(uri + 5, *argv, len + 1);
    pal_config.manifest = uri;
    pal_config.manifest_handle = manifest;

    return 0;
   12ea2:	31 c0                	xor    %eax,%eax
}
   12ea4:	41 5c                	pop    %r12
   12ea6:	41 5d                	pop    %r13
   12ea8:	41 5e                	pop    %r14
   12eaa:	41 5f                	pop    %r15
   12eac:	5d                   	pop    %rbp
   12ead:	c3                   	retq   
   12eae:	66 90                	xchg   %ax,%ax
   12eb0:	4d 89 c4             	mov    %r8,%r12
    /* must be a shebang */
    int fd = INLINE_SYSCALL(open, 3, *argv, O_RDONLY|O_CLOEXEC, 0);

    if (IS_ERR(fd)) {
bad_shebang:
        printf("The program is either not libpal.so or script with "
   12eb3:	48 8d 3d 56 bc 00 00 	lea    0xbc56(%rip),%rdi        # 1eb10 <slab_levels+0x5870>
   12eba:	31 c0                	xor    %eax,%eax
   12ebc:	e8 5f 5f ff ff       	callq  8e20 <pal_printf>
               "shebang. I can't recognize.\n");
        INLINE_SYSCALL(close, 1, fd);
   12ec1:	4c 89 e7             	mov    %r12,%rdi
   12ec4:	b8 06 00 00 00       	mov    $0x6,%eax
   12ec9:	cd 80                	int    $0x80
   12ecb:	bb 00 00 00 00       	mov    $0x0,%ebx
   12ed0:	83 d3 00             	adc    $0x0,%ebx
    memcpy(uri + 5, *argv, len + 1);
    pal_config.manifest = uri;
    pal_config.manifest_handle = manifest;

    return 0;
}
   12ed3:	48 83 c4 58          	add    $0x58,%rsp
    if (IS_ERR(fd)) {
bad_shebang:
        printf("The program is either not libpal.so or script with "
               "shebang. I can't recognize.\n");
        INLINE_SYSCALL(close, 1, fd);
        return -PAL_ERROR_INVAL;
   12ed7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    memcpy(uri + 5, *argv, len + 1);
    pal_config.manifest = uri;
    pal_config.manifest_handle = manifest;

    return 0;
}
   12edc:	5b                   	pop    %rbx
   12edd:	41 5c                	pop    %r12
   12edf:	41 5d                	pop    %r13
   12ee1:	41 5e                	pop    %r14
   12ee3:	41 5f                	pop    %r15
   12ee5:	5d                   	pop    %rbp
   12ee6:	c3                   	retq   
    char * p = &buffer[2];
    while (*p && *p != ' ' && *p != '\r' && *p != '\n');
    p++;

    if (!libname) {
        char * name = malloc(p - buffer - 1);
   12ee7:	bf 02 00 00 00       	mov    $0x2,%edi
   12eec:	e8 0f 5b ff ff       	callq  8a00 <malloc>
        memcpy(name, &buffer[2], p - buffer - 2);
   12ef1:	48 8d 75 82          	lea    -0x7e(%rbp),%rsi
    char * p = &buffer[2];
    while (*p && *p != ' ' && *p != '\r' && *p != '\n');
    p++;

    if (!libname) {
        char * name = malloc(p - buffer - 1);
   12ef5:	48 89 c3             	mov    %rax,%rbx
        memcpy(name, &buffer[2], p - buffer - 2);
   12ef8:	ba 01 00 00 00       	mov    $0x1,%edx
   12efd:	48 89 c7             	mov    %rax,%rdi
   12f00:	e8 7b 33 00 00       	callq  16280 <memcpy>
        libname = name;
   12f05:	48 89 1d ec 1b 21 00 	mov    %rbx,0x211bec(%rip)        # 224af8 <libname>
   12f0c:	e9 01 ff ff ff       	jmpq   12e12 <read_shebang+0xd2>
   12f11:	4d 63 e4             	movslq %r12d,%r12
   12f14:	eb 9d                	jmp    12eb3 <read_shebang+0x173>
   12f16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   12f1d:	00 00 00 

0000000000012f20 <pal_linux_main>:

extern void setup_pal_map (const char * realname, ElfW(Dyn) ** dyn,
                           ElfW(Addr) addr);

void pal_linux_main (void * args)
{
   12f20:	55                   	push   %rbp
   12f21:	48 89 e5             	mov    %rsp,%rbp
   12f24:	41 57                	push   %r15
   12f26:	41 56                	push   %r14
   12f28:	41 55                	push   %r13
   12f2a:	41 54                	push   %r12
   12f2c:	49 89 fc             	mov    %rdi,%r12
   12f2f:	53                   	push   %rbx
   12f30:	48 81 ec 98 02 00 00 	sub    $0x298,%rsp
     *       ---------------------------------------
     *            user stack
     */
    const char ** all_args = (const char **) args;
    //Workaround because sometimes BSD misaligns arguments on stack
    if (all_args[0] == 0) 
   12f37:	48 8b 07             	mov    (%rdi),%rax
   12f3a:	48 85 c0             	test   %rax,%rax
   12f3d:	0f 84 1d 07 00 00    	je     13660 <pal_linux_main+0x740>
	    all_args++;
    int argc = (uintptr_t) all_args[0];
    const char ** argv = &all_args[1];
   12f43:	49 8d 7c 24 08       	lea    0x8(%r12),%rdi
     */
    const char ** all_args = (const char **) args;
    //Workaround because sometimes BSD misaligns arguments on stack
    if (all_args[0] == 0) 
	    all_args++;
    int argc = (uintptr_t) all_args[0];
   12f48:	41 89 c7             	mov    %eax,%r15d
    const char ** argv = &all_args[1];
    const char ** envp = argv + argc + 1;
   12f4b:	48 98                	cltq   
   12f4d:	48 8d 44 c7 08       	lea    0x8(%rdi,%rax,8),%rax
    const char ** all_args = (const char **) args;
    //Workaround because sometimes BSD misaligns arguments on stack
    if (all_args[0] == 0) 
	    all_args++;
    int argc = (uintptr_t) all_args[0];
    const char ** argv = &all_args[1];
   12f52:	48 89 bd 60 fd ff ff 	mov    %rdi,-0x2a0(%rbp)
    const char ** envp = argv + argc + 1;

    /* fetch environment information from aux vectors */
    void ** auxv = (void **) envp + 1;
    for (; *(auxv - 1); auxv++);
   12f59:	48 83 38 00          	cmpq   $0x0,(%rax)
    int argc = (uintptr_t) all_args[0];
    const char ** argv = &all_args[1];
    const char ** envp = argv + argc + 1;

    /* fetch environment information from aux vectors */
    void ** auxv = (void **) envp + 1;
   12f5d:	48 8d 58 08          	lea    0x8(%rax),%rbx
    //Workaround because sometimes BSD misaligns arguments on stack
    if (all_args[0] == 0) 
	    all_args++;
    int argc = (uintptr_t) all_args[0];
    const char ** argv = &all_args[1];
    const char ** envp = argv + argc + 1;
   12f61:	48 89 85 68 fd ff ff 	mov    %rax,-0x298(%rbp)

    /* fetch environment information from aux vectors */
    void ** auxv = (void **) envp + 1;
    for (; *(auxv - 1); auxv++);
   12f68:	48 89 d8             	mov    %rbx,%rax
   12f6b:	74 0e                	je     12f7b <pal_linux_main+0x5b>
   12f6d:	0f 1f 00             	nopl   (%rax)
   12f70:	48 83 c0 08          	add    $0x8,%rax
   12f74:	48 83 78 f8 00       	cmpq   $0x0,-0x8(%rax)
   12f79:	75 f5                	jne    12f70 <pal_linux_main+0x50>
    ElfW(auxv_t) *av;
    for (av = (ElfW(auxv_t) *)auxv ; av->a_type != AT_NULL ; av++)
   12f7b:	48 8b 10             	mov    (%rax),%rdx
   12f7e:	48 85 d2             	test   %rdx,%rdx
   12f81:	74 52                	je     12fd5 <pal_linux_main+0xb5>
   12f83:	4c 8b 05 c6 16 21 00 	mov    0x2116c6(%rip),%r8        # 224650 <pagesz>
   12f8a:	8b 35 74 1b 21 00    	mov    0x211b74(%rip),%esi        # 224b04 <uid>
        switch (av->a_type) {
   12f90:	48 8d 0d dd bd 00 00 	lea    0xbddd(%rip),%rcx        # 1ed74 <slab_levels+0x5ad4>
   12f97:	8b 3d 63 1b 21 00    	mov    0x211b63(%rip),%edi        # 224b00 <gid>
   12f9d:	0f 1f 00             	nopl   (%rax)
   12fa0:	48 83 ea 06          	sub    $0x6,%rdx
   12fa4:	48 83 fa 08          	cmp    $0x8,%rdx
   12fa8:	77 0c                	ja     12fb6 <pal_linux_main+0x96>
   12faa:	48 63 14 91          	movslq (%rcx,%rdx,4),%rdx
   12fae:	48 01 ca             	add    %rcx,%rdx
   12fb1:	ff e2                	jmpq   *%rdx
            case AT_EUID:
                uid ^= av->a_un.a_val;
                break;
            case AT_GID:
            case AT_EGID:
                gid ^= av->a_un.a_val;
   12fb3:	33 78 08             	xor    0x8(%rax),%edi

    /* fetch environment information from aux vectors */
    void ** auxv = (void **) envp + 1;
    for (; *(auxv - 1); auxv++);
    ElfW(auxv_t) *av;
    for (av = (ElfW(auxv_t) *)auxv ; av->a_type != AT_NULL ; av++)
   12fb6:	48 83 c0 10          	add    $0x10,%rax
   12fba:	48 8b 10             	mov    (%rax),%rdx
   12fbd:	48 85 d2             	test   %rdx,%rdx
   12fc0:	75 de                	jne    12fa0 <pal_linux_main+0x80>
   12fc2:	4c 89 05 87 16 21 00 	mov    %r8,0x211687(%rip)        # 224650 <pagesz>
   12fc9:	89 3d 31 1b 21 00    	mov    %edi,0x211b31(%rip)        # 224b00 <gid>
   12fcf:	89 35 2f 1b 21 00    	mov    %esi,0x211b2f(%rip)        # 224b04 <uid>
            case AT_SYSINFO_EHDR:
                sysinfo_ehdr = av->a_un.a_val;
                break;
#endif
        }
    if (memcmp(*argv + strlen(*argv) - LIBRARY_NAMELEN, LIBRARY_NAME,
   12fd5:	4d 8b 6c 24 08       	mov    0x8(%r12),%r13
   12fda:	4c 89 ef             	mov    %r13,%rdi
   12fdd:	e8 be 37 00 00       	callq  167a0 <strlen>
   12fe2:	48 8d 35 8f ba 00 00 	lea    0xba8f(%rip),%rsi        # 1ea78 <slab_levels+0x57d8>
   12fe9:	49 8d 7c 05 f7       	lea    -0x9(%r13,%rax,1),%rdi
   12fee:	ba 09 00 00 00       	mov    $0x9,%edx
   12ff3:	e8 18 33 00 00       	callq  16310 <memcmp>
   12ff8:	85 c0                	test   %eax,%eax
   12ffa:	0f 85 c2 05 00 00    	jne    135c2 <pal_linux_main+0x6a2>
               LIBRARY_NAMELEN) == 0) {
        libname = *argv;
   13000:	49 8b 44 24 08       	mov    0x8(%r12),%rax
   13005:	48 89 05 ec 1a 21 00 	mov    %rax,0x211aec(%rip)        # 224af8 <libname>
        argv++;
   1300c:	49 8d 44 24 10       	lea    0x10(%r12),%rax
   13011:	48 89 85 60 fd ff ff 	mov    %rax,-0x2a0(%rbp)
        argc--;
   13018:	41 8d 47 ff          	lea    -0x1(%r15),%eax

        if (argc >= 1 && (*argv)[0] == ':') {
   1301c:	85 c0                	test   %eax,%eax
        }
    if (memcmp(*argv + strlen(*argv) - LIBRARY_NAMELEN, LIBRARY_NAME,
               LIBRARY_NAMELEN) == 0) {
        libname = *argv;
        argv++;
        argc--;
   1301e:	89 85 5c fd ff ff    	mov    %eax,-0x2a4(%rbp)

        if (argc >= 1 && (*argv)[0] == ':') {
   13024:	7e 0e                	jle    13034 <pal_linux_main+0x114>
   13026:	49 8b 44 24 10       	mov    0x10(%r12),%rax
   1302b:	80 38 3a             	cmpb   $0x3a,(%rax)
   1302e:	0f 84 ed 05 00 00    	je     13621 <pal_linux_main+0x701>
       load offset which is zero if the binary was loaded at the address
       it is prelinked for.  */

    /* fetch environment information from aux vectors */
    //Consume envp vector
    for (; *(auxv - 1); auxv++);
   13034:	48 8b 85 68 fd ff ff 	mov    -0x298(%rbp),%rax
   1303b:	48 83 38 00          	cmpq   $0x0,(%rax)
   1303f:	74 21                	je     13062 <pal_linux_main+0x142>
   13041:	48 83 c3 08          	add    $0x8,%rbx
   13045:	48 83 7b f8 00       	cmpq   $0x0,-0x8(%rbx)
   1304a:	75 f5                	jne    13041 <pal_linux_main+0x121>
    
    //Start processing auxv
    ElfW(auxv_t) *av;
    for (av = (ElfW(auxv_t) *)auxv ; av->a_type != AT_NULL ; av++)
   1304c:	48 8b 03             	mov    (%rbx),%rax
   1304f:	48 85 c0             	test   %rax,%rax
   13052:	74 16                	je     1306a <pal_linux_main+0x14a>
           if (av->a_type == AT_BASE){ 
   13054:	48 83 f8 07          	cmp    $0x7,%rax
   13058:	0f 84 52 05 00 00    	je     135b0 <pal_linux_main+0x690>
    //Consume envp vector
    for (; *(auxv - 1); auxv++);
    
    //Start processing auxv
    ElfW(auxv_t) *av;
    for (av = (ElfW(auxv_t) *)auxv ; av->a_type != AT_NULL ; av++)
   1305e:	48 83 c3 10          	add    $0x10,%rbx
   13062:	48 8b 03             	mov    (%rbx),%rax
   13065:	48 85 c0             	test   %rax,%rax
   13068:	75 ea                	jne    13054 <pal_linux_main+0x134>

/* Return the run-time load address of the shared object.  */
static inline Elf64_Addr __attribute__ ((unused))
elf_machine_load_address (void** auxv)
{
    Elf64_Addr addr = NULL;
   1306a:	45 31 e4             	xor    %r12d,%r12d
    ElfW(auxv_t) *av;
    for (av = (ElfW(auxv_t) *)auxv ; av->a_type != AT_NULL ; av++)
           if (av->a_type == AT_BASE){ 
			addr = av->a_un.a_val;
	   		break;}
    assert((void *)addr != NULL);
   1306d:	48 8d 3d c4 56 00 00 	lea    0x56c4(%rip),%rdi        # 18738 <write_config+0x188>
   13074:	48 8d 15 99 b9 00 00 	lea    0xb999(%rip),%rdx        # 1ea14 <slab_levels+0x5774>
   1307b:	48 8d 35 9f b9 00 00 	lea    0xb99f(%rip),%rsi        # 1ea21 <slab_levels+0x5781>
   13082:	b9 53 00 00 00       	mov    $0x53,%ecx
   13087:	31 c0                	xor    %eax,%eax
   13089:	e8 92 5d ff ff       	callq  8e20 <pal_printf>
   1308e:	e8 dd 39 ff ff       	callq  6a70 <__assert>
   13093:	bf 01 00 00 00       	mov    $0x1,%edi
   13098:	e8 e3 f4 ff ff       	callq  12580 <_DkProcessExit>
   1309d:	0f 1f 00             	nopl   (%rax)
    ElfW(Addr) pal_addr = elf_machine_load_address((void**)envp + 1);
    
    /* parse argc, argv, envp and auxv */
    ElfW(Dyn) * pal_dyn[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM +
                        DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];
    memset(pal_dyn, 0, sizeof(pal_dyn));
   130a0:	48 8d 85 70 fd ff ff 	lea    -0x290(%rbp),%rax
   130a7:	ba 60 02 00 00       	mov    $0x260,%edx
   130ac:	31 f6                	xor    %esi,%esi
   130ae:	48 89 c7             	mov    %rax,%rdi
   130b1:	48 89 85 50 fd ff ff 	mov    %rax,-0x2b0(%rbp)
   130b8:	e8 e3 30 00 00       	callq  161a0 <memset>
   uses global data.  */
static inline Elf64_Addr __attribute__ ((unused))
elf_machine_dynamic (Elf64_Addr mapbase)
{
    Elf64_Addr addr;
    addr = (Elf64_Addr)&_DYNAMIC + mapbase;
   130bd:	4c 89 e2             	mov    %r12,%rdx
   130c0:	48 03 15 b1 08 21 00 	add    0x2108b1(%rip),%rdx        # 223978 <_DYNAMIC+0x190>
    typedef Elf32_Word d_tag_utype;
#elif __ELF_NATIVE_CLASS == 64
    typedef Elf64_Xword d_tag_utype;
#endif

    while (dyn->d_tag != DT_NULL) {
   130c7:	48 8b 02             	mov    (%rdx),%rax
   130ca:	48 85 c0             	test   %rax,%rax
   130cd:	0f 84 9d 00 00 00    	je     13170 <pal_linux_main+0x250>
            l_info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;

        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
            l_info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;
   130d3:	48 8d 7d d0          	lea    -0x30(%rbp),%rdi
   130d7:	48 bb a0 f7 ff 7f 03 	mov    $0x37ffff7a0,%rbx
   130de:	00 00 00 
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM] = dyn;

        else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)
            l_info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;
   130e1:	49 b8 40 ef ff 7f 03 	mov    $0x37fffef40,%r8
   130e8:	00 00 00 

        else if (dyn->d_tag >= DT_LOPROC &&
                 dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)
            l_info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;

        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
   130eb:	be ff ff ff 6f       	mov    $0x6fffffff,%esi

        else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM] = dyn;

        else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)
   130f0:	41 ba ff fd ff 6f    	mov    $0x6ffffdff,%r10d
            l_info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;

        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
   130f6:	41 bb ff fe ff 6f    	mov    $0x6ffffeff,%r11d
            l_info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;
   130fc:	48 01 fb             	add    %rdi,%rbx
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM] = dyn;

        else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)
            l_info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;
   130ff:	49 01 f8             	add    %rdi,%r8
        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
            l_info[VERSYMIDX (dyn->d_tag)] = dyn;

        else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM] = dyn;
   13102:	41 b9 31 00 00 00    	mov    $0x31,%r9d
        else if (dyn->d_tag >= DT_LOPROC &&
                 dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)
            l_info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;

        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
            l_info[VERSYMIDX (dyn->d_tag)] = dyn;
   13108:	bf 21 00 00 70       	mov    $0x70000021,%edi
   1310d:	eb 1e                	jmp    1312d <pal_linux_main+0x20d>
   1310f:	90                   	nop    
   13110:	48 89 f9             	mov    %rdi,%rcx
   13113:	48 29 c1             	sub    %rax,%rcx
   13116:	48 89 c8             	mov    %rcx,%rax
   13119:	48 89 94 c5 70 fd ff 	mov    %rdx,-0x290(%rbp,%rax,8)
   13120:	ff 

        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
            l_info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;

        ++dyn;
   13121:	48 83 c2 10          	add    $0x10,%rdx
    typedef Elf32_Word d_tag_utype;
#elif __ELF_NATIVE_CLASS == 64
    typedef Elf64_Xword d_tag_utype;
#endif

    while (dyn->d_tag != DT_NULL) {
   13125:	48 8b 02             	mov    (%rdx),%rax
   13128:	48 85 c0             	test   %rax,%rax
   1312b:	74 43                	je     13170 <pal_linux_main+0x250>
        if ((d_tag_utype) dyn->d_tag < DT_NUM)
   1312d:	48 83 f8 21          	cmp    $0x21,%rax
   13131:	76 e6                	jbe    13119 <pal_linux_main+0x1f9>

        else if (dyn->d_tag >= DT_LOPROC &&
                 dyn->d_tag < DT_LOPROC + DT_THISPROCNUM)
            l_info[dyn->d_tag - DT_LOPROC + DT_NUM] = dyn;

        else if ((d_tag_utype) DT_VERSIONTAGIDX (dyn->d_tag) < DT_VERSIONTAGNUM)
   13133:	48 89 f1             	mov    %rsi,%rcx
   13136:	48 29 c1             	sub    %rax,%rcx
   13139:	48 83 f9 0f          	cmp    $0xf,%rcx
   1313d:	76 d1                	jbe    13110 <pal_linux_main+0x1f0>
            l_info[VERSYMIDX (dyn->d_tag)] = dyn;

        else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)
   1313f:	8d 0c 00             	lea    (%rax,%rax,1),%ecx
   13142:	d1 f9                	sar    %ecx
   13144:	83 f9 fc             	cmp    $0xfffffffffffffffc,%ecx
   13147:	0f 86 b3 03 00 00    	jbe    13500 <pal_linux_main+0x5e0>
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
   1314d:	44 89 c8             	mov    %r9d,%eax
   13150:	29 c8                	sub    %ecx,%eax
                   + DT_VERSIONTAGNUM] = dyn;
   13152:	48 89 94 c5 70 fd ff 	mov    %rdx,-0x290(%rbp,%rax,8)
   13159:	ff 

        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
            l_info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;

        ++dyn;
   1315a:	48 83 c2 10          	add    $0x10,%rdx
    typedef Elf32_Word d_tag_utype;
#elif __ELF_NATIVE_CLASS == 64
    typedef Elf64_Xword d_tag_utype;
#endif

    while (dyn->d_tag != DT_NULL) {
   1315e:	48 8b 02             	mov    (%rdx),%rax
   13161:	48 85 c0             	test   %rax,%rax
   13164:	75 c7                	jne    1312d <pal_linux_main+0x20d>
   13166:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1316d:	00 00 00 
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;

        ++dyn;
    }

    if (l_addr != 0) {
   13170:	4d 85 e4             	test   %r12,%r12
   13173:	74 7d                	je     131f2 <pal_linux_main+0x2d2>
            if (l_info[tag]) {                            \
		l_info[tag]->d_un.d_ptr += l_addr;        \
            }                                             \
        } while(0);

        ADJUST_DYN_INFO (DT_HASH);
   13175:	48 8b 85 90 fd ff ff 	mov    -0x270(%rbp),%rax
   1317c:	48 85 c0             	test   %rax,%rax
   1317f:	74 04                	je     13185 <pal_linux_main+0x265>
   13181:	4c 01 60 08          	add    %r12,0x8(%rax)
        ADJUST_DYN_INFO (DT_PLTGOT);
   13185:	48 8b 85 88 fd ff ff 	mov    -0x278(%rbp),%rax
   1318c:	48 85 c0             	test   %rax,%rax
   1318f:	74 04                	je     13195 <pal_linux_main+0x275>
   13191:	4c 01 60 08          	add    %r12,0x8(%rax)
        ADJUST_DYN_INFO (DT_STRTAB);
   13195:	48 8b 85 98 fd ff ff 	mov    -0x268(%rbp),%rax
   1319c:	48 85 c0             	test   %rax,%rax
   1319f:	74 04                	je     131a5 <pal_linux_main+0x285>
   131a1:	4c 01 60 08          	add    %r12,0x8(%rax)
        ADJUST_DYN_INFO (DT_SYMTAB);
   131a5:	48 8b 85 a0 fd ff ff 	mov    -0x260(%rbp),%rax
   131ac:	48 85 c0             	test   %rax,%rax
   131af:	74 04                	je     131b5 <pal_linux_main+0x295>
   131b1:	4c 01 60 08          	add    %r12,0x8(%rax)

# if ! ELF_MACHINE_NO_RELA
        ADJUST_DYN_INFO (DT_RELA);
   131b5:	48 8b 85 a8 fd ff ff 	mov    -0x258(%rbp),%rax
   131bc:	48 85 c0             	test   %rax,%rax
   131bf:	74 04                	je     131c5 <pal_linux_main+0x2a5>
   131c1:	4c 01 60 08          	add    %r12,0x8(%rax)

# if ! ELF_MACHINE_NO_REL
        ADJUST_DYN_INFO (DT_REL);
# endif

        ADJUST_DYN_INFO (DT_JMPREL);
   131c5:	48 8b 85 28 fe ff ff 	mov    -0x1d8(%rbp),%rax
   131cc:	48 85 c0             	test   %rax,%rax
   131cf:	74 04                	je     131d5 <pal_linux_main+0x2b5>
   131d1:	4c 01 60 08          	add    %r12,0x8(%rax)
        ADJUST_DYN_INFO (VERSYMIDX (DT_VERSYM));
   131d5:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
   131dc:	48 85 c0             	test   %rax,%rax
   131df:	74 04                	je     131e5 <pal_linux_main+0x2c5>
   131e1:	4c 01 60 08          	add    %r12,0x8(%rax)
        ADJUST_DYN_INFO (DT_ADDRTAGIDX (DT_GNU_HASH) + DT_NUM + DT_THISPROCNUM
   131e5:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   131e9:	48 85 c0             	test   %rax,%rax
   131ec:	74 04                	je     131f2 <pal_linux_main+0x2d2>
   131ee:	4c 01 60 08          	add    %r12,0x8(%rax)
                      + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM);
# undef ADJUST_DYN_INFO
    }

    /* Then a bunch of assertion, we could kind of ignore them */
    if (l_info[DT_PLTREL]) {
   131f2:	48 8b 85 10 fe ff ff 	mov    -0x1f0(%rbp),%rax
   131f9:	48 85 c0             	test   %rax,%rax
   131fc:	74 37                	je     13235 <pal_linux_main+0x315>
#if ELF_MACHINE_NO_RELA
        assert (l_info[DT_PLTREL]->d_un.d_val == DT_REL);

#elif ELF_MACHINE_NO_REL
        assert (l_info[DT_PLTREL]->d_un.d_val == DT_RELA);
   131fe:	48 83 78 08 07       	cmpq   $0x7,0x8(%rax)
   13203:	74 30                	je     13235 <pal_linux_main+0x315>
   13205:	48 8d 3d 2c 55 00 00 	lea    0x552c(%rip),%rdi        # 18738 <write_config+0x188>
   1320c:	48 8d 15 23 b8 00 00 	lea    0xb823(%rip),%rdx        # 1ea36 <slab_levels+0x5796>
   13213:	48 8d 35 de 5d 00 00 	lea    0x5dde(%rip),%rsi        # 18ff8 <handle_sizes.1924+0x878>
   1321a:	b9 96 00 00 00       	mov    $0x96,%ecx
   1321f:	31 c0                	xor    %eax,%eax
   13221:	e8 fa 5b ff ff       	callq  8e20 <pal_printf>
   13226:	e8 45 38 ff ff       	callq  6a70 <__assert>
   1322b:	bf 01 00 00 00       	mov    $0x1,%edi
   13230:	e8 4b f3 ff ff       	callq  12580 <_DkProcessExit>
                || l_info[DT_PLTREL]->d_un.d_val == DT_RELA);
#endif
    }

#if ! ELF_MACHINE_NO_RELA
    if (l_info[DT_RELA])
   13235:	48 83 bd a8 fd ff ff 	cmpq   $0x0,-0x258(%rbp)
   1323c:	00 
   1323d:	74 3e                	je     1327d <pal_linux_main+0x35d>
        assert (l_info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela)));
   1323f:	48 8b 85 b8 fd ff ff 	mov    -0x248(%rbp),%rax
   13246:	48 83 78 08 18       	cmpq   $0x18,0x8(%rax)
   1324b:	74 30                	je     1327d <pal_linux_main+0x35d>
   1324d:	48 8d 3d e4 54 00 00 	lea    0x54e4(%rip),%rdi        # 18738 <write_config+0x188>
   13254:	48 8d 15 db b7 00 00 	lea    0xb7db(%rip),%rdx        # 1ea36 <slab_levels+0x5796>
   1325b:	48 8d 35 c6 5d 00 00 	lea    0x5dc6(%rip),%rsi        # 19028 <handle_sizes.1924+0x8a8>
   13262:	b9 a0 00 00 00       	mov    $0xa0,%ecx
   13267:	31 c0                	xor    %eax,%eax
   13269:	e8 b2 5b ff ff       	callq  8e20 <pal_printf>
   1326e:	e8 fd 37 ff ff       	callq  6a70 <__assert>
   13273:	bf 01 00 00 00       	mov    $0x1,%edi
   13278:	e8 03 f3 ff ff       	callq  12580 <_DkProcessExit>
        assert (l_info[DT_RELENT]->d_un.d_val == sizeof (ElfW(Rel)));
#endif

#ifdef RTLD_BOOTSTRAP
    /* Only the bind now flags are allowed.  */
    assert (!l_info[VERSYMIDX (DT_FLAGS_1)]
   1327d:	48 8b 85 a0 fe ff ff 	mov    -0x160(%rbp),%rax
   13284:	48 85 c0             	test   %rax,%rax
   13287:	74 37                	je     132c0 <pal_linux_main+0x3a0>
   13289:	48 83 78 08 01       	cmpq   $0x1,0x8(%rax)
   1328e:	74 30                	je     132c0 <pal_linux_main+0x3a0>
   13290:	48 8d 3d a1 54 00 00 	lea    0x54a1(%rip),%rdi        # 18738 <write_config+0x188>
   13297:	48 8d 15 98 b7 00 00 	lea    0xb798(%rip),%rdx        # 1ea36 <slab_levels+0x5796>
   1329e:	48 8d 35 bb b8 00 00 	lea    0xb8bb(%rip),%rsi        # 1eb60 <slab_levels+0x58c0>
   132a5:	b9 ab 00 00 00       	mov    $0xab,%ecx
   132aa:	31 c0                	xor    %eax,%eax
   132ac:	e8 6f 5b ff ff       	callq  8e20 <pal_printf>
   132b1:	e8 ba 37 ff ff       	callq  6a70 <__assert>
   132b6:	bf 01 00 00 00       	mov    $0x1,%edi
   132bb:	e8 c0 f2 ff ff       	callq  12580 <_DkProcessExit>
            || l_info[VERSYMIDX (DT_FLAGS_1)]->d_un.d_val == DF_1_NOW);
    assert (!l_info[DT_FLAGS]
   132c0:	48 8b 85 60 fe ff ff 	mov    -0x1a0(%rbp),%rax
   132c7:	48 85 c0             	test   %rax,%rax
   132ca:	74 37                	je     13303 <pal_linux_main+0x3e3>
   132cc:	48 83 78 08 08       	cmpq   $0x8,0x8(%rax)
   132d1:	74 30                	je     13303 <pal_linux_main+0x3e3>
   132d3:	48 8d 3d 5e 54 00 00 	lea    0x545e(%rip),%rdi        # 18738 <write_config+0x188>
   132da:	48 8d 15 55 b7 00 00 	lea    0xb755(%rip),%rdx        # 1ea36 <slab_levels+0x5796>
   132e1:	48 8d 35 d8 b8 00 00 	lea    0xb8d8(%rip),%rsi        # 1ebc0 <slab_levels+0x5920>
   132e8:	b9 ad 00 00 00       	mov    $0xad,%ecx
   132ed:	31 c0                	xor    %eax,%eax
   132ef:	e8 2c 5b ff ff       	callq  8e20 <pal_printf>
   132f4:	e8 77 37 ff ff       	callq  6a70 <__assert>
   132f9:	bf 01 00 00 00       	mov    $0x1,%edi
   132fe:	e8 7d f2 ff ff       	callq  12580 <_DkProcessExit>
            || l_info[DT_FLAGS]->d_un.d_val == DF_BIND_NOW);
    /* Flags must not be set for ld.so.  */
    assert (!l_info[DT_RUNPATH]);
   13303:	48 83 bd 58 fe ff ff 	cmpq   $0x0,-0x1a8(%rbp)
   1330a:	00 
   1330b:	74 30                	je     1333d <pal_linux_main+0x41d>
   1330d:	48 8d 3d 24 54 00 00 	lea    0x5424(%rip),%rdi        # 18738 <write_config+0x188>
   13314:	48 8d 15 1b b7 00 00 	lea    0xb71b(%rip),%rdx        # 1ea36 <slab_levels+0x5796>
   1331b:	48 8d 35 29 b7 00 00 	lea    0xb729(%rip),%rsi        # 1ea4b <slab_levels+0x57ab>
   13322:	b9 af 00 00 00       	mov    $0xaf,%ecx
   13327:	31 c0                	xor    %eax,%eax
   13329:	e8 f2 5a ff ff       	callq  8e20 <pal_printf>
   1332e:	e8 3d 37 ff ff       	callq  6a70 <__assert>
   13333:	bf 01 00 00 00       	mov    $0x1,%edi
   13338:	e8 43 f2 ff ff       	callq  12580 <_DkProcessExit>
    assert (!l_info[DT_RPATH]);
   1333d:	48 83 bd e8 fd ff ff 	cmpq   $0x0,-0x218(%rbp)
   13344:	00 
   13345:	74 30                	je     13377 <pal_linux_main+0x457>
   13347:	48 8d 3d ea 53 00 00 	lea    0x53ea(%rip),%rdi        # 18738 <write_config+0x188>
   1334e:	48 8d 15 e1 b6 00 00 	lea    0xb6e1(%rip),%rdx        # 1ea36 <slab_levels+0x5796>
   13355:	48 8d 35 03 b7 00 00 	lea    0xb703(%rip),%rsi        # 1ea5f <slab_levels+0x57bf>
   1335c:	b9 b0 00 00 00       	mov    $0xb0,%ecx
   13361:	31 c0                	xor    %eax,%eax
   13363:	e8 b8 5a ff ff       	callq  8e20 <pal_printf>
   13368:	e8 03 37 ff ff       	callq  6a70 <__assert>
   1336d:	bf 01 00 00 00       	mov    $0x1,%edi
   13372:	e8 09 f2 ff ff       	callq  12580 <_DkProcessExit>
{
    struct { ElfW(Addr) start, size; } ranges[2];
    ranges[0].size = ranges[1].size = 0;
    ranges[0].start = ranges[1].start = 0;

    if (l_info[dt_reloc]) {
   13377:	48 8b 85 a8 fd ff ff 	mov    -0x258(%rbp),%rax
   1337e:	48 85 c0             	test   %rax,%rax
   13381:	0f 84 c9 02 00 00    	je     13650 <pal_linux_main+0x730>
        ranges[0].start = D_PTR (l_info[dt_reloc]);
   13387:	4c 8b 70 08          	mov    0x8(%rax),%r14
        ranges[0].size = l_info[dt_reloc_sz]->d_un.d_val;
   1338b:	48 8b 85 b0 fd ff ff 	mov    -0x250(%rbp),%rax
   13392:	48 8b 58 08          	mov    0x8(%rax),%rbx
   13396:	4d 89 f5             	mov    %r14,%r13
   13399:	4e 8d 3c 33          	lea    (%rbx,%r14,1),%r15
    }

    if (l_info[DT_PLTREL]
   1339d:	48 8b 85 10 fe ff ff 	mov    -0x1f0(%rbp),%rax
   133a4:	48 85 c0             	test   %rax,%rax
   133a7:	74 0b                	je     133b4 <pal_linux_main+0x494>
        && l_info[DT_PLTREL]->d_un.d_val == dt_reloc) {
   133a9:	48 83 78 08 07       	cmpq   $0x7,0x8(%rax)
   133ae:	0f 84 1c 02 00 00    	je     135d0 <pal_linux_main+0x6b0>
                    bool do_rel, bool do_rel_relative)
{
    ElfW(Rel) *r = (void *) reladdr;
    ElfW(Rel) *end = (void *) (reladdr + relsize);

    if (!l_info[DT_SYMTAB])
   133b4:	48 8b 85 a0 fd ff ff 	mov    -0x260(%rbp),%rax
   133bb:	48 85 c0             	test   %rax,%rax
   133be:	0f 84 5c 01 00 00    	je     13520 <pal_linux_main+0x600>
        return;

    {
        ElfW(Sym) *symtab = (void *) D_PTR (l_info[DT_SYMTAB]);
        ElfW(Word) nrelative = (l_info[RELCOUNT_IDX] == NULL
   133c4:	48 8b 8d b0 fe ff ff 	mov    -0x150(%rbp),%rcx

    if (!l_info[DT_SYMTAB])
        return;

    {
        ElfW(Sym) *symtab = (void *) D_PTR (l_info[DT_SYMTAB]);
   133cb:	4c 8b 70 08          	mov    0x8(%rax),%r14
        ElfW(Word) nrelative = (l_info[RELCOUNT_IDX] == NULL
   133cf:	48 85 c9             	test   %rcx,%rcx
   133d2:	0f 84 98 02 00 00    	je     13670 <pal_linux_main+0x750>
                                ? 0 : l_info[RELCOUNT_IDX]->d_un.d_val);
        ElfW(Rel) *relative = r;
        r = r + MIN (nrelative, relsize / sizeof (ElfW(Rel)));
   133d8:	48 89 d8             	mov    %rbx,%rax
   133db:	48 ba ab aa aa aa aa 	mov    $0xaaaaaaaaaaaaaaab,%rdx
   133e2:	aa aa aa 
   133e5:	48 f7 e2             	mul    %rdx
   133e8:	8b 41 08             	mov    0x8(%rcx),%eax
   133eb:	48 c1 ea 04          	shr    $0x4,%rdx
   133ef:	48 39 c2             	cmp    %rax,%rdx
   133f2:	48 0f 47 d0          	cmova  %rax,%rdx
   133f6:	48 8d 04 52          	lea    (%rdx,%rdx,2),%rax
   133fa:	49 8d 5c c5 00       	lea    0x0(%r13,%rax,8),%rbx
# else
            /* ...or we know the object has been prelinked.  */
            if (l_addr != 0 || !l_info[VALIDX(DT_GNU_PRELINKED)])
# endif
#endif
                for (; relative < r; ++relative) {
   133ff:	4c 39 eb             	cmp    %r13,%rbx
   13402:	76 64                	jbe    13468 <pal_linux_main+0x548>
   13404:	4c 89 b5 48 fd ff ff 	mov    %r14,-0x2b8(%rbp)
   1340b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		    //printf("relocate: %08x\n", relative);
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
   13410:	4d 89 e6             	mov    %r12,%r14
   13413:	4d 03 75 00          	add    0x0(%r13),%r14
#endif
elf_machine_rela_relative (Elf64_Addr l_addr, const Elf64_Rela *reloc,
                           void *const reloc_addr_arg)
{
    Elf64_Addr *const reloc_addr = reloc_addr_arg;
    assert (ELF64_R_TYPE (reloc->r_info) == R_X86_64_RELATIVE);
   13417:	41 83 7d 08 08       	cmpl   $0x8,0x8(%r13)
   1341c:	74 30                	je     1344e <pal_linux_main+0x52e>
   1341e:	48 8d 3d 13 53 00 00 	lea    0x5313(%rip),%rdi        # 18738 <write_config+0x188>
   13425:	48 8d 15 56 b6 00 00 	lea    0xb656(%rip),%rdx        # 1ea82 <slab_levels+0x57e2>
   1342c:	48 8d 35 2d 5c 00 00 	lea    0x5c2d(%rip),%rsi        # 19060 <handle_sizes.1924+0x8e0>
   13433:	b9 da 00 00 00       	mov    $0xda,%ecx
   13438:	31 c0                	xor    %eax,%eax
   1343a:	e8 e1 59 ff ff       	callq  8e20 <pal_printf>
   1343f:	e8 2c 36 ff ff       	callq  6a70 <__assert>
   13444:	bf 01 00 00 00       	mov    $0x1,%edi
   13449:	e8 32 f1 ff ff       	callq  12580 <_DkProcessExit>
    *reloc_addr = l_addr + reloc->r_addend;
   1344e:	4c 89 e0             	mov    %r12,%rax
   13451:	49 03 45 10          	add    0x10(%r13),%rax
# else
            /* ...or we know the object has been prelinked.  */
            if (l_addr != 0 || !l_info[VALIDX(DT_GNU_PRELINKED)])
# endif
#endif
                for (; relative < r; ++relative) {
   13455:	49 83 c5 18          	add    $0x18,%r13
   13459:	4c 39 eb             	cmp    %r13,%rbx
   1345c:	49 89 06             	mov    %rax,(%r14)
   1345f:	77 af                	ja     13410 <pal_linux_main+0x4f0>
   13461:	4c 8b b5 48 fd ff ff 	mov    -0x2b8(%rbp),%r14
		    //printf("relocate: %08x\n", relative);
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
                }
        for (; r < end; ++r) {
   13468:	49 39 df             	cmp    %rbx,%r15
   1346b:	0f 86 af 00 00 00    	jbe    13520 <pal_linux_main+0x600>
   13471:	4c 89 fe             	mov    %r15,%rsi
   13474:	4d 89 f7             	mov    %r14,%r15
   13477:	eb 3a                	jmp    134b3 <pal_linux_main+0x593>
   13479:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        }
    }
#endif

    if (sym != NULL
        && __builtin_expect (ELFW(ST_TYPE) (sym->st_info)
   13480:	0f b6 4a 04          	movzbl 0x4(%rdx),%ecx
        elf_machine_rela_debug (R_X86_64_NONE, sym, 0);
        return;
    }

#ifdef RTLD_BOOTSTRAP
    Elf64_Addr value = (sym == NULL ? 0 : l_addr + sym->st_value);
   13484:	4c 89 e0             	mov    %r12,%rax
   13487:	48 03 42 08          	add    0x8(%rdx),%rax
        }
    }
#endif

    if (sym != NULL
        && __builtin_expect (ELFW(ST_TYPE) (sym->st_info)
   1348b:	83 e1 0f             	and    $0xf,%ecx
   1348e:	80 f9 0a             	cmp    $0xa,%cl
   13491:	0f 84 f9 00 00 00    	je     13590 <pal_linux_main+0x670>

    /* In the libc loader, they guaranteed that only R_ARCH_RELATIVE,
       R_ARCH_GLOB_DAT, R_ARCH_JUMP_SLOT appear in ld.so. We observed
       the same thing in libpal.so, so we are gonna to make the same
       assumption */
    switch (r_type)
   13497:	49 83 fd 06          	cmp    $0x6,%r13
   1349b:	74 06                	je     134a3 <pal_linux_main+0x583>
   1349d:	49 83 fd 07          	cmp    $0x7,%r13
   134a1:	75 07                	jne    134aa <pal_linux_main+0x58a>
            *reloc_addr = value + reloc->r_addend;
            break;

        case R_X86_64_JUMP_SLOT:
            elf_machine_rela_debug (R_X86_64_JUMP_SLOT, SYM, value);
            *reloc_addr = value + reloc->r_addend;
   134a3:	48 03 43 10          	add    0x10(%rbx),%rax
   134a7:	49 89 06             	mov    %rax,(%r14)
   134aa:	48 83 c3 18          	add    $0x18,%rbx
   134ae:	48 39 de             	cmp    %rbx,%rsi
   134b1:	76 6d                	jbe    13520 <pal_linux_main+0x600>
	    //printf("relocate: %08x\n", r);
            elf_machine_rel (l_info, l_addr, r,
                             &symtab[ELFW(R_SYM) (r->r_info)],
   134b3:	48 8b 43 08          	mov    0x8(%rbx),%rax
                             (void *) (l_addr + r->r_offset),
   134b7:	4d 89 e6             	mov    %r12,%r14
   134ba:	4c 03 33             	add    (%rbx),%r14
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
                }
        for (; r < end; ++r) {
	    //printf("relocate: %08x\n", r);
            elf_machine_rel (l_info, l_addr, r,
                             &symtab[ELFW(R_SYM) (r->r_info)],
   134bd:	48 89 c2             	mov    %rax,%rdx
elf_machine_rela (Elf64_Dyn **l_info, Elf64_Addr l_addr,
                  Elf64_Rela *reloc, Elf64_Sym *sym, void *const reloc_addr_arg,
                  bool rel, bool rel_relative)
{
    Elf64_Addr *const reloc_addr = reloc_addr_arg;
    const unsigned long int r_type = ELF64_R_TYPE (reloc->r_info);
   134c0:	41 89 c5             	mov    %eax,%r13d
   134c3:	48 c1 ea 20          	shr    $0x20,%rdx
#endif
        }
        return;
    }

    if (__builtin_expect (r_type == R_X86_64_NONE, 0))
   134c7:	a9 f7 ff ff ff       	test   $0xfffffff7,%eax
   134cc:	48 8d 14 52          	lea    (%rdx,%rdx,2),%rdx
		    //printf("relocate: %08x\n", relative);
                    DO_ELF_MACHINE_REL_RELATIVE (l_addr, relative);
                }
        for (; r < end; ++r) {
	    //printf("relocate: %08x\n", r);
            elf_machine_rel (l_info, l_addr, r,
   134d0:	49 8d 14 d7          	lea    (%r15,%rdx,8),%rdx
   134d4:	74 d4                	je     134aa <pal_linux_main+0x58a>
        elf_machine_rela_debug (R_X86_64_NONE, sym, 0);
        return;
    }

#ifdef RTLD_BOOTSTRAP
    Elf64_Addr value = (sym == NULL ? 0 : l_addr + sym->st_value);
   134d6:	48 85 d2             	test   %rdx,%rdx
   134d9:	75 a5                	jne    13480 <pal_linux_main+0x560>
   134db:	31 c0                	xor    %eax,%eax
   134dd:	eb b8                	jmp    13497 <pal_linux_main+0x577>
   134df:	90                   	nop    
            case AT_PAGESZ:
                pagesz = av->a_un.a_val;
                break;
            case AT_UID:
            case AT_EUID:
                uid ^= av->a_un.a_val;
   134e0:	33 70 08             	xor    0x8(%rax),%esi
   134e3:	e9 ce fa ff ff       	jmpq   12fb6 <pal_linux_main+0x96>
   134e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   134ef:	00 
    for (; *(auxv - 1); auxv++);
    ElfW(auxv_t) *av;
    for (av = (ElfW(auxv_t) *)auxv ; av->a_type != AT_NULL ; av++)
        switch (av->a_type) {
            case AT_PAGESZ:
                pagesz = av->a_un.a_val;
   134f0:	4c 8b 40 08          	mov    0x8(%rax),%r8
   134f4:	e9 bd fa ff ff       	jmpq   12fb6 <pal_linux_main+0x96>
   134f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

        else if ((d_tag_utype) DT_EXTRATAGIDX (dyn->d_tag) < DT_EXTRANUM)
            l_info[DT_EXTRATAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
                   + DT_VERSIONTAGNUM] = dyn;

        else if ((d_tag_utype) DT_VALTAGIDX (dyn->d_tag) < DT_VALNUM)
   13500:	4c 89 d1             	mov    %r10,%rcx
   13503:	48 29 c1             	sub    %rax,%rcx
   13506:	48 83 f9 0b          	cmp    $0xb,%rcx
   1350a:	77 64                	ja     13570 <pal_linux_main+0x650>
            l_info[DT_VALTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
   1350c:	48 f7 d8             	neg    %rax
                   + DT_VERSIONTAGNUM + DT_EXTRANUM] = dyn;
   1350f:	49 89 14 c0          	mov    %rdx,(%r8,%rax,8)
   13513:	e9 09 fc ff ff       	jmpq   13121 <pal_linux_main+0x201>
   13518:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1351f:	00 
                        DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];
    memset(pal_dyn, 0, sizeof(pal_dyn));
    elf_get_dynamic_info((ElfW(Dyn) *)elf_machine_dynamic(pal_addr), pal_dyn, pal_addr);
    ELF_DYNAMIC_RELOCATE(pal_dyn, pal_addr);

    init_slab_mgr();
   13520:	e8 9b 53 ff ff       	callq  88c0 <init_slab_mgr>
    setup_pal_map(XSTRINGIFY(SRCDIR) "/" LIBRARY_NAME, pal_dyn, pal_addr);
   13525:	48 8b b5 50 fd ff ff 	mov    -0x2b0(%rbp),%rsi
   1352c:	48 8d 3d 3e b5 00 00 	lea    0xb53e(%rip),%rdi        # 1ea71 <slab_levels+0x57d1>
   13533:	4c 89 e2             	mov    %r12,%rdx
   13536:	e8 15 09 00 00       	callq  13e50 <setup_pal_map>

    /* jump to main function */
    pal_main(argc, argv, envp);
   1353b:	48 8b 95 68 fd ff ff 	mov    -0x298(%rbp),%rdx
   13542:	48 8b b5 60 fd ff ff 	mov    -0x2a0(%rbp),%rsi
   13549:	8b bd 5c fd ff ff    	mov    -0x2a4(%rbp),%edi
   1354f:	e8 7c 28 ff ff       	callq  5dd0 <pal_main>
}
   13554:	48 81 c4 98 02 00 00 	add    $0x298,%rsp
   1355b:	5b                   	pop    %rbx
   1355c:	41 5c                	pop    %r12
   1355e:	41 5d                	pop    %r13
   13560:	41 5e                	pop    %r14
   13562:	41 5f                	pop    %r15
   13564:	5d                   	pop    %rbp
   13565:	c3                   	retq   
   13566:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1356d:	00 00 00 

        else if ((d_tag_utype) DT_ADDRTAGIDX (dyn->d_tag) < DT_ADDRNUM)
   13570:	4c 89 d9             	mov    %r11,%rcx
   13573:	48 29 c1             	sub    %rax,%rcx
   13576:	48 83 f9 0a          	cmp    $0xa,%rcx
   1357a:	0f 87 a1 fb ff ff    	ja     13121 <pal_linux_main+0x201>
            l_info[DT_ADDRTAGIDX (dyn->d_tag) + DT_NUM + DT_THISPROCNUM
   13580:	48 f7 d8             	neg    %rax
                   + DT_VERSIONTAGNUM + DT_EXTRANUM + DT_VALNUM] = dyn;
   13583:	48 89 14 c3          	mov    %rdx,(%rbx,%rax,8)
   13587:	e9 95 fb ff ff       	jmpq   13121 <pal_linux_main+0x201>
   1358c:	0f 1f 40 00          	nopl   0x0(%rax)
#endif

    if (sym != NULL
        && __builtin_expect (ELFW(ST_TYPE) (sym->st_info)
                             == STT_GNU_IFUNC, 0)
        && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1))
   13590:	66 83 7a 06 00       	cmpw   $0x0,0x6(%rdx)
   13595:	0f 84 fc fe ff ff    	je     13497 <pal_linux_main+0x577>
   1359b:	48 89 b5 48 fd ff ff 	mov    %rsi,-0x2b8(%rbp)
        value = ((Elf64_Addr (*) (void)) value) ();
   135a2:	ff d0                	callq  *%rax
   135a4:	48 8b b5 48 fd ff ff 	mov    -0x2b8(%rbp),%rsi
   135ab:	e9 e7 fe ff ff       	jmpq   13497 <pal_linux_main+0x577>
    
    //Start processing auxv
    ElfW(auxv_t) *av;
    for (av = (ElfW(auxv_t) *)auxv ; av->a_type != AT_NULL ; av++)
           if (av->a_type == AT_BASE){ 
			addr = av->a_un.a_val;
   135b0:	4c 8b 63 08          	mov    0x8(%rbx),%r12
	   		break;}
    assert((void *)addr != NULL);
   135b4:	4d 85 e4             	test   %r12,%r12
   135b7:	0f 85 e3 fa ff ff    	jne    130a0 <pal_linux_main+0x180>
   135bd:	e9 ab fa ff ff       	jmpq   1306d <pal_linux_main+0x14d>
     */
    const char ** all_args = (const char **) args;
    //Workaround because sometimes BSD misaligns arguments on stack
    if (all_args[0] == 0) 
	    all_args++;
    int argc = (uintptr_t) all_args[0];
   135c2:	44 89 bd 5c fd ff ff 	mov    %r15d,-0x2a4(%rbp)
   135c9:	e9 66 fa ff ff       	jmpq   13034 <pal_linux_main+0x114>
   135ce:	66 90                	xchg   %ax,%ax
        ranges[0].size = l_info[dt_reloc_sz]->d_un.d_val;
    }

    if (l_info[DT_PLTREL]
        && l_info[DT_PLTREL]->d_un.d_val == dt_reloc) {
        ElfW(Addr) start = D_PTR (l_info[DT_JMPREL]);
   135d0:	48 8b 85 28 fe ff ff 	mov    -0x1d8(%rbp),%rax
            ranges[0].start + ranges[0].size != start) {
            ranges[1].start = start;
            ranges[1].size = l_info[DT_PLTRELSZ]->d_un.d_val;
        } else {
            /* Combine processing the sections.  */
            assert (ranges[0].start + ranges[0].size == start);
   135d7:	4c 39 78 08          	cmp    %r15,0x8(%rax)
   135db:	74 30                	je     1360d <pal_linux_main+0x6ed>
   135dd:	48 8d 3d 54 51 00 00 	lea    0x5154(%rip),%rdi        # 18738 <write_config+0x188>
   135e4:	48 8d 15 4b b4 00 00 	lea    0xb44b(%rip),%rdx        # 1ea36 <slab_levels+0x5796>
   135eb:	48 8d 35 16 b6 00 00 	lea    0xb616(%rip),%rsi        # 1ec08 <slab_levels+0x5968>
   135f2:	b9 01 01 00 00       	mov    $0x101,%ecx
   135f7:	31 c0                	xor    %eax,%eax
   135f9:	e8 22 58 ff ff       	callq  8e20 <pal_printf>
   135fe:	e8 6d 34 ff ff       	callq  6a70 <__assert>
   13603:	bf 01 00 00 00       	mov    $0x1,%edi
   13608:	e8 73 ef ff ff       	callq  12580 <_DkProcessExit>
            ranges[0].size += l_info[DT_PLTRELSZ]->d_un.d_val;
   1360d:	48 8b 85 80 fd ff ff 	mov    -0x280(%rbp),%rax
   13614:	48 03 58 08          	add    0x8(%rax),%rbx
   13618:	4e 8d 3c 33          	lea    (%rbx,%r14,1),%r15
   1361c:	e9 93 fd ff ff       	jmpq   133b4 <pal_linux_main+0x494>
        libname = *argv;
        argv++;
        argc--;

        if (argc >= 1 && (*argv)[0] == ':') {
            child_args = (*argv) + 1;
   13621:	48 83 c0 01          	add    $0x1,%rax
   13625:	48 89 05 c4 14 21 00 	mov    %rax,0x2114c4(%rip)        # 224af0 <child_args>
            argv++;
   1362c:	49 8d 44 24 18       	lea    0x18(%r12),%rax
   13631:	48 89 85 60 fd ff ff 	mov    %rax,-0x2a0(%rbp)
            argc--;
   13638:	41 8d 47 fe          	lea    -0x2(%r15),%eax
   1363c:	89 85 5c fd ff ff    	mov    %eax,-0x2a4(%rbp)
   13642:	e9 ed f9 ff ff       	jmpq   13034 <pal_linux_main+0x114>
   13647:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1364e:	00 00 
{
    struct { ElfW(Addr) start, size; } ranges[2];
    ranges[0].size = ranges[1].size = 0;
    ranges[0].start = ranges[1].start = 0;

    if (l_info[dt_reloc]) {
   13650:	45 31 ed             	xor    %r13d,%r13d
   13653:	45 31 ff             	xor    %r15d,%r15d
                                        bool, bool),
                      ElfW(Dyn) **l_info, ElfW(Addr) l_addr,
                      bool rel, bool rel_relative)
{
    struct { ElfW(Addr) start, size; } ranges[2];
    ranges[0].size = ranges[1].size = 0;
   13656:	31 db                	xor    %ebx,%ebx
    ranges[0].start = ranges[1].start = 0;
   13658:	45 31 f6             	xor    %r14d,%r14d
   1365b:	e9 3d fd ff ff       	jmpq   1339d <pal_linux_main+0x47d>
   13660:	48 8b 47 08          	mov    0x8(%rdi),%rax
     *            user stack
     */
    const char ** all_args = (const char **) args;
    //Workaround because sometimes BSD misaligns arguments on stack
    if (all_args[0] == 0) 
	    all_args++;
   13664:	49 83 c4 08          	add    $0x8,%r12
   13668:	e9 d6 f8 ff ff       	jmpq   12f43 <pal_linux_main+0x23>
   1366d:	0f 1f 00             	nopl   (%rax)
    if (!l_info[DT_SYMTAB])
        return;

    {
        ElfW(Sym) *symtab = (void *) D_PTR (l_info[DT_SYMTAB]);
        ElfW(Word) nrelative = (l_info[RELCOUNT_IDX] == NULL
   13670:	4c 89 eb             	mov    %r13,%rbx
   13673:	e9 f0 fd ff ff       	jmpq   13468 <pal_linux_main+0x548>
   13678:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1367f:	00 

0000000000013680 <create_domain_dir>:
    /* jump to main function */
    pal_main(argc, argv, envp);
}

int create_domain_dir (void)
{
   13680:	55                   	push   %rbp
    int ret = 0;
    const char * path;

    ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_PIPEDIR), 0777);
   13681:	41 b8 88 00 00 00    	mov    $0x88,%r8d
   13687:	be ff 01 00 00       	mov    $0x1ff,%esi
   1368c:	48 8d 3d 09 b4 00 00 	lea    0xb409(%rip),%rdi        # 1ea9c <slab_levels+0x57fc>
   13693:	44 89 c0             	mov    %r8d,%eax
    /* jump to main function */
    pal_main(argc, argv, envp);
}

int create_domain_dir (void)
{
   13696:	48 89 e5             	mov    %rsp,%rbp
   13699:	41 54                	push   %r12
   1369b:	53                   	push   %rbx
   1369c:	48 83 ec 10          	sub    $0x10,%rsp
    int ret = 0;
    const char * path;

    ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_PIPEDIR), 0777);
   136a0:	cd 80                	int    $0x80
   136a2:	48 89 c2             	mov    %rax,%rdx
   136a5:	bb 00 00 00 00       	mov    $0x0,%ebx
   136aa:	83 d3 00             	adc    $0x0,%ebx
   136ad:	31 c9                	xor    %ecx,%ecx
   136af:	85 db                	test   %ebx,%ebx
   136b1:	0f 95 c1             	setne  %cl
   136b4:	48 89 c8             	mov    %rcx,%rax
   136b7:	48 f7 d8             	neg    %rax
   136ba:	48 31 c2             	xor    %rax,%rdx
   136bd:	48 01 ca             	add    %rcx,%rdx

    if (IS_ERR(ret) && ERRNO(ret) != EEXIST) {
   136c0:	83 fa ef             	cmp    $0xffffffffffffffef,%edx
   136c3:	74 3b                	je     13700 <create_domain_dir+0x80>
   136c5:	89 d0                	mov    %edx,%eax
   136c7:	c1 e8 1f             	shr    $0x1f,%eax
   136ca:	84 c0                	test   %al,%al
   136cc:	74 32                	je     13700 <create_domain_dir+0x80>
        if (ERRNO(ret) == ENOENT) {
   136ce:	83 fa fe             	cmp    $0xfffffffffffffffe,%edx
   136d1:	89 d1                	mov    %edx,%ecx
int create_domain_dir (void)
{
    int ret = 0;
    const char * path;

    ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_PIPEDIR), 0777);
   136d3:	49 89 f9             	mov    %rdi,%r9

    if (IS_ERR(ret) && ERRNO(ret) != EEXIST) {
        if (ERRNO(ret) == ENOENT) {
   136d6:	0f 84 b8 00 00 00    	je     13794 <create_domain_dir+0x114>
                ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_PIPEDIR), 0777);
            }
        }

        if (IS_ERR(ret)) {
            printf("Cannot create directory %s (%e), "
   136dc:	89 ca                	mov    %ecx,%edx
   136de:	48 8d 3d 53 b5 00 00 	lea    0xb553(%rip),%rdi        # 1ec38 <slab_levels+0x5998>
   136e5:	4c 89 ce             	mov    %r9,%rsi
   136e8:	f7 da                	neg    %edx
   136ea:	31 c0                	xor    %eax,%eax
   136ec:	e8 2f 57 ff ff       	callq  8e20 <pal_printf>
        }
    } while (IS_ERR(ret));

    pal_sec_info.domain_id = id;
    return 0;
}
   136f1:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
        }

        if (IS_ERR(ret)) {
            printf("Cannot create directory %s (%e), "
                   "please check permission\n", path, ERRNO(ret));
            return -PAL_ERROR_DENIED;
   136f5:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
        }
    } while (IS_ERR(ret));

    pal_sec_info.domain_id = id;
    return 0;
}
   136fa:	5b                   	pop    %rbx
   136fb:	41 5c                	pop    %r12
   136fd:	5d                   	pop    %rbp
   136fe:	c3                   	retq   
   136ff:	90                   	nop    
                   "please check permission\n", path, ERRNO(ret));
            return -PAL_ERROR_DENIED;
        }
    }

    if (!IS_ERR(ret))
   13700:	85 d2                	test   %edx,%edx
   13702:	0f 89 02 01 00 00    	jns    1380a <create_domain_dir+0x18a>
        INLINE_SYSCALL(chmod, 2, GRAPHENE_PIPEDIR, 0777);

    char * pipedir = __alloca(GRAPHENE_PIPEDIR_LEN + 10);
   13708:	48 83 ec 30          	sub    $0x30,%rsp
    unsigned int id;

    do {
        if (!getrand(&id, sizeof(unsigned int))) {
   1370c:	48 8d 7d ec          	lea    -0x14(%rbp),%rdi
   13710:	be 04 00 00 00       	mov    $0x4,%esi
    }

    if (!IS_ERR(ret))
        INLINE_SYSCALL(chmod, 2, GRAPHENE_PIPEDIR, 0777);

    char * pipedir = __alloca(GRAPHENE_PIPEDIR_LEN + 10);
   13715:	4c 8d 64 24 0f       	lea    0xf(%rsp),%r12
    unsigned int id;

    do {
        if (!getrand(&id, sizeof(unsigned int))) {
   1371a:	e8 f1 2d ff ff       	callq  6510 <getrand>
    }

    if (!IS_ERR(ret))
        INLINE_SYSCALL(chmod, 2, GRAPHENE_PIPEDIR, 0777);

    char * pipedir = __alloca(GRAPHENE_PIPEDIR_LEN + 10);
   1371f:	49 83 e4 f0          	and    $0xfffffffffffffff0,%r12
    unsigned int id;

    do {
        if (!getrand(&id, sizeof(unsigned int))) {
   13723:	85 c0                	test   %eax,%eax
   13725:	0f 84 ff 00 00 00    	je     1382a <create_domain_dir+0x1aa>
            printf("Unable to generate random numbers\n");
            return -PAL_ERROR_DENIED;
        }

        snprintf(pipedir, GRAPHENE_PIPEDIR_LEN + 10,
   1372b:	8b 4d ec             	mov    -0x14(%rbp),%ecx
   1372e:	48 8d 15 93 ae 00 00 	lea    0xae93(%rip),%rdx        # 1e5c8 <slab_levels+0x5328>
   13735:	4c 89 e7             	mov    %r12,%rdi
   13738:	be 1d 00 00 00       	mov    $0x1d,%esi
   1373d:	31 c0                	xor    %eax,%eax
   1373f:	e8 6c 57 ff ff       	callq  8eb0 <pal_snprintf>
                 GRAPHENE_PIPEDIR "/%08x", id);

        ret = INLINE_SYSCALL(mkdir, 2, pipedir, 0700);
   13744:	ba 88 00 00 00       	mov    $0x88,%edx
   13749:	be c0 01 00 00       	mov    $0x1c0,%esi
   1374e:	4c 89 e7             	mov    %r12,%rdi
   13751:	89 d0                	mov    %edx,%eax
   13753:	cd 80                	int    $0x80
   13755:	48 89 c1             	mov    %rax,%rcx
   13758:	bb 00 00 00 00       	mov    $0x0,%ebx
   1375d:	83 d3 00             	adc    $0x0,%ebx
   13760:	31 f6                	xor    %esi,%esi
   13762:	85 db                	test   %ebx,%ebx
   13764:	40 0f 95 c6          	setne  %sil
   13768:	48 89 f0             	mov    %rsi,%rax
   1376b:	48 f7 d8             	neg    %rax
   1376e:	48 31 c1             	xor    %rax,%rcx
   13771:	48 01 f1             	add    %rsi,%rcx

        if (IS_ERR(ret) && ERRNO(ret) != -EEXIST) {
   13774:	85 c9                	test   %ecx,%ecx
   13776:	0f 88 c8 00 00 00    	js     13844 <create_domain_dir+0x1c4>
                   "please fix permission\n", pipedir, ERRNO(ret));
            return -PAL_ERROR_DENIED;
        }
    } while (IS_ERR(ret));

    pal_sec_info.domain_id = id;
   1377c:	8b 55 ec             	mov    -0x14(%rbp),%edx
   1377f:	48 8b 05 22 03 21 00 	mov    0x210322(%rip),%rax        # 223aa8 <_DYNAMIC+0x2c0>
   13786:	89 50 08             	mov    %edx,0x8(%rax)
    return 0;
}
   13789:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
            return -PAL_ERROR_DENIED;
        }
    } while (IS_ERR(ret));

    pal_sec_info.domain_id = id;
    return 0;
   1378d:	31 c0                	xor    %eax,%eax
}
   1378f:	5b                   	pop    %rbx
   13790:	41 5c                	pop    %r12
   13792:	5d                   	pop    %rbp
   13793:	c3                   	retq   

    ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_PIPEDIR), 0777);

    if (IS_ERR(ret) && ERRNO(ret) != EEXIST) {
        if (ERRNO(ret) == ENOENT) {
            ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_TMPDIR), 0777);
   13794:	48 8d 3d 15 b3 00 00 	lea    0xb315(%rip),%rdi        # 1eab0 <slab_levels+0x5810>
   1379b:	44 89 c0             	mov    %r8d,%eax
   1379e:	cd 80                	int    $0x80
   137a0:	48 89 c1             	mov    %rax,%rcx
   137a3:	bb 00 00 00 00       	mov    $0x0,%ebx
   137a8:	83 d3 00             	adc    $0x0,%ebx
   137ab:	31 d2                	xor    %edx,%edx
   137ad:	85 db                	test   %ebx,%ebx
   137af:	0f 95 c2             	setne  %dl
   137b2:	48 89 d0             	mov    %rdx,%rax
   137b5:	48 f7 d8             	neg    %rax
   137b8:	48 31 c1             	xor    %rax,%rcx
   137bb:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax
            if (!IS_ERR(ret)) {
   137bf:	85 c0                	test   %eax,%eax

    ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_PIPEDIR), 0777);

    if (IS_ERR(ret) && ERRNO(ret) != EEXIST) {
        if (ERRNO(ret) == ENOENT) {
            ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_TMPDIR), 0777);
   137c1:	89 c1                	mov    %eax,%ecx
            if (!IS_ERR(ret)) {
   137c3:	0f 88 9e 00 00 00    	js     13867 <create_domain_dir+0x1e7>
                INLINE_SYSCALL(chmod, 2, GRAPHENE_TMPDIR, 0777);
   137c9:	b8 0f 00 00 00       	mov    $0xf,%eax
   137ce:	cd 80                	int    $0x80
   137d0:	bb 00 00 00 00       	mov    $0x0,%ebx
   137d5:	83 d3 00             	adc    $0x0,%ebx
                ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_PIPEDIR), 0777);
   137d8:	4c 89 cf             	mov    %r9,%rdi
   137db:	44 89 c0             	mov    %r8d,%eax
   137de:	cd 80                	int    $0x80
   137e0:	49 89 c0             	mov    %rax,%r8
   137e3:	bb 00 00 00 00       	mov    $0x0,%ebx
   137e8:	83 d3 00             	adc    $0x0,%ebx
   137eb:	31 c0                	xor    %eax,%eax
   137ed:	85 db                	test   %ebx,%ebx
   137ef:	0f 95 c0             	setne  %al
   137f2:	48 89 c2             	mov    %rax,%rdx
   137f5:	48 f7 da             	neg    %rdx
   137f8:	49 31 d0             	xor    %rdx,%r8
   137fb:	49 01 c0             	add    %rax,%r8
            }
        }

        if (IS_ERR(ret)) {
   137fe:	45 85 c0             	test   %r8d,%r8d
    if (IS_ERR(ret) && ERRNO(ret) != EEXIST) {
        if (ERRNO(ret) == ENOENT) {
            ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_TMPDIR), 0777);
            if (!IS_ERR(ret)) {
                INLINE_SYSCALL(chmod, 2, GRAPHENE_TMPDIR, 0777);
                ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_PIPEDIR), 0777);
   13801:	44 89 c1             	mov    %r8d,%ecx
            }
        }

        if (IS_ERR(ret)) {
   13804:	0f 88 d2 fe ff ff    	js     136dc <create_domain_dir+0x5c>
            return -PAL_ERROR_DENIED;
        }
    }

    if (!IS_ERR(ret))
        INLINE_SYSCALL(chmod, 2, GRAPHENE_PIPEDIR, 0777);
   1380a:	be ff 01 00 00       	mov    $0x1ff,%esi
   1380f:	48 8d 3d 86 b2 00 00 	lea    0xb286(%rip),%rdi        # 1ea9c <slab_levels+0x57fc>
   13816:	b8 0f 00 00 00       	mov    $0xf,%eax
   1381b:	cd 80                	int    $0x80
   1381d:	bb 00 00 00 00       	mov    $0x0,%ebx
   13822:	83 d3 00             	adc    $0x0,%ebx
   13825:	e9 de fe ff ff       	jmpq   13708 <create_domain_dir+0x88>
    char * pipedir = __alloca(GRAPHENE_PIPEDIR_LEN + 10);
    unsigned int id;

    do {
        if (!getrand(&id, sizeof(unsigned int))) {
            printf("Unable to generate random numbers\n");
   1382a:	48 8d 3d 47 b4 00 00 	lea    0xb447(%rip),%rdi        # 1ec78 <slab_levels+0x59d8>
   13831:	e8 ea 55 ff ff       	callq  8e20 <pal_printf>
        }
    } while (IS_ERR(ret));

    pal_sec_info.domain_id = id;
    return 0;
}
   13836:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
    unsigned int id;

    do {
        if (!getrand(&id, sizeof(unsigned int))) {
            printf("Unable to generate random numbers\n");
            return -PAL_ERROR_DENIED;
   1383a:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
        }
    } while (IS_ERR(ret));

    pal_sec_info.domain_id = id;
    return 0;
}
   1383f:	5b                   	pop    %rbx
   13840:	41 5c                	pop    %r12
   13842:	5d                   	pop    %rbp
   13843:	c3                   	retq   
                 GRAPHENE_PIPEDIR "/%08x", id);

        ret = INLINE_SYSCALL(mkdir, 2, pipedir, 0700);

        if (IS_ERR(ret) && ERRNO(ret) != -EEXIST) {
            printf("Cannot create directory %s (%e), "
   13844:	89 ca                	mov    %ecx,%edx
   13846:	48 8d 3d 53 b4 00 00 	lea    0xb453(%rip),%rdi        # 1eca0 <slab_levels+0x5a00>
   1384d:	4c 89 e6             	mov    %r12,%rsi
   13850:	f7 da                	neg    %edx
   13852:	31 c0                	xor    %eax,%eax
   13854:	e8 c7 55 ff ff       	callq  8e20 <pal_printf>
        }
    } while (IS_ERR(ret));

    pal_sec_info.domain_id = id;
    return 0;
}
   13859:	48 8d 65 f0          	lea    -0x10(%rbp),%rsp
        ret = INLINE_SYSCALL(mkdir, 2, pipedir, 0700);

        if (IS_ERR(ret) && ERRNO(ret) != -EEXIST) {
            printf("Cannot create directory %s (%e), "
                   "please fix permission\n", pipedir, ERRNO(ret));
            return -PAL_ERROR_DENIED;
   1385d:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
        }
    } while (IS_ERR(ret));

    pal_sec_info.domain_id = id;
    return 0;
}
   13862:	5b                   	pop    %rbx
   13863:	41 5c                	pop    %r12
   13865:	5d                   	pop    %rbp
   13866:	c3                   	retq   

    ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_PIPEDIR), 0777);

    if (IS_ERR(ret) && ERRNO(ret) != EEXIST) {
        if (ERRNO(ret) == ENOENT) {
            ret = INLINE_SYSCALL(mkdir, 2, (path = GRAPHENE_TMPDIR), 0777);
   13867:	4c 8d 0d 42 b2 00 00 	lea    0xb242(%rip),%r9        # 1eab0 <slab_levels+0x5810>
   1386e:	e9 69 fe ff ff       	jmpq   136dc <create_domain_dir+0x5c>
   13873:	66 66 66 66 2e 0f 1f 	nopw   %cs:0x0(%rax,%rax,1)
   1387a:	84 00 00 00 00 00 

0000000000013880 <_DkInitHost>:
{
    return memcmp(key, "loader.", 7);
}

int _DkInitHost (int * pargc, const char *** pargv)
{
   13880:	55                   	push   %rbp
   13881:	48 89 e5             	mov    %rsp,%rbp
   13884:	41 57                	push   %r15
   13886:	41 56                	push   %r14
   13888:	41 55                	push   %r13
   1388a:	41 54                	push   %r12
   1388c:	53                   	push   %rbx
   1388d:	48 81 ec c8 01 00 00 	sub    $0x1c8,%rsp
    int argc = *pargc;
   13894:	44 8b 2f             	mov    (%rdi),%r13d
{
    return memcmp(key, "loader.", 7);
}

int _DkInitHost (int * pargc, const char *** pargv)
{
   13897:	48 89 bd 38 fe ff ff 	mov    %rdi,-0x1c8(%rbp)
   1389e:	48 89 b5 30 fe ff ff 	mov    %rsi,-0x1d0(%rbp)
    int argc = *pargc;
    const char ** argv = *pargv, * first_argv = NULL;
   138a5:	4c 8b 36             	mov    (%rsi),%r14
    int ret = 0;

    if (!child_args && !argc) {
   138a8:	45 85 ed             	test   %r13d,%r13d
   138ab:	75 0e                	jne    138bb <_DkInitHost+0x3b>
   138ad:	48 83 3d 3b 12 21 00 	cmpq   $0x0,0x21123b(%rip)        # 224af0 <child_args>
   138b4:	00 
   138b5:	0f 84 b9 04 00 00    	je     13d74 <_DkInitHost+0x4f4>
        printf("USAGE: libpal.so [executable|manifest] args ...\n");
        return -PAL_ERROR_INVAL;
    }

    if (pal_sec_info.pal_name)
   138bb:	4c 8b 25 e6 01 21 00 	mov    0x2101e6(%rip),%r12        # 223aa8 <_DYNAMIC+0x2c0>
   138c2:	49 8b 04 24          	mov    (%r12),%rax
   138c6:	48 85 c0             	test   %rax,%rax
   138c9:	74 07                	je     138d2 <_DkInitHost+0x52>
        libname = pal_sec_info.pal_name;
   138cb:	48 89 05 26 12 21 00 	mov    %rax,0x211226(%rip)        # 224af8 <libname>

    pal_linux_config.pid = INLINE_SYSCALL(getpid, 0);
   138d2:	b9 14 00 00 00       	mov    $0x14,%ecx
   138d7:	89 c8                	mov    %ecx,%eax
   138d9:	cd 80                	int    $0x80
   138db:	48 89 c2             	mov    %rax,%rdx
   138de:	bb 00 00 00 00       	mov    $0x0,%ebx
   138e3:	83 d3 00             	adc    $0x0,%ebx
   138e6:	31 c9                	xor    %ecx,%ecx
   138e8:	85 db                	test   %ebx,%ebx
   138ea:	0f 95 c1             	setne  %cl
   138ed:	48 89 c8             	mov    %rcx,%rax
   138f0:	48 f7 d8             	neg    %rax
   138f3:	48 31 c2             	xor    %rax,%rdx
   138f6:	48 8b 05 63 00 21 00 	mov    0x210063(%rip),%rax        # 223960 <_DYNAMIC+0x178>
   138fd:	48 01 ca             	add    %rcx,%rdx
   13900:	89 10                	mov    %edx,(%rax)

    signal_setup();
   13902:	e8 a9 17 00 00       	callq  150b0 <signal_setup>

    if (child_args) {
   13907:	48 8b 3d e2 11 21 00 	mov    0x2111e2(%rip),%rdi        # 224af0 <child_args>
   1390e:	48 85 ff             	test   %rdi,%rdi
   13911:	0f 84 e9 01 00 00    	je     13b00 <_DkInitHost+0x280>
        if ((ret = init_child_process(child_args)) < 0)
   13917:	e8 84 e8 ff ff       	callq  121a0 <init_child_process>
   1391c:	85 c0                	test   %eax,%eax
   1391e:	0f 88 c7 01 00 00    	js     13aeb <_DkInitHost+0x26b>
   13924:	4c 8b 3d f5 00 21 00 	mov    0x2100f5(%rip),%r15        # 223a20 <_DYNAMIC+0x238>
}

int _DkInitHost (int * pargc, const char *** pargv)
{
    int argc = *pargc;
    const char ** argv = *pargv, * first_argv = NULL;
   1392b:	48 c7 85 28 fe ff ff 	movq   $0x0,-0x1d8(%rbp)
   13932:	00 00 00 00 
   13936:	49 8b 7f 10          	mov    0x10(%r15),%rdi
        pal_config.manifest_handle = file;
        goto read_manifest;
    }

read_manifest:
    if (!pal_config.manifest_handle) {
   1393a:	48 85 ff             	test   %rdi,%rdi
   1393d:	48 8d 9d 60 fe ff ff 	lea    -0x1a0(%rbp),%rbx
   13944:	0f 84 ea 02 00 00    	je     13c34 <_DkInitHost+0x3b4>
        goto done_init;
    }

    PAL_STREAM_ATTR attr;

    if ((ret = _DkStreamAttributesQuerybyHandle(pal_config.manifest_handle,
   1394a:	48 89 de             	mov    %rbx,%rsi
   1394d:	e8 de 07 ff ff       	callq  4130 <_DkStreamAttributesQuerybyHandle>
   13952:	85 c0                	test   %eax,%eax
   13954:	0f 88 91 01 00 00    	js     13aeb <_DkInitHost+0x26b>
        return ret;

    void * cfg_addr = NULL;
    size_t cfg_size = attr.size;

    if ((ret = _DkStreamMap(pal_config.manifest_handle, &cfg_addr,
   1395a:	48 8b 05 2f 00 21 00 	mov    0x21002f(%rip),%rax        # 223990 <_DYNAMIC+0x1a8>
    if ((ret = _DkStreamAttributesQuerybyHandle(pal_config.manifest_handle,
                                                &attr)) < 0)
        return ret;

    void * cfg_addr = NULL;
    size_t cfg_size = attr.size;
   13961:	48 8b 9d 70 fe ff ff 	mov    -0x190(%rbp),%rbx

    if ((ret = _DkStreamAttributesQuerybyHandle(pal_config.manifest_handle,
                                                &attr)) < 0)
        return ret;

    void * cfg_addr = NULL;
   13968:	48 c7 85 50 fe ff ff 	movq   $0x0,-0x1b0(%rbp)
   1396f:	00 00 00 00 
    size_t cfg_size = attr.size;

    if ((ret = _DkStreamMap(pal_config.manifest_handle, &cfg_addr,
   13973:	48 83 38 00          	cmpq   $0x0,(%rax)
   13977:	49 89 d8             	mov    %rbx,%r8
   1397a:	74 14                	je     13990 <_DkInitHost+0x110>
                            PAL_PROT_READ, 0,
                            ALLOC_ALIGNUP(cfg_size))) < 0)
   1397c:	48 8b 05 c5 01 21 00 	mov    0x2101c5(%rip),%rax        # 223b48 <_DYNAMIC+0x360>
   13983:	4c 03 00             	add    (%rax),%r8
   13986:	48 8b 05 6b 01 21 00 	mov    0x21016b(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
        return ret;

    void * cfg_addr = NULL;
    size_t cfg_size = attr.size;

    if ((ret = _DkStreamMap(pal_config.manifest_handle, &cfg_addr,
   1398d:	4c 23 00             	and    (%rax),%r8
   13990:	49 8b 7f 10          	mov    0x10(%r15),%rdi
   13994:	48 8d b5 50 fe ff ff 	lea    -0x1b0(%rbp),%rsi
   1399b:	31 c9                	xor    %ecx,%ecx
   1399d:	ba 01 00 00 00       	mov    $0x1,%edx
   139a2:	e8 f9 08 ff ff       	callq  42a0 <_DkStreamMap>
   139a7:	85 c0                	test   %eax,%eax
   139a9:	0f 88 3c 01 00 00    	js     13aeb <_DkInitHost+0x26b>
                            PAL_PROT_READ, 0,
                            ALLOC_ALIGNUP(cfg_size))) < 0)
        return ret;

    struct config_store * root_config = malloc(sizeof(struct config_store));
   139af:	bf 40 00 00 00       	mov    $0x40,%edi
   139b4:	e8 47 50 ff ff       	callq  8a00 <malloc>
   139b9:	49 89 c0             	mov    %rax,%r8
    root_config->raw_data = cfg_addr;
   139bc:	48 8b 85 50 fe ff ff 	mov    -0x1b0(%rbp),%rax
    root_config->malloc = malloc;
    root_config->free = free;

    const char * errstring = NULL;

    if ((ret = read_config(root_config, loader_filter, &errstring)) < 0) {
   139c3:	48 8d 95 58 fe ff ff 	lea    -0x1a8(%rbp),%rdx
   139ca:	48 8d 35 ef f1 ff ff 	lea    -0xe11(%rip),%rsi        # 12bc0 <loader_filter>
                            ALLOC_ALIGNUP(cfg_size))) < 0)
        return ret;

    struct config_store * root_config = malloc(sizeof(struct config_store));
    root_config->raw_data = cfg_addr;
    root_config->raw_size = cfg_size;
   139d1:	49 89 58 28          	mov    %rbx,0x28(%r8)
    root_config->malloc = malloc;
    root_config->free = free;

    const char * errstring = NULL;

    if ((ret = read_config(root_config, loader_filter, &errstring)) < 0) {
   139d5:	4c 89 c7             	mov    %r8,%rdi
   139d8:	4c 89 85 20 fe ff ff 	mov    %r8,-0x1e0(%rbp)
    root_config->raw_data = cfg_addr;
    root_config->raw_size = cfg_size;
    root_config->malloc = malloc;
    root_config->free = free;

    const char * errstring = NULL;
   139df:	48 c7 85 58 fe ff ff 	movq   $0x0,-0x1a8(%rbp)
   139e6:	00 00 00 00 
                            PAL_PROT_READ, 0,
                            ALLOC_ALIGNUP(cfg_size))) < 0)
        return ret;

    struct config_store * root_config = malloc(sizeof(struct config_store));
    root_config->raw_data = cfg_addr;
   139ea:	49 89 40 20          	mov    %rax,0x20(%r8)
    root_config->raw_size = cfg_size;
    root_config->malloc = malloc;
   139ee:	48 8b 05 db ff 20 00 	mov    0x20ffdb(%rip),%rax        # 2239d0 <_DYNAMIC+0x1e8>
   139f5:	49 89 40 30          	mov    %rax,0x30(%r8)
    root_config->free = free;
   139f9:	48 8b 05 98 01 21 00 	mov    0x210198(%rip),%rax        # 223b98 <_DYNAMIC+0x3b0>
   13a00:	49 89 40 38          	mov    %rax,0x38(%r8)

    const char * errstring = NULL;

    if ((ret = read_config(root_config, loader_filter, &errstring)) < 0) {
   13a04:	e8 f7 46 00 00       	callq  18100 <read_config>
   13a09:	85 c0                	test   %eax,%eax
   13a0b:	4c 8b 85 20 fe ff ff 	mov    -0x1e0(%rbp),%r8
   13a12:	0f 88 18 04 00 00    	js     13e30 <_DkInitHost+0x5b0>
    pal_config.root_config = root_config;

    char cfgbuf[CONFIG_MAX];
    int len;

    if (!pal_linux_config.noexec && !pal_config.exec_handle) {
   13a18:	48 8b 05 41 ff 20 00 	mov    0x20ff41(%rip),%rax        # 223960 <_DYNAMIC+0x178>
    if ((ret = read_config(root_config, loader_filter, &errstring)) < 0) {
        printf("Can't read manifest: %s\n", errstring);
        return -PAL_ERROR_INVAL;
    }

    pal_config.root_config = root_config;
   13a1f:	4d 89 47 20          	mov    %r8,0x20(%r15)

    char cfgbuf[CONFIG_MAX];
    int len;

    if (!pal_linux_config.noexec && !pal_config.exec_handle) {
   13a23:	80 78 18 00          	cmpb   $0x0,0x18(%rax)
   13a27:	0f 84 63 01 00 00    	je     13b90 <_DkInitHost+0x310>
            pal_config.exec = remalloc(cfgbuf, len + 1);
            pal_config.exec_handle = file;
        }
    }

    if (!child_args) {
   13a2d:	48 83 3d bb 10 21 00 	cmpq   $0x0,0x2110bb(%rip)        # 224af0 <child_args>
   13a34:	00 
   13a35:	0f 84 75 03 00 00    	je     13db0 <_DkInitHost+0x530>
done_init:
    if (!child_args && pal_config.exec)
        printf("Program \"%s\" loaded in Graphene Library OS\n",
               pal_config.exec);

    pal_config.lib_name = libname;
   13a3b:	48 8b 05 b6 10 21 00 	mov    0x2110b6(%rip),%rax        # 224af8 <libname>
   13a42:	49 89 47 28          	mov    %rax,0x28(%r15)
    if (!child_args && !pal_sec_info.domain_id) {
        if ((ret = create_domain_dir()) < 0)
            return ret;
    }

    PAL_HANDLE thread = malloc(HANDLE_SIZE(thread));
   13a46:	bf 10 00 00 00       	mov    $0x10,%edi
   13a4b:	e8 b0 4f ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(thread, thread);
    thread->thread.tid = pal_linux_config.pid;
   13a50:	48 8b 0d 09 ff 20 00 	mov    0x20ff09(%rip),%rcx        # 223960 <_DYNAMIC+0x178>
        if ((ret = create_domain_dir()) < 0)
            return ret;
    }

    PAL_HANDLE thread = malloc(HANDLE_SIZE(thread));
    SET_HANDLE_TYPE(thread, thread);
   13a57:	c7 00 0e 00 00 00    	movl   $0xe,(%rax)
   13a5d:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
   13a64:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    thread->thread.tid = pal_linux_config.pid;
    __pal_control.first_thread = thread;
   13a6b:	4c 8b 3d 06 01 21 00 	mov    0x210106(%rip),%r15        # 223b78 <_DYNAMIC+0x390>
            return ret;
    }

    PAL_HANDLE thread = malloc(HANDLE_SIZE(thread));
    SET_HANDLE_TYPE(thread, thread);
    thread->thread.tid = pal_linux_config.pid;
   13a72:	8b 11                	mov    (%rcx),%edx
   13a74:	89 50 0c             	mov    %edx,0xc(%rax)
#if USE_VDSO_GETTIME == 1
    if (sysinfo_ehdr)
        setup_vdso_map(sysinfo_ehdr);
#endif

    if (!pal_sec_info.mcast_port) {
   13a77:	66 41 83 7c 24 1c 00 	cmpw   $0x0,0x1c(%r12)
    }

    PAL_HANDLE thread = malloc(HANDLE_SIZE(thread));
    SET_HANDLE_TYPE(thread, thread);
    thread->thread.tid = pal_linux_config.pid;
    __pal_control.first_thread = thread;
   13a7e:	49 89 47 48          	mov    %rax,0x48(%r15)
#if USE_VDSO_GETTIME == 1
    if (sysinfo_ehdr)
        setup_vdso_map(sysinfo_ehdr);
#endif

    if (!pal_sec_info.mcast_port) {
   13a82:	75 23                	jne    13aa7 <_DkInitHost+0x227>
        do {
            getrand(&pal_sec_info.mcast_port, sizeof(unsigned short));
   13a84:	49 8d 5c 24 1c       	lea    0x1c(%r12),%rbx
   13a89:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
   13a90:	be 02 00 00 00       	mov    $0x2,%esi
   13a95:	48 89 df             	mov    %rbx,%rdi
   13a98:	e8 73 2a ff ff       	callq  6510 <getrand>
        } while (pal_sec_info.mcast_port < 1024);
   13a9d:	66 41 81 7c 24 1c ff 	cmpw   $0x3ff,0x1c(%r12)
   13aa4:	03 
   13aa5:	76 e9                	jbe    13a90 <_DkInitHost+0x210>
    }

    __pal_control.broadcast_stream = pal_sec_info.mcast_handle ? :
   13aa7:	49 8b 44 24 20       	mov    0x20(%r12),%rax
   13aac:	48 85 c0             	test   %rax,%rax
   13aaf:	0f 84 eb 02 00 00    	je     13da0 <_DkInitHost+0x520>
                            _DkBroadcastStreamOpen(pal_sec_info.mcast_port);

    if (first_argv) {
   13ab5:	48 8b 8d 28 fe ff ff 	mov    -0x1d8(%rbp),%rcx
        do {
            getrand(&pal_sec_info.mcast_port, sizeof(unsigned short));
        } while (pal_sec_info.mcast_port < 1024);
    }

    __pal_control.broadcast_stream = pal_sec_info.mcast_handle ? :
   13abc:	49 89 47 58          	mov    %rax,0x58(%r15)
                            _DkBroadcastStreamOpen(pal_sec_info.mcast_port);

    if (first_argv) {
   13ac0:	48 85 c9             	test   %rcx,%rcx
   13ac3:	0f 84 27 02 00 00    	je     13cf0 <_DkInitHost+0x470>
        argc++;
        argv--;
   13ac9:	49 8d 46 f8          	lea    -0x8(%r14),%rax

    __pal_control.broadcast_stream = pal_sec_info.mcast_handle ? :
                            _DkBroadcastStreamOpen(pal_sec_info.mcast_port);

    if (first_argv) {
        argc++;
   13acd:	41 83 c5 01          	add    $0x1,%r13d
        argv--;
        argv[0] = first_argv;
   13ad1:	49 89 4e f8          	mov    %rcx,-0x8(%r14)
    }

    *pargc = argc;
   13ad5:	48 8b 8d 38 fe ff ff 	mov    -0x1c8(%rbp),%rcx
   13adc:	44 89 29             	mov    %r13d,(%rcx)
    *pargv = argv;
   13adf:	48 8b 8d 30 fe ff ff 	mov    -0x1d0(%rbp),%rcx
   13ae6:	48 89 01             	mov    %rax,(%rcx)

    return 0;
   13ae9:	31 c0                	xor    %eax,%eax
}
   13aeb:	48 81 c4 c8 01 00 00 	add    $0x1c8,%rsp
   13af2:	5b                   	pop    %rbx
   13af3:	41 5c                	pop    %r12
   13af5:	41 5d                	pop    %r13
   13af7:	41 5e                	pop    %r14
   13af9:	41 5f                	pop    %r15
   13afb:	5d                   	pop    %rbp
   13afc:	c3                   	retq   
   13afd:	0f 1f 00             	nopl   (%rax)
            return ret;

        goto read_manifest;
    }

    if (!libname) {
   13b00:	48 83 3d f0 0f 21 00 	cmpq   $0x0,0x210ff0(%rip)        # 224af8 <libname>
   13b07:	00 
   13b08:	0f 84 04 03 00 00    	je     13e12 <_DkInitHost+0x592>

        goto read_manifest;
    }

    PAL_HANDLE file = NULL;
    const char * file_uri = NULL;
   13b0e:	48 c7 85 48 fe ff ff 	movq   $0x0,-0x1b8(%rbp)
   13b15:	00 00 00 00 

    if (argv[0][0] != '-') {
   13b19:	49 8b 3e             	mov    (%r14),%rdi
   13b1c:	80 3f 2d             	cmpb   $0x2d,(%rdi)
   13b1f:	0f 84 7e 01 00 00    	je     13ca3 <_DkInitHost+0x423>
        file = try_open_runnable(argv[0], true, &file_uri);
   13b25:	48 8d 95 48 fe ff ff 	lea    -0x1b8(%rbp),%rdx
   13b2c:	be 01 00 00 00       	mov    $0x1,%esi
   13b31:	e8 aa f0 ff ff       	callq  12be0 <try_open_runnable>
        if (!file)
   13b36:	48 85 c0             	test   %rax,%rax

    PAL_HANDLE file = NULL;
    const char * file_uri = NULL;

    if (argv[0][0] != '-') {
        file = try_open_runnable(argv[0], true, &file_uri);
   13b39:	48 89 c3             	mov    %rax,%rbx
        if (!file)
   13b3c:	0f 84 4a 02 00 00    	je     13d8c <_DkInitHost+0x50c>
            return -PAL_ERROR_DENIED;

        first_argv = argv[0];
   13b42:	49 8b 06             	mov    (%r14),%rax
        argc--;
        argv++;

        /* the file laoded might be a executable */
        if (check_elf_object(file)) {
   13b45:	48 89 df             	mov    %rbx,%rdi
        file = try_open_runnable(argv[0], true, &file_uri);
        if (!file)
            return -PAL_ERROR_DENIED;

        first_argv = argv[0];
        argc--;
   13b48:	41 83 ed 01          	sub    $0x1,%r13d
        argv++;
   13b4c:	49 83 c6 08          	add    $0x8,%r14
    if (argv[0][0] != '-') {
        file = try_open_runnable(argv[0], true, &file_uri);
        if (!file)
            return -PAL_ERROR_DENIED;

        first_argv = argv[0];
   13b50:	48 89 85 28 fe ff ff 	mov    %rax,-0x1d8(%rbp)
        argc--;
        argv++;

        /* the file laoded might be a executable */
        if (check_elf_object(file)) {
   13b57:	e8 d4 3b ff ff       	callq  7730 <check_elf_object>
   13b5c:	85 c0                	test   %eax,%eax
   13b5e:	0f 84 9c 01 00 00    	je     13d00 <_DkInitHost+0x480>
            pal_config.manifest        = file_uri;
   13b64:	4c 8b 3d b5 fe 20 00 	mov    0x20feb5(%rip),%r15        # 223a20 <_DYNAMIC+0x238>
   13b6b:	48 8b 85 48 fe ff ff 	mov    -0x1b8(%rbp),%rax
            pal_config.manifest_handle = file;
            goto read_manifest;
   13b72:	48 89 df             	mov    %rbx,%rdi
        argv++;

        /* the file laoded might be a executable */
        if (check_elf_object(file)) {
            pal_config.manifest        = file_uri;
            pal_config.manifest_handle = file;
   13b75:	49 89 5f 10          	mov    %rbx,0x10(%r15)
        argc--;
        argv++;

        /* the file laoded might be a executable */
        if (check_elf_object(file)) {
            pal_config.manifest        = file_uri;
   13b79:	49 89 07             	mov    %rax,(%r15)
   13b7c:	48 8d 9d 60 fe ff ff 	lea    -0x1a0(%rbp),%rbx
            pal_config.manifest_handle = file;
            goto read_manifest;
   13b83:	e9 c2 fd ff ff       	jmpq   1394a <_DkInitHost+0xca>
   13b88:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   13b8f:	00 
    pal_config.root_config = root_config;

    char cfgbuf[CONFIG_MAX];
    int len;

    if (!pal_linux_config.noexec && !pal_config.exec_handle) {
   13b90:	49 83 7f 18 00       	cmpq   $0x0,0x18(%r15)
   13b95:	0f 85 92 fe ff ff    	jne    13a2d <_DkInitHost+0x1ad>
        /* find executable in the manifest */
        if ((len = get_config(root_config, "loader.exec", cfgbuf,
   13b9b:	48 8d 9d d0 fe ff ff 	lea    -0x130(%rbp),%rbx
   13ba2:	48 8d 35 48 af 00 00 	lea    0xaf48(%rip),%rsi        # 1eaf1 <slab_levels+0x5851>
   13ba9:	4c 89 c7             	mov    %r8,%rdi
   13bac:	b9 00 01 00 00       	mov    $0x100,%ecx
   13bb1:	4c 89 85 20 fe ff ff 	mov    %r8,-0x1e0(%rbp)
   13bb8:	48 89 da             	mov    %rbx,%rdx
   13bbb:	e8 f0 42 00 00       	callq  17eb0 <get_config>
   13bc0:	85 c0                	test   %eax,%eax
   13bc2:	89 85 1c fe ff ff    	mov    %eax,-0x1e4(%rbp)
   13bc8:	4c 8b 85 20 fe ff ff 	mov    -0x1e0(%rbp),%r8
   13bcf:	0f 8e 58 fe ff ff    	jle    13a2d <_DkInitHost+0x1ad>
                              CONFIG_MAX)) > 0) {
            if (!(file = try_open_runnable(cfgbuf, false, NULL)))
   13bd5:	31 d2                	xor    %edx,%edx
   13bd7:	31 f6                	xor    %esi,%esi
   13bd9:	48 89 df             	mov    %rbx,%rdi
   13bdc:	4c 89 85 10 fe ff ff 	mov    %r8,-0x1f0(%rbp)
   13be3:	e8 f8 ef ff ff       	callq  12be0 <try_open_runnable>
   13be8:	48 85 c0             	test   %rax,%rax
   13beb:	0f 84 9b 01 00 00    	je     13d8c <_DkInitHost+0x50c>
                return -PAL_ERROR_DENIED;

            if ((ret = check_elf_object(file)) < 0)
   13bf1:	48 89 c7             	mov    %rax,%rdi
   13bf4:	48 89 85 20 fe ff ff 	mov    %rax,-0x1e0(%rbp)
   13bfb:	e8 30 3b ff ff       	callq  7730 <check_elf_object>
   13c00:	85 c0                	test   %eax,%eax
   13c02:	0f 88 e3 fe ff ff    	js     13aeb <_DkInitHost+0x26b>
                return ret;

            pal_config.exec = remalloc(cfgbuf, len + 1);
   13c08:	8b 8d 1c fe ff ff    	mov    -0x1e4(%rbp),%ecx
   13c0e:	48 89 df             	mov    %rbx,%rdi
   13c11:	8d 71 01             	lea    0x1(%rcx),%esi
   13c14:	e8 e7 4f ff ff       	callq  8c00 <remalloc>
            pal_config.exec_handle = file;
   13c19:	4c 8b 95 20 fe ff ff 	mov    -0x1e0(%rbp),%r10
                return -PAL_ERROR_DENIED;

            if ((ret = check_elf_object(file)) < 0)
                return ret;

            pal_config.exec = remalloc(cfgbuf, len + 1);
   13c20:	49 89 47 08          	mov    %rax,0x8(%r15)
            pal_config.exec_handle = file;
   13c24:	4c 8b 85 10 fe ff ff 	mov    -0x1f0(%rbp),%r8
   13c2b:	4d 89 57 18          	mov    %r10,0x18(%r15)
   13c2f:	e9 f9 fd ff ff       	jmpq   13a2d <_DkInitHost+0x1ad>
        goto read_manifest;
    }

read_manifest:
    if (!pal_config.manifest_handle) {
        printf("Can't fine any manifest, going to run without one\n");
   13c34:	48 8d 3d d5 b0 00 00 	lea    0xb0d5(%rip),%rdi        # 1ed10 <slab_levels+0x5a70>
   13c3b:	31 c0                	xor    %eax,%eax
   13c3d:	e8 de 51 ff ff       	callq  8e20 <pal_printf>
        if (!first_argv)
            first_argv = pal_config.exec;
    }

done_init:
    if (!child_args && pal_config.exec)
   13c42:	48 83 3d a6 0e 21 00 	cmpq   $0x0,0x210ea6(%rip)        # 224af0 <child_args>
   13c49:	00 
   13c4a:	0f 85 eb fd ff ff    	jne    13a3b <_DkInitHost+0x1bb>
   13c50:	49 8b 77 08          	mov    0x8(%r15),%rsi
   13c54:	48 85 f6             	test   %rsi,%rsi
   13c57:	0f 84 a5 01 00 00    	je     13e02 <_DkInitHost+0x582>
        printf("Program \"%s\" loaded in Graphene Library OS\n",
   13c5d:	48 8d 3d e4 b0 00 00 	lea    0xb0e4(%rip),%rdi        # 1ed48 <slab_levels+0x5aa8>
   13c64:	31 c0                	xor    %eax,%eax
   13c66:	e8 b5 51 ff ff       	callq  8e20 <pal_printf>
               pal_config.exec);

    pal_config.lib_name = libname;

    if (!child_args && !pal_sec_info.domain_id) {
   13c6b:	48 83 3d 7d 0e 21 00 	cmpq   $0x0,0x210e7d(%rip)        # 224af0 <child_args>
   13c72:	00 
done_init:
    if (!child_args && pal_config.exec)
        printf("Program \"%s\" loaded in Graphene Library OS\n",
               pal_config.exec);

    pal_config.lib_name = libname;
   13c73:	48 8b 05 7e 0e 21 00 	mov    0x210e7e(%rip),%rax        # 224af8 <libname>
   13c7a:	49 89 47 28          	mov    %rax,0x28(%r15)

    if (!child_args && !pal_sec_info.domain_id) {
   13c7e:	0f 85 c2 fd ff ff    	jne    13a46 <_DkInitHost+0x1c6>
   13c84:	41 8b 44 24 08       	mov    0x8(%r12),%eax
   13c89:	85 c0                	test   %eax,%eax
   13c8b:	0f 85 b5 fd ff ff    	jne    13a46 <_DkInitHost+0x1c6>
        if ((ret = create_domain_dir()) < 0)
   13c91:	e8 ea f9 ff ff       	callq  13680 <create_domain_dir>
   13c96:	85 c0                	test   %eax,%eax
   13c98:	0f 89 a8 fd ff ff    	jns    13a46 <_DkInitHost+0x1c6>
   13c9e:	e9 48 fe ff ff       	jmpq   13aeb <_DkInitHost+0x26b>
   13ca3:	4c 8b 3d 76 fd 20 00 	mov    0x20fd76(%rip),%r15        # 223a20 <_DYNAMIC+0x238>
}

int _DkInitHost (int * pargc, const char *** pargv)
{
    int argc = *pargc;
    const char ** argv = *pargv, * first_argv = NULL;
   13caa:	48 c7 85 28 fe ff ff 	movq   $0x0,-0x1d8(%rbp)
   13cb1:	00 00 00 00 
            pal_config.manifest_handle = file;
            goto read_manifest;
        }
    }

    if ((file = try_open_runnable("file:manifest", false, NULL))) {
   13cb5:	48 8d 3d 0e ae 00 00 	lea    0xae0e(%rip),%rdi        # 1eaca <slab_levels+0x582a>
   13cbc:	31 d2                	xor    %edx,%edx
   13cbe:	31 f6                	xor    %esi,%esi
   13cc0:	e8 1b ef ff ff       	callq  12be0 <try_open_runnable>
   13cc5:	48 85 c0             	test   %rax,%rax
   13cc8:	0f 84 59 01 00 00    	je     13e27 <_DkInitHost+0x5a7>
        pal_config.manifest = "file:manifest";
   13cce:	48 8d 0d f5 ad 00 00 	lea    0xadf5(%rip),%rcx        # 1eaca <slab_levels+0x582a>
        pal_config.manifest_handle = file;
   13cd5:	49 89 47 10          	mov    %rax,0x10(%r15)
   13cd9:	48 89 c7             	mov    %rax,%rdi
   13cdc:	48 8d 9d 60 fe ff ff 	lea    -0x1a0(%rbp),%rbx
            goto read_manifest;
        }
    }

    if ((file = try_open_runnable("file:manifest", false, NULL))) {
        pal_config.manifest = "file:manifest";
   13ce3:	49 89 0f             	mov    %rcx,(%r15)
   13ce6:	e9 5f fc ff ff       	jmpq   1394a <_DkInitHost+0xca>
   13ceb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   13cf0:	4c 89 f0             	mov    %r14,%rax
   13cf3:	e9 dd fd ff ff       	jmpq   13ad5 <_DkInitHost+0x255>
   13cf8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   13cff:	00 
        pal_config.exec        = file_uri;
        pal_config.exec_handle = file;

        const char * manifest_uri;
        char manifest_path[80];
        snprintf(manifest_path, 80, "%s.manifest", pal_config.exec);
   13d00:	4c 8d 85 d0 fe ff ff 	lea    -0x130(%rbp),%r8
            pal_config.manifest        = file_uri;
            pal_config.manifest_handle = file;
            goto read_manifest;
        }

        pal_config.exec        = file_uri;
   13d07:	48 8b 8d 48 fe ff ff 	mov    -0x1b8(%rbp),%rcx
   13d0e:	4c 8b 3d 0b fd 20 00 	mov    0x20fd0b(%rip),%r15        # 223a20 <_DYNAMIC+0x238>
        pal_config.exec_handle = file;

        const char * manifest_uri;
        char manifest_path[80];
        snprintf(manifest_path, 80, "%s.manifest", pal_config.exec);
   13d15:	48 8d 15 a2 ad 00 00 	lea    0xada2(%rip),%rdx        # 1eabe <slab_levels+0x581e>
   13d1c:	be 50 00 00 00       	mov    $0x50,%esi
   13d21:	31 c0                	xor    %eax,%eax
   13d23:	4c 89 c7             	mov    %r8,%rdi
   13d26:	4c 89 85 20 fe ff ff 	mov    %r8,-0x1e0(%rbp)
            pal_config.manifest        = file_uri;
            pal_config.manifest_handle = file;
            goto read_manifest;
        }

        pal_config.exec        = file_uri;
   13d2d:	49 89 4f 08          	mov    %rcx,0x8(%r15)
        pal_config.exec_handle = file;
   13d31:	49 89 5f 18          	mov    %rbx,0x18(%r15)

        const char * manifest_uri;
        char manifest_path[80];
        snprintf(manifest_path, 80, "%s.manifest", pal_config.exec);

        if ((file = try_open_runnable(manifest_path, false, &manifest_uri))) {
   13d35:	48 8d 9d 60 fe ff ff 	lea    -0x1a0(%rbp),%rbx
        pal_config.exec        = file_uri;
        pal_config.exec_handle = file;

        const char * manifest_uri;
        char manifest_path[80];
        snprintf(manifest_path, 80, "%s.manifest", pal_config.exec);
   13d3c:	e8 6f 51 ff ff       	callq  8eb0 <pal_snprintf>

        if ((file = try_open_runnable(manifest_path, false, &manifest_uri))) {
   13d41:	4c 8b 85 20 fe ff ff 	mov    -0x1e0(%rbp),%r8
   13d48:	31 f6                	xor    %esi,%esi
   13d4a:	48 89 da             	mov    %rbx,%rdx
   13d4d:	4c 89 c7             	mov    %r8,%rdi
   13d50:	e8 8b ee ff ff       	callq  12be0 <try_open_runnable>
   13d55:	48 85 c0             	test   %rax,%rax
   13d58:	0f 84 57 ff ff ff    	je     13cb5 <_DkInitHost+0x435>
            pal_config.manifest = manifest_uri;
   13d5e:	48 8b 95 60 fe ff ff 	mov    -0x1a0(%rbp),%rdx
            pal_config.manifest_handle = file;
   13d65:	49 89 47 10          	mov    %rax,0x10(%r15)
            goto read_manifest;
   13d69:	48 89 c7             	mov    %rax,%rdi
        const char * manifest_uri;
        char manifest_path[80];
        snprintf(manifest_path, 80, "%s.manifest", pal_config.exec);

        if ((file = try_open_runnable(manifest_path, false, &manifest_uri))) {
            pal_config.manifest = manifest_uri;
   13d6c:	49 89 17             	mov    %rdx,(%r15)
            pal_config.manifest_handle = file;
            goto read_manifest;
   13d6f:	e9 d6 fb ff ff       	jmpq   1394a <_DkInitHost+0xca>
    int argc = *pargc;
    const char ** argv = *pargv, * first_argv = NULL;
    int ret = 0;

    if (!child_args && !argc) {
        printf("USAGE: libpal.so [executable|manifest] args ...\n");
   13d74:	48 8d 3d 5d af 00 00 	lea    0xaf5d(%rip),%rdi        # 1ecd8 <slab_levels+0x5a38>
   13d7b:	31 c0                	xor    %eax,%eax
   13d7d:	e8 9e 50 ff ff       	callq  8e20 <pal_printf>
        return -PAL_ERROR_INVAL;
   13d82:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   13d87:	e9 5f fd ff ff       	jmpq   13aeb <_DkInitHost+0x26b>
    if (!pal_linux_config.noexec && !pal_config.exec_handle) {
        /* find executable in the manifest */
        if ((len = get_config(root_config, "loader.exec", cfgbuf,
                              CONFIG_MAX)) > 0) {
            if (!(file = try_open_runnable(cfgbuf, false, NULL)))
                return -PAL_ERROR_DENIED;
   13d8c:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   13d91:	e9 55 fd ff ff       	jmpq   13aeb <_DkInitHost+0x26b>
   13d96:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   13d9d:	00 00 00 
            getrand(&pal_sec_info.mcast_port, sizeof(unsigned short));
        } while (pal_sec_info.mcast_port < 1024);
    }

    __pal_control.broadcast_stream = pal_sec_info.mcast_handle ? :
                            _DkBroadcastStreamOpen(pal_sec_info.mcast_port);
   13da0:	41 0f b7 7c 24 1c    	movzwl 0x1c(%r12),%edi
        do {
            getrand(&pal_sec_info.mcast_port, sizeof(unsigned short));
        } while (pal_sec_info.mcast_port < 1024);
    }

    __pal_control.broadcast_stream = pal_sec_info.mcast_handle ? :
   13da6:	e8 85 b7 ff ff       	callq  f530 <_DkBroadcastStreamOpen>
   13dab:	e9 05 fd ff ff       	jmpq   13ab5 <_DkInitHost+0x235>
            pal_config.exec_handle = file;
        }
    }

    if (!child_args) {
        if ((len = get_config(root_config, "loader.execname", cfgbuf,
   13db0:	48 8d 9d d0 fe ff ff 	lea    -0x130(%rbp),%rbx
   13db7:	48 8d 35 3f ad 00 00 	lea    0xad3f(%rip),%rsi        # 1eafd <slab_levels+0x585d>
   13dbe:	b9 00 01 00 00       	mov    $0x100,%ecx
   13dc3:	4c 89 c7             	mov    %r8,%rdi
   13dc6:	48 89 da             	mov    %rbx,%rdx
   13dc9:	e8 e2 40 00 00       	callq  17eb0 <get_config>
   13dce:	85 c0                	test   %eax,%eax
   13dd0:	7e 12                	jle    13de4 <_DkInitHost+0x564>
                              CONFIG_MAX)) > 0)
            first_argv = remalloc(cfgbuf, len + 1);
   13dd2:	8d 70 01             	lea    0x1(%rax),%esi
   13dd5:	48 89 df             	mov    %rbx,%rdi
   13dd8:	e8 23 4e ff ff       	callq  8c00 <remalloc>
   13ddd:	48 89 85 28 fe ff ff 	mov    %rax,-0x1d8(%rbp)

        if (!first_argv)
   13de4:	48 83 bd 28 fe ff ff 	cmpq   $0x0,-0x1d8(%rbp)
   13deb:	00 
   13dec:	0f 85 50 fe ff ff    	jne    13c42 <_DkInitHost+0x3c2>
            first_argv = pal_config.exec;
   13df2:	49 8b 47 08          	mov    0x8(%r15),%rax
   13df6:	48 89 85 28 fe ff ff 	mov    %rax,-0x1d8(%rbp)
   13dfd:	e9 40 fe ff ff       	jmpq   13c42 <_DkInitHost+0x3c2>
done_init:
    if (!child_args && pal_config.exec)
        printf("Program \"%s\" loaded in Graphene Library OS\n",
               pal_config.exec);

    pal_config.lib_name = libname;
   13e02:	48 8b 05 ef 0c 21 00 	mov    0x210cef(%rip),%rax        # 224af8 <libname>
   13e09:	49 89 47 28          	mov    %rax,0x28(%r15)
   13e0d:	e9 72 fe ff ff       	jmpq   13c84 <_DkInitHost+0x404>

        goto read_manifest;
    }

    if (!libname) {
        if ((ret = read_shebang(argv)) < 0)
   13e12:	4c 89 f7             	mov    %r14,%rdi
   13e15:	e8 26 ef ff ff       	callq  12d40 <read_shebang>
   13e1a:	85 c0                	test   %eax,%eax
   13e1c:	0f 89 02 fb ff ff    	jns    13924 <_DkInitHost+0xa4>
   13e22:	e9 c4 fc ff ff       	jmpq   13aeb <_DkInitHost+0x26b>
   13e27:	49 8b 7f 10          	mov    0x10(%r15),%rdi
   13e2b:	e9 0a fb ff ff       	jmpq   1393a <_DkInitHost+0xba>
    root_config->free = free;

    const char * errstring = NULL;

    if ((ret = read_config(root_config, loader_filter, &errstring)) < 0) {
        printf("Can't read manifest: %s\n", errstring);
   13e30:	48 8b b5 58 fe ff ff 	mov    -0x1a8(%rbp),%rsi
   13e37:	48 8d 3d 9a ac 00 00 	lea    0xac9a(%rip),%rdi        # 1ead8 <slab_levels+0x5838>
   13e3e:	31 c0                	xor    %eax,%eax
   13e40:	e8 db 4f ff ff       	callq  8e20 <pal_printf>
        return -PAL_ERROR_INVAL;
   13e45:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
   13e4a:	e9 9c fc ff ff       	jmpq   13aeb <_DkInitHost+0x26b>
   13e4f:	90                   	nop    

0000000000013e50 <setup_pal_map>:

extern void setup_elf_hash (struct link_map *map);
//extern unsigned long allocsize, allocshift, allocmask;

void setup_pal_map (const char * realname, ElfW(Dyn) ** dyn, ElfW(Addr) addr)
{	
   13e50:	55                   	push   %rbp
   13e51:	48 89 e5             	mov    %rsp,%rbp
   13e54:	41 57                	push   %r15
   13e56:	41 56                	push   %r14
   13e58:	41 55                	push   %r13
   13e5a:	41 54                	push   %r12
   13e5c:	49 89 ff             	mov    %rdi,%r15
   13e5f:	53                   	push   %rbx
   13e60:	49 89 f6             	mov    %rsi,%r14
   13e63:	49 89 d5             	mov    %rdx,%r13
   13e66:	48 83 ec 18          	sub    $0x18,%rsp
    /*was originally only getting initialized in pal_main, but the alignments below fail because these aren't initialized, so called them here as well*/
    allocsize  = _DkGetPagesize();
   13e6a:	e8 b1 ee ff ff       	callq  12d20 <_DkGetPagesize>
   13e6f:	4c 8b 25 1a fb 20 00 	mov    0x20fb1a(%rip),%r12        # 223990 <_DYNAMIC+0x1a8>
    allocshift = allocsize - 1;
    allocmask  = ~allocshift;
    //pal_printf("Loaded libraries %x", &loaded_libraries);
    assert (loaded_libraries == NULL); //-> points to a bad address. Why?
   13e76:	48 8b 1d ab fc 20 00 	mov    0x20fcab(%rip),%rbx        # 223b28 <_DYNAMIC+0x340>

void setup_pal_map (const char * realname, ElfW(Dyn) ** dyn, ElfW(Addr) addr)
{	
    /*was originally only getting initialized in pal_main, but the alignments below fail because these aren't initialized, so called them here as well*/
    allocsize  = _DkGetPagesize();
    allocshift = allocsize - 1;
   13e7d:	48 8b 0d c4 fc 20 00 	mov    0x20fcc4(%rip),%rcx        # 223b48 <_DYNAMIC+0x360>
//extern unsigned long allocsize, allocshift, allocmask;

void setup_pal_map (const char * realname, ElfW(Dyn) ** dyn, ElfW(Addr) addr)
{	
    /*was originally only getting initialized in pal_main, but the alignments below fail because these aren't initialized, so called them here as well*/
    allocsize  = _DkGetPagesize();
   13e84:	49 89 04 24          	mov    %rax,(%r12)
    allocshift = allocsize - 1;
   13e88:	48 83 e8 01          	sub    $0x1,%rax
    allocmask  = ~allocshift;
    //pal_printf("Loaded libraries %x", &loaded_libraries);
    assert (loaded_libraries == NULL); //-> points to a bad address. Why?
   13e8c:	48 83 3b 00          	cmpq   $0x0,(%rbx)

void setup_pal_map (const char * realname, ElfW(Dyn) ** dyn, ElfW(Addr) addr)
{	
    /*was originally only getting initialized in pal_main, but the alignments below fail because these aren't initialized, so called them here as well*/
    allocsize  = _DkGetPagesize();
    allocshift = allocsize - 1;
   13e90:	48 89 01             	mov    %rax,(%rcx)
    allocmask  = ~allocshift;
   13e93:	48 8b 0d 5e fc 20 00 	mov    0x20fc5e(%rip),%rcx        # 223af8 <_DYNAMIC+0x310>
   13e9a:	48 f7 d0             	not    %rax
   13e9d:	48 89 01             	mov    %rax,(%rcx)
    //pal_printf("Loaded libraries %x", &loaded_libraries);
    assert (loaded_libraries == NULL); //-> points to a bad address. Why?
   13ea0:	74 30                	je     13ed2 <setup_pal_map+0x82>
   13ea2:	48 8d 3d 8f 48 00 00 	lea    0x488f(%rip),%rdi        # 18738 <write_config+0x188>
   13ea9:	48 8d 15 14 4f 00 00 	lea    0x4f14(%rip),%rdx        # 18dc4 <handle_sizes.1924+0x644>
   13eb0:	48 8d 35 e1 ae 00 00 	lea    0xaee1(%rip),%rsi        # 1ed98 <slab_levels+0x5af8>
   13eb7:	b9 3a 00 00 00       	mov    $0x3a,%ecx
   13ebc:	31 c0                	xor    %eax,%eax
   13ebe:	e8 5d 4f ff ff       	callq  8e20 <pal_printf>
   13ec3:	e8 a8 2b ff ff       	callq  6a70 <__assert>
   13ec8:	bf 01 00 00 00       	mov    $0x1,%edi
   13ecd:	e8 ae e6 ff ff       	callq  12580 <_DkProcessExit>
    const ElfW(Ehdr) * header = (void *) addr;
    struct link_map * l = new_elf_object(realname, OBJECT_RTLD);
   13ed2:	31 f6                	xor    %esi,%esi
   13ed4:	4c 89 ff             	mov    %r15,%rdi
   13ed7:	e8 04 2c ff ff       	callq  6ae0 <new_elf_object>
    memcpy(l->l_info, dyn, sizeof(l->l_info));
   13edc:	48 8d 78 48          	lea    0x48(%rax),%rdi
   13ee0:	ba 60 02 00 00       	mov    $0x260,%edx
   13ee5:	4c 89 f6             	mov    %r14,%rsi
    allocshift = allocsize - 1;
    allocmask  = ~allocshift;
    //pal_printf("Loaded libraries %x", &loaded_libraries);
    assert (loaded_libraries == NULL); //-> points to a bad address. Why?
    const ElfW(Ehdr) * header = (void *) addr;
    struct link_map * l = new_elf_object(realname, OBJECT_RTLD);
   13ee8:	49 89 c7             	mov    %rax,%r15
    memcpy(l->l_info, dyn, sizeof(l->l_info));
   13eeb:	e8 90 23 00 00       	callq  16280 <memcpy>
   uses global data.  */
static inline Elf64_Addr __attribute__ ((unused))
elf_machine_dynamic (Elf64_Addr mapbase)
{
    Elf64_Addr addr;
    addr = (Elf64_Addr)&_DYNAMIC + mapbase;
   13ef0:	4c 89 e8             	mov    %r13,%rax
   13ef3:	48 03 05 7e fa 20 00 	add    0x20fa7e(%rip),%rax        # 223978 <_DYNAMIC+0x190>
    l->l_real_ld = l->l_ld = (void *) elf_machine_dynamic(addr);
    l->l_addr  = addr;
   13efa:	4d 89 2f             	mov    %r13,(%r15)
    l->l_soname = "libpal.so";
    l->l_text_start = (ElfW(Addr)) &text_start;
    l->l_text_end   = (ElfW(Addr)) &text_end;
    l->l_data_start = (ElfW(Addr)) &data_start;
    l->l_data_end   = (ElfW(Addr)) &data_end;
    setup_elf_hash(l);
   13efd:	4c 89 ff             	mov    %r15,%rdi
    //pal_printf("Loaded libraries %x", &loaded_libraries);
    assert (loaded_libraries == NULL); //-> points to a bad address. Why?
    const ElfW(Ehdr) * header = (void *) addr;
    struct link_map * l = new_elf_object(realname, OBJECT_RTLD);
    memcpy(l->l_info, dyn, sizeof(l->l_info));
    l->l_real_ld = l->l_ld = (void *) elf_machine_dynamic(addr);
   13f00:	49 89 47 30          	mov    %rax,0x30(%r15)
   13f04:	49 89 47 10          	mov    %rax,0x10(%r15)
    l->l_addr  = addr;
    l->l_entry = header->e_entry;
   13f08:	49 8b 45 18          	mov    0x18(%r13),%rax
   13f0c:	49 89 87 b0 02 00 00 	mov    %rax,0x2b0(%r15)
    l->l_phdr  = (void *) (addr + header->e_phoff);
   13f13:	4c 89 e8             	mov    %r13,%rax
   13f16:	49 03 45 20          	add    0x20(%r13),%rax
   13f1a:	49 89 87 a8 02 00 00 	mov    %rax,0x2a8(%r15)
    l->l_phnum = header->e_phnum;
   13f21:	41 0f b7 45 38       	movzwl 0x38(%r13),%eax
    l->l_relocated = true;
   13f26:	41 c6 47 40 01       	movb   $0x1,0x40(%r15)
    l->l_lookup_symbol = true;
   13f2b:	41 c6 47 41 01       	movb   $0x1,0x41(%r15)
    memcpy(l->l_info, dyn, sizeof(l->l_info));
    l->l_real_ld = l->l_ld = (void *) elf_machine_dynamic(addr);
    l->l_addr  = addr;
    l->l_entry = header->e_entry;
    l->l_phdr  = (void *) (addr + header->e_phoff);
    l->l_phnum = header->e_phnum;
   13f30:	66 41 89 87 b8 02 00 	mov    %ax,0x2b8(%r15)
   13f37:	00 
    l->l_relocated = true;
    l->l_lookup_symbol = true;
    l->l_soname = "libpal.so";
   13f38:	48 8d 05 39 ab 00 00 	lea    0xab39(%rip),%rax        # 1ea78 <slab_levels+0x57d8>
   13f3f:	49 89 47 38          	mov    %rax,0x38(%r15)
    l->l_text_start = (ElfW(Addr)) &text_start;
   13f43:	48 8b 05 6e fb 20 00 	mov    0x20fb6e(%rip),%rax        # 223ab8 <_DYNAMIC+0x2d0>
   13f4a:	49 89 87 c0 02 00 00 	mov    %rax,0x2c0(%r15)
    l->l_text_end   = (ElfW(Addr)) &text_end;
   13f51:	48 8b 05 80 fa 20 00 	mov    0x20fa80(%rip),%rax        # 2239d8 <_DYNAMIC+0x1f0>
   13f58:	49 89 87 c8 02 00 00 	mov    %rax,0x2c8(%r15)
    l->l_data_start = (ElfW(Addr)) &data_start;
   13f5f:	48 8b 05 5a fb 20 00 	mov    0x20fb5a(%rip),%rax        # 223ac0 <_DYNAMIC+0x2d8>
   13f66:	49 89 87 d0 02 00 00 	mov    %rax,0x2d0(%r15)
    l->l_data_end   = (ElfW(Addr)) &data_end;
   13f6d:	48 8b 05 0c fc 20 00 	mov    0x20fc0c(%rip),%rax        # 223b80 <_DYNAMIC+0x398>
   13f74:	49 89 87 d8 02 00 00 	mov    %rax,0x2d8(%r15)
    setup_elf_hash(l);
   13f7b:	e8 d0 2b ff ff       	callq  6b50 <setup_elf_hash>

    void * begin_hole = (void *) ALLOC_ALIGNUP(l->l_text_end);
   13f80:	49 83 3c 24 00       	cmpq   $0x0,(%r12)
   13f85:	0f 84 b5 00 00 00    	je     14040 <setup_pal_map+0x1f0>
   13f8b:	48 8b 05 66 fb 20 00 	mov    0x20fb66(%rip),%rax        # 223af8 <_DYNAMIC+0x310>
   13f92:	48 8b 0d af fb 20 00 	mov    0x20fbaf(%rip),%rcx        # 223b48 <_DYNAMIC+0x360>
   13f99:	48 8b 30             	mov    (%rax),%rsi
   13f9c:	49 8b 87 c8 02 00 00 	mov    0x2c8(%r15),%rax
   13fa3:	48 03 01             	add    (%rcx),%rax
   13fa6:	48 21 f0             	and    %rsi,%rax
    void * end_hole = (void *) ALLOC_ALIGNDOWN(l->l_data_start);
   13fa9:	49 23 b7 d0 02 00 00 	and    0x2d0(%r15),%rsi

    /* Usually the test segment and data segment of a loaded library has
       a gap between them. Need to fill the hole with a empty area */
    if (begin_hole < end_hole) {
   13fb0:	48 39 c6             	cmp    %rax,%rsi
   13fb3:	0f 87 9e 00 00 00    	ja     14057 <setup_pal_map+0x207>
        _DkVirtualMemoryAlloc(&addr, end_hole - begin_hole,
                              PAL_ALLOC_RESERVE, PAL_PROT_NONE);
    }

    /* Set up debugging before the debugger is notified for the first time.  */
    if (l->l_info[DT_DEBUG] != NULL)
   13fb9:	49 8b 87 f0 00 00 00 	mov    0xf0(%r15),%rax
   13fc0:	48 85 c0             	test   %rax,%rax
   13fc3:	74 0b                	je     13fd0 <setup_pal_map+0x180>
        l->l_info[DT_DEBUG]->d_un.d_ptr = (ElfW(Addr)) &pal_r_debug;
   13fc5:	48 8b 15 7c fa 20 00 	mov    0x20fa7c(%rip),%rdx        # 223a48 <_DYNAMIC+0x260>
   13fcc:	48 89 50 08          	mov    %rdx,0x8(%rax)

    l->l_prev = l->l_next = NULL;
    rtld_map = l;
   13fd0:	48 8b 05 c9 fa 20 00 	mov    0x20fac9(%rip),%rax        # 223aa0 <_DYNAMIC+0x2b8>
    loaded_libraries = l;

    if (!pal_sec_info._r_debug) {
   13fd7:	4c 8b 25 ca fa 20 00 	mov    0x20faca(%rip),%r12        # 223aa8 <_DYNAMIC+0x2c0>

    /* Set up debugging before the debugger is notified for the first time.  */
    if (l->l_info[DT_DEBUG] != NULL)
        l->l_info[DT_DEBUG]->d_un.d_ptr = (ElfW(Addr)) &pal_r_debug;

    l->l_prev = l->l_next = NULL;
   13fde:	49 c7 47 18 00 00 00 	movq   $0x0,0x18(%r15)
   13fe5:	00 
   13fe6:	49 c7 47 20 00 00 00 	movq   $0x0,0x20(%r15)
   13fed:	00 
    rtld_map = l;
    loaded_libraries = l;
   13fee:	4c 89 3b             	mov    %r15,(%rbx)
    /* Set up debugging before the debugger is notified for the first time.  */
    if (l->l_info[DT_DEBUG] != NULL)
        l->l_info[DT_DEBUG]->d_un.d_ptr = (ElfW(Addr)) &pal_r_debug;

    l->l_prev = l->l_next = NULL;
    rtld_map = l;
   13ff1:	4c 89 38             	mov    %r15,(%rax)
    loaded_libraries = l;

    if (!pal_sec_info._r_debug) {
   13ff4:	49 8b 44 24 30       	mov    0x30(%r12),%rax
   13ff9:	48 85 c0             	test   %rax,%rax
   13ffc:	74 75                	je     14073 <setup_pal_map+0x223>
        pal_r_debug.r_ldbase = addr;
        pal_r_debug.r_map = loaded_libraries;
        pal_sec_info._r_debug = &pal_r_debug;
        pal_sec_info._dl_debug_state = &pal_dl_debug_state;
    } else {
        pal_sec_info._r_debug->r_state = RT_ADD;
   13ffe:	c7 40 18 01 00 00 00 	movl   $0x1,0x18(%rax)
        pal_sec_info._dl_debug_state();
   14005:	41 ff 54 24 28       	callq  *0x28(%r12)

        if (pal_sec_info._r_debug->r_map) {
   1400a:	49 8b 54 24 30       	mov    0x30(%r12),%rdx
   1400f:	48 8b 42 08          	mov    0x8(%rdx),%rax
   14013:	48 85 c0             	test   %rax,%rax
   14016:	0f 84 94 00 00 00    	je     140b0 <setup_pal_map+0x260>
            l->l_prev = pal_sec_info._r_debug->r_map;
   1401c:	49 89 47 20          	mov    %rax,0x20(%r15)
            pal_sec_info._r_debug->r_map->l_next = l;
   14020:	4c 89 78 18          	mov    %r15,0x18(%rax)
        } else {
            pal_sec_info._r_debug->r_map = loaded_libraries;
        }

        pal_sec_info._r_debug->r_state = RT_CONSISTENT;
   14024:	c7 42 18 00 00 00 00 	movl   $0x0,0x18(%rdx)
        pal_sec_info._dl_debug_state();
   1402b:	41 ff 54 24 28       	callq  *0x28(%r12)
    }
}
   14030:	48 83 c4 18          	add    $0x18,%rsp
   14034:	5b                   	pop    %rbx
   14035:	41 5c                	pop    %r12
   14037:	41 5d                	pop    %r13
   14039:	41 5e                	pop    %r14
   1403b:	41 5f                	pop    %r15
   1403d:	5d                   	pop    %rbp
   1403e:	c3                   	retq   
   1403f:	90                   	nop    
    l->l_text_end   = (ElfW(Addr)) &text_end;
    l->l_data_start = (ElfW(Addr)) &data_start;
    l->l_data_end   = (ElfW(Addr)) &data_end;
    setup_elf_hash(l);

    void * begin_hole = (void *) ALLOC_ALIGNUP(l->l_text_end);
   14040:	49 8b 87 c8 02 00 00 	mov    0x2c8(%r15),%rax
    void * end_hole = (void *) ALLOC_ALIGNDOWN(l->l_data_start);
   14047:	49 8b b7 d0 02 00 00 	mov    0x2d0(%r15),%rsi

    /* Usually the test segment and data segment of a loaded library has
       a gap between them. Need to fill the hole with a empty area */
    if (begin_hole < end_hole) {
   1404e:	48 39 c6             	cmp    %rax,%rsi
   14051:	0f 86 62 ff ff ff    	jbe    13fb9 <setup_pal_map+0x169>
        void * addr = begin_hole;
        _DkVirtualMemoryAlloc(&addr, end_hole - begin_hole,
   14057:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
   1405b:	48 29 c6             	sub    %rax,%rsi
   1405e:	31 c9                	xor    %ecx,%ecx
   14060:	ba 02 00 00 00       	mov    $0x2,%edx
    void * end_hole = (void *) ALLOC_ALIGNDOWN(l->l_data_start);

    /* Usually the test segment and data segment of a loaded library has
       a gap between them. Need to fill the hole with a empty area */
    if (begin_hole < end_hole) {
        void * addr = begin_hole;
   14065:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
        _DkVirtualMemoryAlloc(&addr, end_hole - begin_hole,
   14069:	e8 22 c1 ff ff       	callq  10190 <_DkVirtualMemoryAlloc>
   1406e:	e9 46 ff ff ff       	jmpq   13fb9 <setup_pal_map+0x169>
    l->l_prev = l->l_next = NULL;
    rtld_map = l;
    loaded_libraries = l;

    if (!pal_sec_info._r_debug) {
        pal_r_debug.r_version = 1;
   14073:	48 8b 05 ce f9 20 00 	mov    0x20f9ce(%rip),%rax        # 223a48 <_DYNAMIC+0x260>
        pal_r_debug.r_brk = (ElfW(Addr)) &pal_dl_debug_state;
   1407a:	48 8b 15 cf fa 20 00 	mov    0x20facf(%rip),%rdx        # 223b50 <_DYNAMIC+0x368>
    l->l_prev = l->l_next = NULL;
    rtld_map = l;
    loaded_libraries = l;

    if (!pal_sec_info._r_debug) {
        pal_r_debug.r_version = 1;
   14081:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
        pal_r_debug.r_brk = (ElfW(Addr)) &pal_dl_debug_state;
   14087:	48 89 50 10          	mov    %rdx,0x10(%rax)
        pal_r_debug.r_ldbase = addr;
   1408b:	4c 89 68 20          	mov    %r13,0x20(%rax)
        pal_r_debug.r_map = loaded_libraries;
   1408f:	4c 89 78 08          	mov    %r15,0x8(%rax)
        pal_sec_info._r_debug = &pal_r_debug;
   14093:	49 89 44 24 30       	mov    %rax,0x30(%r12)
        pal_sec_info._dl_debug_state = &pal_dl_debug_state;
   14098:	49 89 54 24 28       	mov    %rdx,0x28(%r12)
        }

        pal_sec_info._r_debug->r_state = RT_CONSISTENT;
        pal_sec_info._dl_debug_state();
    }
}
   1409d:	48 83 c4 18          	add    $0x18,%rsp
   140a1:	5b                   	pop    %rbx
   140a2:	41 5c                	pop    %r12
   140a4:	41 5d                	pop    %r13
   140a6:	41 5e                	pop    %r14
   140a8:	41 5f                	pop    %r15
   140aa:	5d                   	pop    %rbp
   140ab:	c3                   	retq   
   140ac:	0f 1f 40 00          	nopl   0x0(%rax)

        if (pal_sec_info._r_debug->r_map) {
            l->l_prev = pal_sec_info._r_debug->r_map;
            pal_sec_info._r_debug->r_map->l_next = l;
        } else {
            pal_sec_info._r_debug->r_map = loaded_libraries;
   140b0:	48 8b 03             	mov    (%rbx),%rax
   140b3:	48 89 42 08          	mov    %rax,0x8(%rdx)
   140b7:	e9 68 ff ff ff       	jmpq   14024 <setup_pal_map+0x1d4>
   140bc:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000140c0 <resolve_map_in_rtld>:
    free(l);
}
#endif

ElfW(Addr) resolve_map_in_rtld (ElfW(Sym) * ref)
{
   140c0:	55                   	push   %rbp
    /* We are not using this, because in Linux we can rely on
       rtld_map to directly lookup symbols */
    return 0;
}
   140c1:	31 c0                	xor    %eax,%eax
    free(l);
}
#endif

ElfW(Addr) resolve_map_in_rtld (ElfW(Sym) * ref)
{
   140c3:	48 89 e5             	mov    %rsp,%rbp
    /* We are not using this, because in Linux we can rely on
       rtld_map to directly lookup symbols */
    return 0;
}
   140c6:	5d                   	pop    %rbp
   140c7:	c3                   	retq   
   140c8:	90                   	nop    
   140c9:	90                   	nop    
   140ca:	90                   	nop    
   140cb:	90                   	nop    
   140cc:	90                   	nop    
   140cd:	90                   	nop    
   140ce:	90                   	nop    
   140cf:	90                   	nop    

00000000000140d0 <_DkSystemTimeQuery>:
long int (*__vdso_gettimeofday) (struct timeval *, void *);
# endif
#endif

unsigned long _DkSystemTimeQuery (void)
{
   140d0:	55                   	push   %rbp
#if USE_VDSO_GETTIME == 1
    if (__vdso_clock_gettime) {
        ret = __vdso_clock_gettime(CLOCK_MONOTONIC, &time);
    } else {
#endif
        ret = INLINE_SYSCALL(clock_gettime, 2, CLOCK_MONOTONIC, &time);
   140d1:	bf 04 00 00 00       	mov    $0x4,%edi
long int (*__vdso_gettimeofday) (struct timeval *, void *);
# endif
#endif

unsigned long _DkSystemTimeQuery (void)
{
   140d6:	48 89 e5             	mov    %rsp,%rbp
   140d9:	53                   	push   %rbx
#if USE_VDSO_GETTIME == 1
    if (__vdso_clock_gettime) {
        ret = __vdso_clock_gettime(CLOCK_MONOTONIC, &time);
    } else {
#endif
        ret = INLINE_SYSCALL(clock_gettime, 2, CLOCK_MONOTONIC, &time);
   140da:	bb e8 00 00 00       	mov    $0xe8,%ebx
   140df:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
   140e3:	89 d8                	mov    %ebx,%eax
long int (*__vdso_gettimeofday) (struct timeval *, void *);
# endif
#endif

unsigned long _DkSystemTimeQuery (void)
{
   140e5:	cd 80                	int    $0x80
   140e7:	48 89 c2             	mov    %rax,%rdx
   140ea:	bb 00 00 00 00       	mov    $0x0,%ebx
   140ef:	83 d3 00             	adc    $0x0,%ebx
   140f2:	31 c9                	xor    %ecx,%ecx
   140f4:	85 db                	test   %ebx,%ebx
   140f6:	0f 95 c1             	setne  %cl
   140f9:	48 89 c8             	mov    %rcx,%rax
   140fc:	48 f7 d8             	neg    %rax
   140ff:	48 31 c2             	xor    %rax,%rdx
#if USE_VDSO_GETTIME == 1
    }
#endif

    /* Come on, gettimeofday mostly never fails */
    if (IS_ERR(ret))
   14102:	89 d0                	mov    %edx,%eax
   14104:	01 c8                	add    %ecx,%eax
   14106:	78 38                	js     14140 <_DkSystemTimeQuery+0x70>
        return 0;

    /* in microseconds */
    return time.tv_sec * 1000000 + time.tv_nsec / 1000;
   14108:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
   1410c:	48 ba cf f7 53 e3 a5 	mov    $0x20c49ba5e353f7cf,%rdx
   14113:	9b c4 20 
   14116:	48 69 75 e0 40 42 0f 	imul   $0xf4240,-0x20(%rbp),%rsi
   1411d:	00 
        return 0;

    /* in microseconds */
    return time.tv_sec * 1000000 + time.tv_usec;
#endif
}
   1411e:	48 89 c8             	mov    %rcx,%rax
   14121:	48 c1 f9 3f          	sar    $0x3f,%rcx
   14125:	5b                   	pop    %rbx
    /* Come on, gettimeofday mostly never fails */
    if (IS_ERR(ret))
        return 0;

    /* in microseconds */
    return time.tv_sec * 1000000 + time.tv_nsec / 1000;
   14126:	48 f7 ea             	imul   %rdx
        return 0;

    /* in microseconds */
    return time.tv_sec * 1000000 + time.tv_usec;
#endif
}
   14129:	5d                   	pop    %rbp
    /* Come on, gettimeofday mostly never fails */
    if (IS_ERR(ret))
        return 0;

    /* in microseconds */
    return time.tv_sec * 1000000 + time.tv_nsec / 1000;
   1412a:	48 c1 fa 07          	sar    $0x7,%rdx
   1412e:	48 29 ca             	sub    %rcx,%rdx
   14131:	48 8d 04 16          	lea    (%rsi,%rdx,1),%rax
        return 0;

    /* in microseconds */
    return time.tv_sec * 1000000 + time.tv_usec;
#endif
}
   14135:	c3                   	retq   
   14136:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1413d:	00 00 00 
    }
#endif

    /* Come on, gettimeofday mostly never fails */
    if (IS_ERR(ret))
        return 0;
   14140:	31 c0                	xor    %eax,%eax
        return 0;

    /* in microseconds */
    return time.tv_sec * 1000000 + time.tv_usec;
#endif
}
   14142:	5b                   	pop    %rbx
   14143:	5d                   	pop    %rbp
   14144:	c3                   	retq   
   14145:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
   1414c:	00 00 00 00 

0000000000014150 <_DkRandomBitsRead>:

int _DkRandomBitsRead (void * buffer, int size)
{
   14150:	4c 8b 0d 51 f9 20 00 	mov    0x20f951(%rip),%r9        # 223aa8 <_DYNAMIC+0x2c0>
   14157:	55                   	push   %rbp
   14158:	49 89 fa             	mov    %rdi,%r10
   1415b:	48 89 e5             	mov    %rsp,%rbp
   1415e:	41 54                	push   %r12
   14160:	53                   	push   %rbx
    if (!pal_sec_info.rand_gen) {
   14161:	49 63 79 18          	movslq 0x18(%r9),%rdi
    return time.tv_sec * 1000000 + time.tv_usec;
#endif
}

int _DkRandomBitsRead (void * buffer, int size)
{
   14165:	41 89 f4             	mov    %esi,%r12d
    if (!pal_sec_info.rand_gen) {
   14168:	85 ff                	test   %edi,%edi
   1416a:	75 3d                	jne    141a9 <_DkRandomBitsRead+0x59>
        int fd = INLINE_SYSCALL(open, 3, "/dev/urandom", O_RDONLY, 0);
   1416c:	b9 05 00 00 00       	mov    $0x5,%ecx
   14171:	31 d2                	xor    %edx,%edx
   14173:	31 f6                	xor    %esi,%esi
   14175:	48 8d 3d 35 ac 00 00 	lea    0xac35(%rip),%rdi        # 1edb1 <slab_levels+0x5b11>
   1417c:	89 c8                	mov    %ecx,%eax
   1417e:	cd 80                	int    $0x80
   14180:	49 89 c0             	mov    %rax,%r8
   14183:	bb 00 00 00 00       	mov    $0x0,%ebx
   14188:	83 d3 00             	adc    $0x0,%ebx
   1418b:	31 c9                	xor    %ecx,%ecx
   1418d:	85 db                	test   %ebx,%ebx
   1418f:	0f 95 c1             	setne  %cl
   14192:	48 89 c8             	mov    %rcx,%rax
   14195:	48 f7 d8             	neg    %rax
   14198:	4c 31 c0             	xor    %r8,%rax
   1419b:	48 01 c8             	add    %rcx,%rax
        if (IS_ERR(fd))
   1419e:	85 c0                	test   %eax,%eax
   141a0:	78 43                	js     141e5 <_DkRandomBitsRead+0x95>
            return -PAL_ERROR_DENIED;

        pal_sec_info.rand_gen = fd;
   141a2:	41 89 41 18          	mov    %eax,0x18(%r9)
   141a6:	48 63 f8             	movslq %eax,%rdi
    }

    int bytes = INLINE_SYSCALL(read, 3, pal_sec_info.rand_gen, buffer, size);
   141a9:	bb 03 00 00 00       	mov    $0x3,%ebx
   141ae:	49 63 d4             	movslq %r12d,%rdx
   141b1:	4c 89 d6             	mov    %r10,%rsi
   141b4:	89 d8                	mov    %ebx,%eax
   141b6:	cd 80                	int    $0x80
   141b8:	48 89 c1             	mov    %rax,%rcx
   141bb:	bb 00 00 00 00       	mov    $0x0,%ebx
   141c0:	83 d3 00             	adc    $0x0,%ebx
   141c3:	31 d2                	xor    %edx,%edx
   141c5:	85 db                	test   %ebx,%ebx
   141c7:	0f 95 c2             	setne  %dl
   141ca:	48 89 d0             	mov    %rdx,%rax
   141cd:	48 f7 d8             	neg    %rax
   141d0:	48 31 c8             	xor    %rcx,%rax
   141d3:	48 01 d0             	add    %rdx,%rax
    return IS_ERR(bytes) ? -PAL_ERROR_DENIED : bytes;
   141d6:	ba fa ff ff ff       	mov    $0xfffffffa,%edx
   141db:	85 c0                	test   %eax,%eax
   141dd:	0f 48 c2             	cmovs  %edx,%eax
}
   141e0:	5b                   	pop    %rbx
   141e1:	41 5c                	pop    %r12
   141e3:	5d                   	pop    %rbp
   141e4:	c3                   	retq   
int _DkRandomBitsRead (void * buffer, int size)
{
    if (!pal_sec_info.rand_gen) {
        int fd = INLINE_SYSCALL(open, 3, "/dev/urandom", O_RDONLY, 0);
        if (IS_ERR(fd))
            return -PAL_ERROR_DENIED;
   141e5:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   141ea:	eb f4                	jmp    141e0 <_DkRandomBitsRead+0x90>
   141ec:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000141f0 <_DkInstructionCacheFlush>:
    int bytes = INLINE_SYSCALL(read, 3, pal_sec_info.rand_gen, buffer, size);
    return IS_ERR(bytes) ? -PAL_ERROR_DENIED : bytes;
}

int _DkInstructionCacheFlush (const void * addr, size_t size)
{
   141f0:	55                   	push   %rbp
    return -PAL_ERROR_NOTIMPLEMENTED;
}
   141f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    int bytes = INLINE_SYSCALL(read, 3, pal_sec_info.rand_gen, buffer, size);
    return IS_ERR(bytes) ? -PAL_ERROR_DENIED : bytes;
}

int _DkInstructionCacheFlush (const void * addr, size_t size)
{
   141f6:	48 89 e5             	mov    %rsp,%rbp
    return -PAL_ERROR_NOTIMPLEMENTED;
}
   141f9:	5d                   	pop    %rbp
   141fa:	c3                   	retq   
   141fb:	90                   	nop    
   141fc:	90                   	nop    
   141fd:	90                   	nop    
   141fe:	90                   	nop    
   141ff:	90                   	nop    

0000000000014200 <gipc_close>:
    *handle = hdl;
    return 0;
}

int gipc_close (PAL_HANDLE handle)
{
   14200:	55                   	push   %rbp
    int ret = INLINE_SYSCALL(close, 1, handle->gipc.fd);
   14201:	be 06 00 00 00       	mov    $0x6,%esi
   14206:	89 f0                	mov    %esi,%eax
    *handle = hdl;
    return 0;
}

int gipc_close (PAL_HANDLE handle)
{
   14208:	48 89 e5             	mov    %rsp,%rbp
   1420b:	53                   	push   %rbx
    int ret = INLINE_SYSCALL(close, 1, handle->gipc.fd);
   1420c:	8b 7f 0c             	mov    0xc(%rdi),%edi
   1420f:	cd 80                	int    $0x80
   14211:	48 89 c1             	mov    %rax,%rcx
   14214:	bb 00 00 00 00       	mov    $0x0,%ebx
   14219:	83 d3 00             	adc    $0x0,%ebx
   1421c:	31 d2                	xor    %edx,%edx
   1421e:	85 db                	test   %ebx,%ebx
   14220:	0f 95 c2             	setne  %dl
   14223:	48 89 d0             	mov    %rdx,%rax
   14226:	48 f7 d8             	neg    %rax
   14229:	48 31 c1             	xor    %rax,%rcx
   1422c:	48 8d 04 11          	lea    (%rcx,%rdx,1),%rax

    if (IS_ERR(ret))
        return -PAL_ERROR_BADHANDLE;

    return 0;
}
   14230:	5b                   	pop    %rbx
    int ret = INLINE_SYSCALL(close, 1, handle->gipc.fd);

    if (IS_ERR(ret))
        return -PAL_ERROR_BADHANDLE;

    return 0;
   14231:	c1 f8 1f             	sar    $0x1f,%eax
   14234:	83 e0 f9             	and    $0xfffffffffffffff9,%eax
}
   14237:	5d                   	pop    %rbp
   14238:	c3                   	retq   
   14239:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000014240 <gipc_getrealpath>:

const char * gipc_getrealpath (PAL_HANDLE handle)
{
   14240:	55                   	push   %rbp
    return GIPC_FILE;
}
   14241:	48 8d 05 76 ab 00 00 	lea    0xab76(%rip),%rax        # 1edbe <slab_levels+0x5b1e>

    return 0;
}

const char * gipc_getrealpath (PAL_HANDLE handle)
{
   14248:	48 89 e5             	mov    %rsp,%rbp
    return GIPC_FILE;
}
   1424b:	5d                   	pop    %rbp
   1424c:	c3                   	retq   
   1424d:	0f 1f 00             	nopl   (%rax)

0000000000014250 <gipc_open>:
#include <fcntl.h>
#include <sched.h>

int gipc_open (PAL_HANDLE * handle, const char * type, const char * uri,
               int access, int share, int create, int options)
{
   14250:	55                   	push   %rbp
   14251:	49 89 d0             	mov    %rdx,%r8
    int64_t token;
    int rv;

    int fd = INLINE_SYSCALL(open, 3, GIPC_FILE, O_RDONLY|O_CLOEXEC, 0);
   14254:	be 00 00 10 00       	mov    $0x100000,%esi
   14259:	31 d2                	xor    %edx,%edx
#include <fcntl.h>
#include <sched.h>

int gipc_open (PAL_HANDLE * handle, const char * type, const char * uri,
               int access, int share, int create, int options)
{
   1425b:	48 89 e5             	mov    %rsp,%rbp
   1425e:	41 55                	push   %r13
   14260:	41 54                	push   %r12
   14262:	53                   	push   %rbx
    int64_t token;
    int rv;

    int fd = INLINE_SYSCALL(open, 3, GIPC_FILE, O_RDONLY|O_CLOEXEC, 0);
   14263:	bb 05 00 00 00       	mov    $0x5,%ebx
#include <fcntl.h>
#include <sched.h>

int gipc_open (PAL_HANDLE * handle, const char * type, const char * uri,
               int access, int share, int create, int options)
{
   14268:	49 89 fd             	mov    %rdi,%r13
    int64_t token;
    int rv;

    int fd = INLINE_SYSCALL(open, 3, GIPC_FILE, O_RDONLY|O_CLOEXEC, 0);
   1426b:	89 d8                	mov    %ebx,%eax
   1426d:	48 8d 3d 4a ab 00 00 	lea    0xab4a(%rip),%rdi        # 1edbe <slab_levels+0x5b1e>
#include <fcntl.h>
#include <sched.h>

int gipc_open (PAL_HANDLE * handle, const char * type, const char * uri,
               int access, int share, int create, int options)
{
   14274:	48 83 ec 08          	sub    $0x8,%rsp
    int64_t token;
    int rv;

    int fd = INLINE_SYSCALL(open, 3, GIPC_FILE, O_RDONLY|O_CLOEXEC, 0);
   14278:	cd 80                	int    $0x80
   1427a:	48 89 c1             	mov    %rax,%rcx
   1427d:	bb 00 00 00 00       	mov    $0x0,%ebx
   14282:	83 d3 00             	adc    $0x0,%ebx
   14285:	31 d2                	xor    %edx,%edx
   14287:	85 db                	test   %ebx,%ebx
   14289:	0f 95 c2             	setne  %dl
   1428c:	48 89 d0             	mov    %rdx,%rax
   1428f:	48 f7 d8             	neg    %rax
   14292:	48 31 c8             	xor    %rcx,%rax
   14295:	4c 8d 24 10          	lea    (%rax,%rdx,1),%r12

    if (IS_ERR(fd))
   14299:	45 85 e4             	test   %r12d,%r12d
   1429c:	78 72                	js     14310 <gipc_open+0xc0>
   1429e:	4c 89 c7             	mov    %r8,%rdi
        return -PAL_ERROR_DENIED;

    token = atoi(uri);
   142a1:	e8 4a 26 00 00       	callq  168f0 <atoi>

    rv = INLINE_SYSCALL(ioctl, 3, fd, GIPC_JOIN, token);
   142a6:	4d 63 c4             	movslq %r12d,%r8
   142a9:	b9 36 00 00 00       	mov    $0x36,%ecx
    int fd = INLINE_SYSCALL(open, 3, GIPC_FILE, O_RDONLY|O_CLOEXEC, 0);

    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;

    token = atoi(uri);
   142ae:	48 63 d0             	movslq %eax,%rdx

    rv = INLINE_SYSCALL(ioctl, 3, fd, GIPC_JOIN, token);
   142b1:	be 03 6b 08 40       	mov    $0x40086b03,%esi
   142b6:	4c 89 c7             	mov    %r8,%rdi
   142b9:	89 c8                	mov    %ecx,%eax
   142bb:	cd 80                	int    $0x80
   142bd:	48 89 c2             	mov    %rax,%rdx
   142c0:	bb 00 00 00 00       	mov    $0x0,%ebx
   142c5:	83 d3 00             	adc    $0x0,%ebx
   142c8:	31 c9                	xor    %ecx,%ecx
   142ca:	85 db                	test   %ebx,%ebx
   142cc:	0f 95 c1             	setne  %cl
   142cf:	48 89 c8             	mov    %rcx,%rax
   142d2:	48 f7 d8             	neg    %rax
   142d5:	48 31 d0             	xor    %rdx,%rax

    if (rv < 0) {
   142d8:	01 c8                	add    %ecx,%eax
   142da:	78 44                	js     14320 <gipc_open+0xd0>
        INLINE_SYSCALL(close, 1, fd);
        return -PAL_ERROR_DENIED;
    }

    PAL_HANDLE hdl = malloc(HANDLE_SIZE(gipc));
   142dc:	bf 10 00 00 00       	mov    $0x10,%edi
   142e1:	e8 1a 47 ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, gipc);
   142e6:	c7 00 11 00 00 00    	movl   $0x11,(%rax)
   142ec:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
   142f3:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    hdl->gipc.fd = fd;
   142fa:	44 89 60 0c          	mov    %r12d,0xc(%rax)
    *handle = hdl;
   142fe:	49 89 45 00          	mov    %rax,0x0(%r13)
    return 0;
   14302:	31 c0                	xor    %eax,%eax
}
   14304:	48 83 c4 08          	add    $0x8,%rsp
   14308:	5b                   	pop    %rbx
   14309:	41 5c                	pop    %r12
   1430b:	41 5d                	pop    %r13
   1430d:	5d                   	pop    %rbp
   1430e:	c3                   	retq   
   1430f:	90                   	nop    
    int rv;

    int fd = INLINE_SYSCALL(open, 3, GIPC_FILE, O_RDONLY|O_CLOEXEC, 0);

    if (IS_ERR(fd))
        return -PAL_ERROR_DENIED;
   14310:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   14315:	eb ed                	jmp    14304 <gipc_open+0xb4>
   14317:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1431e:	00 00 
    token = atoi(uri);

    rv = INLINE_SYSCALL(ioctl, 3, fd, GIPC_JOIN, token);

    if (rv < 0) {
        INLINE_SYSCALL(close, 1, fd);
   14320:	b8 06 00 00 00       	mov    $0x6,%eax
   14325:	cd 80                	int    $0x80
   14327:	bb 00 00 00 00       	mov    $0x0,%ebx
   1432c:	83 d3 00             	adc    $0x0,%ebx
        return -PAL_ERROR_DENIED;
   1432f:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   14334:	eb ce                	jmp    14304 <gipc_open+0xb4>
   14336:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1433d:	00 00 00 

0000000000014340 <_DkCreatePhysicalMemoryChannel>:
        .open               = &gipc_open,
        .close              = &gipc_close,
    };

int _DkCreatePhysicalMemoryChannel (PAL_HANDLE * handle, unsigned long * key)
{
   14340:	55                   	push   %rbp
   14341:	49 89 f8             	mov    %rdi,%r8
   14344:	48 89 e5             	mov    %rsp,%rbp
   14347:	41 55                	push   %r13
   14349:	41 54                	push   %r12

static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
   1434b:	48 8d 85 70 ff ff ff 	lea    -0x90(%rbp),%rax
   14352:	53                   	push   %rbx
   14353:	49 89 f4             	mov    %rsi,%r12
   14356:	48 83 ec 78          	sub    $0x78,%rsp
   1435a:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    frame->func = func;
   14361:	48 8b 05 40 f6 20 00 	mov    0x20f640(%rip),%rax        # 2239a8 <_DYNAMIC+0x1c0>
    frame->funcname = funcname;
    frame->context = NULL;
   14368:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
   1436f:	00 
    frame->retval = NULL;
   14370:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
   14377:	00 
static inline
void __store_frame (struct pal_frame * frame,
                    void * func, const char * funcname)
{
    frame->self = frame;
    frame->func = func;
   14378:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
    frame->funcname = funcname;
   1437f:	48 8d 05 ef 49 00 00 	lea    0x49ef(%rip),%rax        # 18d75 <handle_sizes.1924+0x5f5>
   14386:	48 89 45 80          	mov    %rax,-0x80(%rbp)
    frame->context = NULL;
    frame->retval = NULL;
    arch_store_frame(&frame->arch)
   1438a:	48 89 e0             	mov    %rsp,%rax
   1438d:	48 89 45 88          	mov    %rax,-0x78(%rbp)
   14391:	48 89 e8             	mov    %rbp,%rax
   14394:	48 89 45 90          	mov    %rax,-0x70(%rbp)
   14398:	48 89 d8             	mov    %rbx,%rax
   1439b:	48 89 45 98          	mov    %rax,-0x68(%rbp)
   1439f:	48 89 f0             	mov    %rsi,%rax
   143a2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
   143a6:	48 89 f8             	mov    %rdi,%rax
   143a9:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
   143ad:	4c 89 e0             	mov    %r12,%rax
   143b0:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
   143b4:	4c 89 e8             	mov    %r13,%rax
   143b7:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
   143bb:	4c 89 f0             	mov    %r14,%rax
   143be:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
   143c2:	4c 89 f8             	mov    %r15,%rax
    store_frame(CreatePhysicalMemoryChannel);

    unsigned long token = 0;
    int fd = INLINE_SYSCALL(open, 3, GIPC_FILE, O_RDONLY|O_CLOEXEC, 0);
   143c5:	b9 05 00 00 00       	mov    $0x5,%ecx
   143ca:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
   143ce:	31 d2                	xor    %edx,%edx
   143d0:	be 00 00 10 00       	mov    $0x100000,%esi
   143d5:	48 8d 3d e2 a9 00 00 	lea    0xa9e2(%rip),%rdi        # 1edbe <slab_levels+0x5b1e>
   143dc:	89 c8                	mov    %ecx,%eax
   143de:	cd 80                	int    $0x80
   143e0:	48 89 c1             	mov    %rax,%rcx
   143e3:	bb 00 00 00 00       	mov    $0x0,%ebx
   143e8:	83 d3 00             	adc    $0x0,%ebx
   143eb:	31 d2                	xor    %edx,%edx
   143ed:	85 db                	test   %ebx,%ebx
   143ef:	0f 95 c2             	setne  %dl
   143f2:	48 89 d0             	mov    %rdx,%rax
   143f5:	48 f7 d8             	neg    %rax
   143f8:	48 31 c8             	xor    %rcx,%rax
   143fb:	48 8d 1c 10          	lea    (%rax,%rdx,1),%rbx

    if (IS_ERR(fd))
   143ff:	85 db                	test   %ebx,%ebx
   14401:	78 6d                	js     14470 <_DkCreatePhysicalMemoryChannel+0x130>
        goto err;


    PAL_HANDLE hdl = malloc(HANDLE_SIZE(gipc));
   14403:	bf 10 00 00 00       	mov    $0x10,%edi
   14408:	4d 89 c5             	mov    %r8,%r13
   1440b:	e8 f0 45 ff ff       	callq  8a00 <malloc>
    SET_HANDLE_TYPE(hdl, gipc);
    hdl->gipc.fd = fd;

    // ioctl to create a new queue
    token = INLINE_SYSCALL(ioctl, 3, fd, GIPC_CREATE, 0);
   14410:	48 63 fb             	movslq %ebx,%rdi
        goto err;


    PAL_HANDLE hdl = malloc(HANDLE_SIZE(gipc));
    SET_HANDLE_TYPE(hdl, gipc);
    hdl->gipc.fd = fd;
   14413:	89 58 0c             	mov    %ebx,0xc(%rax)

    // ioctl to create a new queue
    token = INLINE_SYSCALL(ioctl, 3, fd, GIPC_CREATE, 0);
   14416:	bb 36 00 00 00       	mov    $0x36,%ebx

    if (IS_ERR(fd))
        goto err;


    PAL_HANDLE hdl = malloc(HANDLE_SIZE(gipc));
   1441b:	49 89 c0             	mov    %rax,%r8
    SET_HANDLE_TYPE(hdl, gipc);
   1441e:	c7 00 11 00 00 00    	movl   $0x11,(%rax)
   14424:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%rax)
   1442b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
    hdl->gipc.fd = fd;

    // ioctl to create a new queue
    token = INLINE_SYSCALL(ioctl, 3, fd, GIPC_CREATE, 0);
   14432:	31 d2                	xor    %edx,%edx
   14434:	be 02 6b 08 40       	mov    $0x40086b02,%esi
   14439:	89 d8                	mov    %ebx,%eax
   1443b:	cd 80                	int    $0x80
   1443d:	48 89 c1             	mov    %rax,%rcx
   14440:	bb 00 00 00 00       	mov    $0x0,%ebx
   14445:	83 d3 00             	adc    $0x0,%ebx
   14448:	31 d2                	xor    %edx,%edx
   1444a:	85 db                	test   %ebx,%ebx
    if (token < 0)
        goto err_fd;

    *handle = hdl;
   1444c:	4d 89 45 00          	mov    %r8,0x0(%r13)
   14450:	0f 95 c2             	setne  %dl
   14453:	48 89 d0             	mov    %rdx,%rax
   14456:	48 f7 d8             	neg    %rax
   14459:	48 31 c1             	xor    %rax,%rcx
    *key = token;
    return 0;
   1445c:	31 c0                	xor    %eax,%eax
   1445e:	48 01 d1             	add    %rdx,%rcx
   14461:	49 89 0c 24          	mov    %rcx,(%r12)
 err_fd:
    INLINE_SYSCALL(close, 1, fd);

 err:
    return -PAL_ERROR_DENIED;
}
   14465:	48 83 c4 78          	add    $0x78,%rsp
   14469:	5b                   	pop    %rbx
   1446a:	41 5c                	pop    %r12
   1446c:	41 5d                	pop    %r13
   1446e:	5d                   	pop    %rbp
   1446f:	c3                   	retq   

 err_fd:
    INLINE_SYSCALL(close, 1, fd);

 err:
    return -PAL_ERROR_DENIED;
   14470:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   14475:	eb ee                	jmp    14465 <_DkCreatePhysicalMemoryChannel+0x125>
   14477:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1447e:	00 00 

0000000000014480 <_DkPhysicalMemoryCommit>:
}

int _DkPhysicalMemoryCommit (PAL_HANDLE channel, int entries, void ** addrs,
                             unsigned long * sizes, int flags)
{
   14480:	55                   	push   %rbp

    struct gipc_send gs;
    int nsent = 0, n;
    unsigned long npagesent = 0;

    while (nsent < entries) {
   14481:	85 f6                	test   %esi,%esi
    return -PAL_ERROR_DENIED;
}

int _DkPhysicalMemoryCommit (PAL_HANDLE channel, int entries, void ** addrs,
                             unsigned long * sizes, int flags)
{
   14483:	41 89 f2             	mov    %esi,%r10d
   14486:	48 89 e5             	mov    %rsp,%rbp
   14489:	41 57                	push   %r15
   1448b:	41 56                	push   %r14
   1448d:	41 55                	push   %r13
   1448f:	41 54                	push   %r12
   14491:	53                   	push   %rbx
    int fd = channel->gipc.fd;
   14492:	4c 63 67 0c          	movslq 0xc(%rdi),%r12

    struct gipc_send gs;
    int nsent = 0, n;
    unsigned long npagesent = 0;

    while (nsent < entries) {
   14496:	0f 8e b2 00 00 00    	jle    1454e <_DkPhysicalMemoryCommit+0xce>
   1449c:	49 89 d5             	mov    %rdx,%r13
   1449f:	49 89 ce             	mov    %rcx,%r14
   144a2:	4c 8d 7d b0          	lea    -0x50(%rbp),%r15
   144a6:	45 31 c9             	xor    %r9d,%r9d
   144a9:	45 31 c0             	xor    %r8d,%r8d
   144ac:	eb 14                	jmp    144c2 <_DkPhysicalMemoryCommit+0x42>
   144ae:	66 90                	xchg   %ax,%ax
            if (!npagesent)
                return -PAL_ERROR_DENIED;
            return npagesent;
        }

        npagesent += ret;
   144b0:	48 63 d2             	movslq %edx,%rdx
        nsent += n;
   144b3:	41 01 c8             	add    %ecx,%r8d
            if (!npagesent)
                return -PAL_ERROR_DENIED;
            return npagesent;
        }

        npagesent += ret;
   144b6:	49 01 d1             	add    %rdx,%r9

    struct gipc_send gs;
    int nsent = 0, n;
    unsigned long npagesent = 0;

    while (nsent < entries) {
   144b9:	45 39 c2             	cmp    %r8d,%r10d
   144bc:	0f 8e 7e 00 00 00    	jle    14540 <_DkPhysicalMemoryCommit+0xc0>
        n = entries - nsent;
   144c2:	44 89 d1             	mov    %r10d,%ecx
   144c5:	b8 20 00 00 00       	mov    $0x20,%eax

        gs.entries  = n;
        gs.addr = (unsigned long *) (addrs + nsent);
        gs.len  = (unsigned long *) (sizes + nsent);

        int ret = INLINE_SYSCALL(ioctl, 3, fd, GIPC_SEND, &gs);
   144ca:	be 00 6b 08 80       	mov    $0x80086b00,%esi
    struct gipc_send gs;
    int nsent = 0, n;
    unsigned long npagesent = 0;

    while (nsent < entries) {
        n = entries - nsent;
   144cf:	44 29 c1             	sub    %r8d,%ecx

        gs.entries  = n;
        gs.addr = (unsigned long *) (addrs + nsent);
        gs.len  = (unsigned long *) (sizes + nsent);

        int ret = INLINE_SYSCALL(ioctl, 3, fd, GIPC_SEND, &gs);
   144d2:	4c 89 e7             	mov    %r12,%rdi
   144d5:	83 f9 20             	cmp    $0x20,%ecx
   144d8:	0f 4f c8             	cmovg  %eax,%ecx
        n = entries - nsent;

        if (n > ADDR_ENTS)
            n = ADDR_ENTS;

        gs.entries  = n;
   144db:	48 63 c1             	movslq %ecx,%rax
   144de:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        gs.addr = (unsigned long *) (addrs + nsent);
   144e2:	49 63 c0             	movslq %r8d,%rax
   144e5:	48 c1 e0 03          	shl    $0x3,%rax
   144e9:	49 8d 54 05 00       	lea    0x0(%r13,%rax,1),%rdx
        gs.len  = (unsigned long *) (sizes + nsent);
   144ee:	4c 01 f0             	add    %r14,%rax
   144f1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)

        int ret = INLINE_SYSCALL(ioctl, 3, fd, GIPC_SEND, &gs);
   144f5:	b8 36 00 00 00       	mov    $0x36,%eax

        if (n > ADDR_ENTS)
            n = ADDR_ENTS;

        gs.entries  = n;
        gs.addr = (unsigned long *) (addrs + nsent);
   144fa:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
        gs.len  = (unsigned long *) (sizes + nsent);

        int ret = INLINE_SYSCALL(ioctl, 3, fd, GIPC_SEND, &gs);
   144fe:	4c 89 fa             	mov    %r15,%rdx
   14501:	cd 80                	int    $0x80
   14503:	48 89 c6             	mov    %rax,%rsi
   14506:	bb 00 00 00 00       	mov    $0x0,%ebx
   1450b:	83 d3 00             	adc    $0x0,%ebx
   1450e:	31 d2                	xor    %edx,%edx
   14510:	85 db                	test   %ebx,%ebx
   14512:	0f 95 c2             	setne  %dl
   14515:	48 89 d0             	mov    %rdx,%rax
   14518:	48 f7 d8             	neg    %rax
   1451b:	48 31 c6             	xor    %rax,%rsi
   1451e:	48 01 f2             	add    %rsi,%rdx

        if (IS_ERR(ret)) {
   14521:	85 d2                	test   %edx,%edx
   14523:	79 8b                	jns    144b0 <_DkPhysicalMemoryCommit+0x30>
            if (!npagesent)
                return -PAL_ERROR_DENIED;
            return npagesent;
   14525:	4d 85 c9             	test   %r9,%r9
   14528:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   1452d:	41 0f 45 c1          	cmovne %r9d,%eax
        npagesent += ret;
        nsent += n;
    }

    return npagesent;
}
   14531:	5b                   	pop    %rbx
   14532:	41 5c                	pop    %r12
   14534:	41 5d                	pop    %r13
   14536:	41 5e                	pop    %r14
   14538:	41 5f                	pop    %r15
   1453a:	5d                   	pop    %rbp
   1453b:	c3                   	retq   
   1453c:	0f 1f 40 00          	nopl   0x0(%rax)
   14540:	44 89 c8             	mov    %r9d,%eax
   14543:	5b                   	pop    %rbx
   14544:	41 5c                	pop    %r12
   14546:	41 5d                	pop    %r13
   14548:	41 5e                	pop    %r14
   1454a:	41 5f                	pop    %r15
   1454c:	5d                   	pop    %rbp
   1454d:	c3                   	retq   

    struct gipc_send gs;
    int nsent = 0, n;
    unsigned long npagesent = 0;

    while (nsent < entries) {
   1454e:	31 c0                	xor    %eax,%eax

        npagesent += ret;
        nsent += n;
    }

    return npagesent;
   14550:	eb df                	jmp    14531 <_DkPhysicalMemoryCommit+0xb1>
   14552:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
   14559:	1f 84 00 00 00 00 00 

0000000000014560 <_DkPhysicalMemoryMap>:
}

int _DkPhysicalMemoryMap (PAL_HANDLE channel, int entries, void ** addrs,
                          unsigned long * sizes, unsigned int * prots)
{
   14560:	55                   	push   %rbp
    int fd = channel->gipc.fd;
    struct gipc_recv gr;
    int nrecv = 0, n;
    unsigned long npagerecv = 0;

    while (nrecv < entries) {
   14561:	85 f6                	test   %esi,%esi
    return npagesent;
}

int _DkPhysicalMemoryMap (PAL_HANDLE channel, int entries, void ** addrs,
                          unsigned long * sizes, unsigned int * prots)
{
   14563:	48 89 e5             	mov    %rsp,%rbp
   14566:	41 57                	push   %r15
   14568:	41 56                	push   %r14
   1456a:	41 55                	push   %r13
   1456c:	41 54                	push   %r12
   1456e:	41 89 f4             	mov    %esi,%r12d
   14571:	53                   	push   %rbx
    int fd = channel->gipc.fd;
   14572:	4c 63 6f 0c          	movslq 0xc(%rdi),%r13
    struct gipc_recv gr;
    int nrecv = 0, n;
    unsigned long npagerecv = 0;

    while (nrecv < entries) {
   14576:	0f 8e c2 00 00 00    	jle    1463e <_DkPhysicalMemoryMap+0xde>
   1457c:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
   14580:	49 89 d6             	mov    %rdx,%r14
   14583:	49 89 cf             	mov    %rcx,%r15
   14586:	45 31 d2             	xor    %r10d,%r10d
   14589:	45 31 c9             	xor    %r9d,%r9d
   1458c:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
   14590:	eb 12                	jmp    145a4 <_DkPhysicalMemoryMap+0x44>
            if (!npagerecv)
                return -PAL_ERROR_DENIED;
            return npagerecv;
        }

        npagerecv += ret;
   14592:	48 63 d2             	movslq %edx,%rdx
        nrecv += n;
   14595:	41 01 c9             	add    %ecx,%r9d
            if (!npagerecv)
                return -PAL_ERROR_DENIED;
            return npagerecv;
        }

        npagerecv += ret;
   14598:	49 01 d2             	add    %rdx,%r10
    int fd = channel->gipc.fd;
    struct gipc_recv gr;
    int nrecv = 0, n;
    unsigned long npagerecv = 0;

    while (nrecv < entries) {
   1459b:	45 39 cc             	cmp    %r9d,%r12d
   1459e:	0f 8e 8c 00 00 00    	jle    14630 <_DkPhysicalMemoryMap+0xd0>
        n = entries - nrecv;
   145a4:	44 89 e1             	mov    %r12d,%ecx
   145a7:	b8 20 00 00 00       	mov    $0x20,%eax

        if (n > ADDR_ENTS)
            n = ADDR_ENTS;

        gr.entries = n;
        gr.addr = (unsigned long *) (addrs + nrecv);
   145ac:	49 63 d1             	movslq %r9d,%rdx
    struct gipc_recv gr;
    int nrecv = 0, n;
    unsigned long npagerecv = 0;

    while (nrecv < entries) {
        n = entries - nrecv;
   145af:	44 29 c9             	sub    %r9d,%ecx
        gr.entries = n;
        gr.addr = (unsigned long *) (addrs + nrecv);
        gr.len  = (unsigned long *) (sizes + nrecv);
        gr.prot = (int *) (prots + nrecv);

        int ret = INLINE_SYSCALL(ioctl, 3, fd, GIPC_RECV, &gr);
   145b2:	4c 89 ef             	mov    %r13,%rdi
   145b5:	83 f9 20             	cmp    $0x20,%ecx
   145b8:	0f 4f c8             	cmovg  %eax,%ecx
        n = entries - nrecv;

        if (n > ADDR_ENTS)
            n = ADDR_ENTS;

        gr.entries = n;
   145bb:	48 63 c1             	movslq %ecx,%rax
   145be:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
        gr.addr = (unsigned long *) (addrs + nrecv);
   145c2:	48 8d 04 d5 00 00 00 	lea    0x0(,%rdx,8),%rax
   145c9:	00 
   145ca:	49 8d 34 06          	lea    (%r14,%rax,1),%rsi
        gr.len  = (unsigned long *) (sizes + nrecv);
   145ce:	4c 01 f8             	add    %r15,%rax
   145d1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
        gr.prot = (int *) (prots + nrecv);
   145d5:	49 8d 04 90          	lea    (%r8,%rdx,4),%rax

        int ret = INLINE_SYSCALL(ioctl, 3, fd, GIPC_RECV, &gr);
   145d9:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx

        if (n > ADDR_ENTS)
            n = ADDR_ENTS;

        gr.entries = n;
        gr.addr = (unsigned long *) (addrs + nrecv);
   145dd:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
        gr.len  = (unsigned long *) (sizes + nrecv);
        gr.prot = (int *) (prots + nrecv);

        int ret = INLINE_SYSCALL(ioctl, 3, fd, GIPC_RECV, &gr);
   145e1:	be 01 6b 08 40       	mov    $0x40086b01,%esi
            n = ADDR_ENTS;

        gr.entries = n;
        gr.addr = (unsigned long *) (addrs + nrecv);
        gr.len  = (unsigned long *) (sizes + nrecv);
        gr.prot = (int *) (prots + nrecv);
   145e6:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

        int ret = INLINE_SYSCALL(ioctl, 3, fd, GIPC_RECV, &gr);
   145ea:	b8 36 00 00 00       	mov    $0x36,%eax
   145ef:	cd 80                	int    $0x80
   145f1:	48 89 c6             	mov    %rax,%rsi
   145f4:	bb 00 00 00 00       	mov    $0x0,%ebx
   145f9:	83 d3 00             	adc    $0x0,%ebx
   145fc:	31 d2                	xor    %edx,%edx
   145fe:	85 db                	test   %ebx,%ebx
   14600:	0f 95 c2             	setne  %dl
   14603:	48 89 d0             	mov    %rdx,%rax
   14606:	48 f7 d8             	neg    %rax
   14609:	48 31 c6             	xor    %rax,%rsi
   1460c:	48 01 f2             	add    %rsi,%rdx

        if (IS_ERR(ret)) {
   1460f:	85 d2                	test   %edx,%edx
   14611:	0f 89 7b ff ff ff    	jns    14592 <_DkPhysicalMemoryMap+0x32>
            if (!npagerecv)
                return -PAL_ERROR_DENIED;
            return npagerecv;
   14617:	4d 85 d2             	test   %r10,%r10
   1461a:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
   1461f:	41 0f 45 c2          	cmovne %r10d,%eax
        npagerecv += ret;
        nrecv += n;
    }

    return npagerecv;
}
   14623:	5b                   	pop    %rbx
   14624:	41 5c                	pop    %r12
   14626:	41 5d                	pop    %r13
   14628:	41 5e                	pop    %r14
   1462a:	41 5f                	pop    %r15
   1462c:	5d                   	pop    %rbp
   1462d:	c3                   	retq   
   1462e:	66 90                	xchg   %ax,%ax
   14630:	44 89 d0             	mov    %r10d,%eax
   14633:	5b                   	pop    %rbx
   14634:	41 5c                	pop    %r12
   14636:	41 5d                	pop    %r13
   14638:	41 5e                	pop    %r14
   1463a:	41 5f                	pop    %r15
   1463c:	5d                   	pop    %rbp
   1463d:	c3                   	retq   
    int fd = channel->gipc.fd;
    struct gipc_recv gr;
    int nrecv = 0, n;
    unsigned long npagerecv = 0;

    while (nrecv < entries) {
   1463e:	31 c0                	xor    %eax,%eax

        npagerecv += ret;
        nrecv += n;
    }

    return npagerecv;
   14640:	eb e1                	jmp    14623 <_DkPhysicalMemoryMap+0xc3>
   14642:	90                   	nop    
   14643:	90                   	nop    
   14644:	90                   	nop    
   14645:	90                   	nop    
   14646:	90                   	nop    
   14647:	90                   	nop    
   14648:	90                   	nop    
   14649:	90                   	nop    
   1464a:	90                   	nop    
   1464b:	90                   	nop    
   1464c:	90                   	nop    
   1464d:	90                   	nop    
   1464e:	90                   	nop    
   1464f:	90                   	nop    

0000000000014650 <_DkDummyEventUpcall>:
    return ret;
}

static int _DkDummyEventUpcall (int event_num, PAL_UPCALL upcall,
                                int flags)
{
   14650:	55                   	push   %rbp
    struct handler * handler = pal_handlers[event_num];
   14651:	48 63 ff             	movslq %edi,%rdi
    return ret;
}

static int _DkDummyEventUpcall (int event_num, PAL_UPCALL upcall,
                                int flags)
{
   14654:	48 89 e5             	mov    %rsp,%rbp
   14657:	41 55                	push   %r13
   14659:	41 54                	push   %r12
   1465b:	53                   	push   %rbx
   1465c:	49 89 f5             	mov    %rsi,%r13
   1465f:	41 89 d4             	mov    %edx,%r12d
   14662:	48 83 ec 08          	sub    $0x8,%rsp
    struct handler * handler = pal_handlers[event_num];
   14666:	48 8b 05 9b f4 20 00 	mov    0x20f49b(%rip),%rax        # 223b08 <_DYNAMIC+0x320>
   1466d:	48 8b 1c f8          	mov    (%rax,%rdi,8),%rbx

    _DkMutexLock(&handler->lock);
   14671:	48 89 df             	mov    %rbx,%rdi
   14674:	e8 d7 c5 ff ff       	callq  10c50 <_DkMutexLock>
    handler->upcall = upcall;
   14679:	4c 89 6b 08          	mov    %r13,0x8(%rbx)
    handler->flags = flags;
   1467d:	44 89 63 10          	mov    %r12d,0x10(%rbx)
    _DkMutexUnlock(&handler->lock);
   14681:	48 89 df             	mov    %rbx,%rdi
   14684:	e8 37 c8 ff ff       	callq  10ec0 <_DkMutexUnlock>

    return 0;
}
   14689:	48 83 c4 08          	add    $0x8,%rsp
   1468d:	31 c0                	xor    %eax,%eax
   1468f:	5b                   	pop    %rbx
   14690:	41 5c                	pop    %r12
   14692:	41 5d                	pop    %r13
   14694:	5d                   	pop    %rbp
   14695:	c3                   	retq   
   14696:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1469d:	00 00 00 

00000000000146a0 <_DkCompatibilitySighandler>:
        /* Failure    */ &_DkDummyEventUpcall,
    };

static void _DkCompatibilitySighandler (int signum, siginfo_t * info,
                                        struct ucontext * uc)
{
   146a0:	55                   	push   %rbp
    printf("compatibility support: detected an unintercepted system call\n");
   146a1:	48 8d 3d 20 a7 00 00 	lea    0xa720(%rip),%rdi        # 1edc8 <slab_levels+0x5b28>
   146a8:	31 c0                	xor    %eax,%eax
        /* Failure    */ &_DkDummyEventUpcall,
    };

static void _DkCompatibilitySighandler (int signum, siginfo_t * info,
                                        struct ucontext * uc)
{
   146aa:	48 89 e5             	mov    %rsp,%rbp
   146ad:	41 56                	push   %r14
   146af:	41 54                	push   %r12
   146b1:	53                   	push   %rbx
   146b2:	48 89 d3             	mov    %rdx,%rbx
   146b5:	48 83 ec 08          	sub    $0x8,%rsp
    printf("compatibility support: detected an unintercepted system call\n");
   146b9:	e8 62 47 ff ff       	callq  8e20 <pal_printf>

    if (!pal_config.syscall_sym_addr)
   146be:	4c 8b 25 5b f3 20 00 	mov    0x20f35b(%rip),%r12        # 223a20 <_DYNAMIC+0x238>
   146c5:	49 8b 8c 24 88 00 00 	mov    0x88(%r12),%rcx
   146cc:	00 
   146cd:	48 85 c9             	test   %rcx,%rcx
   146d0:	74 42                	je     14714 <_DkCompatibilitySighandler+0x74>
        _DkProcessExit(-1);

    asm volatile ("movq %6, %%r10\r\n"
   146d2:	48 8b 83 90 00 00 00 	mov    0x90(%rbx),%rax
   146d9:	48 8b 7b 68          	mov    0x68(%rbx),%rdi
   146dd:	48 8b 73 70          	mov    0x70(%rbx),%rsi
   146e1:	48 8b 93 88 00 00 00 	mov    0x88(%rbx),%rdx
   146e8:	4c 8b 5b 38          	mov    0x38(%rbx),%r11
   146ec:	4c 8b 63 28          	mov    0x28(%rbx),%r12
   146f0:	4c 8b 73 30          	mov    0x30(%rbx),%r14
   146f4:	4d 89 da             	mov    %r11,%r10
   146f7:	4d 89 e0             	mov    %r12,%r8
   146fa:	4d 89 f1             	mov    %r14,%r9
   146fd:	ff d1                	callq  *%rcx
   146ff:	48 89 c0             	mov    %rax,%rax
   14702:	48 89 83 90 00 00 00 	mov    %rax,0x90(%rbx)
                    "d" (uc->uc_mcontext.gregs[REG_RDX]),
                    "r" (uc->uc_mcontext.gregs[REG_R10]),
                    "r" (uc->uc_mcontext.gregs[REG_R8]),
                    "r" (uc->uc_mcontext.gregs[REG_R9])
                  : "memory", "r10", "r8", "r9");
}
   14709:	48 83 c4 08          	add    $0x8,%rsp
   1470d:	5b                   	pop    %rbx
   1470e:	41 5c                	pop    %r12
   14710:	41 5e                	pop    %r14
   14712:	5d                   	pop    %rbp
   14713:	c3                   	retq   
                                        struct ucontext * uc)
{
    printf("compatibility support: detected an unintercepted system call\n");

    if (!pal_config.syscall_sym_addr)
        _DkProcessExit(-1);
   14714:	bf ff ff ff ff       	mov    $0xffffffff,%edi
   14719:	e8 62 de ff ff       	callq  12580 <_DkProcessExit>
   1471e:	49 8b 8c 24 88 00 00 	mov    0x88(%r12),%rcx
   14725:	00 
   14726:	eb aa                	jmp    146d2 <_DkCompatibilitySighandler+0x32>
   14728:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1472f:	00 

0000000000014730 <get_frame.isra.0>:

#define ADDR_IN_PAL(addr)               \
        ((void *) (addr) > pal_config.lib_text_start && \
         (void *) (addr) < pal_config.lib_text_end)

static struct pal_frame * get_frame (struct ucontext * uc)
   14730:	48 8b 05 e9 f2 20 00 	mov    0x20f2e9(%rip),%rax        # 223a20 <_DYNAMIC+0x238>
   14737:	55                   	push   %rbp
   14738:	48 89 e5             	mov    %rsp,%rbp
{
    unsigned long rip = uc->uc_mcontext.gregs[REG_RIP];
    unsigned long rbp = uc->uc_mcontext.gregs[REG_RBP];

    if (!ADDR_IN_PAL(rip))
   1473b:	48 8b 50 58          	mov    0x58(%rax),%rdx
   1473f:	48 39 d6             	cmp    %rdx,%rsi
   14742:	76 3a                	jbe    1477e <get_frame.isra.0+0x4e>
   14744:	48 8b 48 60          	mov    0x60(%rax),%rcx
   14748:	48 39 ce             	cmp    %rcx,%rsi
   1474b:	72 0b                	jb     14758 <get_frame.isra.0+0x28>
   1474d:	eb 2f                	jmp    1477e <get_frame.isra.0+0x4e>
   1474f:	90                   	nop    
        return NULL;

    while (ADDR_IN_PAL(((unsigned long *) rbp)[1]))
   14750:	48 39 c1             	cmp    %rax,%rcx
   14753:	76 0c                	jbe    14761 <get_frame.isra.0+0x31>
        rbp = *(unsigned long *) rbp;
   14755:	48 8b 3f             	mov    (%rdi),%rdi
    unsigned long rbp = uc->uc_mcontext.gregs[REG_RBP];

    if (!ADDR_IN_PAL(rip))
        return NULL;

    while (ADDR_IN_PAL(((unsigned long *) rbp)[1]))
   14758:	48 8b 47 08          	mov    0x8(%rdi),%rax
   1475c:	48 39 c2             	cmp    %rax,%rdx
   1475f:	72 ef                	jb     14750 <get_frame.isra.0+0x20>
        rbp = *(unsigned long *) rbp;

    struct pal_frame * frame = (struct pal_frame *) rbp - 1;
   14761:	48 8d 47 90          	lea    -0x70(%rdi),%rax
   14765:	48 81 ef b0 00 00 00 	sub    $0xb0,%rdi
   1476c:	0f 1f 40 00          	nopl   0x0(%rax)

    for (int i = 0 ; i < 8 ; i++) {
        if (frame->self == frame)
   14770:	48 3b 00             	cmp    (%rax),%rax
   14773:	74 0b                	je     14780 <get_frame.isra.0+0x50>
            return frame;

        frame = (struct pal_frame *) ((void *) frame - 8);
   14775:	48 83 e8 08          	sub    $0x8,%rax
    while (ADDR_IN_PAL(((unsigned long *) rbp)[1]))
        rbp = *(unsigned long *) rbp;

    struct pal_frame * frame = (struct pal_frame *) rbp - 1;

    for (int i = 0 ; i < 8 ; i++) {
   14779:	48 39 f8             	cmp    %rdi,%rax
   1477c:	75 f2                	jne    14770 <get_frame.isra.0+0x40>
{
    unsigned long rip = uc->uc_mcontext.gregs[REG_RIP];
    unsigned long rbp = uc->uc_mcontext.gregs[REG_RBP];

    if (!ADDR_IN_PAL(rip))
        return NULL;
   1477e:	31 c0                	xor    %eax,%eax

        frame = (struct pal_frame *) ((void *) frame - 8);
    }

    return NULL;
}
   14780:	5d                   	pop    %rbp
   14781:	c3                   	retq   
   14782:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
   14789:	1f 84 00 00 00 00 00 

0000000000014790 <set_sighandler>:
         "    syscall\n");
DEFINE_RESTORE_RT(__NR_rt_sigreturn)
*/#endif

int set_sighandler (int * sigs, int nsig, void * handler)
{
   14790:	55                   	push   %rbp
#endif

    __sigemptyset((_sigset_t *) &action.sa_mask);
    __sigaddset((_sigset_t *) &action.sa_mask, SIGCONT);

    for (int i = 0 ; i < nsig ; i++) {
   14791:	85 f6                	test   %esi,%esi
         "    syscall\n");
DEFINE_RESTORE_RT(__NR_rt_sigreturn)
*/#endif

int set_sighandler (int * sigs, int nsig, void * handler)
{
   14793:	48 89 e5             	mov    %rsp,%rbp
   14796:	41 55                	push   %r13
   14798:	41 54                	push   %r12
   1479a:	53                   	push   %rbx
    struct sigaction action;
    action.sa_handler = (void (*)(int)) handler;
   1479b:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
    action.sa_flags = SA_SIGINFO;

#if !defined(__i386__)
    action.sa_flags |= SA_RESTORER;
   1479f:	c7 45 c8 40 00 00 04 	movl   $0x4000040,-0x38(%rbp)
    return BODY;							      \
  }
#endif 

__SIGSETFN (__sigismember, (__set->__val[__word] & __mask) ? 1 : 0, __const)
__SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), )
   147a6:	48 c7 45 cc 00 00 04 	movq   $0x40000,-0x34(%rbp)
   147ad:	00 
#endif

    __sigemptyset((_sigset_t *) &action.sa_mask);
    __sigaddset((_sigset_t *) &action.sa_mask, SIGCONT);

    for (int i = 0 ; i < nsig ; i++) {
   147ae:	0f 8e 1c 01 00 00    	jle    148d0 <set_sighandler+0x140>
   147b4:	83 ee 01             	sub    $0x1,%esi
   147b7:	4c 8d 6d c0          	lea    -0x40(%rbp),%r13
   147bb:	49 89 f8             	mov    %rdi,%r8
   147be:	4c 8d 4c b7 04       	lea    0x4(%rdi,%rsi,4),%r9
   147c3:	49 89 fa             	mov    %rdi,%r10
            action.sa_flags |= SA_NOCLDSTOP|SA_NOCLDWAIT;

#if defined(__i386__)
        int ret = INLINE_SYSCALL(sigaction, 3, sigs[i], &action, NULL)
#else
        int ret = INLINE_SYSCALL(sigaction, 4, sigs[i], &action, NULL,
   147c6:	41 bc a0 01 00 00    	mov    $0x1a0,%r12d
   147cc:	eb 43                	jmp    14811 <set_sighandler+0x81>
   147ce:	66 90                	xchg   %ax,%ax
   147d0:	b9 10 00 00 00       	mov    $0x10,%ecx
   147d5:	31 d2                	xor    %edx,%edx
   147d7:	4c 89 ee             	mov    %r13,%rsi
   147da:	44 89 e0             	mov    %r12d,%eax
   147dd:	cd 80                	int    $0x80
   147df:	48 89 c2             	mov    %rax,%rdx
   147e2:	bb 00 00 00 00       	mov    $0x0,%ebx
   147e7:	83 d3 00             	adc    $0x0,%ebx
   147ea:	31 c0                	xor    %eax,%eax
   147ec:	85 db                	test   %ebx,%ebx
   147ee:	0f 95 c0             	setne  %al
   147f1:	48 89 c1             	mov    %rax,%rcx
   147f4:	48 f7 d9             	neg    %rcx
   147f7:	48 31 ca             	xor    %rcx,%rdx
                                 sizeof(sigset_t));
#endif
        if (IS_ERR(ret))
   147fa:	89 d3                	mov    %edx,%ebx
   147fc:	01 c3                	add    %eax,%ebx
   147fe:	0f 88 bc 00 00 00    	js     148c0 <set_sighandler+0x130>
   14804:	49 83 c2 04          	add    $0x4,%r10
            return -PAL_ERROR_DENIED;

        action.sa_flags &= ~(SA_NOCLDSTOP|SA_NOCLDWAIT);
   14808:	83 65 c8 d7          	andl   $0xffffffffffffffd7,-0x38(%rbp)
#endif

    __sigemptyset((_sigset_t *) &action.sa_mask);
    __sigaddset((_sigset_t *) &action.sa_mask, SIGCONT);

    for (int i = 0 ; i < nsig ; i++) {
   1480c:	4d 39 ca             	cmp    %r9,%r10
   1480f:	74 0f                	je     14820 <set_sighandler+0x90>
        if (sigs[i] == SIGCHLD)
   14811:	49 63 3a             	movslq (%r10),%rdi
   14814:	83 ff 14             	cmp    $0x14,%edi
   14817:	75 b7                	jne    147d0 <set_sighandler+0x40>
            action.sa_flags |= SA_NOCLDSTOP|SA_NOCLDWAIT;
   14819:	83 4d c8 28          	orl    $0x28,-0x38(%rbp)
   1481d:	eb b1                	jmp    147d0 <set_sighandler+0x40>
   1481f:	90                   	nop    
   14820:	48 8b 35 39 f1 20 00 	mov    0x20f139(%rip),%rsi        # 223960 <_DYNAMIC+0x178>
    }

    bool maskset = false;
    int ret = 0;
    _sigset_t mask;
    __sigemptyset(&mask);
   14827:	48 c7 45 b0 00 00 00 	movq   $0x0,-0x50(%rbp)
   1482e:	00 
   1482f:	45 31 d2             	xor    %r10d,%r10d
    unsigned long int __word = __sigword (__sig);			      \
    return BODY;							      \
  }
#endif 

__SIGSETFN (__sigismember, (__set->__val[__word] & __mask) ? 1 : 0, __const)
   14832:	bf 01 00 00 00       	mov    $0x1,%edi
   14837:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1483e:	00 00 
   14840:	41 8b 00             	mov    (%r8),%eax
   14843:	48 89 fa             	mov    %rdi,%rdx
   14846:	8d 48 ff             	lea    -0x1(%rax),%ecx
   14849:	48 d3 e2             	shl    %cl,%rdx
   1484c:	48 63 c9             	movslq %ecx,%rcx
   1484f:	48 c1 e9 06          	shr    $0x6,%rcx
   14853:	48 8b 44 ce 10       	mov    0x10(%rsi,%rcx,8),%rax
    for (int i = 0 ; i < nsig ; i++)
        if (__sigismember(&pal_linux_config.sigset, sigs[i])) {
   14858:	48 85 d0             	test   %rdx,%rax
   1485b:	74 19                	je     14876 <set_sighandler+0xe6>
__SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), )
__SIGSETFN (__sigdelset, ((__set->__val[__word] &= ~__mask), 0), )
   1485d:	49 89 d2             	mov    %rdx,%r10
    return BODY;							      \
  }
#endif 

__SIGSETFN (__sigismember, (__set->__val[__word] & __mask) ? 1 : 0, __const)
__SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), )
   14860:	48 09 54 cd b0       	or     %rdx,-0x50(%rbp,%rcx,8)
__SIGSETFN (__sigdelset, ((__set->__val[__word] &= ~__mask), 0), )
   14865:	49 f7 d2             	not    %r10
   14868:	4c 21 d0             	and    %r10,%rax
            __sigdelset(&pal_linux_config.sigset, sigs[i]);
            __sigaddset(&mask, sigs[i]);
            maskset = true;
   1486b:	41 ba 01 00 00 00    	mov    $0x1,%r10d
   14871:	48 89 44 ce 10       	mov    %rax,0x10(%rsi,%rcx,8)
   14876:	49 83 c0 04          	add    $0x4,%r8

    bool maskset = false;
    int ret = 0;
    _sigset_t mask;
    __sigemptyset(&mask);
    for (int i = 0 ; i < nsig ; i++)
   1487a:	4d 39 c1             	cmp    %r8,%r9
   1487d:	75 c1                	jne    14840 <set_sighandler+0xb0>
    }

    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
   1487f:	45 31 c0             	xor    %r8d,%r8d
            __sigdelset(&pal_linux_config.sigset, sigs[i]);
            __sigaddset(&mask, sigs[i]);
            maskset = true;
        }

    if (maskset) {
   14882:	45 84 d2             	test   %r10b,%r10b
   14885:	74 3f                	je     148c6 <set_sighandler+0x136>
#if defined(__i386__)
        ret = INLINE_SYSCALL(sigprocmask, 3, SIG_UNBLOCK, &mask, NULL)
#else
        ret = INLINE_SYSCALL(sigprocmask, 4, SIG_UNBLOCK, &mask, NULL,
   14887:	bb 54 01 00 00       	mov    $0x154,%ebx
   1488c:	b9 10 00 00 00       	mov    $0x10,%ecx
   14891:	31 d2                	xor    %edx,%edx
   14893:	48 8d 75 b0          	lea    -0x50(%rbp),%rsi
   14897:	bf 02 00 00 00       	mov    $0x2,%edi
   1489c:	89 d8                	mov    %ebx,%eax
   1489e:	cd 80                	int    $0x80
   148a0:	48 89 c2             	mov    %rax,%rdx
   148a3:	bb 00 00 00 00       	mov    $0x0,%ebx
   148a8:	83 d3 00             	adc    $0x0,%ebx
   148ab:	31 c9                	xor    %ecx,%ecx
   148ad:	85 db                	test   %ebx,%ebx
   148af:	0f 95 c1             	setne  %cl
   148b2:	48 89 c8             	mov    %rcx,%rax
   148b5:	48 f7 d8             	neg    %rax
   148b8:	48 31 d0             	xor    %rdx,%rax
                             sizeof(sigset_t));
#endif
    }

    if (IS_ERR(ret))
   148bb:	01 c8                	add    %ecx,%eax
   148bd:	79 07                	jns    148c6 <set_sighandler+0x136>
   148bf:	90                   	nop    
#else
        int ret = INLINE_SYSCALL(sigaction, 4, sigs[i], &action, NULL,
                                 sizeof(sigset_t));
#endif
        if (IS_ERR(ret))
            return -PAL_ERROR_DENIED;
   148c0:	41 b8 fa ff ff ff    	mov    $0xfffffffa,%r8d

    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
}
   148c6:	44 89 c0             	mov    %r8d,%eax
   148c9:	5b                   	pop    %rbx
   148ca:	41 5c                	pop    %r12
   148cc:	41 5d                	pop    %r13
   148ce:	5d                   	pop    %rbp
   148cf:	c3                   	retq   
    }

    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
   148d0:	45 31 c0             	xor    %r8d,%r8d
   148d3:	eb f1                	jmp    148c6 <set_sighandler+0x136>
   148d5:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
   148dc:	00 00 00 00 

00000000000148e0 <_DkPersistentEventUpcall>:
    return 0;
}

static int _DkPersistentEventUpcall (int event_num, PAL_UPCALL upcall,
                                     int flags)
{
   148e0:	55                   	push   %rbp
    struct handler * handler = pal_handlers[event_num];
   148e1:	48 8b 05 20 f2 20 00 	mov    0x20f220(%rip),%rax        # 223b08 <_DYNAMIC+0x320>
    return 0;
}

static int _DkPersistentEventUpcall (int event_num, PAL_UPCALL upcall,
                                     int flags)
{
   148e8:	48 89 e5             	mov    %rsp,%rbp
   148eb:	41 56                	push   %r14
   148ed:	41 55                	push   %r13
   148ef:	41 54                	push   %r12
   148f1:	53                   	push   %rbx
    struct handler * handler = pal_handlers[event_num];
   148f2:	48 63 df             	movslq %edi,%rbx
   148f5:	4c 8b 24 d8          	mov    (%rax,%rbx,8),%r12
    return 0;
}

static int _DkPersistentEventUpcall (int event_num, PAL_UPCALL upcall,
                                     int flags)
{
   148f9:	49 89 f6             	mov    %rsi,%r14
   148fc:	41 89 d5             	mov    %edx,%r13d
    struct handler * handler = pal_handlers[event_num];

    _DkMutexLock(&handler->lock);
   148ff:	4c 89 e7             	mov    %r12,%rdi
   14902:	e8 49 c3 ff ff       	callq  10c50 <_DkMutexLock>
    handler->upcall = upcall;
    handler->flags = flags;
    _DkMutexUnlock(&handler->lock);
   14907:	4c 89 e7             	mov    %r12,%rdi
                                     int flags)
{
    struct handler * handler = pal_handlers[event_num];

    _DkMutexLock(&handler->lock);
    handler->upcall = upcall;
   1490a:	4d 89 74 24 08       	mov    %r14,0x8(%r12)
    handler->flags = flags;
   1490f:	45 89 6c 24 10       	mov    %r13d,0x10(%r12)
    _DkMutexUnlock(&handler->lock);
   14914:	e8 a7 c5 ff ff       	callq  10ec0 <_DkMutexUnlock>
        /* Failure     */ { .signum = { 0 }, .handler = NULL },
    };

static int _DkPersistentSighandlerSetup (int event_num)
{
    int nsigs, * sigs = on_signals[event_num].signum;
   14919:	48 8b 15 a0 f0 20 00 	mov    0x20f0a0(%rip),%rdx        # 2239c0 <_DYNAMIC+0x1d8>
   14920:	48 8d 04 5b          	lea    (%rbx,%rbx,2),%rax
   14924:	48 8d 3c c2          	lea    (%rdx,%rax,8),%rdi
    for (nsigs = 0 ; sigs[nsigs] ; nsigs++);
   14928:	8b 37                	mov    (%rdi),%esi
   1492a:	85 f6                	test   %esi,%esi
   1492c:	74 35                	je     14963 <_DkPersistentEventUpcall+0x83>
   1492e:	48 8d 47 04          	lea    0x4(%rdi),%rax
   14932:	31 f6                	xor    %esi,%esi
   14934:	48 83 c0 04          	add    $0x4,%rax
   14938:	8b 48 fc             	mov    -0x4(%rax),%ecx
   1493b:	83 c6 01             	add    $0x1,%esi
   1493e:	85 c9                	test   %ecx,%ecx
   14940:	75 f2                	jne    14934 <_DkPersistentEventUpcall+0x54>

    void * sighandler = on_signals[event_num].handler;
   14942:	48 8d 04 5b          	lea    (%rbx,%rbx,2),%rax

    int ret = set_sighandler (sigs, nsigs, sighandler);
   14946:	48 8b 54 c2 10       	mov    0x10(%rdx,%rax,8),%rdx
   1494b:	e8 40 fe ff ff       	callq  14790 <set_sighandler>
   14950:	ba 00 00 00 00       	mov    $0x0,%edx
   14955:	85 c0                	test   %eax,%eax
    handler->upcall = upcall;
    handler->flags = flags;
    _DkMutexUnlock(&handler->lock);

    return _DkPersistentSighandlerSetup(event_num);
}
   14957:	5b                   	pop    %rbx
   14958:	0f 4f c2             	cmovg  %edx,%eax
   1495b:	41 5c                	pop    %r12
   1495d:	41 5d                	pop    %r13
   1495f:	41 5e                	pop    %r14
   14961:	5d                   	pop    %rbp
   14962:	c3                   	retq   
    };

static int _DkPersistentSighandlerSetup (int event_num)
{
    int nsigs, * sigs = on_signals[event_num].signum;
    for (nsigs = 0 ; sigs[nsigs] ; nsigs++);
   14963:	31 f6                	xor    %esi,%esi
   14965:	eb db                	jmp    14942 <_DkPersistentEventUpcall+0x62>
   14967:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1496e:	00 00 

0000000000014970 <block_signals>:

    return 0;
}

int block_signals (int * sigs, int nsig)
{
   14970:	55                   	push   %rbp
    bool maskset = false;
    int ret = 0;
    _sigset_t mask;
    __sigemptyset(&mask);
    for (int i = 0 ; i < nsig ; i++)
   14971:	85 f6                	test   %esi,%esi

    return 0;
}

int block_signals (int * sigs, int nsig)
{
   14973:	48 89 e5             	mov    %rsp,%rbp
   14976:	53                   	push   %rbx
    bool maskset = false;
    int ret = 0;
    _sigset_t mask;
    __sigemptyset(&mask);
   14977:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
   1497e:	00 
    for (int i = 0 ; i < nsig ; i++)
   1497f:	0f 8e 9b 00 00 00    	jle    14a20 <block_signals+0xb0>
   14985:	83 ee 01             	sub    $0x1,%esi
   14988:	45 31 d2             	xor    %r10d,%r10d
    unsigned long int __word = __sigword (__sig);			      \
    return BODY;							      \
  }
#endif 

__SIGSETFN (__sigismember, (__set->__val[__word] & __mask) ? 1 : 0, __const)
   1498b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   14991:	4c 8d 4c b7 04       	lea    0x4(%rdi,%rsi,4),%r9
   14996:	48 8b 35 c3 ef 20 00 	mov    0x20efc3(%rip),%rsi        # 223960 <_DYNAMIC+0x178>
   1499d:	0f 1f 00             	nopl   (%rax)
   149a0:	8b 07                	mov    (%rdi),%eax
   149a2:	4c 89 c2             	mov    %r8,%rdx
   149a5:	8d 48 ff             	lea    -0x1(%rax),%ecx
   149a8:	48 d3 e2             	shl    %cl,%rdx
   149ab:	48 63 c9             	movslq %ecx,%rcx
   149ae:	48 c1 e9 06          	shr    $0x6,%rcx
   149b2:	48 8b 44 ce 10       	mov    0x10(%rsi,%rcx,8),%rax
        if (!__sigismember(&pal_linux_config.sigset, sigs[i])) {
   149b7:	48 85 d0             	test   %rdx,%rax
   149ba:	75 13                	jne    149cf <block_signals+0x5f>
__SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), )
   149bc:	48 09 54 cd e0       	or     %rdx,-0x20(%rbp,%rcx,8)
            __sigaddset(&pal_linux_config.sigset, sigs[i]);
            __sigaddset(&mask, sigs[i]);
            maskset = true;
   149c1:	48 09 d0             	or     %rdx,%rax
   149c4:	41 ba 01 00 00 00    	mov    $0x1,%r10d
   149ca:	48 89 44 ce 10       	mov    %rax,0x10(%rsi,%rcx,8)
   149cf:	48 83 c7 04          	add    $0x4,%rdi
{
    bool maskset = false;
    int ret = 0;
    _sigset_t mask;
    __sigemptyset(&mask);
    for (int i = 0 ; i < nsig ; i++)
   149d3:	4c 39 cf             	cmp    %r9,%rdi
   149d6:	75 c8                	jne    149a0 <block_signals+0x30>
            __sigaddset(&pal_linux_config.sigset, sigs[i]);
            __sigaddset(&mask, sigs[i]);
            maskset = true;
        }

    if (maskset) {
   149d8:	45 84 d2             	test   %r10b,%r10b
   149db:	74 43                	je     14a20 <block_signals+0xb0>
#if defined(__i386__)
        ret = INLINE_SYSCALL(sigprocmask, 3, SIG_BLOCK, &mask, NULL)
#else
        ret = INLINE_SYSCALL(sigprocmask, 4, SIG_BLOCK, &mask, NULL,
   149dd:	bb 54 01 00 00       	mov    $0x154,%ebx
   149e2:	b9 10 00 00 00       	mov    $0x10,%ecx
   149e7:	31 d2                	xor    %edx,%edx
   149e9:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
   149ed:	bf 01 00 00 00       	mov    $0x1,%edi
   149f2:	89 d8                	mov    %ebx,%eax
   149f4:	cd 80                	int    $0x80
   149f6:	48 89 c1             	mov    %rax,%rcx
   149f9:	bb 00 00 00 00       	mov    $0x0,%ebx
   149fe:	83 d3 00             	adc    $0x0,%ebx
   14a01:	31 d2                	xor    %edx,%edx
   14a03:	85 db                	test   %ebx,%ebx
   14a05:	0f 95 c2             	setne  %dl
   14a08:	48 89 d0             	mov    %rdx,%rax
   14a0b:	48 f7 d8             	neg    %rax
   14a0e:	48 31 c8             	xor    %rcx,%rax
   14a11:	48 01 d0             	add    %rdx,%rax
    }

    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
   14a14:	c1 f8 1f             	sar    $0x1f,%eax
}
   14a17:	83 e0 fa             	and    $0xfffffffffffffffa,%eax
   14a1a:	5b                   	pop    %rbx
   14a1b:	5d                   	pop    %rbp
   14a1c:	c3                   	retq   
   14a1d:	0f 1f 00             	nopl   (%rax)
    }

    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
   14a20:	31 c0                	xor    %eax,%eax
}
   14a22:	5b                   	pop    %rbx
   14a23:	5d                   	pop    %rbp
   14a24:	c3                   	retq   
   14a25:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
   14a2c:	00 00 00 00 

0000000000014a30 <_DkGenericEventUpcall>:
    return _DkPersistentSighandlerSetup(event_num);
}

static int _DkGenericEventUpcall (int event_num, PAL_UPCALL upcall,
                                  int flags)
{
   14a30:	55                   	push   %rbp
    int nsigs, * sigs = on_signals[event_num].signum;
   14a31:	48 63 cf             	movslq %edi,%rcx
   14a34:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
    return _DkPersistentSighandlerSetup(event_num);
}

static int _DkGenericEventUpcall (int event_num, PAL_UPCALL upcall,
                                  int flags)
{
   14a38:	48 89 e5             	mov    %rsp,%rbp
   14a3b:	41 57                	push   %r15
   14a3d:	41 56                	push   %r14
   14a3f:	41 55                	push   %r13
   14a41:	41 54                	push   %r12
   14a43:	49 89 f4             	mov    %rsi,%r12
   14a46:	53                   	push   %rbx
   14a47:	48 83 ec 18          	sub    $0x18,%rsp
    int nsigs, * sigs = on_signals[event_num].signum;
   14a4b:	48 8b 35 6e ef 20 00 	mov    0x20ef6e(%rip),%rsi        # 2239c0 <_DYNAMIC+0x1d8>
   14a52:	4c 8d 34 c6          	lea    (%rsi,%rax,8),%r14
    for (nsigs = 0 ; sigs[nsigs] ; nsigs++);
   14a56:	45 8b 06             	mov    (%r14),%r8d
   14a59:	45 85 c0             	test   %r8d,%r8d
   14a5c:	74 7e                	je     14adc <_DkGenericEventUpcall+0xac>
   14a5e:	49 8d 46 04          	lea    0x4(%r14),%rax
   14a62:	31 db                	xor    %ebx,%ebx
   14a64:	48 83 c0 04          	add    $0x4,%rax
   14a68:	8b 78 fc             	mov    -0x4(%rax),%edi
   14a6b:	83 c3 01             	add    $0x1,%ebx
   14a6e:	85 ff                	test   %edi,%edi
   14a70:	75 f2                	jne    14a64 <_DkGenericEventUpcall+0x34>

    void * sighandler = on_signals[event_num].handler;
   14a72:	48 8d 04 49          	lea    (%rcx,%rcx,2),%rax
   14a76:	89 55 cc             	mov    %edx,-0x34(%rbp)
   14a79:	4c 8b 7c c6 10       	mov    0x10(%rsi,%rax,8),%r15
    struct handler * handler = pal_handlers[event_num];
   14a7e:	48 8b 05 83 f0 20 00 	mov    0x20f083(%rip),%rax        # 223b08 <_DYNAMIC+0x320>
   14a85:	4c 8b 2c c8          	mov    (%rax,%rcx,8),%r13
    int ret = 0;

    _DkMutexLock(&handler->lock);
   14a89:	4c 89 ef             	mov    %r13,%rdi
   14a8c:	e8 bf c1 ff ff       	callq  10c50 <_DkMutexLock>
    handler->upcall = upcall;
    handler->flags = flags;
   14a91:	8b 55 cc             	mov    -0x34(%rbp),%edx
    void * sighandler = on_signals[event_num].handler;
    struct handler * handler = pal_handlers[event_num];
    int ret = 0;

    _DkMutexLock(&handler->lock);
    handler->upcall = upcall;
   14a94:	4d 89 65 08          	mov    %r12,0x8(%r13)
    handler->flags = flags;
    _DkMutexUnlock(&handler->lock);
   14a98:	4c 89 ef             	mov    %r13,%rdi
    struct handler * handler = pal_handlers[event_num];
    int ret = 0;

    _DkMutexLock(&handler->lock);
    handler->upcall = upcall;
    handler->flags = flags;
   14a9b:	41 89 55 10          	mov    %edx,0x10(%r13)
    _DkMutexUnlock(&handler->lock);
   14a9f:	e8 1c c4 ff ff       	callq  10ec0 <_DkMutexUnlock>

    if (upcall)
   14aa4:	4d 85 e4             	test   %r12,%r12
   14aa7:	74 1b                	je     14ac4 <_DkGenericEventUpcall+0x94>
        ret = set_sighandler (sigs, nsigs, sighandler);
    else
        ret = block_signals (sigs, nsigs);

    return ret;
}
   14aa9:	48 83 c4 18          	add    $0x18,%rsp
    handler->upcall = upcall;
    handler->flags = flags;
    _DkMutexUnlock(&handler->lock);

    if (upcall)
        ret = set_sighandler (sigs, nsigs, sighandler);
   14aad:	4c 89 fa             	mov    %r15,%rdx
   14ab0:	89 de                	mov    %ebx,%esi
   14ab2:	4c 89 f7             	mov    %r14,%rdi
    else
        ret = block_signals (sigs, nsigs);

    return ret;
}
   14ab5:	5b                   	pop    %rbx
   14ab6:	41 5c                	pop    %r12
   14ab8:	41 5d                	pop    %r13
   14aba:	41 5e                	pop    %r14
   14abc:	41 5f                	pop    %r15
   14abe:	5d                   	pop    %rbp
    handler->upcall = upcall;
    handler->flags = flags;
    _DkMutexUnlock(&handler->lock);

    if (upcall)
        ret = set_sighandler (sigs, nsigs, sighandler);
   14abf:	e9 cc fc ff ff       	jmpq   14790 <set_sighandler>
    else
        ret = block_signals (sigs, nsigs);

    return ret;
}
   14ac4:	48 83 c4 18          	add    $0x18,%rsp
    _DkMutexUnlock(&handler->lock);

    if (upcall)
        ret = set_sighandler (sigs, nsigs, sighandler);
    else
        ret = block_signals (sigs, nsigs);
   14ac8:	89 de                	mov    %ebx,%esi
   14aca:	4c 89 f7             	mov    %r14,%rdi

    return ret;
}
   14acd:	5b                   	pop    %rbx
   14ace:	41 5c                	pop    %r12
   14ad0:	41 5d                	pop    %r13
   14ad2:	41 5e                	pop    %r14
   14ad4:	41 5f                	pop    %r15
   14ad6:	5d                   	pop    %rbp
    _DkMutexUnlock(&handler->lock);

    if (upcall)
        ret = set_sighandler (sigs, nsigs, sighandler);
    else
        ret = block_signals (sigs, nsigs);
   14ad7:	e9 94 fe ff ff       	jmpq   14970 <block_signals>

static int _DkGenericEventUpcall (int event_num, PAL_UPCALL upcall,
                                  int flags)
{
    int nsigs, * sigs = on_signals[event_num].signum;
    for (nsigs = 0 ; sigs[nsigs] ; nsigs++);
   14adc:	31 db                	xor    %ebx,%ebx
   14ade:	eb 92                	jmp    14a72 <_DkGenericEventUpcall+0x42>

0000000000014ae0 <unblock_signals>:

    return 0;
}

int unblock_signals (int * sigs, int nsig)
{
   14ae0:	55                   	push   %rbp
    bool maskset = false;
    int ret = 0;
    _sigset_t mask;
    __sigemptyset(&mask);
    for (int i = 0 ; i < nsig ; i++)
   14ae1:	85 f6                	test   %esi,%esi

    return 0;
}

int unblock_signals (int * sigs, int nsig)
{
   14ae3:	48 89 e5             	mov    %rsp,%rbp
   14ae6:	53                   	push   %rbx
    bool maskset = false;
    int ret = 0;
    _sigset_t mask;
    __sigemptyset(&mask);
   14ae7:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
   14aee:	00 
    for (int i = 0 ; i < nsig ; i++)
   14aef:	0f 8e 9e 00 00 00    	jle    14b93 <unblock_signals+0xb3>
   14af5:	83 ee 01             	sub    $0x1,%esi
   14af8:	45 31 d2             	xor    %r10d,%r10d
    unsigned long int __word = __sigword (__sig);			      \
    return BODY;							      \
  }
#endif 

__SIGSETFN (__sigismember, (__set->__val[__word] & __mask) ? 1 : 0, __const)
   14afb:	41 b8 01 00 00 00    	mov    $0x1,%r8d
   14b01:	4c 8d 4c b7 04       	lea    0x4(%rdi,%rsi,4),%r9
   14b06:	48 8b 35 53 ee 20 00 	mov    0x20ee53(%rip),%rsi        # 223960 <_DYNAMIC+0x178>
   14b0d:	0f 1f 00             	nopl   (%rax)
   14b10:	8b 07                	mov    (%rdi),%eax
   14b12:	4c 89 c2             	mov    %r8,%rdx
   14b15:	8d 48 ff             	lea    -0x1(%rax),%ecx
   14b18:	48 d3 e2             	shl    %cl,%rdx
   14b1b:	48 63 c9             	movslq %ecx,%rcx
   14b1e:	48 c1 e9 06          	shr    $0x6,%rcx
   14b22:	48 8b 44 ce 10       	mov    0x10(%rsi,%rcx,8),%rax
        if (__sigismember(&pal_linux_config.sigset, sigs[i])) {
   14b27:	48 85 d0             	test   %rdx,%rax
   14b2a:	74 19                	je     14b45 <unblock_signals+0x65>
__SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), )
__SIGSETFN (__sigdelset, ((__set->__val[__word] &= ~__mask), 0), )
   14b2c:	49 89 d2             	mov    %rdx,%r10
    return BODY;							      \
  }
#endif 

__SIGSETFN (__sigismember, (__set->__val[__word] & __mask) ? 1 : 0, __const)
__SIGSETFN (__sigaddset, ((__set->__val[__word] |= __mask), 0), )
   14b2f:	48 09 54 cd e0       	or     %rdx,-0x20(%rbp,%rcx,8)
__SIGSETFN (__sigdelset, ((__set->__val[__word] &= ~__mask), 0), )
   14b34:	49 f7 d2             	not    %r10
   14b37:	4c 21 d0             	and    %r10,%rax
            __sigdelset(&pal_linux_config.sigset, sigs[i]);
            __sigaddset(&mask, sigs[i]);
            maskset = true;
   14b3a:	41 ba 01 00 00 00    	mov    $0x1,%r10d
   14b40:	48 89 44 ce 10       	mov    %rax,0x10(%rsi,%rcx,8)
   14b45:	48 83 c7 04          	add    $0x4,%rdi
{
    bool maskset = false;
    int ret = 0;
    _sigset_t mask;
    __sigemptyset(&mask);
    for (int i = 0 ; i < nsig ; i++)
   14b49:	4c 39 cf             	cmp    %r9,%rdi
   14b4c:	75 c2                	jne    14b10 <unblock_signals+0x30>
            __sigdelset(&pal_linux_config.sigset, sigs[i]);
            __sigaddset(&mask, sigs[i]);
            maskset = true;
        }

    if (maskset) {
   14b4e:	45 84 d2             	test   %r10b,%r10b
   14b51:	74 40                	je     14b93 <unblock_signals+0xb3>
#if defined(__i386__)
        ret = INLINE_SYSCALL(sigprocmask, 3, SIG_UNBLOCK, &mask, NULL)
#else
        ret = INLINE_SYSCALL(sigprocmask, 4, SIG_UNBLOCK, &mask, NULL,
   14b53:	bb 54 01 00 00       	mov    $0x154,%ebx
   14b58:	b9 10 00 00 00       	mov    $0x10,%ecx
   14b5d:	31 d2                	xor    %edx,%edx
   14b5f:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
   14b63:	bf 02 00 00 00       	mov    $0x2,%edi
   14b68:	89 d8                	mov    %ebx,%eax
   14b6a:	cd 80                	int    $0x80
   14b6c:	48 89 c1             	mov    %rax,%rcx
   14b6f:	bb 00 00 00 00       	mov    $0x0,%ebx
   14b74:	83 d3 00             	adc    $0x0,%ebx
   14b77:	31 d2                	xor    %edx,%edx
   14b79:	85 db                	test   %ebx,%ebx
   14b7b:	0f 95 c2             	setne  %dl
   14b7e:	48 89 d0             	mov    %rdx,%rax
   14b81:	48 f7 d8             	neg    %rax
   14b84:	48 31 c8             	xor    %rcx,%rax
   14b87:	48 01 d0             	add    %rdx,%rax
    }

    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
   14b8a:	c1 f8 1f             	sar    $0x1f,%eax
}
   14b8d:	83 e0 fa             	and    $0xfffffffffffffffa,%eax
   14b90:	5b                   	pop    %rbx
   14b91:	5d                   	pop    %rbp
   14b92:	c3                   	retq   
    }

    if (IS_ERR(ret))
        return -PAL_ERROR_DENIED;

    return 0;
   14b93:	31 c0                	xor    %eax,%eax
}
   14b95:	5b                   	pop    %rbx
   14b96:	5d                   	pop    %rbp
   14b97:	c3                   	retq   
   14b98:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   14b9f:	00 

0000000000014ba0 <unset_sighandler>:

int unset_sighandler (int * sigs, int nsig)
{
   14ba0:	85 f6                	test   %esi,%esi
   14ba2:	41 89 f1             	mov    %esi,%r9d
    for (int i = 0 ; i < nsig ; i++) {
   14ba5:	0f 8e 9d 00 00 00    	jle    14c48 <unset_sighandler+0xa8>

    return 0;
}

int unset_sighandler (int * sigs, int nsig)
{
   14bab:	55                   	push   %rbp
   14bac:	49 89 fa             	mov    %rdi,%r10
    for (int i = 0 ; i < nsig ; i++) {
#if defined(__i386__)
        int ret = INLINE_SYSCALL(sigaction, 4, sigs[i], SIG_DFL, NULL)
#else
        int ret = INLINE_SYSCALL(sigaction, 4, sigs[i], SIG_DFL, NULL,
   14baf:	b9 08 00 00 00       	mov    $0x8,%ecx
   14bb4:	31 d2                	xor    %edx,%edx
   14bb6:	31 f6                	xor    %esi,%esi

    return 0;
}

int unset_sighandler (int * sigs, int nsig)
{
   14bb8:	48 89 e5             	mov    %rsp,%rbp
   14bbb:	53                   	push   %rbx
    for (int i = 0 ; i < nsig ; i++) {
#if defined(__i386__)
        int ret = INLINE_SYSCALL(sigaction, 4, sigs[i], SIG_DFL, NULL)
#else
        int ret = INLINE_SYSCALL(sigaction, 4, sigs[i], SIG_DFL, NULL,
   14bbc:	bb a0 01 00 00       	mov    $0x1a0,%ebx
   14bc1:	48 63 3f             	movslq (%rdi),%rdi
   14bc4:	89 d8                	mov    %ebx,%eax
   14bc6:	cd 80                	int    $0x80
   14bc8:	48 89 c2             	mov    %rax,%rdx
   14bcb:	bb 00 00 00 00       	mov    $0x0,%ebx
   14bd0:	83 d3 00             	adc    $0x0,%ebx
   14bd3:	31 c9                	xor    %ecx,%ecx
   14bd5:	85 db                	test   %ebx,%ebx
   14bd7:	0f 95 c1             	setne  %cl
   14bda:	48 89 c8             	mov    %rcx,%rax
   14bdd:	48 f7 d8             	neg    %rax
   14be0:	48 31 d0             	xor    %rdx,%rax
                                 sizeof(_sigset_t));
#endif
        if (IS_ERR(ret))
   14be3:	01 c8                	add    %ecx,%eax
   14be5:	78 59                	js     14c40 <unset_sighandler+0xa0>
   14be7:	41 83 e9 01          	sub    $0x1,%r9d
   14beb:	4d 8d 42 04          	lea    0x4(%r10),%r8
   14bef:	4f 8d 4c 8a 04       	lea    0x4(%r10,%r9,4),%r9
{
    for (int i = 0 ; i < nsig ; i++) {
#if defined(__i386__)
        int ret = INLINE_SYSCALL(sigaction, 4, sigs[i], SIG_DFL, NULL)
#else
        int ret = INLINE_SYSCALL(sigaction, 4, sigs[i], SIG_DFL, NULL,
   14bf4:	41 ba a0 01 00 00    	mov    $0x1a0,%r10d
   14bfa:	eb 3a                	jmp    14c36 <unset_sighandler+0x96>
   14bfc:	0f 1f 40 00          	nopl   0x0(%rax)
   14c00:	49 63 38             	movslq (%r8),%rdi
   14c03:	b9 08 00 00 00       	mov    $0x8,%ecx
   14c08:	31 d2                	xor    %edx,%edx
   14c0a:	31 f6                	xor    %esi,%esi
   14c0c:	44 89 d0             	mov    %r10d,%eax
   14c0f:	cd 80                	int    $0x80
   14c11:	48 89 c2             	mov    %rax,%rdx
   14c14:	bb 00 00 00 00       	mov    $0x0,%ebx
   14c19:	83 d3 00             	adc    $0x0,%ebx
   14c1c:	31 c9                	xor    %ecx,%ecx
   14c1e:	85 db                	test   %ebx,%ebx
   14c20:	0f 95 c1             	setne  %cl
   14c23:	49 83 c0 04          	add    $0x4,%r8
   14c27:	48 89 ce             	mov    %rcx,%rsi
   14c2a:	48 f7 de             	neg    %rsi
   14c2d:	48 31 f2             	xor    %rsi,%rdx
                                 sizeof(_sigset_t));
#endif
        if (IS_ERR(ret))
   14c30:	89 d0                	mov    %edx,%eax
   14c32:	01 c8                	add    %ecx,%eax
   14c34:	78 0a                	js     14c40 <unset_sighandler+0xa0>
    return 0;
}

int unset_sighandler (int * sigs, int nsig)
{
    for (int i = 0 ; i < nsig ; i++) {
   14c36:	4d 39 c8             	cmp    %r9,%r8
   14c39:	75 c5                	jne    14c00 <unset_sighandler+0x60>
                                 sizeof(_sigset_t));
#endif
        if (IS_ERR(ret))
            return -PAL_ERROR_DENIED;
    }
    return 0;
   14c3b:	31 c0                	xor    %eax,%eax
}
   14c3d:	5b                   	pop    %rbx
   14c3e:	5d                   	pop    %rbp
   14c3f:	c3                   	retq   
#else
        int ret = INLINE_SYSCALL(sigaction, 4, sigs[i], SIG_DFL, NULL,
                                 sizeof(_sigset_t));
#endif
        if (IS_ERR(ret))
            return -PAL_ERROR_DENIED;
   14c40:	b8 fa ff ff ff       	mov    $0xfffffffa,%eax
    }
    return 0;
}
   14c45:	5b                   	pop    %rbx
   14c46:	5d                   	pop    %rbp
   14c47:	c3                   	retq   
                                 sizeof(_sigset_t));
#endif
        if (IS_ERR(ret))
            return -PAL_ERROR_DENIED;
    }
    return 0;
   14c48:	31 c0                	xor    %eax,%eax
}
   14c4a:	c3                   	retq   
   14c4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000014c50 <_DkGenericEventTrigger>:
    }
}

void _DkGenericEventTrigger (int event_num, PAL_UPCALL upcall, int flags,
                             PAL_NUM arg, struct pal_frame * frame)
{
   14c50:	55                   	push   %rbp
   14c51:	48 89 f0             	mov    %rsi,%rax
   14c54:	48 89 e5             	mov    %rsp,%rbp
   14c57:	48 83 ec 20          	sub    $0x20,%rsp
    struct event event;

    event.event_num = event_num;
    event.instance = pal_sec_info.domain_id;
   14c5b:	48 8b 35 46 ee 20 00 	mov    0x20ee46(%rip),%rsi        # 223aa8 <_DYNAMIC+0x2c0>
    event.flags = flags;
    event.frame = frame;

    (*upcall) (&event, arg, frame ? frame->context : NULL);
   14c62:	4d 85 c0             	test   %r8,%r8
void _DkGenericEventTrigger (int event_num, PAL_UPCALL upcall, int flags,
                             PAL_NUM arg, struct pal_frame * frame)
{
    struct event event;

    event.event_num = event_num;
   14c65:	89 7d e8             	mov    %edi,-0x18(%rbp)
    event.instance = pal_sec_info.domain_id;
    event.flags = flags;
   14c68:	89 55 ec             	mov    %edx,-0x14(%rbp)
    event.frame = frame;
   14c6b:	4c 89 45 f0          	mov    %r8,-0x10(%rbp)
                             PAL_NUM arg, struct pal_frame * frame)
{
    struct event event;

    event.event_num = event_num;
    event.instance = pal_sec_info.domain_id;
   14c6f:	8b 76 08             	mov    0x8(%rsi),%esi
   14c72:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
    event.flags = flags;
    event.frame = frame;

    (*upcall) (&event, arg, frame ? frame->context : NULL);
   14c76:	74 18                	je     14c90 <_DkGenericEventTrigger+0x40>
   14c78:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
   14c7c:	49 8b 50 60          	mov    0x60(%r8),%rdx
   14c80:	48 89 ce             	mov    %rcx,%rsi
   14c83:	ff d0                	callq  *%rax
}
   14c85:	c9                   	leaveq 
   14c86:	c3                   	retq   
   14c87:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   14c8e:	00 00 
    event.event_num = event_num;
    event.instance = pal_sec_info.domain_id;
    event.flags = flags;
    event.frame = frame;

    (*upcall) (&event, arg, frame ? frame->context : NULL);
   14c90:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
   14c94:	31 d2                	xor    %edx,%edx
   14c96:	48 89 ce             	mov    %rcx,%rsi
   14c99:	ff d0                	callq  *%rax
}
   14c9b:	c9                   	leaveq 
   14c9c:	c3                   	retq   
   14c9d:	0f 1f 00             	nopl   (%rax)

0000000000014ca0 <_DkGenericSignalHandle>:

static bool _DkGenericSignalHandle (int event_num, siginfo_t * info,
                                    struct pal_frame * frame)
{
   14ca0:	55                   	push   %rbp
   14ca1:	48 63 cf             	movslq %edi,%rcx
   14ca4:	48 89 e5             	mov    %rsp,%rbp
   14ca7:	41 57                	push   %r15
   14ca9:	41 56                	push   %r14
   14cab:	41 55                	push   %r13
   14cad:	41 54                	push   %r12
   14caf:	49 89 f6             	mov    %rsi,%r14
   14cb2:	53                   	push   %rbx
   14cb3:	49 89 cc             	mov    %rcx,%r12
   14cb6:	49 89 d7             	mov    %rdx,%r15
   14cb9:	48 83 ec 18          	sub    $0x18,%rsp
    struct handler * handler = pal_handlers[event_num];
   14cbd:	48 8b 05 44 ee 20 00 	mov    0x20ee44(%rip),%rax        # 223b08 <_DYNAMIC+0x320>
   14cc4:	48 8b 1c c8          	mov    (%rax,%rcx,8),%rbx

    _DkMutexLock(&handler->lock);
   14cc8:	48 89 df             	mov    %rbx,%rdi
   14ccb:	e8 80 bf ff ff       	callq  10c50 <_DkMutexLock>
    PAL_UPCALL upcall = handler->upcall;
   14cd0:	4c 8b 6b 08          	mov    0x8(%rbx),%r13
    int flags = handler->flags;
   14cd4:	8b 53 10             	mov    0x10(%rbx),%edx
    _DkMutexUnlock(&handler->lock);
   14cd7:	48 89 df             	mov    %rbx,%rdi
{
    struct handler * handler = pal_handlers[event_num];

    _DkMutexLock(&handler->lock);
    PAL_UPCALL upcall = handler->upcall;
    int flags = handler->flags;
   14cda:	89 55 cc             	mov    %edx,-0x34(%rbp)
    _DkMutexUnlock(&handler->lock);
   14cdd:	e8 de c1 ff ff       	callq  10ec0 <_DkMutexUnlock>

    PAL_NUM arg = 0;

    if (upcall) {
   14ce2:	4d 85 ed             	test   %r13,%r13
   14ce5:	74 3d                	je     14d24 <_DkGenericSignalHandle+0x84>
        if (event_num == PAL_EVENT_DIVZERO ||
            event_num == PAL_EVENT_MEMFAULT ||
   14ce7:	41 8d 44 24 ff       	lea    -0x1(%r12),%eax
            event_num == PAL_EVENT_ILLEGAL)
            arg = (PAL_NUM) (info ? info->si_addr : 0);
   14cec:	8b 55 cc             	mov    -0x34(%rbp),%edx
   14cef:	83 f8 02             	cmp    $0x2,%eax
   14cf2:	77 2c                	ja     14d20 <_DkGenericSignalHandle+0x80>
   14cf4:	4d 85 f6             	test   %r14,%r14
   14cf7:	74 27                	je     14d20 <_DkGenericSignalHandle+0x80>
   14cf9:	49 8b 4e 18          	mov    0x18(%r14),%rcx

        _DkGenericEventTrigger(event_num, upcall, flags, arg, frame);
   14cfd:	4d 89 f8             	mov    %r15,%r8
   14d00:	4c 89 ee             	mov    %r13,%rsi
   14d03:	44 89 e7             	mov    %r12d,%edi
   14d06:	e8 45 ff ff ff       	callq  14c50 <_DkGenericEventTrigger>
        return true;
    }

    return false;
}
   14d0b:	48 83 c4 18          	add    $0x18,%rsp
            event_num == PAL_EVENT_MEMFAULT ||
            event_num == PAL_EVENT_ILLEGAL)
            arg = (PAL_NUM) (info ? info->si_addr : 0);

        _DkGenericEventTrigger(event_num, upcall, flags, arg, frame);
        return true;
   14d0f:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    return false;
}
   14d14:	5b                   	pop    %rbx
   14d15:	41 5c                	pop    %r12
   14d17:	41 5d                	pop    %r13
   14d19:	41 5e                	pop    %r14
   14d1b:	41 5f                	pop    %r15
   14d1d:	5d                   	pop    %rbp
   14d1e:	c3                   	retq   
   14d1f:	90                   	nop    

    if (upcall) {
        if (event_num == PAL_EVENT_DIVZERO ||
            event_num == PAL_EVENT_MEMFAULT ||
            event_num == PAL_EVENT_ILLEGAL)
            arg = (PAL_NUM) (info ? info->si_addr : 0);
   14d20:	31 c9                	xor    %ecx,%ecx
   14d22:	eb d9                	jmp    14cfd <_DkGenericSignalHandle+0x5d>
        _DkGenericEventTrigger(event_num, upcall, flags, arg, frame);
        return true;
    }

    return false;
}
   14d24:	48 83 c4 18          	add    $0x18,%rsp

        _DkGenericEventTrigger(event_num, upcall, flags, arg, frame);
        return true;
    }

    return false;
   14d28:	31 c0                	xor    %eax,%eax
}
   14d2a:	5b                   	pop    %rbx
   14d2b:	41 5c                	pop    %r12
   14d2d:	41 5d                	pop    %r13
   14d2f:	41 5e                	pop    %r14
   14d31:	41 5f                	pop    %r15
   14d33:	5d                   	pop    %rbp
   14d34:	c3                   	retq   
   14d35:	66 66 2e 0f 1f 84 00 	nopw   %cs:0x0(%rax,%rax,1)
   14d3c:	00 00 00 00 

0000000000014d40 <_DkTerminateSighandler>:
    _DkGenericSignalHandle(event_num, info, frame);
}

static void _DkTerminateSighandler (int signum, siginfo_t * info,
                                    struct ucontext * uc)
{
   14d40:	55                   	push   %rbp
   14d41:	48 89 e5             	mov    %rsp,%rbp
   14d44:	41 55                	push   %r13
   14d46:	41 54                	push   %r12
   14d48:	53                   	push   %rbx
   14d49:	41 89 fc             	mov    %edi,%r12d
   14d4c:	48 89 d3             	mov    %rdx,%rbx
   14d4f:	48 83 ec 08          	sub    $0x8,%rsp
    struct pal_frame * frame = get_frame(uc);
   14d53:	48 8b b2 a8 00 00 00 	mov    0xa8(%rdx),%rsi
   14d5a:	48 8b 7a 78          	mov    0x78(%rdx),%rdi
   14d5e:	e8 cd f9 ff ff       	callq  14730 <get_frame.isra.0>

    if (!frame) {
   14d63:	48 85 c0             	test   %rax,%rax
}

static void _DkTerminateSighandler (int signum, siginfo_t * info,
                                    struct ucontext * uc)
{
    struct pal_frame * frame = get_frame(uc);
   14d66:	49 89 c5             	mov    %rax,%r13

    if (!frame) {
   14d69:	74 67                	je     14dd2 <_DkTerminateSighandler+0x92>
        frame->retval   = NULL;
        arch_store_frame(&frame->arch);
    }

    if (uc) {
        frame->context = __alloca(sizeof(PAL_CONTEXT));
   14d6b:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
        memcpy(frame->context, uc->uc_mcontext.gregs, sizeof(PAL_CONTEXT));
   14d72:	48 8d 73 28          	lea    0x28(%rbx),%rsi
   14d76:	ba b8 00 00 00       	mov    $0xb8,%edx
        frame->retval   = NULL;
        arch_store_frame(&frame->arch);
    }

    if (uc) {
        frame->context = __alloca(sizeof(PAL_CONTEXT));
   14d7b:	48 8d 7c 24 0f       	lea    0xf(%rsp),%rdi
   14d80:	48 83 e7 f0          	and    $0xfffffffffffffff0,%rdi
   14d84:	49 89 7d 60          	mov    %rdi,0x60(%r13)
        memcpy(frame->context, uc->uc_mcontext.gregs, sizeof(PAL_CONTEXT));
   14d88:	e8 f3 14 00 00       	callq  16280 <memcpy>
   14d8d:	41 8d 7c 24 fe       	lea    -0x2(%r12),%edi
   14d92:	83 ff 11             	cmp    $0x11,%edi
   14d95:	77 1d                	ja     14db4 <_DkTerminateSighandler+0x74>
   14d97:	48 8d 05 a2 a0 00 00 	lea    0xa0a2(%rip),%rax        # 1ee40 <CSWTCH.16>
   14d9e:	8b 3c b8             	mov    (%rax,%rdi,4),%edi
    } else {
        frame->context = NULL;
    }

    int event_num = get_event_num(signum);
    if (event_num == -1)
   14da1:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   14da4:	74 0e                	je     14db4 <_DkTerminateSighandler+0x74>
        return;

    if (!_DkGenericSignalHandle(event_num, NULL, frame))
   14da6:	31 f6                	xor    %esi,%esi
   14da8:	4c 89 ea             	mov    %r13,%rdx
   14dab:	e8 f0 fe ff ff       	callq  14ca0 <_DkGenericSignalHandle>
   14db0:	84 c0                	test   %al,%al
   14db2:	74 0c                	je     14dc0 <_DkTerminateSighandler+0x80>
        _DkThreadExit(0);
}
   14db4:	48 8d 65 e8          	lea    -0x18(%rbp),%rsp
   14db8:	5b                   	pop    %rbx
   14db9:	41 5c                	pop    %r12
   14dbb:	41 5d                	pop    %r13
   14dbd:	5d                   	pop    %rbp
   14dbe:	c3                   	retq   
   14dbf:	90                   	nop    
    int event_num = get_event_num(signum);
    if (event_num == -1)
        return;

    if (!_DkGenericSignalHandle(event_num, NULL, frame))
        _DkThreadExit(0);
   14dc0:	31 ff                	xor    %edi,%edi
   14dc2:	e8 e9 b8 ff ff       	callq  106b0 <_DkThreadExit>
}
   14dc7:	48 8d 65 e8          	lea    -0x18(%rbp),%rsp
   14dcb:	5b                   	pop    %rbx
   14dcc:	41 5c                	pop    %r12
   14dce:	41 5d                	pop    %r13
   14dd0:	5d                   	pop    %rbp
   14dd1:	c3                   	retq   
                                    struct ucontext * uc)
{
    struct pal_frame * frame = get_frame(uc);

    if (!frame) {
        frame = __alloca(sizeof(struct pal_frame));
   14dd2:	48 81 ec 80 00 00 00 	sub    $0x80,%rsp
        frame->self = frame;
        frame->func = &_DkTerminateSighandler;
   14dd9:	48 8d 05 60 ff ff ff 	lea    -0xa0(%rip),%rax        # 14d40 <_DkTerminateSighandler>
                                    struct ucontext * uc)
{
    struct pal_frame * frame = get_frame(uc);

    if (!frame) {
        frame = __alloca(sizeof(struct pal_frame));
   14de0:	4c 8d 6c 24 0f       	lea    0xf(%rsp),%r13
   14de5:	49 83 e5 f0          	and    $0xfffffffffffffff0,%r13
        frame->self = frame;
        frame->func = &_DkTerminateSighandler;
   14de9:	49 89 45 08          	mov    %rax,0x8(%r13)
        frame->funcname = "DkTerminateSighandler";
   14ded:	48 8d 05 12 a0 00 00 	lea    0xa012(%rip),%rax        # 1ee06 <slab_levels+0x5b66>
{
    struct pal_frame * frame = get_frame(uc);

    if (!frame) {
        frame = __alloca(sizeof(struct pal_frame));
        frame->self = frame;
   14df4:	4d 89 6d 00          	mov    %r13,0x0(%r13)
        frame->func = &_DkTerminateSighandler;
        frame->funcname = "DkTerminateSighandler";
        frame->context  = NULL;
   14df8:	49 c7 45 60 00 00 00 	movq   $0x0,0x60(%r13)
   14dff:	00 
        frame->retval   = NULL;
   14e00:	49 c7 45 68 00 00 00 	movq   $0x0,0x68(%r13)
   14e07:	00 

    if (!frame) {
        frame = __alloca(sizeof(struct pal_frame));
        frame->self = frame;
        frame->func = &_DkTerminateSighandler;
        frame->funcname = "DkTerminateSighandler";
   14e08:	49 89 45 10          	mov    %rax,0x10(%r13)
        frame->context  = NULL;
        frame->retval   = NULL;
        arch_store_frame(&frame->arch);
   14e0c:	48 89 e0             	mov    %rsp,%rax
   14e0f:	49 89 45 18          	mov    %rax,0x18(%r13)
   14e13:	48 89 e8             	mov    %rbp,%rax
   14e16:	49 89 45 20          	mov    %rax,0x20(%r13)
   14e1a:	48 89 d8             	mov    %rbx,%rax
   14e1d:	49 89 45 28          	mov    %rax,0x28(%r13)
   14e21:	48 89 f0             	mov    %rsi,%rax
   14e24:	49 89 45 30          	mov    %rax,0x30(%r13)
   14e28:	48 89 f8             	mov    %rdi,%rax
   14e2b:	49 89 45 38          	mov    %rax,0x38(%r13)
   14e2f:	4c 89 e0             	mov    %r12,%rax
   14e32:	49 89 45 40          	mov    %rax,0x40(%r13)
   14e36:	4c 89 e8             	mov    %r13,%rax
   14e39:	49 89 45 48          	mov    %rax,0x48(%r13)
   14e3d:	4c 89 f0             	mov    %r14,%rax
   14e40:	49 89 45 50          	mov    %rax,0x50(%r13)
   14e44:	4c 89 f8             	mov    %r15,%rax
   14e47:	49 89 45 58          	mov    %rax,0x58(%r13)
   14e4b:	e9 1b ff ff ff       	jmpq   14d6b <_DkTerminateSighandler+0x2b>

0000000000014e50 <notify_failure>:
    if (frame)
        return_frame(frame, PAL_ERROR_CONNFAILED);
}

void notify_failure (unsigned long error)
{
   14e50:	55                   	push   %rbp
   14e51:	48 89 e5             	mov    %rsp,%rbp
   14e54:	41 55                	push   %r13
   14e56:	41 54                	push   %r12
   14e58:	53                   	push   %rbx
   14e59:	49 89 fd             	mov    %rdi,%r13
    _DkMutexLock(&handler_Failure.lock);
   14e5c:	48 8d 3d ad f8 20 00 	lea    0x20f8ad(%rip),%rdi        # 224710 <handler_Failure>
    if (frame)
        return_frame(frame, PAL_ERROR_CONNFAILED);
}

void notify_failure (unsigned long error)
{
   14e63:	48 83 ec 08          	sub    $0x8,%rsp
    _DkMutexLock(&handler_Failure.lock);
   14e67:	e8 e4 bd ff ff       	callq  10c50 <_DkMutexLock>
    PAL_UPCALL upcall = handler_Failure.upcall;
   14e6c:	48 8b 1d a5 f8 20 00 	mov    0x20f8a5(%rip),%rbx        # 224718 <handler_Failure+0x8>
    int flags = handler_Failure.flags;
    _DkMutexUnlock(&handler_Failure.lock);
   14e73:	48 8d 3d 96 f8 20 00 	lea    0x20f896(%rip),%rdi        # 224710 <handler_Failure>

void notify_failure (unsigned long error)
{
    _DkMutexLock(&handler_Failure.lock);
    PAL_UPCALL upcall = handler_Failure.upcall;
    int flags = handler_Failure.flags;
   14e7a:	44 8b 25 9f f8 20 00 	mov    0x20f89f(%rip),%r12d        # 224720 <handler_Failure+0x10>
    _DkMutexUnlock(&handler_Failure.lock);
   14e81:	e8 3a c0 ff ff       	callq  10ec0 <_DkMutexUnlock>

    if (upcall)
   14e86:	48 85 db             	test   %rbx,%rbx
   14e89:	74 25                	je     14eb0 <notify_failure+0x60>
        _DkGenericEventTrigger(PAL_EVENT_FAILURE, upcall, flags,
                               error, NULL);
}
   14e8b:	48 83 c4 08          	add    $0x8,%rsp
    PAL_UPCALL upcall = handler_Failure.upcall;
    int flags = handler_Failure.flags;
    _DkMutexUnlock(&handler_Failure.lock);

    if (upcall)
        _DkGenericEventTrigger(PAL_EVENT_FAILURE, upcall, flags,
   14e8f:	4c 89 e9             	mov    %r13,%rcx
   14e92:	44 89 e2             	mov    %r12d,%edx
   14e95:	48 89 de             	mov    %rbx,%rsi
   14e98:	45 31 c0             	xor    %r8d,%r8d
   14e9b:	bf 07 00 00 00       	mov    $0x7,%edi
                               error, NULL);
}
   14ea0:	5b                   	pop    %rbx
   14ea1:	41 5c                	pop    %r12
   14ea3:	41 5d                	pop    %r13
   14ea5:	5d                   	pop    %rbp
    PAL_UPCALL upcall = handler_Failure.upcall;
    int flags = handler_Failure.flags;
    _DkMutexUnlock(&handler_Failure.lock);

    if (upcall)
        _DkGenericEventTrigger(PAL_EVENT_FAILURE, upcall, flags,
   14ea6:	e9 a5 fd ff ff       	jmpq   14c50 <_DkGenericEventTrigger>
   14eab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
                               error, NULL);
}
   14eb0:	48 83 c4 08          	add    $0x8,%rsp
   14eb4:	5b                   	pop    %rbx
   14eb5:	41 5c                	pop    %r12
   14eb7:	41 5d                	pop    %r13
   14eb9:	5d                   	pop    %rbp
   14eba:	c3                   	retq   
   14ebb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000014ec0 <return_frame>:

    return NULL;
}

static void return_frame (struct pal_frame * frame, int err)
{
   14ec0:	55                   	push   %rbp
   14ec1:	48 89 e5             	mov    %rsp,%rbp
   14ec4:	41 57                	push   %r15
   14ec6:	41 56                	push   %r14
   14ec8:	41 55                	push   %r13
   14eca:	41 54                	push   %r12
   14ecc:	53                   	push   %rbx
   14ecd:	48 83 ec 18          	sub    $0x18,%rsp
   14ed1:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    notify_failure(err);
   14ed5:	48 63 fe             	movslq %esi,%rdi
   14ed8:	e8 73 ff ff ff       	callq  14e50 <notify_failure>
    arch_restore_frame(&frame->arch);
   14edd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   14ee1:	4c 8b 78 58          	mov    0x58(%rax),%r15
   14ee5:	4c 8b 70 50          	mov    0x50(%rax),%r14
   14ee9:	4c 8b 68 48          	mov    0x48(%rax),%r13
   14eed:	4c 8b 60 40          	mov    0x40(%rax),%r12
   14ef1:	48 8b 78 38          	mov    0x38(%rax),%rdi
   14ef5:	48 8b 70 30          	mov    0x30(%rax),%rsi
   14ef9:	48 8b 58 28          	mov    0x28(%rax),%rbx
   14efd:	48 8b 68 20          	mov    0x20(%rax),%rbp
   14f01:	48 8b 60 18          	mov    0x18(%rax),%rsp
    asm volatile ("leaveq\r\n"
   14f05:	c9                   	leaveq 
   14f06:	c3                   	retq   
                  "retq\r\n"
                  ::: "memory");
}
   14f07:	48 83 c4 18          	add    $0x18,%rsp
   14f0b:	5b                   	pop    %rbx
   14f0c:	41 5c                	pop    %r12
   14f0e:	41 5d                	pop    %r13
   14f10:	41 5e                	pop    %r14
   14f12:	41 5f                	pop    %r15
   14f14:	5d                   	pop    %rbp
   14f15:	c3                   	retq   
   14f16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   14f1d:	00 00 00 

0000000000014f20 <_DkGenericSighandler>:

static void _DkGenericSighandler (int signum, siginfo_t * info,
                                  struct ucontext * uc)
{
   14f20:	55                   	push   %rbp
   14f21:	48 89 e5             	mov    %rsp,%rbp
   14f24:	41 56                	push   %r14
   14f26:	41 55                	push   %r13
   14f28:	49 89 f5             	mov    %rsi,%r13
   14f2b:	41 54                	push   %r12
   14f2d:	53                   	push   %rbx
   14f2e:	89 fb                	mov    %edi,%ebx
        bool go = false;
        while (!go);
    }
#endif

    struct pal_frame * frame = get_frame(uc);
   14f30:	48 8b b2 a8 00 00 00 	mov    0xa8(%rdx),%rsi
   14f37:	48 8b 7a 78          	mov    0x78(%rdx),%rdi
                  ::: "memory");
}

static void _DkGenericSighandler (int signum, siginfo_t * info,
                                  struct ucontext * uc)
{
   14f3b:	49 89 d6             	mov    %rdx,%r14
        bool go = false;
        while (!go);
    }
#endif

    struct pal_frame * frame = get_frame(uc);
   14f3e:	e8 ed f7 ff ff       	callq  14730 <get_frame.isra.0>

    if (frame && frame->func != &_DkGenericSighandler &&
   14f43:	48 85 c0             	test   %rax,%rax
        bool go = false;
        while (!go);
    }
#endif

    struct pal_frame * frame = get_frame(uc);
   14f46:	49 89 c4             	mov    %rax,%r12

    if (frame && frame->func != &_DkGenericSighandler &&
   14f49:	74 35                	je     14f80 <_DkGenericSighandler+0x60>
   14f4b:	48 8d 05 ce ff ff ff 	lea    -0x32(%rip),%rax        # 14f20 <_DkGenericSighandler>
   14f52:	49 39 44 24 08       	cmp    %rax,0x8(%r12)
   14f57:	74 27                	je     14f80 <_DkGenericSighandler+0x60>
        signum != SIGCONT &&
        signum != SIGINT  &&
   14f59:	83 fb 02             	cmp    $0x2,%ebx
   14f5c:	74 22                	je     14f80 <_DkGenericSighandler+0x60>
   14f5e:	8d 43 f1             	lea    -0xf(%rbx),%eax
   14f61:	83 e0 fb             	and    $0xfffffffffffffffb,%eax
   14f64:	74 1a                	je     14f80 <_DkGenericSighandler+0x60>
        signum != SIGTERM) {
        return_frame(frame, PAL_ERROR_BADADDR);
   14f66:	be 0f 00 00 00       	mov    $0xf,%esi
   14f6b:	4c 89 e7             	mov    %r12,%rdi
   14f6e:	e8 4d ff ff ff       	callq  14ec0 <return_frame>
    } else {
        frame->context = NULL;
    }

    _DkGenericSignalHandle(event_num, info, frame);
}
   14f73:	48 8d 65 e0          	lea    -0x20(%rbp),%rsp
   14f77:	5b                   	pop    %rbx
   14f78:	41 5c                	pop    %r12
   14f7a:	41 5d                	pop    %r13
   14f7c:	41 5e                	pop    %r14
   14f7e:	5d                   	pop    %rbp
   14f7f:	c3                   	retq   
   14f80:	83 eb 02             	sub    $0x2,%ebx
   14f83:	83 fb 11             	cmp    $0x11,%ebx
   14f86:	77 eb                	ja     14f73 <_DkGenericSighandler+0x53>
   14f88:	48 8d 05 b1 9e 00 00 	lea    0x9eb1(%rip),%rax        # 1ee40 <CSWTCH.16>
   14f8f:	8b 1c 98             	mov    (%rax,%rbx,4),%ebx
        return_frame(frame, PAL_ERROR_BADADDR);
        return;
    }

    int event_num = get_event_num(signum);
    if (event_num == -1)
   14f92:	83 fb ff             	cmp    $0xffffffffffffffff,%ebx
   14f95:	74 dc                	je     14f73 <_DkGenericSighandler+0x53>
        return;

    if (!frame) {
   14f97:	4d 85 e4             	test   %r12,%r12
   14f9a:	74 44                	je     14fe0 <_DkGenericSighandler+0xc0>
        frame->retval   = NULL;
        arch_store_frame(&frame->arch);
    }

    if (uc) {
        frame->context = __alloca(sizeof(PAL_CONTEXT));
   14f9c:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
        memcpy(frame->context, uc->uc_mcontext.gregs, sizeof(PAL_CONTEXT));
   14fa3:	49 8d 76 28          	lea    0x28(%r14),%rsi
   14fa7:	ba b8 00 00 00       	mov    $0xb8,%edx
        frame->retval   = NULL;
        arch_store_frame(&frame->arch);
    }

    if (uc) {
        frame->context = __alloca(sizeof(PAL_CONTEXT));
   14fac:	48 8d 7c 24 0f       	lea    0xf(%rsp),%rdi
   14fb1:	48 83 e7 f0          	and    $0xfffffffffffffff0,%rdi
   14fb5:	49 89 7c 24 60       	mov    %rdi,0x60(%r12)
        memcpy(frame->context, uc->uc_mcontext.gregs, sizeof(PAL_CONTEXT));
   14fba:	e8 c1 12 00 00       	callq  16280 <memcpy>
    } else {
        frame->context = NULL;
    }

    _DkGenericSignalHandle(event_num, info, frame);
   14fbf:	4c 89 e2             	mov    %r12,%rdx
   14fc2:	4c 89 ee             	mov    %r13,%rsi
   14fc5:	89 df                	mov    %ebx,%edi
   14fc7:	e8 d4 fc ff ff       	callq  14ca0 <_DkGenericSignalHandle>
}
   14fcc:	48 8d 65 e0          	lea    -0x20(%rbp),%rsp
   14fd0:	5b                   	pop    %rbx
   14fd1:	41 5c                	pop    %r12
   14fd3:	41 5d                	pop    %r13
   14fd5:	41 5e                	pop    %r14
   14fd7:	5d                   	pop    %rbp
   14fd8:	c3                   	retq   
   14fd9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    int event_num = get_event_num(signum);
    if (event_num == -1)
        return;

    if (!frame) {
        frame = __alloca(sizeof(struct pal_frame));
   14fe0:	48 81 ec 80 00 00 00 	sub    $0x80,%rsp
        frame->self     = frame;
        frame->func     = &_DkGenericSighandler;
   14fe7:	48 8d 05 32 ff ff ff 	lea    -0xce(%rip),%rax        # 14f20 <_DkGenericSighandler>
    int event_num = get_event_num(signum);
    if (event_num == -1)
        return;

    if (!frame) {
        frame = __alloca(sizeof(struct pal_frame));
   14fee:	4c 8d 64 24 0f       	lea    0xf(%rsp),%r12
   14ff3:	49 83 e4 f0          	and    $0xfffffffffffffff0,%r12
        frame->self     = frame;
        frame->func     = &_DkGenericSighandler;
   14ff7:	49 89 44 24 08       	mov    %rax,0x8(%r12)
        frame->funcname = "DkGenericSighandler";
   14ffc:	48 8d 05 19 9e 00 00 	lea    0x9e19(%rip),%rax        # 1ee1c <slab_levels+0x5b7c>
    if (event_num == -1)
        return;

    if (!frame) {
        frame = __alloca(sizeof(struct pal_frame));
        frame->self     = frame;
   15003:	4d 89 24 24          	mov    %r12,(%r12)
        frame->func     = &_DkGenericSighandler;
        frame->funcname = "DkGenericSighandler";
        frame->context  = NULL;
   15007:	49 c7 44 24 60 00 00 	movq   $0x0,0x60(%r12)
   1500e:	00 00 
        frame->retval   = NULL;
   15010:	49 c7 44 24 68 00 00 	movq   $0x0,0x68(%r12)
   15017:	00 00 

    if (!frame) {
        frame = __alloca(sizeof(struct pal_frame));
        frame->self     = frame;
        frame->func     = &_DkGenericSighandler;
        frame->funcname = "DkGenericSighandler";
   15019:	49 89 44 24 10       	mov    %rax,0x10(%r12)
        frame->context  = NULL;
        frame->retval   = NULL;
        arch_store_frame(&frame->arch);
   1501e:	48 89 e0             	mov    %rsp,%rax
   15021:	49 89 44 24 18       	mov    %rax,0x18(%r12)
   15026:	48 89 e8             	mov    %rbp,%rax
   15029:	49 89 44 24 20       	mov    %rax,0x20(%r12)
   1502e:	48 89 d8             	mov    %rbx,%rax
   15031:	49 89 44 24 28       	mov    %rax,0x28(%r12)
   15036:	48 89 f0             	mov    %rsi,%rax
   15039:	49 89 44 24 30       	mov    %rax,0x30(%r12)
   1503e:	48 89 f8             	mov    %rdi,%rax
   15041:	49 89 44 24 38       	mov    %rax,0x38(%r12)
   15046:	4c 89 e0             	mov    %r12,%rax
   15049:	49 89 44 24 40       	mov    %rax,0x40(%r12)
   1504e:	4c 89 e8             	mov    %r13,%rax
   15051:	49 89 44 24 48       	mov    %rax,0x48(%r12)
   15056:	4c 89 f0             	mov    %r14,%rax
   15059:	49 89 44 24 50       	mov    %rax,0x50(%r12)
   1505e:	4c 89 f8             	mov    %r15,%rax
   15061:	49 89 44 24 58       	mov    %rax,0x58(%r12)
   15066:	e9 31 ff ff ff       	jmpq   14f9c <_DkGenericSighandler+0x7c>
   1506b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000015070 <_DkPipeSighandler>:
        _DkThreadExit(0);
}

static void _DkPipeSighandler (int signum, siginfo_t * info,
                               struct ucontext * uc)
{
   15070:	55                   	push   %rbp
    struct pal_frame * frame = get_frame(uc);
   15071:	48 8b b2 a8 00 00 00 	mov    0xa8(%rdx),%rsi
   15078:	48 8b 7a 78          	mov    0x78(%rdx),%rdi
        _DkThreadExit(0);
}

static void _DkPipeSighandler (int signum, siginfo_t * info,
                               struct ucontext * uc)
{
   1507c:	48 89 e5             	mov    %rsp,%rbp
    struct pal_frame * frame = get_frame(uc);
   1507f:	e8 ac f6 ff ff       	callq  14730 <get_frame.isra.0>
    if (frame)
   15084:	48 85 c0             	test   %rax,%rax
   15087:	74 17                	je     150a0 <_DkPipeSighandler+0x30>
        return_frame(frame, PAL_ERROR_CONNFAILED);
}
   15089:	5d                   	pop    %rbp
static void _DkPipeSighandler (int signum, siginfo_t * info,
                               struct ucontext * uc)
{
    struct pal_frame * frame = get_frame(uc);
    if (frame)
        return_frame(frame, PAL_ERROR_CONNFAILED);
   1508a:	be 18 00 00 00       	mov    $0x18,%esi
   1508f:	48 89 c7             	mov    %rax,%rdi
   15092:	e9 29 fe ff ff       	jmpq   14ec0 <return_frame>
   15097:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1509e:	00 00 
}
   150a0:	5d                   	pop    %rbp
   150a1:	c3                   	retq   
   150a2:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
   150a9:	1f 84 00 00 00 00 00 

00000000000150b0 <signal_setup>:
                    "r" (uc->uc_mcontext.gregs[REG_R9])
                  : "memory", "r10", "r8", "r9");
}

int signal_setup (void)
{
   150b0:	55                   	push   %rbp
    int ret, sig;
    __sigemptyset(&pal_linux_config.sigset);

    if ((ret = _DkPersistentEventUpcall(PAL_EVENT_DIVZERO,  NULL, 0)) < 0)
   150b1:	31 d2                	xor    %edx,%edx
   150b3:	31 f6                	xor    %esi,%esi
   150b5:	bf 01 00 00 00       	mov    $0x1,%edi
                    "r" (uc->uc_mcontext.gregs[REG_R9])
                  : "memory", "r10", "r8", "r9");
}

int signal_setup (void)
{
   150ba:	48 89 e5             	mov    %rsp,%rbp
   150bd:	53                   	push   %rbx
   150be:	48 83 ec 18          	sub    $0x18,%rsp
    int ret, sig;
    __sigemptyset(&pal_linux_config.sigset);
   150c2:	48 8b 05 97 e8 20 00 	mov    0x20e897(%rip),%rax        # 223960 <_DYNAMIC+0x178>
   150c9:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
   150d0:	00 

    if ((ret = _DkPersistentEventUpcall(PAL_EVENT_DIVZERO,  NULL, 0)) < 0)
   150d1:	e8 0a f8 ff ff       	callq  148e0 <_DkPersistentEventUpcall>
   150d6:	85 c0                	test   %eax,%eax
   150d8:	78 76                	js     15150 <signal_setup+0xa0>
        goto err;

    if ((ret = _DkPersistentEventUpcall(PAL_EVENT_MEMFAULT,  NULL, 0)) < 0)
   150da:	31 d2                	xor    %edx,%edx
   150dc:	31 f6                	xor    %esi,%esi
   150de:	bf 02 00 00 00       	mov    $0x2,%edi
   150e3:	e8 f8 f7 ff ff       	callq  148e0 <_DkPersistentEventUpcall>
   150e8:	85 c0                	test   %eax,%eax
   150ea:	78 64                	js     15150 <signal_setup+0xa0>
        goto err;

    if ((ret = _DkPersistentEventUpcall(PAL_EVENT_ILLEGAL,  NULL, 0)) < 0)
   150ec:	31 d2                	xor    %edx,%edx
   150ee:	31 f6                	xor    %esi,%esi
   150f0:	bf 03 00 00 00       	mov    $0x3,%edi
   150f5:	e8 e6 f7 ff ff       	callq  148e0 <_DkPersistentEventUpcall>
   150fa:	85 c0                	test   %eax,%eax
   150fc:	78 52                	js     15150 <signal_setup+0xa0>
        goto err;

    sig = SIGPIPE;
    if ((ret = set_sighandler(&sig, 1, &_DkPipeSighandler)) < 0)
   150fe:	48 8d 5d ec          	lea    -0x14(%rbp),%rbx
   15102:	48 8d 15 67 ff ff ff 	lea    -0x99(%rip),%rdx        # 15070 <_DkPipeSighandler>
   15109:	be 01 00 00 00       	mov    $0x1,%esi
        goto err;

    if ((ret = _DkPersistentEventUpcall(PAL_EVENT_ILLEGAL,  NULL, 0)) < 0)
        goto err;

    sig = SIGPIPE;
   1510e:	c7 45 ec 0d 00 00 00 	movl   $0xd,-0x14(%rbp)
    if ((ret = set_sighandler(&sig, 1, &_DkPipeSighandler)) < 0)
   15115:	48 89 df             	mov    %rbx,%rdi
   15118:	e8 73 f6 ff ff       	callq  14790 <set_sighandler>
   1511d:	85 c0                	test   %eax,%eax
   1511f:	78 2f                	js     15150 <signal_setup+0xa0>
        goto err;

    sig = SIGSYS;
    if ((ret = set_sighandler(&sig, 1, &_DkCompatibilitySighandler)) < 0)
   15121:	48 8d 15 78 f5 ff ff 	lea    -0xa88(%rip),%rdx        # 146a0 <_DkCompatibilitySighandler>
   15128:	be 01 00 00 00       	mov    $0x1,%esi
   1512d:	48 89 df             	mov    %rbx,%rdi

    sig = SIGPIPE;
    if ((ret = set_sighandler(&sig, 1, &_DkPipeSighandler)) < 0)
        goto err;

    sig = SIGSYS;
   15130:	c7 45 ec 0c 00 00 00 	movl   $0xc,-0x14(%rbp)
    if ((ret = set_sighandler(&sig, 1, &_DkCompatibilitySighandler)) < 0)
   15137:	e8 54 f6 ff ff       	callq  14790 <set_sighandler>
   1513c:	ba 00 00 00 00       	mov    $0x0,%edx
   15141:	85 c0                	test   %eax,%eax
   15143:	0f 4f c2             	cmovg  %edx,%eax
   15146:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1514d:	00 00 00 

    return 0;

err:
    return ret;
}
   15150:	48 83 c4 18          	add    $0x18,%rsp
   15154:	5b                   	pop    %rbx
   15155:	5d                   	pop    %rbp
   15156:	c3                   	retq   
   15157:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1515e:	00 00 

0000000000015160 <_DkExceptionReturn>:

void _DkExceptionReturn (const void * event)
{
   15160:	48 8b 15 41 e9 20 00 	mov    0x20e941(%rip),%rdx        # 223aa8 <_DYNAMIC+0x2c0>
   15167:	48 89 f8             	mov    %rdi,%rax
    const struct event * e = (const struct event *) event;

    if (e->instance == pal_sec_info.domain_id)
   1516a:	8b 52 08             	mov    0x8(%rdx),%edx
   1516d:	48 39 17             	cmp    %rdx,(%rdi)
   15170:	74 6c                	je     151de <_DkExceptionReturn+0x7e>
        return;

    int event_n = e->event_num;

    if (event_n > 0 && event_n <= PAL_EVENT_NUM_BOUND) {
   15172:	8b 4f 08             	mov    0x8(%rdi),%ecx
   15175:	8d 51 ff             	lea    -0x1(%rcx),%edx
   15178:	83 fa 07             	cmp    $0x7,%edx
   1517b:	77 61                	ja     151de <_DkExceptionReturn+0x7e>
err:
    return ret;
}

void _DkExceptionReturn (const void * event)
{
   1517d:	55                   	push   %rbp
   1517e:	48 89 e5             	mov    %rsp,%rbp
   15181:	41 57                	push   %r15
   15183:	41 56                	push   %r14
   15185:	41 55                	push   %r13
   15187:	41 54                	push   %r12
   15189:	53                   	push   %rbx
        return;

    int event_n = e->event_num;

    if (event_n > 0 && event_n <= PAL_EVENT_NUM_BOUND) {
        arch_restore_frame(&e->frame->arch);
   1518a:	48 8b 57 10          	mov    0x10(%rdi),%rdx
   1518e:	4c 8b 7a 58          	mov    0x58(%rdx),%r15
   15192:	48 8b 50 10          	mov    0x10(%rax),%rdx
   15196:	4c 8b 72 50          	mov    0x50(%rdx),%r14
   1519a:	48 8b 50 10          	mov    0x10(%rax),%rdx
   1519e:	4c 8b 6a 48          	mov    0x48(%rdx),%r13
   151a2:	48 8b 50 10          	mov    0x10(%rax),%rdx
   151a6:	4c 8b 62 40          	mov    0x40(%rdx),%r12
   151aa:	48 8b 50 10          	mov    0x10(%rax),%rdx
   151ae:	48 8b 7a 38          	mov    0x38(%rdx),%rdi
   151b2:	48 8b 50 10          	mov    0x10(%rax),%rdx
   151b6:	48 8b 72 30          	mov    0x30(%rdx),%rsi
   151ba:	48 8b 50 10          	mov    0x10(%rax),%rdx
   151be:	48 8b 5a 28          	mov    0x28(%rdx),%rbx
   151c2:	48 8b 50 10          	mov    0x10(%rax),%rdx
   151c6:	48 8b 6a 20          	mov    0x20(%rdx),%rbp
   151ca:	48 8b 40 10          	mov    0x10(%rax),%rax
   151ce:	48 8b 60 18          	mov    0x18(%rax),%rsp
        asm volatile ("leaveq\r\n"
   151d2:	c9                   	leaveq 
   151d3:	c3                   	retq   
                      "retq\r\n"
                      ::: "memory");
    }
}
   151d4:	5b                   	pop    %rbx
   151d5:	41 5c                	pop    %r12
   151d7:	41 5d                	pop    %r13
   151d9:	41 5e                	pop    %r14
   151db:	41 5f                	pop    %r15
   151dd:	5d                   	pop    %rbp
   151de:	f3 c3                	repz retq 

00000000000151e0 <__get_path>:
#include <arpa/inet.h>
#include "../../security/Linux/utils.h"
#include "graphene.h"

static const char * __get_path (struct config_store * config, const char * key)
{
   151e0:	55                   	push   %rbp
    char uri[CONFIG_MAX];

    if (get_config(config, key, uri, CONFIG_MAX) <= 0 ||
   151e1:	b9 00 01 00 00       	mov    $0x100,%ecx
#include <arpa/inet.h>
#include "../../security/Linux/utils.h"
#include "graphene.h"

static const char * __get_path (struct config_store * config, const char * key)
{
   151e6:	48 89 e5             	mov    %rsp,%rbp
   151e9:	41 54                	push   %r12
   151eb:	53                   	push   %rbx
    char uri[CONFIG_MAX];

    if (get_config(config, key, uri, CONFIG_MAX) <= 0 ||
   151ec:	48 8d 9d f0 fe ff ff 	lea    -0x110(%rbp),%rbx
#include <arpa/inet.h>
#include "../../security/Linux/utils.h"
#include "graphene.h"

static const char * __get_path (struct config_store * config, const char * key)
{
   151f3:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
    char uri[CONFIG_MAX];

    if (get_config(config, key, uri, CONFIG_MAX) <= 0 ||
   151fa:	48 89 da             	mov    %rbx,%rdx
   151fd:	e8 ae 2c 00 00       	callq  17eb0 <get_config>
   15202:	85 c0                	test   %eax,%eax
   15204:	7e 09                	jle    1520f <__get_path+0x2f>
extern unsigned long pageshift;
extern unsigned long pagemask;

static inline int is_file_uri (const char * uri)
{
    if (uri[0] == 'f' && uri[1] == 'i' && uri[2] == 'l' && uri[3] == 'e' &&
   15206:	80 bd f0 fe ff ff 66 	cmpb   $0x66,-0x110(%rbp)
   1520d:	74 11                	je     15220 <__get_path+0x40>
        !is_file_uri(uri))
        return NULL;

    return file_uri_to_path(uri, strlen(uri));
}
   1520f:	48 81 c4 00 01 00 00 	add    $0x100,%rsp
    char * path;

    if (len == 5) {
        path = malloc(2);
        if (!path)
            return NULL;
   15216:	31 c0                	xor    %eax,%eax
   15218:	5b                   	pop    %rbx
   15219:	41 5c                	pop    %r12
   1521b:	5d                   	pop    %rbp
   1521c:	c3                   	retq   
   1521d:	0f 1f 00             	nopl   (%rax)
extern unsigned long pageshift;
extern unsigned long pagemask;

static inline int is_file_uri (const char * uri)
{
    if (uri[0] == 'f' && uri[1] == 'i' && uri[2] == 'l' && uri[3] == 'e' &&
   15220:	80 bd f1 fe ff ff 69 	cmpb   $0x69,-0x10f(%rbp)
   15227:	75 e6                	jne    1520f <__get_path+0x2f>
   15229:	80 bd f2 fe ff ff 6c 	cmpb   $0x6c,-0x10e(%rbp)
   15230:	75 dd                	jne    1520f <__get_path+0x2f>
   15232:	80 bd f3 fe ff ff 65 	cmpb   $0x65,-0x10d(%rbp)
   15239:	75 d4                	jne    1520f <__get_path+0x2f>
   1523b:	80 bd f4 fe ff ff 3a 	cmpb   $0x3a,-0x10c(%rbp)
   15242:	75 cb                	jne    1520f <__get_path+0x2f>

    if (get_config(config, key, uri, CONFIG_MAX) <= 0 ||
        !is_file_uri(uri))
        return NULL;

    return file_uri_to_path(uri, strlen(uri));
   15244:	48 89 df             	mov    %rbx,%rdi
   15247:	e8 54 15 00 00       	callq  167a0 <strlen>

static inline const char * file_uri_to_path (const char * uri, int len)
{
    char * path;

    if (len == 5) {
   1524c:	83 f8 05             	cmp    $0x5,%eax
   1524f:	49 89 c4             	mov    %rax,%r12
   15252:	74 51                	je     152a5 <__get_path+0xc5>
        path[0] = '.';
        path[1] = 0;
        return path;
    }

    path = malloc(len - 4);
   15254:	41 8d 7c 24 fc       	lea    -0x4(%r12),%edi
   15259:	e8 a2 37 ff ff       	callq  8a00 <malloc>
    if (!path)
   1525e:	48 85 c0             	test   %rax,%rax
        path[0] = '.';
        path[1] = 0;
        return path;
    }

    path = malloc(len - 4);
   15261:	48 89 c6             	mov    %rax,%rsi
    if (!path)
   15264:	74 a9                	je     1520f <__get_path+0x2f>
   15266:	45 8d 44 24 fa       	lea    -0x6(%r12),%r8d
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
        *d = *s;
   1526b:	48 8d 53 05          	lea    0x5(%rbx),%rdx
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   1526f:	31 c9                	xor    %ecx,%ecx
   15271:	4c 89 c0             	mov    %r8,%rax
   15274:	49 83 c0 01          	add    $0x1,%r8
   15278:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1527f:	00 
        *d = *s;
   15280:	0f b6 3c 0a          	movzbl (%rdx,%rcx,1),%edi
   15284:	40 88 3c 0e          	mov    %dil,(%rsi,%rcx,1)
   15288:	48 83 c1 01          	add    $0x1,%rcx
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   1528c:	4c 39 c1             	cmp    %r8,%rcx
   1528f:	75 ef                	jne    15280 <__get_path+0xa0>
        d++;
        s++;
        len--;
    }

    *d = 0;
   15291:	c6 44 06 01 00       	movb   $0x0,0x1(%rsi,%rax,1)
}
   15296:	48 81 c4 00 01 00 00 	add    $0x100,%rsp
   1529d:	48 89 f0             	mov    %rsi,%rax
   152a0:	5b                   	pop    %rbx
   152a1:	41 5c                	pop    %r12
   152a3:	5d                   	pop    %rbp
   152a4:	c3                   	retq   
static inline const char * file_uri_to_path (const char * uri, int len)
{
    char * path;

    if (len == 5) {
        path = malloc(2);
   152a5:	bf 02 00 00 00       	mov    $0x2,%edi
   152aa:	e8 51 37 ff ff       	callq  8a00 <malloc>
        if (!path)
   152af:	48 85 c0             	test   %rax,%rax
   152b2:	0f 84 57 ff ff ff    	je     1520f <__get_path+0x2f>
            return NULL;

        path[0] = '.';
   152b8:	c6 00 2e             	movb   $0x2e,(%rax)
        path[1] = 0;
   152bb:	c6 40 01 00          	movb   $0x0,0x1(%rax)
   152bf:	48 81 c4 00 01 00 00 	add    $0x100,%rsp
   152c6:	5b                   	pop    %rbx
   152c7:	41 5c                	pop    %r12
   152c9:	5d                   	pop    %rbp
   152ca:	c3                   	retq   
   152cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000152d0 <get_preload_paths>:

#define PRELOAD_MAX     16

int get_preload_paths (struct config_store * config, const char *** paths)
{
   152d0:	55                   	push   %rbp
    char cfgbuf[CONFIG_MAX];

    if (get_config(config, "loader.preload", cfgbuf, CONFIG_MAX) <= 0)
   152d1:	b9 00 01 00 00       	mov    $0x100,%ecx
}

#define PRELOAD_MAX     16

int get_preload_paths (struct config_store * config, const char *** paths)
{
   152d6:	48 89 e5             	mov    %rsp,%rbp
   152d9:	41 57                	push   %r15
   152db:	41 56                	push   %r14
   152dd:	41 55                	push   %r13
   152df:	41 54                	push   %r12
    char cfgbuf[CONFIG_MAX];

    if (get_config(config, "loader.preload", cfgbuf, CONFIG_MAX) <= 0)
   152e1:	4c 8d a5 d0 fe ff ff 	lea    -0x130(%rbp),%r12
}

#define PRELOAD_MAX     16

int get_preload_paths (struct config_store * config, const char *** paths)
{
   152e8:	53                   	push   %rbx
    char cfgbuf[CONFIG_MAX];

    if (get_config(config, "loader.preload", cfgbuf, CONFIG_MAX) <= 0)
   152e9:	4c 89 e2             	mov    %r12,%rdx
}

#define PRELOAD_MAX     16

int get_preload_paths (struct config_store * config, const char *** paths)
{
   152ec:	48 81 ec 98 01 00 00 	sub    $0x198,%rsp
   152f3:	48 89 b5 48 fe ff ff 	mov    %rsi,-0x1b8(%rbp)
    char cfgbuf[CONFIG_MAX];

    if (get_config(config, "loader.preload", cfgbuf, CONFIG_MAX) <= 0)
   152fa:	48 8d 35 c4 36 00 00 	lea    0x36c4(%rip),%rsi        # 189c5 <handle_sizes.1924+0x245>
   15301:	e8 aa 2b 00 00       	callq  17eb0 <get_config>
   15306:	85 c0                	test   %eax,%eax
   15308:	0f 8e 30 01 00 00    	jle    1543e <get_preload_paths+0x16e>
   1530e:	0f b6 b5 d0 fe ff ff 	movzbl -0x130(%rbp),%esi
   15315:	45 31 ed             	xor    %r13d,%r13d
   15318:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1531f:	00 

    const char * p = cfgbuf, * n;
    const char * preload_paths[PRELOAD_MAX];
    int npreload = 0;

    while (*p && npreload < PRELOAD_MAX) {
   15320:	40 84 f6             	test   %sil,%sil
   15323:	74 43                	je     15368 <get_preload_paths+0x98>
   15325:	41 83 fd 0f          	cmp    $0xf,%r13d
   15329:	7f 3d                	jg     15368 <get_preload_paths+0x98>
        for (n = p ; *n && *n != ',' ; n++);
   1532b:	40 80 fe 2c          	cmp    $0x2c,%sil
   1532f:	4c 89 e3             	mov    %r12,%rbx
   15332:	75 10                	jne    15344 <get_preload_paths+0x74>
   15334:	eb 20                	jmp    15356 <get_preload_paths+0x86>
   15336:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1533d:	00 00 00 
   15340:	84 c9                	test   %cl,%cl
   15342:	74 0c                	je     15350 <get_preload_paths+0x80>
   15344:	48 83 c3 01          	add    $0x1,%rbx
   15348:	0f b6 0b             	movzbl (%rbx),%ecx
   1534b:	80 f9 2c             	cmp    $0x2c,%cl
   1534e:	75 f0                	jne    15340 <get_preload_paths+0x70>
extern unsigned long pageshift;
extern unsigned long pagemask;

static inline int is_file_uri (const char * uri)
{
    if (uri[0] == 'f' && uri[1] == 'i' && uri[2] == 'l' && uri[3] == 'e' &&
   15350:	40 80 fe 66          	cmp    $0x66,%sil
   15354:	74 6a                	je     153c0 <get_preload_paths+0xf0>
            goto next;

        if (!(preload_paths[npreload++] = file_uri_to_path(p, n - p)))
            return -ENOMEM;
next:
        p = *n ? n + 1 : n;
   15356:	80 3b 00             	cmpb   $0x0,(%rbx)
   15359:	74 58                	je     153b3 <get_preload_paths+0xe3>
   1535b:	0f b6 73 01          	movzbl 0x1(%rbx),%esi
   1535f:	4c 8d 63 01          	lea    0x1(%rbx),%r12

    const char * p = cfgbuf, * n;
    const char * preload_paths[PRELOAD_MAX];
    int npreload = 0;

    while (*p && npreload < PRELOAD_MAX) {
   15363:	40 84 f6             	test   %sil,%sil
   15366:	75 bd                	jne    15325 <get_preload_paths+0x55>
            return -ENOMEM;
next:
        p = *n ? n + 1 : n;
    }

    *paths = malloc(sizeof(const char *) * npreload);
   15368:	42 8d 3c ed 00 00 00 	lea    0x0(,%r13,8),%edi
   1536f:	00 
   15370:	e8 8b 36 ff ff       	callq  8a00 <malloc>
   15375:	48 89 c7             	mov    %rax,%rdi
   15378:	48 8b 85 48 fe ff ff 	mov    -0x1b8(%rbp),%rax
    if (!(*paths))
   1537f:	48 85 ff             	test   %rdi,%rdi
            return -ENOMEM;
next:
        p = *n ? n + 1 : n;
    }

    *paths = malloc(sizeof(const char *) * npreload);
   15382:	48 89 38             	mov    %rdi,(%rax)
    if (!(*paths))
   15385:	0f 84 ba 00 00 00    	je     15445 <get_preload_paths+0x175>
        return -ENOMEM;

    memcpy((*paths), preload_paths, sizeof(const char *) * npreload);
   1538b:	49 63 d5             	movslq %r13d,%rdx
   1538e:	48 8d b5 50 fe ff ff 	lea    -0x1b0(%rbp),%rsi
   15395:	48 c1 e2 03          	shl    $0x3,%rdx
   15399:	e8 e2 0e 00 00       	callq  16280 <memcpy>
    return npreload;
   1539e:	44 89 e8             	mov    %r13d,%eax
}
   153a1:	48 81 c4 98 01 00 00 	add    $0x198,%rsp
   153a8:	5b                   	pop    %rbx
   153a9:	41 5c                	pop    %r12
   153ab:	41 5d                	pop    %r13
   153ad:	41 5e                	pop    %r14
   153af:	41 5f                	pop    %r15
   153b1:	5d                   	pop    %rbp
   153b2:	c3                   	retq   
   153b3:	49 89 dc             	mov    %rbx,%r12
   153b6:	31 f6                	xor    %esi,%esi
   153b8:	e9 63 ff ff ff       	jmpq   15320 <get_preload_paths+0x50>
   153bd:	0f 1f 00             	nopl   (%rax)
   153c0:	41 80 7c 24 01 69    	cmpb   $0x69,0x1(%r12)
   153c6:	75 8e                	jne    15356 <get_preload_paths+0x86>
   153c8:	41 80 7c 24 02 6c    	cmpb   $0x6c,0x2(%r12)
   153ce:	75 86                	jne    15356 <get_preload_paths+0x86>
   153d0:	41 80 7c 24 03 65    	cmpb   $0x65,0x3(%r12)
   153d6:	0f 85 7a ff ff ff    	jne    15356 <get_preload_paths+0x86>
   153dc:	41 80 7c 24 04 3a    	cmpb   $0x3a,0x4(%r12)
   153e2:	0f 85 6e ff ff ff    	jne    15356 <get_preload_paths+0x86>
        for (n = p ; *n && *n != ',' ; n++);

        if (!is_file_uri(p))
            goto next;

        if (!(preload_paths[npreload++] = file_uri_to_path(p, n - p)))
   153e8:	49 89 df             	mov    %rbx,%r15
   153eb:	45 8d 75 01          	lea    0x1(%r13),%r14d
   153ef:	4d 29 e7             	sub    %r12,%r15

static inline const char * file_uri_to_path (const char * uri, int len)
{
    char * path;

    if (len == 5) {
   153f2:	41 83 ff 05          	cmp    $0x5,%r15d
   153f6:	74 58                	je     15450 <get_preload_paths+0x180>
        path[0] = '.';
        path[1] = 0;
        return path;
    }

    path = malloc(len - 4);
   153f8:	41 8d 7f fc          	lea    -0x4(%r15),%edi
   153fc:	e8 ff 35 ff ff       	callq  8a00 <malloc>
    if (!path)
   15401:	48 85 c0             	test   %rax,%rax
   15404:	74 3f                	je     15445 <get_preload_paths+0x175>
   15406:	41 8d 77 fa          	lea    -0x6(%r15),%esi
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   1540a:	31 c9                	xor    %ecx,%ecx
   1540c:	49 89 f7             	mov    %rsi,%r15
   1540f:	48 83 c6 01          	add    $0x1,%rsi
        *d = *s;
   15413:	41 0f b6 54 0c 05    	movzbl 0x5(%r12,%rcx,1),%edx
   15419:	88 14 08             	mov    %dl,(%rax,%rcx,1)
   1541c:	48 83 c1 01          	add    $0x1,%rcx
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   15420:	48 39 f1             	cmp    %rsi,%rcx
   15423:	75 ee                	jne    15413 <get_preload_paths+0x143>
        d++;
        s++;
        len--;
    }

    *d = 0;
   15425:	42 c6 44 38 01 00    	movb   $0x0,0x1(%rax,%r15,1)
   1542b:	4d 63 c5             	movslq %r13d,%r8
   1542e:	45 89 f5             	mov    %r14d,%r13d
   15431:	4a 89 84 c5 50 fe ff 	mov    %rax,-0x1b0(%rbp,%r8,8)
   15438:	ff 
   15439:	e9 18 ff ff ff       	jmpq   15356 <get_preload_paths+0x86>
int get_preload_paths (struct config_store * config, const char *** paths)
{
    char cfgbuf[CONFIG_MAX];

    if (get_config(config, "loader.preload", cfgbuf, CONFIG_MAX) <= 0)
        return 0;
   1543e:	31 c0                	xor    %eax,%eax
   15440:	e9 5c ff ff ff       	jmpq   153a1 <get_preload_paths+0xd1>

        if (!is_file_uri(p))
            goto next;

        if (!(preload_paths[npreload++] = file_uri_to_path(p, n - p)))
            return -ENOMEM;
   15445:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   1544a:	e9 52 ff ff ff       	jmpq   153a1 <get_preload_paths+0xd1>
   1544f:	90                   	nop    
static inline const char * file_uri_to_path (const char * uri, int len)
{
    char * path;

    if (len == 5) {
        path = malloc(2);
   15450:	bf 02 00 00 00       	mov    $0x2,%edi
   15455:	e8 a6 35 ff ff       	callq  8a00 <malloc>
        if (!path)
   1545a:	48 85 c0             	test   %rax,%rax
   1545d:	74 e6                	je     15445 <get_preload_paths+0x175>
            return NULL;

        path[0] = '.';
   1545f:	c6 00 2e             	movb   $0x2e,(%rax)
        path[1] = 0;
   15462:	c6 40 01 00          	movb   $0x0,0x1(%rax)
   15466:	eb c3                	jmp    1542b <get_preload_paths+0x15b>
   15468:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1546f:	00 

0000000000015470 <get_fs_paths>:
    memcpy((*paths), preload_paths, sizeof(const char *) * npreload);
    return npreload;
}

int get_fs_paths (struct config_store * config, const char *** paths)
{
   15470:	55                   	push   %rbp
   15471:	48 89 e5             	mov    %rsp,%rbp
   15474:	41 57                	push   %r15
   15476:	41 56                	push   %r14
   15478:	41 55                	push   %r13
   1547a:	41 54                	push   %r12
   1547c:	49 89 f6             	mov    %rsi,%r14
   1547f:	53                   	push   %rbx
    const char * root_path = __get_path(config, "fs.mount.root.uri");
   15480:	48 8d 35 11 9a 00 00 	lea    0x9a11(%rip),%rsi        # 1ee98 <CSWTCH.16+0x58>
    memcpy((*paths), preload_paths, sizeof(const char *) * npreload);
    return npreload;
}

int get_fs_paths (struct config_store * config, const char *** paths)
{
   15487:	49 89 fd             	mov    %rdi,%r13
    const char * root_path = __get_path(config, "fs.mount.root.uri");

    if (!root_path)
        return 0;
   1548a:	31 db                	xor    %ebx,%ebx
    memcpy((*paths), preload_paths, sizeof(const char *) * npreload);
    return npreload;
}

int get_fs_paths (struct config_store * config, const char *** paths)
{
   1548c:	48 81 ec 18 02 00 00 	sub    $0x218,%rsp
   15493:	48 89 bd c8 fd ff ff 	mov    %rdi,-0x238(%rbp)
    const char * root_path = __get_path(config, "fs.mount.root.uri");
   1549a:	e8 41 fd ff ff       	callq  151e0 <__get_path>

    if (!root_path)
   1549f:	48 85 c0             	test   %rax,%rax
    return npreload;
}

int get_fs_paths (struct config_store * config, const char *** paths)
{
    const char * root_path = __get_path(config, "fs.mount.root.uri");
   154a2:	49 89 c7             	mov    %rax,%r15

    if (!root_path)
   154a5:	0f 84 51 01 00 00    	je     155fc <get_fs_paths+0x18c>
        return 0;

    char keys[CONFIG_MAX];
    int nkeys;

    if ((nkeys = get_config_entries(config, "fs.mount.other", keys,
   154ab:	4c 8d a5 d0 fd ff ff 	lea    -0x230(%rbp),%r12
   154b2:	48 8d 35 f1 99 00 00 	lea    0x99f1(%rip),%rsi        # 1eeaa <CSWTCH.16+0x6a>
   154b9:	4c 89 ef             	mov    %r13,%rdi
   154bc:	b9 00 01 00 00       	mov    $0x100,%ecx
   154c1:	4c 89 e2             	mov    %r12,%rdx
   154c4:	e8 57 2a 00 00       	callq  17f20 <get_config_entries>
   154c9:	85 c0                	test   %eax,%eax
   154cb:	0f 49 d8             	cmovns %eax,%ebx
                                    CONFIG_MAX)) < 0)
        nkeys = 0;

    *paths = malloc(sizeof(const char *) * (1 + nkeys));
   154ce:	8d 3c dd 08 00 00 00 	lea    0x8(,%rbx,8),%edi
   154d5:	89 9d c4 fd ff ff    	mov    %ebx,-0x23c(%rbp)
   154db:	41 89 dd             	mov    %ebx,%r13d
   154de:	e8 1d 35 ff ff       	callq  8a00 <malloc>
    if (!(*paths))
   154e3:	48 85 c0             	test   %rax,%rax

    if ((nkeys = get_config_entries(config, "fs.mount.other", keys,
                                    CONFIG_MAX)) < 0)
        nkeys = 0;

    *paths = malloc(sizeof(const char *) * (1 + nkeys));
   154e6:	49 89 06             	mov    %rax,(%r14)
    if (!(*paths))
   154e9:	0f 84 21 01 00 00    	je     15610 <get_fs_paths+0x1a0>
        return -ENOMEM;

    (*paths)[0] = root_path;
    int npaths = 1;

    if (!nkeys)
   154ef:	45 85 ed             	test   %r13d,%r13d

    *paths = malloc(sizeof(const char *) * (1 + nkeys));
    if (!(*paths))
        return -ENOMEM;

    (*paths)[0] = root_path;
   154f2:	4c 89 38             	mov    %r15,(%rax)
    int npaths = 1;
   154f5:	bb 01 00 00 00       	mov    $0x1,%ebx

    if (!nkeys)
   154fa:	0f 84 fc 00 00 00    	je     155fc <get_fs_paths+0x18c>
   15500:	4c 8d bd d0 fe ff ff 	lea    -0x130(%rbp),%r15
   15507:	48 8d 15 7a 99 00 00 	lea    0x997a(%rip),%rdx        # 1ee88 <CSWTCH.16+0x48>
   1550e:	31 c0                	xor    %eax,%eax
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
        *d = *s;
   15510:	0f b6 0c 02          	movzbl (%rdx,%rax,1),%ecx
   15514:	41 88 0c 07          	mov    %cl,(%r15,%rax,1)
   15518:	48 83 c0 01          	add    $0x1,%rax
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   1551c:	48 83 f8 0f          	cmp    $0xf,%rax
   15520:	75 ee                	jne    15510 <get_fs_paths+0xa0>
        goto out;

    char key[CONFIG_MAX], * k = keys, * n;
   15522:	4c 89 e2             	mov    %r12,%rdx
        d++;
        s++;
        len--;
    }

    *d = 0;
   15525:	c6 85 df fe ff ff 00 	movb   $0x0,-0x121(%rbp)

    fast_strcpy(key, "fs.mount.other.", 15);

    for (int i = 0 ; i < nkeys ; i++) {
   1552c:	45 31 ed             	xor    %r13d,%r13d
    *paths = malloc(sizeof(const char *) * (1 + nkeys));
    if (!(*paths))
        return -ENOMEM;

    (*paths)[0] = root_path;
    int npaths = 1;
   1552f:	41 bc 01 00 00 00    	mov    $0x1,%r12d
    char key[CONFIG_MAX], * k = keys, * n;

    fast_strcpy(key, "fs.mount.other.", 15);

    for (int i = 0 ; i < nkeys ; i++) {
        for (n = k ; *n ; n++);
   15535:	0f b6 3a             	movzbl (%rdx),%edi
   15538:	48 89 d3             	mov    %rdx,%rbx
   1553b:	41 ba 0f 00 00 00    	mov    $0xf,%r10d
   15541:	49 8d 47 0f          	lea    0xf(%r15),%rax
   15545:	40 84 ff             	test   %dil,%dil
   15548:	74 4c                	je     15596 <get_fs_paths+0x126>
   1554a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
   15550:	48 83 c3 01          	add    $0x1,%rbx
   15554:	80 3b 00             	cmpb   $0x0,(%rbx)
   15557:	75 f7                	jne    15550 <get_fs_paths+0xe0>
   15559:	48 89 de             	mov    %rbx,%rsi
   1555c:	48 29 d6             	sub    %rdx,%rsi
   1555f:	4c 63 d6             	movslq %esi,%r10
   15562:	49 83 c2 0f          	add    $0xf,%r10
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   15566:	85 f6                	test   %esi,%esi
   15568:	0f 84 a9 00 00 00    	je     15617 <get_fs_paths+0x1a7>
   1556e:	8d 46 ff             	lea    -0x1(%rsi),%eax
   15571:	31 c9                	xor    %ecx,%ecx
        *d = *s;
   15573:	4d 8d 5f 0f          	lea    0xf(%r15),%r11
   15577:	48 89 c6             	mov    %rax,%rsi
   1557a:	48 83 c0 01          	add    $0x1,%rax
   1557e:	eb 04                	jmp    15584 <get_fs_paths+0x114>
   15580:	0f b6 3c 0a          	movzbl (%rdx,%rcx,1),%edi
   15584:	41 88 3c 0b          	mov    %dil,(%r11,%rcx,1)
   15588:	48 83 c1 01          	add    $0x1,%rcx
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   1558c:	48 39 c1             	cmp    %rax,%rcx
   1558f:	75 ef                	jne    15580 <get_fs_paths+0x110>
   15591:	49 8d 44 33 01       	lea    0x1(%r11,%rsi,1),%rax
        int len = n - k;
        fast_strcpy(key + 15, k, len);
        fast_strcpy(key + 15 + len, ".uri", 4);
   15596:	4d 01 fa             	add    %r15,%r10
        d++;
        s++;
        len--;
    }

    *d = 0;
   15599:	c6 00 00             	movb   $0x0,(%rax)
   1559c:	48 8d 05 02 99 00 00 	lea    0x9902(%rip),%rax        # 1eea5 <CSWTCH.16+0x65>
   155a3:	49 8d 72 04          	lea    0x4(%r10),%rsi
   155a7:	4c 89 d2             	mov    %r10,%rdx
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
        *d = *s;
   155aa:	0f b6 08             	movzbl (%rax),%ecx
        d++;
   155ad:	48 83 c2 01          	add    $0x1,%rdx
        s++;
   155b1:	48 83 c0 01          	add    $0x1,%rax
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
        *d = *s;
   155b5:	88 4a ff             	mov    %cl,-0x1(%rdx)
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   155b8:	48 39 f2             	cmp    %rsi,%rdx
   155bb:	75 ed                	jne    155aa <get_fs_paths+0x13a>

        const char * path = __get_path(config, key);
   155bd:	48 8b bd c8 fd ff ff 	mov    -0x238(%rbp),%rdi
        d++;
        s++;
        len--;
    }

    *d = 0;
   155c4:	41 c6 42 04 00       	movb   $0x0,0x4(%r10)
   155c9:	4c 89 fe             	mov    %r15,%rsi
   155cc:	e8 0f fc ff ff       	callq  151e0 <__get_path>
        if (path)
   155d1:	48 85 c0             	test   %rax,%rax
   155d4:	74 0e                	je     155e4 <get_fs_paths+0x174>
            (*paths)[npaths++] = path;
   155d6:	49 8b 16             	mov    (%r14),%rdx
   155d9:	49 63 cc             	movslq %r12d,%rcx
   155dc:	41 83 c4 01          	add    $0x1,%r12d
   155e0:	48 89 04 ca          	mov    %rax,(%rdx,%rcx,8)

    char key[CONFIG_MAX], * k = keys, * n;

    fast_strcpy(key, "fs.mount.other.", 15);

    for (int i = 0 ; i < nkeys ; i++) {
   155e4:	41 83 c5 01          	add    $0x1,%r13d
   155e8:	44 3b ad c4 fd ff ff 	cmp    -0x23c(%rbp),%r13d
        fast_strcpy(key + 15 + len, ".uri", 4);

        const char * path = __get_path(config, key);
        if (path)
            (*paths)[npaths++] = path;
        k = n + 1;
   155ef:	48 8d 53 01          	lea    0x1(%rbx),%rdx

    char key[CONFIG_MAX], * k = keys, * n;

    fast_strcpy(key, "fs.mount.other.", 15);

    for (int i = 0 ; i < nkeys ; i++) {
   155f3:	0f 8c 3c ff ff ff    	jl     15535 <get_fs_paths+0xc5>
   155f9:	44 89 e3             	mov    %r12d,%ebx
            (*paths)[npaths++] = path;
        k = n + 1;
    }
out:
    return npaths;
}
   155fc:	48 81 c4 18 02 00 00 	add    $0x218,%rsp
   15603:	89 d8                	mov    %ebx,%eax
   15605:	5b                   	pop    %rbx
   15606:	41 5c                	pop    %r12
   15608:	41 5d                	pop    %r13
   1560a:	41 5e                	pop    %r14
   1560c:	41 5f                	pop    %r15
   1560e:	5d                   	pop    %rbp
   1560f:	c3                   	retq   
                                    CONFIG_MAX)) < 0)
        nkeys = 0;

    *paths = malloc(sizeof(const char *) * (1 + nkeys));
    if (!(*paths))
        return -ENOMEM;
   15610:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
   15615:	eb e5                	jmp    155fc <get_fs_paths+0x18c>
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   15617:	49 8d 47 0f          	lea    0xf(%r15),%rax
   1561b:	e9 76 ff ff ff       	jmpq   15596 <get_fs_paths+0x126>

0000000000015620 <get_net_rules>:
    return npaths;
}

int get_net_rules (struct config_store * config,
                   struct graphene_net_policy ** net_rules)
{
   15620:	55                   	push   %rbp
    char keys[CONFIG_MAX];
    int nkeys;

    if ((nkeys = get_config_entries(config, "net.rules", keys,
   15621:	b9 00 01 00 00       	mov    $0x100,%ecx
    return npaths;
}

int get_net_rules (struct config_store * config,
                   struct graphene_net_policy ** net_rules)
{
   15626:	48 89 e5             	mov    %rsp,%rbp
   15629:	41 57                	push   %r15
   1562b:	41 56                	push   %r14
   1562d:	41 55                	push   %r13
   1562f:	41 54                	push   %r12
   15631:	49 89 ff             	mov    %rdi,%r15
   15634:	53                   	push   %rbx
    char keys[CONFIG_MAX];
    int nkeys;

    if ((nkeys = get_config_entries(config, "net.rules", keys,
   15635:	48 8d 9d d0 fc ff ff 	lea    -0x330(%rbp),%rbx
    return npaths;
}

int get_net_rules (struct config_store * config,
                   struct graphene_net_policy ** net_rules)
{
   1563c:	48 81 ec 68 03 00 00 	sub    $0x368,%rsp
   15643:	48 89 b5 b8 fc ff ff 	mov    %rsi,-0x348(%rbp)
    char keys[CONFIG_MAX];
    int nkeys;

    if ((nkeys = get_config_entries(config, "net.rules", keys,
   1564a:	48 8d 35 73 98 00 00 	lea    0x9873(%rip),%rsi        # 1eec4 <CSWTCH.16+0x84>
   15651:	48 89 da             	mov    %rbx,%rdx
   15654:	e8 c7 28 00 00       	callq  17f20 <get_config_entries>
   15659:	89 c7                	mov    %eax,%edi
   1565b:	89 85 cc fc ff ff    	mov    %eax,-0x334(%rbp)
                                    CONFIG_MAX)) < 0)
        return 0;
   15661:	31 c0                	xor    %eax,%eax
                   struct graphene_net_policy ** net_rules)
{
    char keys[CONFIG_MAX];
    int nkeys;

    if ((nkeys = get_config_entries(config, "net.rules", keys,
   15663:	85 ff                	test   %edi,%edi
   15665:	0f 88 4f 01 00 00    	js     157ba <get_net_rules+0x19a>
                                    CONFIG_MAX)) < 0)
        return 0;

    struct graphene_net_policy * rules =
            malloc(sizeof(struct graphene_net_policy) * nkeys);
   1566b:	6b ff 2c             	imul   $0x2c,%edi,%edi

    if ((nkeys = get_config_entries(config, "net.rules", keys,
                                    CONFIG_MAX)) < 0)
        return 0;

    struct graphene_net_policy * rules =
   1566e:	e8 8d 33 ff ff       	callq  8a00 <malloc>
            malloc(sizeof(struct graphene_net_policy) * nkeys);

    if (!rules)
   15673:	48 85 c0             	test   %rax,%rax

    if ((nkeys = get_config_entries(config, "net.rules", keys,
                                    CONFIG_MAX)) < 0)
        return 0;

    struct graphene_net_policy * rules =
   15676:	48 89 85 98 fc ff ff 	mov    %rax,-0x368(%rbp)
            malloc(sizeof(struct graphene_net_policy) * nkeys);

    if (!rules)
   1567d:	0f 84 21 06 00 00    	je     15ca4 <get_net_rules+0x684>
   15683:	4c 8d a5 d0 fd ff ff 	lea    -0x230(%rbp),%r12
   1568a:	48 8d 0d 28 98 00 00 	lea    0x9828(%rip),%rcx        # 1eeb9 <CSWTCH.16+0x79>
   15691:	31 c0                	xor    %eax,%eax
        *d = *s;
   15693:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
   15697:	41 88 14 04          	mov    %dl,(%r12,%rax,1)
   1569b:	48 83 c0 01          	add    $0x1,%rax
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   1569f:	48 83 f8 0a          	cmp    $0xa,%rax
   156a3:	75 ee                	jne    15693 <get_net_rules+0x73>
    int nrules = 0;
    char key[CONFIG_MAX], * k = keys, * n;

    fast_strcpy(key, "net.rules.", 10);

    for (int i = 0 ; i < nkeys ; i++) {
   156a5:	8b 85 cc fc ff ff    	mov    -0x334(%rbp),%eax
        d++;
        s++;
        len--;
    }

    *d = 0;
   156ab:	c6 85 da fd ff ff 00 	movb   $0x0,-0x226(%rbp)
   156b2:	85 c0                	test   %eax,%eax
   156b4:	0f 84 33 03 00 00    	je     159ed <get_net_rules+0x3cd>
   156ba:	4c 8d b5 d0 fe ff ff 	lea    -0x130(%rbp),%r14
   156c1:	45 31 ed             	xor    %r13d,%r13d
   156c4:	48 89 d9             	mov    %rbx,%rcx
   156c7:	c7 85 c8 fc ff ff 00 	movl   $0x0,-0x338(%rbp)
   156ce:	00 00 00 
        struct graphene_net_policy * r = &rules[nrules];
        char cfgbuf[CONFIG_MAX];

        for (n = k ; *n ; n++);
   156d1:	0f b6 11             	movzbl (%rcx),%edx
   156d4:	48 89 cb             	mov    %rcx,%rbx
   156d7:	84 d2                	test   %dl,%dl
   156d9:	0f 84 35 02 00 00    	je     15914 <get_net_rules+0x2f4>
   156df:	90                   	nop    
   156e0:	48 83 c3 01          	add    $0x1,%rbx
   156e4:	80 3b 00             	cmpb   $0x0,(%rbx)
   156e7:	75 f7                	jne    156e0 <get_net_rules+0xc0>
   156e9:	48 89 df             	mov    %rbx,%rdi
   156ec:	48 29 cf             	sub    %rcx,%rdi
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   156ef:	85 ff                	test   %edi,%edi
   156f1:	44 8d 57 0a          	lea    0xa(%rdi),%r10d
   156f5:	0f 84 19 02 00 00    	je     15914 <get_net_rules+0x2f4>
   156fb:	8d 77 ff             	lea    -0x1(%rdi),%esi
   156fe:	31 c0                	xor    %eax,%eax
        *d = *s;
   15700:	4d 8d 5c 24 0a       	lea    0xa(%r12),%r11
   15705:	48 89 f7             	mov    %rsi,%rdi
   15708:	48 83 c6 01          	add    $0x1,%rsi
   1570c:	eb 06                	jmp    15714 <get_net_rules+0xf4>
   1570e:	66 90                	xchg   %ax,%ax
   15710:	0f b6 14 01          	movzbl (%rcx,%rax,1),%edx
   15714:	41 88 14 03          	mov    %dl,(%r11,%rax,1)
   15718:	48 83 c0 01          	add    $0x1,%rax
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   1571c:	48 39 f0             	cmp    %rsi,%rax
   1571f:	75 ef                	jne    15710 <get_net_rules+0xf0>
   15721:	49 8d 44 3b 01       	lea    0x1(%r11,%rdi,1),%rax
        d++;
        s++;
        len--;
    }

    *d = 0;
   15726:	c6 00 00             	movb   $0x0,(%rax)
        int len = n - k;
        fast_strcpy(key + 10, k, len);
        key[10 + len] = 0;
   15729:	4d 63 d2             	movslq %r10d,%r10

        int cfglen = get_config(config, key, cfgbuf, CONFIG_MAX);
   1572c:	b9 00 01 00 00       	mov    $0x100,%ecx
   15731:	4c 89 f2             	mov    %r14,%rdx
   15734:	4c 89 e6             	mov    %r12,%rsi
   15737:	4c 89 ff             	mov    %r15,%rdi
        char cfgbuf[CONFIG_MAX];

        for (n = k ; *n ; n++);
        int len = n - k;
        fast_strcpy(key + 10, k, len);
        key[10 + len] = 0;
   1573a:	42 c6 84 15 d0 fd ff 	movb   $0x0,-0x230(%rbp,%r10,1)
   15741:	ff 00 

        int cfglen = get_config(config, key, cfgbuf, CONFIG_MAX);
   15743:	e8 68 27 00 00       	callq  17eb0 <get_config>
        if (cfglen <= 0)
   15748:	85 c0                	test   %eax,%eax
   1574a:	7e 42                	jle    1578e <get_net_rules+0x16e>
        char * c = cfgbuf, * end = cfgbuf + cfglen;
        char * num;
        int family = AF_INET;

        bind_addr = c;
        if (*c == '[') {
   1574c:	0f b6 8d d0 fe ff ff 	movzbl -0x130(%rbp),%ecx

        char * bind_addr;
        unsigned short bind_port_begin, bind_port_end;
        char * conn_addr;
        unsigned short conn_port_begin, conn_port_end;
        char * c = cfgbuf, * end = cfgbuf + cfglen;
   15753:	48 98                	cltq   
   15755:	49 8d 14 06          	lea    (%r14,%rax,1),%rdx
        char * num;
        int family = AF_INET;

        bind_addr = c;
        if (*c == '[') {
   15759:	80 f9 5b             	cmp    $0x5b,%cl
   1575c:	0f 84 be 00 00 00    	je     15820 <get_net_rules+0x200>
                goto next;
            *(c++) = 0;
            if (c == end || *c != ':')
                goto next;
        } else {
            for ( ; c < end && *c != ':' ; c++);
   15762:	4c 39 f2             	cmp    %r14,%rdx
   15765:	0f 86 b9 01 00 00    	jbe    15924 <get_net_rules+0x304>
   1576b:	80 f9 3a             	cmp    $0x3a,%cl
   1576e:	4c 89 f0             	mov    %r14,%rax
   15771:	75 12                	jne    15785 <get_net_rules+0x165>
   15773:	e9 ac 01 00 00       	jmpq   15924 <get_net_rules+0x304>
   15778:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1577f:	00 
   15780:	80 38 3a             	cmpb   $0x3a,(%rax)
   15783:	74 4b                	je     157d0 <get_net_rules+0x1b0>
   15785:	48 83 c0 01          	add    $0x1,%rax
   15789:	48 39 d0             	cmp    %rdx,%rax
   1578c:	75 f2                	jne    15780 <get_net_rules+0x160>
    int nrules = 0;
    char key[CONFIG_MAX], * k = keys, * n;

    fast_strcpy(key, "net.rules.", 10);

    for (int i = 0 ; i < nkeys ; i++) {
   1578e:	41 83 c5 01          	add    $0x1,%r13d
   15792:	44 3b ad cc fc ff ff 	cmp    -0x334(%rbp),%r13d
            goto next;
        r->peer.port_begin = conn_port_begin;
        r->peer.port_end = conn_port_end;
        nrules++;
next:
        k = n + 1;
   15799:	48 8d 4b 01          	lea    0x1(%rbx),%rcx
    int nrules = 0;
    char key[CONFIG_MAX], * k = keys, * n;

    fast_strcpy(key, "net.rules.", 10);

    for (int i = 0 ; i < nkeys ; i++) {
   1579d:	0f 85 2e ff ff ff    	jne    156d1 <get_net_rules+0xb1>
        nrules++;
next:
        k = n + 1;
    }

    *net_rules = rules;
   157a3:	48 8b 85 b8 fc ff ff 	mov    -0x348(%rbp),%rax
   157aa:	48 8b bd 98 fc ff ff 	mov    -0x368(%rbp),%rdi
   157b1:	48 89 38             	mov    %rdi,(%rax)
    return nrules;
   157b4:	8b 85 c8 fc ff ff    	mov    -0x338(%rbp),%eax
}
   157ba:	48 81 c4 68 03 00 00 	add    $0x368,%rsp
   157c1:	5b                   	pop    %rbx
   157c2:	41 5c                	pop    %r12
   157c4:	41 5d                	pop    %r13
   157c6:	41 5e                	pop    %r14
   157c8:	41 5f                	pop    %r15
   157ca:	5d                   	pop    %rbp
   157cb:	c3                   	retq   
   157cc:	0f 1f 40 00          	nopl   0x0(%rax)
        unsigned short bind_port_begin, bind_port_end;
        char * conn_addr;
        unsigned short conn_port_begin, conn_port_end;
        char * c = cfgbuf, * end = cfgbuf + cfglen;
        char * num;
        int family = AF_INET;
   157d0:	41 b9 02 00 00 00    	mov    $0x2,%r9d

        bind_addr = c;
   157d6:	4c 89 b5 c0 fc ff ff 	mov    %r14,-0x340(%rbp)
        } else {
            for ( ; c < end && *c != ':' ; c++);
            if (c == end)
                goto next;
        }
        *(c++) = 0;
   157dd:	48 8d 78 01          	lea    0x1(%rax),%rdi
   157e1:	c6 00 00             	movb   $0x0,(%rax)

        if (c == end)
   157e4:	48 39 d7             	cmp    %rdx,%rdi
   157e7:	74 a5                	je     1578e <get_net_rules+0x16e>
            goto next;
        num = c;
        for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
   157e9:	48 39 fa             	cmp    %rdi,%rdx
   157ec:	76 a0                	jbe    1578e <get_net_rules+0x16e>
   157ee:	0f b6 40 01          	movzbl 0x1(%rax),%eax
   157f2:	83 e8 30             	sub    $0x30,%eax
   157f5:	3c 09                	cmp    $0x9,%al
   157f7:	77 95                	ja     1578e <get_net_rules+0x16e>
   157f9:	48 89 fe             	mov    %rdi,%rsi
   157fc:	eb 0c                	jmp    1580a <get_net_rules+0x1ea>
   157fe:	66 90                	xchg   %ax,%ax
   15800:	0f b6 06             	movzbl (%rsi),%eax
   15803:	83 e8 30             	sub    $0x30,%eax
   15806:	3c 09                	cmp    $0x9,%al
   15808:	77 76                	ja     15880 <get_net_rules+0x260>
   1580a:	48 83 c6 01          	add    $0x1,%rsi
   1580e:	48 39 d6             	cmp    %rdx,%rsi
   15811:	75 ed                	jne    15800 <get_net_rules+0x1e0>
   15813:	e9 76 ff ff ff       	jmpq   1578e <get_net_rules+0x16e>
   15818:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1581f:	00 

        bind_addr = c;
        if (*c == '[') {
            family = AF_INET6;
            bind_addr++;
            for ( ; c < end && *c != ']' ; c++);
   15820:	4c 39 f2             	cmp    %r14,%rdx
   15823:	76 1e                	jbe    15843 <get_net_rules+0x223>
   15825:	4c 89 f1             	mov    %r14,%rcx
   15828:	eb 0b                	jmp    15835 <get_net_rules+0x215>
   1582a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
   15830:	80 39 5d             	cmpb   $0x5d,(%rcx)
   15833:	74 1b                	je     15850 <get_net_rules+0x230>
   15835:	48 83 c1 01          	add    $0x1,%rcx
   15839:	48 39 d1             	cmp    %rdx,%rcx
   1583c:	75 f2                	jne    15830 <get_net_rules+0x210>
   1583e:	e9 4b ff ff ff       	jmpq   1578e <get_net_rules+0x16e>
            if (c == end)
   15843:	0f 84 45 ff ff ff    	je     1578e <get_net_rules+0x16e>
   15849:	4c 89 f1             	mov    %r14,%rcx
   1584c:	0f 1f 40 00          	nopl   0x0(%rax)
                goto next;
            *(c++) = 0;
   15850:	48 8d 41 01          	lea    0x1(%rcx),%rax
   15854:	c6 01 00             	movb   $0x0,(%rcx)
            if (c == end || *c != ':')
   15857:	48 39 d0             	cmp    %rdx,%rax
   1585a:	0f 84 2e ff ff ff    	je     1578e <get_net_rules+0x16e>
   15860:	80 79 01 3a          	cmpb   $0x3a,0x1(%rcx)
   15864:	0f 85 24 ff ff ff    	jne    1578e <get_net_rules+0x16e>
        int family = AF_INET;

        bind_addr = c;
        if (*c == '[') {
            family = AF_INET6;
            bind_addr++;
   1586a:	49 8d 7e 01          	lea    0x1(%r14),%rdi
        char * num;
        int family = AF_INET;

        bind_addr = c;
        if (*c == '[') {
            family = AF_INET6;
   1586e:	41 b9 1c 00 00 00    	mov    $0x1c,%r9d
            bind_addr++;
   15874:	48 89 bd c0 fc ff ff 	mov    %rdi,-0x340(%rbp)
   1587b:	e9 5d ff ff ff       	jmpq   157dd <get_net_rules+0x1bd>

        if (c == end)
            goto next;
        num = c;
        for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
        if (c == num || c == end)
   15880:	48 39 fe             	cmp    %rdi,%rsi
   15883:	0f 84 05 ff ff ff    	je     1578e <get_net_rules+0x16e>
   15889:	48 89 b5 a0 fc ff ff 	mov    %rsi,-0x360(%rbp)
   15890:	48 89 95 a8 fc ff ff 	mov    %rdx,-0x358(%rbp)
   15897:	44 89 8d b0 fc ff ff 	mov    %r9d,-0x350(%rbp)
            goto next;
        bind_port_begin = atoi(num);
   1589e:	e8 4d 10 00 00       	callq  168f0 <atoi>
        if (*c == '-') {
   158a3:	48 8b b5 a0 fc ff ff 	mov    -0x360(%rbp),%rsi
            goto next;
        num = c;
        for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
        if (c == num || c == end)
            goto next;
        bind_port_begin = atoi(num);
   158aa:	41 89 c2             	mov    %eax,%r10d
        if (*c == '-') {
   158ad:	44 8b 8d b0 fc ff ff 	mov    -0x350(%rbp),%r9d
            for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
            if (c == num || c == end)
                goto next;
            bind_port_end = atoi(num);
        } else {
            bind_port_end = bind_port_begin;
   158b4:	44 89 d1             	mov    %r10d,%ecx
        num = c;
        for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
        if (c == num || c == end)
            goto next;
        bind_port_begin = atoi(num);
        if (*c == '-') {
   158b7:	48 8b 95 a8 fc ff ff 	mov    -0x358(%rbp),%rdx
   158be:	0f b6 06             	movzbl (%rsi),%eax
   158c1:	3c 2d                	cmp    $0x2d,%al
   158c3:	74 7d                	je     15942 <get_net_rules+0x322>
                goto next;
            bind_port_end = atoi(num);
        } else {
            bind_port_end = bind_port_begin;
        }
        if (*c != ':')
   158c5:	3c 3a                	cmp    $0x3a,%al
   158c7:	0f 85 c1 fe ff ff    	jne    1578e <get_net_rules+0x16e>
            goto next;
        c++;

        conn_addr = c;
        if (*c == '[') {
   158cd:	0f b6 46 01          	movzbl 0x1(%rsi),%eax
        } else {
            bind_port_end = bind_port_begin;
        }
        if (*c != ':')
            goto next;
        c++;
   158d1:	4c 8d 46 01          	lea    0x1(%rsi),%r8

        conn_addr = c;
        if (*c == '[') {
   158d5:	3c 5b                	cmp    $0x5b,%al
   158d7:	0f 84 1f 01 00 00    	je     159fc <get_net_rules+0x3dc>
                goto next;
            *(c++) = 0;
            if (c == end || *c != ':')
                goto next;
        } else {
            if (family != AF_INET)
   158dd:	41 83 f9 02          	cmp    $0x2,%r9d
   158e1:	0f 85 a7 fe ff ff    	jne    1578e <get_net_rules+0x16e>
                goto next;
            for ( ; c < end && *c != ':' ; c++);
   158e7:	4c 39 c2             	cmp    %r8,%rdx
   158ea:	0f 86 be 03 00 00    	jbe    15cae <get_net_rules+0x68e>
   158f0:	3c 3a                	cmp    $0x3a,%al
   158f2:	0f 84 b6 03 00 00    	je     15cae <get_net_rules+0x68e>
   158f8:	4c 89 c0             	mov    %r8,%rax
   158fb:	eb 09                	jmp    15906 <get_net_rules+0x2e6>
   158fd:	80 38 3a             	cmpb   $0x3a,(%rax)
   15900:	0f 84 44 01 00 00    	je     15a4a <get_net_rules+0x42a>
   15906:	48 83 c0 01          	add    $0x1,%rax
   1590a:	48 39 d0             	cmp    %rdx,%rax
   1590d:	75 ee                	jne    158fd <get_net_rules+0x2dd>
   1590f:	e9 7a fe ff ff       	jmpq   1578e <get_net_rules+0x16e>
    return 0;
}

static inline void fast_strcpy (char * d, const char * s, int len)
{
    while (len) {
   15914:	41 ba 0a 00 00 00    	mov    $0xa,%r10d
   1591a:	49 8d 44 24 0a       	lea    0xa(%r12),%rax
   1591f:	e9 02 fe ff ff       	jmpq   15726 <get_net_rules+0x106>
            *(c++) = 0;
            if (c == end || *c != ':')
                goto next;
        } else {
            for ( ; c < end && *c != ':' ; c++);
            if (c == end)
   15924:	4c 39 f2             	cmp    %r14,%rdx
   15927:	0f 84 61 fe ff ff    	je     1578e <get_net_rules+0x16e>
        unsigned short bind_port_begin, bind_port_end;
        char * conn_addr;
        unsigned short conn_port_begin, conn_port_end;
        char * c = cfgbuf, * end = cfgbuf + cfglen;
        char * num;
        int family = AF_INET;
   1592d:	41 b9 02 00 00 00    	mov    $0x2,%r9d
   15933:	4c 89 f0             	mov    %r14,%rax

        bind_addr = c;
   15936:	4c 89 b5 c0 fc ff ff 	mov    %r14,-0x340(%rbp)
   1593d:	e9 9b fe ff ff       	jmpq   157dd <get_net_rules+0x1bd>
        for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
        if (c == num || c == end)
            goto next;
        bind_port_begin = atoi(num);
        if (*c == '-') {
            num = (++c);
   15942:	48 8d 7e 01          	lea    0x1(%rsi),%rdi
            for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
   15946:	48 39 fa             	cmp    %rdi,%rdx
   15949:	0f 86 3f fe ff ff    	jbe    1578e <get_net_rules+0x16e>
   1594f:	0f b6 46 01          	movzbl 0x1(%rsi),%eax
   15953:	83 e8 30             	sub    $0x30,%eax
   15956:	3c 09                	cmp    $0x9,%al
   15958:	0f 87 30 fe ff ff    	ja     1578e <get_net_rules+0x16e>
   1595e:	49 89 fb             	mov    %rdi,%r11
   15961:	49 8d 73 01          	lea    0x1(%r11),%rsi
   15965:	48 39 d6             	cmp    %rdx,%rsi
   15968:	0f 84 20 fe ff ff    	je     1578e <get_net_rules+0x16e>
   1596e:	66 90                	xchg   %ax,%ax
   15970:	41 0f b6 43 01       	movzbl 0x1(%r11),%eax
   15975:	83 e8 30             	sub    $0x30,%eax
   15978:	3c 09                	cmp    $0x9,%al
   1597a:	77 11                	ja     1598d <get_net_rules+0x36d>
   1597c:	49 89 f3             	mov    %rsi,%r11
   1597f:	49 8d 73 01          	lea    0x1(%r11),%rsi
   15983:	48 39 d6             	cmp    %rdx,%rsi
   15986:	75 e8                	jne    15970 <get_net_rules+0x350>
   15988:	e9 01 fe ff ff       	jmpq   1578e <get_net_rules+0x16e>
            if (c == num || c == end)
   1598d:	48 39 fe             	cmp    %rdi,%rsi
   15990:	0f 84 f8 fd ff ff    	je     1578e <get_net_rules+0x16e>
   15996:	44 89 95 88 fc ff ff 	mov    %r10d,-0x378(%rbp)
   1599d:	48 89 b5 90 fc ff ff 	mov    %rsi,-0x370(%rbp)
   159a4:	48 89 95 a0 fc ff ff 	mov    %rdx,-0x360(%rbp)
   159ab:	44 89 8d a8 fc ff ff 	mov    %r9d,-0x358(%rbp)
   159b2:	4c 89 9d b0 fc ff ff 	mov    %r11,-0x350(%rbp)
                goto next;
            bind_port_end = atoi(num);
   159b9:	e8 32 0f 00 00       	callq  168f0 <atoi>
   159be:	4c 8b 9d b0 fc ff ff 	mov    -0x350(%rbp),%r11
   159c5:	89 c1                	mov    %eax,%ecx
   159c7:	44 8b 95 88 fc ff ff 	mov    -0x378(%rbp),%r10d
   159ce:	48 8b b5 90 fc ff ff 	mov    -0x370(%rbp),%rsi
   159d5:	48 8b 95 a0 fc ff ff 	mov    -0x360(%rbp),%rdx
   159dc:	44 8b 8d a8 fc ff ff 	mov    -0x358(%rbp),%r9d
   159e3:	41 0f b6 43 01       	movzbl 0x1(%r11),%eax
   159e8:	e9 d8 fe ff ff       	jmpq   158c5 <get_net_rules+0x2a5>
            malloc(sizeof(struct graphene_net_policy) * nkeys);

    if (!rules)
        return -ENOMEM;

    int nrules = 0;
   159ed:	c7 85 c8 fc ff ff 00 	movl   $0x0,-0x338(%rbp)
   159f4:	00 00 00 
   159f7:	e9 a7 fd ff ff       	jmpq   157a3 <get_net_rules+0x183>
            goto next;
        c++;

        conn_addr = c;
        if (*c == '[') {
            if (family != AF_INET6)
   159fc:	41 83 f9 1c          	cmp    $0x1c,%r9d
   15a00:	0f 85 88 fd ff ff    	jne    1578e <get_net_rules+0x16e>
                goto next;
            conn_addr++;
            for ( ; c < end && *c != ']' ; c++);
   15a06:	4c 39 c2             	cmp    %r8,%rdx
   15a09:	77 0b                	ja     15a16 <get_net_rules+0x3f6>
   15a0b:	eb 17                	jmp    15a24 <get_net_rules+0x404>
   15a0d:	0f 1f 00             	nopl   (%rax)
   15a10:	41 80 38 5d          	cmpb   $0x5d,(%r8)
   15a14:	74 14                	je     15a2a <get_net_rules+0x40a>
   15a16:	49 83 c0 01          	add    $0x1,%r8
   15a1a:	49 39 d0             	cmp    %rdx,%r8
   15a1d:	75 f1                	jne    15a10 <get_net_rules+0x3f0>
   15a1f:	e9 6a fd ff ff       	jmpq   1578e <get_net_rules+0x16e>
            if (c == end)
   15a24:	0f 84 64 fd ff ff    	je     1578e <get_net_rules+0x16e>
                goto next;
            *(c++) = 0;
   15a2a:	49 8d 40 01          	lea    0x1(%r8),%rax
   15a2e:	41 c6 00 00          	movb   $0x0,(%r8)
            if (c == end || *c != ':')
   15a32:	48 39 d0             	cmp    %rdx,%rax
   15a35:	0f 84 53 fd ff ff    	je     1578e <get_net_rules+0x16e>
   15a3b:	41 80 78 01 3a       	cmpb   $0x3a,0x1(%r8)
   15a40:	0f 85 48 fd ff ff    	jne    1578e <get_net_rules+0x16e>

        conn_addr = c;
        if (*c == '[') {
            if (family != AF_INET6)
                goto next;
            conn_addr++;
   15a46:	4c 8d 46 02          	lea    0x2(%rsi),%r8
                goto next;
            for ( ; c < end && *c != ':' ; c++);
            if (c == end)
                goto next;
        }
        *(c++) = 0;
   15a4a:	48 8d 78 01          	lea    0x1(%rax),%rdi
   15a4e:	c6 00 00             	movb   $0x0,(%rax)

        if (c == end)
   15a51:	48 39 d7             	cmp    %rdx,%rdi
   15a54:	0f 84 34 fd ff ff    	je     1578e <get_net_rules+0x16e>
            goto next;
        num = c;
        for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
   15a5a:	48 39 fa             	cmp    %rdi,%rdx
   15a5d:	0f 86 2b fd ff ff    	jbe    1578e <get_net_rules+0x16e>
   15a63:	0f b6 40 01          	movzbl 0x1(%rax),%eax
   15a67:	83 e8 30             	sub    $0x30,%eax
   15a6a:	3c 09                	cmp    $0x9,%al
   15a6c:	0f 87 1c fd ff ff    	ja     1578e <get_net_rules+0x16e>
   15a72:	48 89 fe             	mov    %rdi,%rsi
   15a75:	eb 17                	jmp    15a8e <get_net_rules+0x46e>
   15a77:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   15a7e:	00 00 
   15a80:	0f b6 06             	movzbl (%rsi),%eax
   15a83:	83 e8 30             	sub    $0x30,%eax
   15a86:	3c 09                	cmp    $0x9,%al
   15a88:	0f 87 22 01 00 00    	ja     15bb0 <get_net_rules+0x590>
   15a8e:	48 83 c6 01          	add    $0x1,%rsi
   15a92:	48 39 d6             	cmp    %rdx,%rsi
   15a95:	75 e9                	jne    15a80 <get_net_rules+0x460>
   15a97:	89 8d 80 fc ff ff    	mov    %ecx,-0x380(%rbp)
   15a9d:	4c 89 85 88 fc ff ff 	mov    %r8,-0x378(%rbp)
   15aa4:	44 89 8d 90 fc ff ff 	mov    %r9d,-0x370(%rbp)
   15aab:	44 89 95 a0 fc ff ff 	mov    %r10d,-0x360(%rbp)
        if (c == num)
            goto next;
        conn_port_begin = atoi(num);
   15ab2:	e8 39 0e 00 00       	callq  168f0 <atoi>
   15ab7:	44 8b 95 a0 fc ff ff 	mov    -0x360(%rbp),%r10d
   15abe:	44 8b 8d 90 fc ff ff 	mov    -0x370(%rbp),%r9d
   15ac5:	4c 8b 85 88 fc ff ff 	mov    -0x378(%rbp),%r8
   15acc:	8b 8d 80 fc ff ff    	mov    -0x380(%rbp),%ecx
   15ad2:	66 89 85 a8 fc ff ff 	mov    %ax,-0x358(%rbp)
   15ad9:	66 89 85 b0 fc ff ff 	mov    %ax,-0x350(%rbp)
    char key[CONFIG_MAX], * k = keys, * n;

    fast_strcpy(key, "net.rules.", 10);

    for (int i = 0 ; i < nkeys ; i++) {
        struct graphene_net_policy * r = &rules[nrules];
   15ae0:	48 63 85 c8 fc ff ff 	movslq -0x338(%rbp),%rax
   15ae7:	48 8b bd 98 fc ff ff 	mov    -0x368(%rbp),%rdi
        if (c != end)
            goto next;
        c++;

        r->family = family;
        if (inet_pton(family, bind_addr, &r->local.addr) < 0)
   15aee:	48 8b b5 c0 fc ff ff 	mov    -0x340(%rbp),%rsi
   15af5:	44 89 95 78 fc ff ff 	mov    %r10d,-0x388(%rbp)
   15afc:	4c 89 85 80 fc ff ff 	mov    %r8,-0x380(%rbp)
   15b03:	89 8d 88 fc ff ff    	mov    %ecx,-0x378(%rbp)
   15b09:	44 89 8d a0 fc ff ff 	mov    %r9d,-0x360(%rbp)
    char key[CONFIG_MAX], * k = keys, * n;

    fast_strcpy(key, "net.rules.", 10);

    for (int i = 0 ; i < nkeys ; i++) {
        struct graphene_net_policy * r = &rules[nrules];
   15b10:	48 8d 14 80          	lea    (%rax,%rax,4),%rdx
   15b14:	48 8d 04 50          	lea    (%rax,%rdx,2),%rax
   15b18:	4c 8d 1c 87          	lea    (%rdi,%rax,4),%r11
        if (c != end)
            goto next;
        c++;

        r->family = family;
        if (inet_pton(family, bind_addr, &r->local.addr) < 0)
   15b1c:	44 89 cf             	mov    %r9d,%edi
   15b1f:	49 8d 53 04          	lea    0x4(%r11),%rdx
        }
        if (c != end)
            goto next;
        c++;

        r->family = family;
   15b23:	66 45 89 0b          	mov    %r9w,(%r11)
        if (inet_pton(family, bind_addr, &r->local.addr) < 0)
   15b27:	4c 89 9d 90 fc ff ff 	mov    %r11,-0x370(%rbp)
   15b2e:	e8 fd 17 00 00       	callq  17330 <__inet_pton>
   15b33:	85 c0                	test   %eax,%eax
   15b35:	0f 88 53 fc ff ff    	js     1578e <get_net_rules+0x16e>
            goto next;
        r->local.port_begin = bind_port_begin;
   15b3b:	4c 8b 9d 90 fc ff ff 	mov    -0x370(%rbp),%r11
   15b42:	44 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%r10d
        r->local.port_end = bind_port_end;
   15b49:	8b 8d 88 fc ff ff    	mov    -0x378(%rbp),%ecx
        if (inet_pton(family, conn_addr, &r->peer.addr) < 0)
   15b4f:	4c 8b 85 80 fc ff ff 	mov    -0x380(%rbp),%r8
   15b56:	44 8b 8d a0 fc ff ff 	mov    -0x360(%rbp),%r9d
   15b5d:	49 8d 53 18          	lea    0x18(%r11),%rdx
        c++;

        r->family = family;
        if (inet_pton(family, bind_addr, &r->local.addr) < 0)
            goto next;
        r->local.port_begin = bind_port_begin;
   15b61:	66 45 89 53 14       	mov    %r10w,0x14(%r11)
        r->local.port_end = bind_port_end;
        if (inet_pton(family, conn_addr, &r->peer.addr) < 0)
   15b66:	4c 89 9d c0 fc ff ff 	mov    %r11,-0x340(%rbp)

        r->family = family;
        if (inet_pton(family, bind_addr, &r->local.addr) < 0)
            goto next;
        r->local.port_begin = bind_port_begin;
        r->local.port_end = bind_port_end;
   15b6d:	66 41 89 4b 16       	mov    %cx,0x16(%r11)
        if (inet_pton(family, conn_addr, &r->peer.addr) < 0)
   15b72:	4c 89 c6             	mov    %r8,%rsi
   15b75:	44 89 cf             	mov    %r9d,%edi
   15b78:	e8 b3 17 00 00       	callq  17330 <__inet_pton>
   15b7d:	85 c0                	test   %eax,%eax
   15b7f:	0f 88 09 fc ff ff    	js     1578e <get_net_rules+0x16e>
            goto next;
        r->peer.port_begin = conn_port_begin;
   15b85:	0f b7 bd a8 fc ff ff 	movzwl -0x358(%rbp),%edi
   15b8c:	4c 8b 9d c0 fc ff ff 	mov    -0x340(%rbp),%r11
        r->peer.port_end = conn_port_end;
        nrules++;
   15b93:	83 85 c8 fc ff ff 01 	addl   $0x1,-0x338(%rbp)
            goto next;
        r->local.port_begin = bind_port_begin;
        r->local.port_end = bind_port_end;
        if (inet_pton(family, conn_addr, &r->peer.addr) < 0)
            goto next;
        r->peer.port_begin = conn_port_begin;
   15b9a:	66 41 89 7b 28       	mov    %di,0x28(%r11)
        r->peer.port_end = conn_port_end;
   15b9f:	0f b7 bd b0 fc ff ff 	movzwl -0x350(%rbp),%edi
   15ba6:	66 41 89 7b 2a       	mov    %di,0x2a(%r11)
   15bab:	e9 de fb ff ff       	jmpq   1578e <get_net_rules+0x16e>

        if (c == end)
            goto next;
        num = c;
        for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
        if (c == num)
   15bb0:	48 39 fe             	cmp    %rdi,%rsi
   15bb3:	0f 84 d5 fb ff ff    	je     1578e <get_net_rules+0x16e>
   15bb9:	48 89 b5 78 fc ff ff 	mov    %rsi,-0x388(%rbp)
   15bc0:	44 89 95 80 fc ff ff 	mov    %r10d,-0x380(%rbp)
   15bc7:	48 89 95 88 fc ff ff 	mov    %rdx,-0x378(%rbp)
   15bce:	44 89 8d 90 fc ff ff 	mov    %r9d,-0x370(%rbp)
   15bd5:	4c 89 85 a0 fc ff ff 	mov    %r8,-0x360(%rbp)
   15bdc:	89 8d b0 fc ff ff    	mov    %ecx,-0x350(%rbp)
            goto next;
        conn_port_begin = atoi(num);
   15be2:	e8 09 0d 00 00       	callq  168f0 <atoi>
        if (c < end && *c == '-') {
   15be7:	48 8b b5 78 fc ff ff 	mov    -0x388(%rbp),%rsi
            goto next;
        num = c;
        for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
        if (c == num)
            goto next;
        conn_port_begin = atoi(num);
   15bee:	66 89 85 a8 fc ff ff 	mov    %ax,-0x358(%rbp)
        if (c < end && *c == '-') {
   15bf5:	8b 8d b0 fc ff ff    	mov    -0x350(%rbp),%ecx
   15bfb:	4c 8b 85 a0 fc ff ff 	mov    -0x360(%rbp),%r8
   15c02:	44 8b 8d 90 fc ff ff 	mov    -0x370(%rbp),%r9d
   15c09:	48 8b 95 88 fc ff ff 	mov    -0x378(%rbp),%rdx
   15c10:	80 3e 2d             	cmpb   $0x2d,(%rsi)
   15c13:	44 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%r10d
   15c1a:	0f 85 6e fb ff ff    	jne    1578e <get_net_rules+0x16e>
            num = (++c);
   15c20:	48 8d 7e 01          	lea    0x1(%rsi),%rdi
            for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
   15c24:	48 39 fa             	cmp    %rdi,%rdx
   15c27:	0f 86 61 fb ff ff    	jbe    1578e <get_net_rules+0x16e>
   15c2d:	0f b6 46 01          	movzbl 0x1(%rsi),%eax
   15c31:	83 e8 30             	sub    $0x30,%eax
   15c34:	3c 09                	cmp    $0x9,%al
   15c36:	0f 87 52 fb ff ff    	ja     1578e <get_net_rules+0x16e>
   15c3c:	48 89 fe             	mov    %rdi,%rsi
   15c3f:	eb 0a                	jmp    15c4b <get_net_rules+0x62b>
   15c41:	0f b6 06             	movzbl (%rsi),%eax
   15c44:	83 e8 30             	sub    $0x30,%eax
   15c47:	3c 09                	cmp    $0x9,%al
   15c49:	77 74                	ja     15cbf <get_net_rules+0x69f>
   15c4b:	48 83 c6 01          	add    $0x1,%rsi
   15c4f:	48 39 d6             	cmp    %rdx,%rsi
   15c52:	75 ed                	jne    15c41 <get_net_rules+0x621>
            if (c == num)
   15c54:	48 39 f7             	cmp    %rsi,%rdi
   15c57:	0f 84 31 fb ff ff    	je     1578e <get_net_rules+0x16e>
   15c5d:	44 89 95 80 fc ff ff 	mov    %r10d,-0x380(%rbp)
   15c64:	44 89 8d 88 fc ff ff 	mov    %r9d,-0x378(%rbp)
   15c6b:	4c 89 85 90 fc ff ff 	mov    %r8,-0x370(%rbp)
   15c72:	89 8d a0 fc ff ff    	mov    %ecx,-0x360(%rbp)
                goto next;
            conn_port_end = atoi(num);
   15c78:	e8 73 0c 00 00       	callq  168f0 <atoi>
   15c7d:	8b 8d a0 fc ff ff    	mov    -0x360(%rbp),%ecx
   15c83:	66 89 85 b0 fc ff ff 	mov    %ax,-0x350(%rbp)
   15c8a:	4c 8b 85 90 fc ff ff 	mov    -0x370(%rbp),%r8
   15c91:	44 8b 8d 88 fc ff ff 	mov    -0x378(%rbp),%r9d
   15c98:	44 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%r10d
   15c9f:	e9 3c fe ff ff       	jmpq   15ae0 <get_net_rules+0x4c0>

    struct graphene_net_policy * rules =
            malloc(sizeof(struct graphene_net_policy) * nkeys);

    if (!rules)
        return -ENOMEM;
   15ca4:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   15ca9:	e9 0c fb ff ff       	jmpq   157ba <get_net_rules+0x19a>
                goto next;
        } else {
            if (family != AF_INET)
                goto next;
            for ( ; c < end && *c != ':' ; c++);
            if (c == end)
   15cae:	4c 39 c2             	cmp    %r8,%rdx
   15cb1:	0f 84 d7 fa ff ff    	je     1578e <get_net_rules+0x16e>
   15cb7:	4c 89 c0             	mov    %r8,%rax
   15cba:	e9 8b fd ff ff       	jmpq   15a4a <get_net_rules+0x42a>
            goto next;
        conn_port_begin = atoi(num);
        if (c < end && *c == '-') {
            num = (++c);
            for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
            if (c == num)
   15cbf:	48 39 f7             	cmp    %rsi,%rdi
   15cc2:	0f 84 c6 fa ff ff    	je     1578e <get_net_rules+0x16e>
   15cc8:	48 89 b5 70 fc ff ff 	mov    %rsi,-0x390(%rbp)
   15ccf:	44 89 95 78 fc ff ff 	mov    %r10d,-0x388(%rbp)
   15cd6:	48 89 95 80 fc ff ff 	mov    %rdx,-0x380(%rbp)
   15cdd:	44 89 8d 88 fc ff ff 	mov    %r9d,-0x378(%rbp)
   15ce4:	4c 89 85 90 fc ff ff 	mov    %r8,-0x370(%rbp)
   15ceb:	89 8d a0 fc ff ff    	mov    %ecx,-0x360(%rbp)
                goto next;
            conn_port_end = atoi(num);
   15cf1:	e8 fa 0b 00 00       	callq  168f0 <atoi>
        } else {
            conn_port_end = conn_port_begin;
        }
        if (c != end)
   15cf6:	48 8b 95 80 fc ff ff 	mov    -0x380(%rbp),%rdx
   15cfd:	48 8b b5 70 fc ff ff 	mov    -0x390(%rbp),%rsi
        if (c < end && *c == '-') {
            num = (++c);
            for ( ; c < end && *c >= '0' && *c <= '9' ; c++);
            if (c == num)
                goto next;
            conn_port_end = atoi(num);
   15d04:	66 89 85 b0 fc ff ff 	mov    %ax,-0x350(%rbp)
        } else {
            conn_port_end = conn_port_begin;
        }
        if (c != end)
   15d0b:	8b 8d a0 fc ff ff    	mov    -0x360(%rbp),%ecx
   15d11:	4c 8b 85 90 fc ff ff 	mov    -0x370(%rbp),%r8
   15d18:	44 8b 8d 88 fc ff ff 	mov    -0x378(%rbp),%r9d
   15d1f:	48 39 f2             	cmp    %rsi,%rdx
   15d22:	44 8b 95 78 fc ff ff 	mov    -0x388(%rbp),%r10d
   15d29:	0f 85 5f fa ff ff    	jne    1578e <get_net_rules+0x16e>
   15d2f:	e9 ac fd ff ff       	jmpq   15ae0 <get_net_rules+0x4c0>
   15d34:	66 66 66 2e 0f 1f 84 	nopw   %cs:0x0(%rax,%rax,1)
   15d3b:	00 00 00 00 00 

0000000000015d40 <ioctl_set_graphene>:
    return nrules;
}

int ioctl_set_graphene (struct config_store * config, int ndefault,
                        const struct graphene_user_policy * default_policies)
{
   15d40:	55                   	push   %rbp
   15d41:	48 89 e5             	mov    %rsp,%rbp
   15d44:	41 57                	push   %r15
   15d46:	41 56                	push   %r14
   15d48:	41 55                	push   %r13
   15d4a:	41 54                	push   %r12
   15d4c:	49 89 ff             	mov    %rdi,%r15
   15d4f:	53                   	push   %rbx
   15d50:	89 f3                	mov    %esi,%ebx
    struct graphene_net_policy * net_rules = NULL;
    int npreload = 0, nfs = 0, net = 0;
    int fd = -1;
    int n = 0;

    npreload = get_preload_paths(config, &preload_paths);
   15d52:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
    return nrules;
}

int ioctl_set_graphene (struct config_store * config, int ndefault,
                        const struct graphene_user_policy * default_policies)
{
   15d56:	48 83 ec 48          	sub    $0x48,%rsp
   15d5a:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
    int ro = GRAPHENE_FS_READ, rw = ro | GRAPHENE_FS_WRITE;
    int ret = 0;
    const char ** preload_paths = NULL;
   15d5e:	48 c7 45 b8 00 00 00 	movq   $0x0,-0x48(%rbp)
   15d65:	00 
    const char ** fs_paths = NULL;
   15d66:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
   15d6d:	00 
    struct graphene_net_policy * net_rules = NULL;
   15d6e:	48 c7 45 c8 00 00 00 	movq   $0x0,-0x38(%rbp)
   15d75:	00 
    int npreload = 0, nfs = 0, net = 0;
    int fd = -1;
    int n = 0;

    npreload = get_preload_paths(config, &preload_paths);
   15d76:	e8 55 f5 ff ff       	callq  152d0 <get_preload_paths>
    if (npreload < 0) {
   15d7b:	85 c0                	test   %eax,%eax
    struct graphene_net_policy * net_rules = NULL;
    int npreload = 0, nfs = 0, net = 0;
    int fd = -1;
    int n = 0;

    npreload = get_preload_paths(config, &preload_paths);
   15d7d:	41 89 c6             	mov    %eax,%r14d
    if (npreload < 0) {
   15d80:	0f 88 4a 02 00 00    	js     15fd0 <ioctl_set_graphene+0x290>
        ret = npreload;
        goto out;
    }

    nfs = get_fs_paths(config, &fs_paths);
   15d86:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
   15d8a:	4c 89 ff             	mov    %r15,%rdi
   15d8d:	e8 de f6 ff ff       	callq  15470 <get_fs_paths>
    if (nfs < 0) {
   15d92:	85 c0                	test   %eax,%eax
    if (npreload < 0) {
        ret = npreload;
        goto out;
    }

    nfs = get_fs_paths(config, &fs_paths);
   15d94:	41 89 c5             	mov    %eax,%r13d
   15d97:	41 89 c4             	mov    %eax,%r12d
    if (nfs < 0) {
   15d9a:	0f 88 a2 01 00 00    	js     15f42 <ioctl_set_graphene+0x202>
        ret = nfs;
        goto out;
    }

    net = get_net_rules(config, &net_rules);
   15da0:	48 8d 75 c8          	lea    -0x38(%rbp),%rsi
   15da4:	4c 89 ff             	mov    %r15,%rdi
   15da7:	e8 74 f8 ff ff       	callq  15620 <get_net_rules>
    if (net < 0) {
   15dac:	85 c0                	test   %eax,%eax
    if (nfs < 0) {
        ret = nfs;
        goto out;
    }

    net = get_net_rules(config, &net_rules);
   15dae:	41 89 c4             	mov    %eax,%r12d
    if (net < 0) {
   15db1:	0f 88 8b 01 00 00    	js     15f42 <ioctl_set_graphene+0x202>
    }

    struct graphene_policies * p =
                __alloca(sizeof(struct graphene_policies) +
                         sizeof(struct graphene_user_policy) *
                         (ndefault + npreload + nfs + net));
   15db7:	46 8d 0c 33          	lea    (%rbx,%r14,1),%r9d

    memcpy(&p->policies[n], default_policies,
   15dbb:	48 63 cb             	movslq %ebx,%rcx
   15dbe:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
   15dc2:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
    }

    struct graphene_policies * p =
                __alloca(sizeof(struct graphene_policies) +
                         sizeof(struct graphene_user_policy) *
                         (ndefault + npreload + nfs + net));
   15dc6:	43 8d 04 29          	lea    (%r9,%r13,1),%eax
   15dca:	44 89 4d 9c          	mov    %r9d,-0x64(%rbp)
   15dce:	44 01 e0             	add    %r12d,%eax
        goto out;
    }

    struct graphene_policies * p =
                __alloca(sizeof(struct graphene_policies) +
                         sizeof(struct graphene_user_policy) *
   15dd1:	48 98                	cltq   
   15dd3:	48 c1 e0 04          	shl    $0x4,%rax
    if (net < 0) {
        ret = net;
        goto out;
    }

    struct graphene_policies * p =
   15dd7:	48 83 c0 20          	add    $0x20,%rax
   15ddb:	48 29 c4             	sub    %rax,%rsp
                __alloca(sizeof(struct graphene_policies) +
                         sizeof(struct graphene_user_policy) *
                         (ndefault + npreload + nfs + net));

    memcpy(&p->policies[n], default_policies,
   15dde:	48 89 c8             	mov    %rcx,%rax
    if (net < 0) {
        ret = net;
        goto out;
    }

    struct graphene_policies * p =
   15de1:	4c 8d 7c 24 0f       	lea    0xf(%rsp),%r15
                __alloca(sizeof(struct graphene_policies) +
                         sizeof(struct graphene_user_policy) *
                         (ndefault + npreload + nfs + net));

    memcpy(&p->policies[n], default_policies,
   15de6:	48 c1 e0 04          	shl    $0x4,%rax
   15dea:	48 89 c2             	mov    %rax,%rdx
    if (net < 0) {
        ret = net;
        goto out;
    }

    struct graphene_policies * p =
   15ded:	49 83 e7 f0          	and    $0xfffffffffffffff0,%r15
                __alloca(sizeof(struct graphene_policies) +
                         sizeof(struct graphene_user_policy) *
                         (ndefault + npreload + nfs + net));

    memcpy(&p->policies[n], default_policies,
   15df1:	49 8d 7f 08          	lea    0x8(%r15),%rdi
   15df5:	e8 86 04 00 00       	callq  16280 <memcpy>
           sizeof(struct graphene_user_policy) * ndefault);
    n += ndefault;

    for (int i = 0 ; i < npreload ; i++) {
   15dfa:	45 85 f6             	test   %r14d,%r14d
   15dfd:	0f 84 f7 01 00 00    	je     15ffa <ioctl_set_graphene+0x2ba>
   15e03:	44 8b 4d 9c          	mov    -0x64(%rbp),%r9d
   15e07:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
   15e0b:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
   15e0f:	44 89 ca             	mov    %r9d,%edx
   15e12:	eb 03                	jmp    15e17 <ioctl_set_graphene+0xd7>
   15e14:	48 63 cb             	movslq %ebx,%rcx
   15e17:	48 c1 e1 04          	shl    $0x4,%rcx
        p->policies[n].type = GRAPHENE_FS_PATH | ro;
        p->policies[n].value = preload_paths[i];
        n++;
   15e1b:	83 c3 01             	add    $0x1,%ebx
   15e1e:	48 83 c6 08          	add    $0x8,%rsi
   15e22:	49 8d 04 0f          	lea    (%r15,%rcx,1),%rax
    memcpy(&p->policies[n], default_policies,
           sizeof(struct graphene_user_policy) * ndefault);
    n += ndefault;

    for (int i = 0 ; i < npreload ; i++) {
        p->policies[n].type = GRAPHENE_FS_PATH | ro;
   15e26:	c7 40 08 16 00 00 00 	movl   $0x16,0x8(%rax)
        p->policies[n].value = preload_paths[i];
   15e2d:	48 8b 4e f8          	mov    -0x8(%rsi),%rcx

    memcpy(&p->policies[n], default_policies,
           sizeof(struct graphene_user_policy) * ndefault);
    n += ndefault;

    for (int i = 0 ; i < npreload ; i++) {
   15e31:	44 39 cb             	cmp    %r9d,%ebx
        p->policies[n].type = GRAPHENE_FS_PATH | ro;
        p->policies[n].value = preload_paths[i];
   15e34:	48 89 48 10          	mov    %rcx,0x10(%rax)

    memcpy(&p->policies[n], default_policies,
           sizeof(struct graphene_user_policy) * ndefault);
    n += ndefault;

    for (int i = 0 ; i < npreload ; i++) {
   15e38:	75 da                	jne    15e14 <ioctl_set_graphene+0xd4>
        p->policies[n].type = GRAPHENE_FS_PATH | ro;
        p->policies[n].value = preload_paths[i];
        n++;
    }

    for (int i = 0 ; i < nfs ; i++) {
   15e3a:	45 85 ed             	test   %r13d,%r13d
   15e3d:	0f 84 b0 01 00 00    	je     15ff3 <ioctl_set_graphene+0x2b3>
   15e43:	46 8d 04 2a          	lea    (%rdx,%r13,1),%r8d
   15e47:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
   15e4b:	44 89 c0             	mov    %r8d,%eax
   15e4e:	66 90                	xchg   %ax,%ax
   15e50:	48 63 ca             	movslq %edx,%rcx
        p->policies[n].type = GRAPHENE_FS_RECURSIVE | rw;
        p->policies[n].value = fs_paths[i];
        n++;
   15e53:	83 c2 01             	add    $0x1,%edx
   15e56:	48 83 c6 08          	add    $0x8,%rsi
   15e5a:	48 c1 e1 04          	shl    $0x4,%rcx
   15e5e:	4c 01 f9             	add    %r15,%rcx
        p->policies[n].value = preload_paths[i];
        n++;
    }

    for (int i = 0 ; i < nfs ; i++) {
        p->policies[n].type = GRAPHENE_FS_RECURSIVE | rw;
   15e61:	c7 41 08 37 00 00 00 	movl   $0x37,0x8(%rcx)
        p->policies[n].value = fs_paths[i];
   15e68:	48 8b 7e f8          	mov    -0x8(%rsi),%rdi
        p->policies[n].type = GRAPHENE_FS_PATH | ro;
        p->policies[n].value = preload_paths[i];
        n++;
    }

    for (int i = 0 ; i < nfs ; i++) {
   15e6c:	44 39 c2             	cmp    %r8d,%edx
        p->policies[n].type = GRAPHENE_FS_RECURSIVE | rw;
        p->policies[n].value = fs_paths[i];
   15e6f:	48 89 79 10          	mov    %rdi,0x10(%rcx)
        p->policies[n].type = GRAPHENE_FS_PATH | ro;
        p->policies[n].value = preload_paths[i];
        n++;
    }

    for (int i = 0 ; i < nfs ; i++) {
   15e73:	75 db                	jne    15e50 <ioctl_set_graphene+0x110>
        p->policies[n].type = GRAPHENE_FS_RECURSIVE | rw;
        p->policies[n].value = fs_paths[i];
        n++;
    }

    for (int i = 0 ; i < net ; i++) {
   15e75:	45 85 e4             	test   %r12d,%r12d
   15e78:	0f 84 6e 01 00 00    	je     15fec <ioctl_set_graphene+0x2ac>
   15e7e:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
   15e82:	41 01 c4             	add    %eax,%r12d
   15e85:	44 89 e6             	mov    %r12d,%esi
   15e88:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   15e8f:	00 
   15e90:	48 63 c8             	movslq %eax,%rcx
        p->policies[n].type = GRAPHENE_NET_RULE;
        p->policies[n].value = &net_rules[i];
        n++;
   15e93:	83 c0 01             	add    $0x1,%eax
   15e96:	48 c1 e1 04          	shl    $0x4,%rcx
   15e9a:	4c 01 f9             	add    %r15,%rcx
        n++;
    }

    for (int i = 0 ; i < net ; i++) {
        p->policies[n].type = GRAPHENE_NET_RULE;
        p->policies[n].value = &net_rules[i];
   15e9d:	48 89 51 10          	mov    %rdx,0x10(%rcx)
   15ea1:	48 83 c2 2c          	add    $0x2c,%rdx
        p->policies[n].type = GRAPHENE_FS_RECURSIVE | rw;
        p->policies[n].value = fs_paths[i];
        n++;
    }

    for (int i = 0 ; i < net ; i++) {
   15ea5:	44 39 e0             	cmp    %r12d,%eax
        p->policies[n].type = GRAPHENE_NET_RULE;
   15ea8:	c7 41 08 05 00 00 00 	movl   $0x5,0x8(%rcx)
        p->policies[n].type = GRAPHENE_FS_RECURSIVE | rw;
        p->policies[n].value = fs_paths[i];
        n++;
    }

    for (int i = 0 ; i < net ; i++) {
   15eaf:	75 df                	jne    15e90 <ioctl_set_graphene+0x150>
        n++;
    }

    p->npolicies = n;

    fd = INLINE_SYSCALL(open, 3, GRAPHENE_FILE, O_RDONLY, 0);
   15eb1:	b9 05 00 00 00       	mov    $0x5,%ecx
        p->policies[n].type = GRAPHENE_NET_RULE;
        p->policies[n].value = &net_rules[i];
        n++;
    }

    p->npolicies = n;
   15eb6:	41 89 37             	mov    %esi,(%r15)

    fd = INLINE_SYSCALL(open, 3, GRAPHENE_FILE, O_RDONLY, 0);
   15eb9:	31 d2                	xor    %edx,%edx
   15ebb:	31 f6                	xor    %esi,%esi
   15ebd:	48 8d 3d 0a 90 00 00 	lea    0x900a(%rip),%rdi        # 1eece <CSWTCH.16+0x8e>
   15ec4:	89 c8                	mov    %ecx,%eax
   15ec6:	cd 80                	int    $0x80
   15ec8:	48 89 c7             	mov    %rax,%rdi
   15ecb:	bb 00 00 00 00       	mov    $0x0,%ebx
   15ed0:	83 d3 00             	adc    $0x0,%ebx
   15ed3:	31 d2                	xor    %edx,%edx
   15ed5:	85 db                	test   %ebx,%ebx
   15ed7:	0f 95 c2             	setne  %dl
   15eda:	48 89 d0             	mov    %rdx,%rax
   15edd:	48 f7 d8             	neg    %rax
   15ee0:	48 31 f8             	xor    %rdi,%rax
   15ee3:	48 8d 3c 10          	lea    (%rax,%rdx,1),%rdi
    if (IS_ERR(fd)) {
   15ee7:	85 ff                	test   %edi,%edi
        n++;
    }

    p->npolicies = n;

    fd = INLINE_SYSCALL(open, 3, GRAPHENE_FILE, O_RDONLY, 0);
   15ee9:	41 89 fc             	mov    %edi,%r12d
    if (IS_ERR(fd)) {
   15eec:	0f 88 e9 00 00 00    	js     15fdb <ioctl_set_graphene+0x29b>
        ret = -ERRNO(fd);
        goto out;
    }

    ret = INLINE_SYSCALL(ioctl, 3, fd, GRAPHENE_SET_TASK, p);
   15ef2:	48 63 cf             	movslq %edi,%rcx
   15ef5:	bb 36 00 00 00       	mov    $0x36,%ebx
   15efa:	4c 89 fa             	mov    %r15,%rdx
   15efd:	be 10 6b 00 20       	mov    $0x20006b10,%esi
   15f02:	48 89 cf             	mov    %rcx,%rdi
   15f05:	89 d8                	mov    %ebx,%eax
   15f07:	cd 80                	int    $0x80
   15f09:	48 89 c6             	mov    %rax,%rsi
   15f0c:	bb 00 00 00 00       	mov    $0x0,%ebx
   15f11:	83 d3 00             	adc    $0x0,%ebx
   15f14:	31 d2                	xor    %edx,%edx
   15f16:	85 db                	test   %ebx,%ebx
    ret = IS_ERR(ret) ? -ERRNO(ret) : 0;
   15f18:	41 bc 00 00 00 00    	mov    $0x0,%r12d
   15f1e:	0f 95 c2             	setne  %dl
   15f21:	48 89 d0             	mov    %rdx,%rax
   15f24:	48 f7 d8             	neg    %rax
   15f27:	48 31 f0             	xor    %rsi,%rax
   15f2a:	48 01 d0             	add    %rdx,%rax
   15f2d:	85 c0                	test   %eax,%eax
   15f2f:	44 0f 4e e0          	cmovle %eax,%r12d

out:
    if (fd != -1)
        INLINE_SYSCALL(close, 1, fd);
   15f33:	b8 06 00 00 00       	mov    $0x6,%eax
   15f38:	cd 80                	int    $0x80
   15f3a:	bb 00 00 00 00       	mov    $0x0,%ebx
   15f3f:	83 d3 00             	adc    $0x0,%ebx

    if (preload_paths) {
   15f42:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
   15f46:	48 85 ff             	test   %rdi,%rdi
   15f49:	74 30                	je     15f7b <ioctl_set_graphene+0x23b>
        for (int i = 0 ; i < npreload ; i++)
   15f4b:	45 85 f6             	test   %r14d,%r14d
   15f4e:	7e 26                	jle    15f76 <ioctl_set_graphene+0x236>
   15f50:	41 83 ee 01          	sub    $0x1,%r14d
   15f54:	31 db                	xor    %ebx,%ebx
   15f56:	49 c1 e6 03          	shl    $0x3,%r14
   15f5a:	eb 08                	jmp    15f64 <ioctl_set_graphene+0x224>
   15f5c:	0f 1f 40 00          	nopl   0x0(%rax)
   15f60:	48 83 c3 08          	add    $0x8,%rbx
            free((void *) preload_paths[i]);
   15f64:	48 8b 3c 1f          	mov    (%rdi,%rbx,1),%rdi
   15f68:	e8 23 2d ff ff       	callq  8c90 <free>
out:
    if (fd != -1)
        INLINE_SYSCALL(close, 1, fd);

    if (preload_paths) {
        for (int i = 0 ; i < npreload ; i++)
   15f6d:	4c 39 f3             	cmp    %r14,%rbx
   15f70:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
   15f74:	75 ea                	jne    15f60 <ioctl_set_graphene+0x220>
            free((void *) preload_paths[i]);
        free(preload_paths);
   15f76:	e8 15 2d ff ff       	callq  8c90 <free>
    }

    if (fs_paths) {
   15f7b:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
   15f7f:	48 85 ff             	test   %rdi,%rdi
   15f82:	74 2c                	je     15fb0 <ioctl_set_graphene+0x270>
        for (int i = 0 ; i < nfs ; i++)
   15f84:	45 85 ed             	test   %r13d,%r13d
   15f87:	7e 22                	jle    15fab <ioctl_set_graphene+0x26b>
   15f89:	41 83 ed 01          	sub    $0x1,%r13d
   15f8d:	31 db                	xor    %ebx,%ebx
   15f8f:	49 c1 e5 03          	shl    $0x3,%r13
   15f93:	eb 04                	jmp    15f99 <ioctl_set_graphene+0x259>
   15f95:	48 83 c3 08          	add    $0x8,%rbx
            free((void *) fs_paths[i]);
   15f99:	48 8b 3c 1f          	mov    (%rdi,%rbx,1),%rdi
   15f9d:	e8 ee 2c ff ff       	callq  8c90 <free>
            free((void *) preload_paths[i]);
        free(preload_paths);
    }

    if (fs_paths) {
        for (int i = 0 ; i < nfs ; i++)
   15fa2:	4c 39 eb             	cmp    %r13,%rbx
   15fa5:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
   15fa9:	75 ea                	jne    15f95 <ioctl_set_graphene+0x255>
            free((void *) fs_paths[i]);
        free(fs_paths);
   15fab:	e8 e0 2c ff ff       	callq  8c90 <free>
    }

    if (net_rules)
   15fb0:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
   15fb4:	48 85 ff             	test   %rdi,%rdi
   15fb7:	74 05                	je     15fbe <ioctl_set_graphene+0x27e>
        free(net_rules);
   15fb9:	e8 d2 2c ff ff       	callq  8c90 <free>

    return ret;
}
   15fbe:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   15fc2:	44 89 e0             	mov    %r12d,%eax
   15fc5:	5b                   	pop    %rbx
   15fc6:	41 5c                	pop    %r12
   15fc8:	41 5d                	pop    %r13
   15fca:	41 5e                	pop    %r14
   15fcc:	41 5f                	pop    %r15
   15fce:	5d                   	pop    %rbp
   15fcf:	c3                   	retq   
   15fd0:	41 89 c4             	mov    %eax,%r12d
    int ro = GRAPHENE_FS_READ, rw = ro | GRAPHENE_FS_WRITE;
    int ret = 0;
    const char ** preload_paths = NULL;
    const char ** fs_paths = NULL;
    struct graphene_net_policy * net_rules = NULL;
    int npreload = 0, nfs = 0, net = 0;
   15fd3:	45 31 ed             	xor    %r13d,%r13d
   15fd6:	e9 67 ff ff ff       	jmpq   15f42 <ioctl_set_graphene+0x202>

    ret = INLINE_SYSCALL(ioctl, 3, fd, GRAPHENE_SET_TASK, p);
    ret = IS_ERR(ret) ? -ERRNO(ret) : 0;

out:
    if (fd != -1)
   15fdb:	83 ff ff             	cmp    $0xffffffffffffffff,%edi
   15fde:	0f 84 5e ff ff ff    	je     15f42 <ioctl_set_graphene+0x202>
   15fe4:	48 63 ff             	movslq %edi,%rdi
   15fe7:	e9 47 ff ff ff       	jmpq   15f33 <ioctl_set_graphene+0x1f3>
        p->policies[n].type = GRAPHENE_FS_RECURSIVE | rw;
        p->policies[n].value = fs_paths[i];
        n++;
    }

    for (int i = 0 ; i < net ; i++) {
   15fec:	89 c6                	mov    %eax,%esi
   15fee:	e9 be fe ff ff       	jmpq   15eb1 <ioctl_set_graphene+0x171>
        p->policies[n].type = GRAPHENE_FS_PATH | ro;
        p->policies[n].value = preload_paths[i];
        n++;
    }

    for (int i = 0 ; i < nfs ; i++) {
   15ff3:	89 d0                	mov    %edx,%eax
   15ff5:	e9 7b fe ff ff       	jmpq   15e75 <ioctl_set_graphene+0x135>
                         sizeof(struct graphene_user_policy) *
                         (ndefault + npreload + nfs + net));

    memcpy(&p->policies[n], default_policies,
           sizeof(struct graphene_user_policy) * ndefault);
    n += ndefault;
   15ffa:	89 da                	mov    %ebx,%edx
   15ffc:	e9 39 fe ff ff       	jmpq   15e3a <ioctl_set_graphene+0xfa>
   16001:	90                   	nop    
   16002:	90                   	nop    
   16003:	90                   	nop    
   16004:	90                   	nop    
   16005:	90                   	nop    
   16006:	90                   	nop    
   16007:	90                   	nop    
   16008:	90                   	nop    
   16009:	90                   	nop    
   1600a:	90                   	nop    
   1600b:	90                   	nop    
   1600c:	90                   	nop    
   1600d:	90                   	nop    
   1600e:	90                   	nop    
   1600f:	90                   	nop    

0000000000016010 <strchr>:

#include <api.h>

/* Find the first occurrence of C in S.  */
char * strchr (const char *s, int c_in)
{
   16010:	55                   	push   %rbp

    c = (unsigned char) c_in;

    /* Handle the first few characters by reading one character at a time.
       Do this until CHAR_PTR is aligned on a longword boundary.  */
    for (char_ptr = (const unsigned char *) s;
   16011:	40 f6 c7 07          	test   $0x7,%dil
    const unsigned char *char_ptr;
    const unsigned long int *longword_ptr;
    unsigned long int longword, magic_bits, charmask;
    unsigned char c;

    c = (unsigned char) c_in;
   16015:	89 f2                	mov    %esi,%edx

#include <api.h>

/* Find the first occurrence of C in S.  */
char * strchr (const char *s, int c_in)
{
   16017:	48 89 e5             	mov    %rsp,%rbp
   1601a:	53                   	push   %rbx

    c = (unsigned char) c_in;

    /* Handle the first few characters by reading one character at a time.
       Do this until CHAR_PTR is aligned on a longword boundary.  */
    for (char_ptr = (const unsigned char *) s;
   1601b:	74 43                	je     16060 <strchr+0x50>
         ((unsigned long int) char_ptr & (sizeof (longword) - 1)) != 0;
         ++char_ptr)
        if (*char_ptr == c)
   1601d:	0f b6 07             	movzbl (%rdi),%eax
   16020:	40 38 f0             	cmp    %sil,%al
   16023:	75 1c                	jne    16041 <strchr+0x31>
   16025:	eb 29                	jmp    16050 <strchr+0x40>
   16027:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1602e:	00 00 

    /* Handle the first few characters by reading one character at a time.
       Do this until CHAR_PTR is aligned on a longword boundary.  */
    for (char_ptr = (const unsigned char *) s;
         ((unsigned long int) char_ptr & (sizeof (longword) - 1)) != 0;
         ++char_ptr)
   16030:	48 83 c7 01          	add    $0x1,%rdi

    c = (unsigned char) c_in;

    /* Handle the first few characters by reading one character at a time.
       Do this until CHAR_PTR is aligned on a longword boundary.  */
    for (char_ptr = (const unsigned char *) s;
   16034:	40 f6 c7 07          	test   $0x7,%dil
   16038:	74 26                	je     16060 <strchr+0x50>
         ((unsigned long int) char_ptr & (sizeof (longword) - 1)) != 0;
         ++char_ptr)
        if (*char_ptr == c)
   1603a:	0f b6 07             	movzbl (%rdi),%eax
   1603d:	38 d0                	cmp    %dl,%al
   1603f:	74 0f                	je     16050 <strchr+0x40>
            return (void *) char_ptr;
        else if (*char_ptr == '\0')
   16041:	84 c0                	test   %al,%al
   16043:	75 eb                	jne    16030 <strchr+0x20>
            return NULL;
   16045:	31 c0                	xor    %eax,%eax
            }
        }
    }

    return NULL;
}
   16047:	5b                   	pop    %rbx
   16048:	5d                   	pop    %rbp
   16049:	c3                   	retq   
   1604a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
               If none of them were, it was a misfire; continue the search.  */

            const unsigned char *cp = (const unsigned char *) (longword_ptr - 1);

            if (*cp == c)
                return (char *) cp;
   16050:	48 89 f8             	mov    %rdi,%rax
            }
        }
    }

    return NULL;
}
   16053:	5b                   	pop    %rbx
   16054:	5d                   	pop    %rbp
   16055:	c3                   	retq   
   16056:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1605d:	00 00 00 
        default:
            return NULL;
    }

    /* Set up a longword, each of whose bytes is C.  */
    charmask = c | (c << 8);
   16060:	40 0f b6 f6          	movzbl %sil,%esi
               are unchanged, most likely one of the bytes was a
               zero.  */
            & ~magic_bits) != 0 ||

            /* That caught zeroes.  Now test for C.  */
            ((((longword ^ charmask) + magic_bits) ^ ~(longword ^ charmask))
   16064:	49 ba ff fe fe fe fe 	mov    $0x7efefefefefefeff,%r10
   1606b:	fe fe 7e 
   1606e:	49 bb 00 01 01 01 01 	mov    $0x8101010101010100,%r11
   16075:	01 01 81 
        default:
            return NULL;
    }

    /* Set up a longword, each of whose bytes is C.  */
    charmask = c | (c << 8);
   16078:	89 f0                	mov    %esi,%eax
   1607a:	c1 e0 08             	shl    $0x8,%eax
   1607d:	09 c6                	or     %eax,%esi
   1607f:	48 63 c6             	movslq %esi,%rax
    charmask |= charmask << 16;
   16082:	49 89 c1             	mov    %rax,%r9
   16085:	49 c1 e1 10          	shl    $0x10,%r9
   16089:	49 09 c1             	or     %rax,%r9
    if (sizeof (longword) > 4)
    /* Do the shift in two steps to avoid a warning if long has 32 bits.  */
        charmask |= (charmask << 16) << 16;
   1608c:	4c 89 c8             	mov    %r9,%rax
   1608f:	48 c1 e0 20          	shl    $0x20,%rax
   16093:	49 09 c1             	or     %rax,%r9
           3) But wait!  Aren't we looking for C as well as zero?
           Good point.  So what we do is XOR LONGWORD with a longword,
           each of whose bytes is C.  This turns each byte that is C
           into a zero.  */

        longword = *longword_ptr++;
   16096:	48 8d 77 08          	lea    0x8(%rdi),%rsi
   1609a:	48 8b 46 f8          	mov    -0x8(%rsi),%rax
               are unchanged, most likely one of the bytes was a
               zero.  */
            & ~magic_bits) != 0 ||

            /* That caught zeroes.  Now test for C.  */
            ((((longword ^ charmask) + magic_bits) ^ ~(longword ^ charmask))
   1609e:	48 89 c1             	mov    %rax,%rcx
        longword = *longword_ptr++;

        /* Add MAGIC_BITS to LONGWORD.  */
        if ((((longword + magic_bits)
            /* Set those bits that were unchanged by the addition.  */
            ^ ~longword)
   160a1:	48 89 c3             	mov    %rax,%rbx
               are unchanged, most likely one of the bytes was a
               zero.  */
            & ~magic_bits) != 0 ||

            /* That caught zeroes.  Now test for C.  */
            ((((longword ^ charmask) + magic_bits) ^ ~(longword ^ charmask))
   160a4:	4c 31 c9             	xor    %r9,%rcx
        longword = *longword_ptr++;

        /* Add MAGIC_BITS to LONGWORD.  */
        if ((((longword + magic_bits)
            /* Set those bits that were unchanged by the addition.  */
            ^ ~longword)
   160a7:	48 f7 d3             	not    %rbx
               are unchanged, most likely one of the bytes was a
               zero.  */
            & ~magic_bits) != 0 ||

            /* That caught zeroes.  Now test for C.  */
            ((((longword ^ charmask) + magic_bits) ^ ~(longword ^ charmask))
   160aa:	49 89 c8             	mov    %rcx,%r8
   160ad:	4c 01 d1             	add    %r10,%rcx
   160b0:	49 f7 d0             	not    %r8
   160b3:	49 31 c8             	xor    %rcx,%r8
           into a zero.  */

        longword = *longword_ptr++;

        /* Add MAGIC_BITS to LONGWORD.  */
        if ((((longword + magic_bits)
   160b6:	4a 8d 0c 10          	lea    (%rax,%r10,1),%rcx
            /* Set those bits that were unchanged by the addition.  */
            ^ ~longword)
   160ba:	48 89 d8             	mov    %rbx,%rax
   160bd:	48 31 c8             	xor    %rcx,%rax
   160c0:	4c 09 c0             	or     %r8,%rax

            /* Look at only the hole bits.  If any of the hole bits
               are unchanged, most likely one of the bytes was a
               zero.  */
            & ~magic_bits) != 0 ||
   160c3:	4c 85 d8             	test   %r11,%rax
   160c6:	0f 84 84 00 00 00    	je     16150 <strchr+0x140>
            /* Which of the bytes was C or zero?
               If none of them were, it was a misfire; continue the search.  */

            const unsigned char *cp = (const unsigned char *) (longword_ptr - 1);

            if (*cp == c)
   160cc:	0f b6 46 f8          	movzbl -0x8(%rsi),%eax
   160d0:	38 d0                	cmp    %dl,%al
   160d2:	0f 84 78 ff ff ff    	je     16050 <strchr+0x40>
                return (char *) cp;
            else if (*cp == '\0')
   160d8:	84 c0                	test   %al,%al
   160da:	0f 84 65 ff ff ff    	je     16045 <strchr+0x35>
                return NULL;
            if (*++cp == c)
   160e0:	0f b6 46 f9          	movzbl -0x7(%rsi),%eax
   160e4:	38 d0                	cmp    %dl,%al
   160e6:	74 70                	je     16158 <strchr+0x148>
                return (char *) cp;
            else if (*cp == '\0')
   160e8:	84 c0                	test   %al,%al
   160ea:	0f 84 55 ff ff ff    	je     16045 <strchr+0x35>
                return NULL;
            if (*++cp == c)
   160f0:	0f b6 46 fa          	movzbl -0x6(%rsi),%eax
   160f4:	38 d0                	cmp    %dl,%al
   160f6:	74 69                	je     16161 <strchr+0x151>
                return (char *) cp;
            else if (*cp == '\0')
   160f8:	84 c0                	test   %al,%al
   160fa:	0f 84 45 ff ff ff    	je     16045 <strchr+0x35>
                return NULL;
            if (*++cp == c)
   16100:	0f b6 46 fb          	movzbl -0x5(%rsi),%eax
   16104:	38 d0                	cmp    %dl,%al
   16106:	74 62                	je     1616a <strchr+0x15a>
                return (char *) cp;
            else if (*cp == '\0')
   16108:	84 c0                	test   %al,%al
   1610a:	0f 84 35 ff ff ff    	je     16045 <strchr+0x35>
                return NULL;
            if (sizeof (longword) > 4) {
                if (*++cp == c)
   16110:	0f b6 46 fc          	movzbl -0x4(%rsi),%eax
   16114:	38 d0                	cmp    %dl,%al
   16116:	74 5b                	je     16173 <strchr+0x163>
                    return (char *) cp;
                else if (*cp == '\0')
   16118:	84 c0                	test   %al,%al
   1611a:	0f 84 25 ff ff ff    	je     16045 <strchr+0x35>
                    return NULL;
                if (*++cp == c)
   16120:	0f b6 46 fd          	movzbl -0x3(%rsi),%eax
   16124:	38 d0                	cmp    %dl,%al
   16126:	74 54                	je     1617c <strchr+0x16c>
                    return (char *) cp;
                else if (*cp == '\0')
   16128:	84 c0                	test   %al,%al
   1612a:	0f 84 15 ff ff ff    	je     16045 <strchr+0x35>
                    return NULL;
                if (*++cp == c)
   16130:	0f b6 46 fe          	movzbl -0x2(%rsi),%eax
   16134:	38 d0                	cmp    %dl,%al
   16136:	74 4d                	je     16185 <strchr+0x175>
                    return (char *) cp;
                else if (*cp == '\0')
   16138:	84 c0                	test   %al,%al
   1613a:	0f 84 05 ff ff ff    	je     16045 <strchr+0x35>
                    return NULL;
                if (*++cp == c)
   16140:	0f b6 46 ff          	movzbl -0x1(%rsi),%eax
   16144:	38 d0                	cmp    %dl,%al
   16146:	74 46                	je     1618e <strchr+0x17e>
                    return (char *) cp;
                else if (*cp == '\0')
   16148:	84 c0                	test   %al,%al
   1614a:	0f 84 f5 fe ff ff    	je     16045 <strchr+0x35>

#include <api.h>

/* Find the first occurrence of C in S.  */
char * strchr (const char *s, int c_in)
{
   16150:	48 89 f7             	mov    %rsi,%rdi
   16153:	e9 3e ff ff ff       	jmpq   16096 <strchr+0x86>
            if (*cp == c)
                return (char *) cp;
            else if (*cp == '\0')
                return NULL;
            if (*++cp == c)
                return (char *) cp;
   16158:	48 8d 47 01          	lea    0x1(%rdi),%rax
   1615c:	e9 e6 fe ff ff       	jmpq   16047 <strchr+0x37>
            else if (*cp == '\0')
                return NULL;
            if (*++cp == c)
                return (char *) cp;
   16161:	48 8d 47 02          	lea    0x2(%rdi),%rax
   16165:	e9 dd fe ff ff       	jmpq   16047 <strchr+0x37>
            else if (*cp == '\0')
                return NULL;
            if (*++cp == c)
                return (char *) cp;
   1616a:	48 8d 47 03          	lea    0x3(%rdi),%rax
   1616e:	e9 d4 fe ff ff       	jmpq   16047 <strchr+0x37>
            else if (*cp == '\0')
                return NULL;
            if (sizeof (longword) > 4) {
                if (*++cp == c)
                    return (char *) cp;
   16173:	48 8d 47 04          	lea    0x4(%rdi),%rax
   16177:	e9 cb fe ff ff       	jmpq   16047 <strchr+0x37>
                else if (*cp == '\0')
                    return NULL;
                if (*++cp == c)
                    return (char *) cp;
   1617c:	48 8d 47 05          	lea    0x5(%rdi),%rax
   16180:	e9 c2 fe ff ff       	jmpq   16047 <strchr+0x37>
                else if (*cp == '\0')
                    return NULL;
                if (*++cp == c)
                    return (char *) cp;
   16185:	48 8d 47 06          	lea    0x6(%rdi),%rax
   16189:	e9 b9 fe ff ff       	jmpq   16047 <strchr+0x37>
                else if (*cp == '\0')
                    return NULL;
                if (*++cp == c)
                    return (char *) cp;
   1618e:	48 8d 47 07          	lea    0x7(%rdi),%rax
   16192:	e9 b0 fe ff ff       	jmpq   16047 <strchr+0x37>
   16197:	90                   	nop    
   16198:	90                   	nop    
   16199:	90                   	nop    
   1619a:	90                   	nop    
   1619b:	90                   	nop    
   1619c:	90                   	nop    
   1619d:	90                   	nop    
   1619e:	90                   	nop    
   1619f:	90                   	nop    

00000000000161a0 <memset>:

typedef unsigned char byte;

void *
memset (void *dstpp, int c, size_t len)
{
   161a0:	55                   	push   %rbp
  long int dstp = (long int) dstpp;

  if (len >= 8)
   161a1:	48 83 fa 07          	cmp    $0x7,%rdx

typedef unsigned char byte;

void *
memset (void *dstpp, int c, size_t len)
{
   161a5:	48 89 f8             	mov    %rdi,%rax
  long int dstp = (long int) dstpp;
   161a8:	48 89 f9             	mov    %rdi,%rcx

typedef unsigned char byte;

void *
memset (void *dstpp, int c, size_t len)
{
   161ab:	48 89 e5             	mov    %rsp,%rbp
  long int dstp = (long int) dstpp;

  if (len >= 8)
   161ae:	0f 86 b0 00 00 00    	jbe    16264 <memset+0xc4>
    {
      size_t xlen;
      op_t cccc;

      cccc = (unsigned char) c;
   161b4:	44 0f b6 c6          	movzbl %sil,%r8d
      cccc |= cccc << 8;
   161b8:	4d 89 c1             	mov    %r8,%r9
  if (len >= 8)
    {
      size_t xlen;
      op_t cccc;

      cccc = (unsigned char) c;
   161bb:	4c 89 c7             	mov    %r8,%rdi
      cccc |= cccc << 8;
   161be:	49 c1 e1 08          	shl    $0x8,%r9
   161c2:	4d 09 c1             	or     %r8,%r9
      cccc |= cccc << 16;
   161c5:	4d 89 c8             	mov    %r9,%r8
   161c8:	49 c1 e0 10          	shl    $0x10,%r8
   161cc:	4d 09 c1             	or     %r8,%r9
      if (OPSIZ > 4)
	/* Do the shift in two steps to avoid warning if long has 32 bits.  */
	cccc |= (cccc << 16) << 16;
   161cf:	4d 89 c8             	mov    %r9,%r8
   161d2:	49 c1 e0 20          	shl    $0x20,%r8
   161d6:	4d 09 c1             	or     %r8,%r9

      /* There are at least some bytes to set.
	 No need to test for LEN == 0 in this alignment loop.  */
      while (dstp % OPSIZ != 0)
   161d9:	a8 07                	test   $0x7,%al
   161db:	74 13                	je     161f0 <memset+0x50>
   161dd:	0f 1f 00             	nopl   (%rax)
	{
	  ((byte *) dstp)[0] = c;
   161e0:	40 88 39             	mov    %dil,(%rcx)
	  dstp += 1;
   161e3:	48 83 c1 01          	add    $0x1,%rcx
	  len -= 1;
   161e7:	48 83 ea 01          	sub    $0x1,%rdx
	/* Do the shift in two steps to avoid warning if long has 32 bits.  */
	cccc |= (cccc << 16) << 16;

      /* There are at least some bytes to set.
	 No need to test for LEN == 0 in this alignment loop.  */
      while (dstp % OPSIZ != 0)
   161eb:	f6 c1 07             	test   $0x7,%cl
   161ee:	75 f0                	jne    161e0 <memset+0x40>
	  dstp += 1;
	  len -= 1;
	}

      /* Write 8 `op_t' per iteration until less than 8 `op_t' remain.  */
      xlen = len / (OPSIZ * 8);
   161f0:	48 89 d7             	mov    %rdx,%rdi
   161f3:	48 c1 ef 06          	shr    $0x6,%rdi
      while (xlen > 0)
   161f7:	48 85 ff             	test   %rdi,%rdi
   161fa:	74 36                	je     16232 <memset+0x92>
   161fc:	49 89 fa             	mov    %rdi,%r10
   161ff:	49 89 c8             	mov    %rcx,%r8
	{
	  ((op_t *) dstp)[0] = cccc;
   16202:	4d 89 08             	mov    %r9,(%r8)
	  ((op_t *) dstp)[1] = cccc;
   16205:	4d 89 48 08          	mov    %r9,0x8(%r8)
   16209:	49 83 c0 40          	add    $0x40,%r8
	  ((op_t *) dstp)[2] = cccc;
   1620d:	4d 89 48 d0          	mov    %r9,-0x30(%r8)
	  ((op_t *) dstp)[3] = cccc;
   16211:	4d 89 48 d8          	mov    %r9,-0x28(%r8)
	  ((op_t *) dstp)[4] = cccc;
   16215:	4d 89 48 e0          	mov    %r9,-0x20(%r8)
	  ((op_t *) dstp)[5] = cccc;
   16219:	4d 89 48 e8          	mov    %r9,-0x18(%r8)
	  ((op_t *) dstp)[6] = cccc;
   1621d:	4d 89 48 f0          	mov    %r9,-0x10(%r8)
	  ((op_t *) dstp)[7] = cccc;
   16221:	4d 89 48 f8          	mov    %r9,-0x8(%r8)
	  len -= 1;
	}

      /* Write 8 `op_t' per iteration until less than 8 `op_t' remain.  */
      xlen = len / (OPSIZ * 8);
      while (xlen > 0)
   16225:	49 83 ea 01          	sub    $0x1,%r10
   16229:	75 d7                	jne    16202 <memset+0x62>
   1622b:	48 c1 e7 06          	shl    $0x6,%rdi
   1622f:	48 01 f9             	add    %rdi,%rcx
	  ((op_t *) dstp)[6] = cccc;
	  ((op_t *) dstp)[7] = cccc;
	  dstp += 8 * OPSIZ;
	  xlen -= 1;
	}
      len %= OPSIZ * 8;
   16232:	48 89 d7             	mov    %rdx,%rdi
   16235:	83 e7 3f             	and    $0x3f,%edi

      /* Write 1 `op_t' per iteration until less than OPSIZ bytes remain.  */
      xlen = len / OPSIZ;
   16238:	48 c1 ef 03          	shr    $0x3,%rdi
      while (xlen > 0)
   1623c:	48 85 ff             	test   %rdi,%rdi
   1623f:	74 20                	je     16261 <memset+0xc1>
   16241:	49 89 fa             	mov    %rdi,%r10
   16244:	49 89 c8             	mov    %rcx,%r8
   16247:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1624e:	00 00 
	{
	  ((op_t *) dstp)[0] = cccc;
   16250:	4d 89 08             	mov    %r9,(%r8)
   16253:	49 83 c0 08          	add    $0x8,%r8
	}
      len %= OPSIZ * 8;

      /* Write 1 `op_t' per iteration until less than OPSIZ bytes remain.  */
      xlen = len / OPSIZ;
      while (xlen > 0)
   16257:	49 83 ea 01          	sub    $0x1,%r10
   1625b:	75 f3                	jne    16250 <memset+0xb0>
   1625d:	48 8d 0c f9          	lea    (%rcx,%rdi,8),%rcx
	{
	  ((op_t *) dstp)[0] = cccc;
	  dstp += OPSIZ;
	  xlen -= 1;
	}
      len %= OPSIZ;
   16261:	83 e2 07             	and    $0x7,%edx
    }

  /* Write the last few bytes.  */
  while (len > 0)
   16264:	48 85 d2             	test   %rdx,%rdx
   16267:	48 8d 3c 11          	lea    (%rcx,%rdx,1),%rdi
   1626b:	74 0f                	je     1627c <memset+0xdc>
   1626d:	0f 1f 00             	nopl   (%rax)
    {
      ((byte *) dstp)[0] = c;
   16270:	40 88 31             	mov    %sil,(%rcx)
      dstp += 1;
   16273:	48 83 c1 01          	add    $0x1,%rcx
	}
      len %= OPSIZ;
    }

  /* Write the last few bytes.  */
  while (len > 0)
   16277:	48 39 f9             	cmp    %rdi,%rcx
   1627a:	75 f4                	jne    16270 <memset+0xd0>
      dstp += 1;
      len -= 1;
    }

  return dstpp;
}
   1627c:	5d                   	pop    %rbp
   1627d:	c3                   	retq   
   1627e:	90                   	nop    
   1627f:	90                   	nop    

0000000000016280 <memcpy>:
#else
#include <stddef.h>
#endif 

void * memcpy (void *dstpp, const void *srcpp, size_t len)
{
   16280:	55                   	push   %rbp

    return dstpp;
#else
  char *d = dstpp;
  const char *s = srcpp;
  while (len--)
   16281:	31 c9                	xor    %ecx,%ecx
   16283:	48 85 d2             	test   %rdx,%rdx
#else
#include <stddef.h>
#endif 

void * memcpy (void *dstpp, const void *srcpp, size_t len)
{
   16286:	48 89 f8             	mov    %rdi,%rax
   16289:	48 89 e5             	mov    %rsp,%rbp

    return dstpp;
#else
  char *d = dstpp;
  const char *s = srcpp;
  while (len--)
   1628c:	74 14                	je     162a2 <memcpy+0x22>
   1628e:	66 90                	xchg   %ax,%ax
    *d++ = *s++;
   16290:	44 0f b6 04 0e       	movzbl (%rsi,%rcx,1),%r8d
   16295:	44 88 04 08          	mov    %r8b,(%rax,%rcx,1)
   16299:	48 83 c1 01          	add    $0x1,%rcx

    return dstpp;
#else
  char *d = dstpp;
  const char *s = srcpp;
  while (len--)
   1629d:	48 39 d1             	cmp    %rdx,%rcx
   162a0:	75 ee                	jne    16290 <memcpy+0x10>
    *d++ = *s++;
  return dstpp;
#endif  
}
   162a2:	5d                   	pop    %rbp
   162a3:	c3                   	retq   
   162a4:	66 66 66 2e 0f 1f 84 	nopw   %cs:0x0(%rax,%rax,1)
   162ab:	00 00 00 00 00 

00000000000162b0 <memmove>:

void * memmove (void * destpp, void * srcpp, size_t len)
{
   162b0:	55                   	push   %rbp
        BYTE_COPY_BWD (dstp, srcp, len);
    }
#else
	char *d = destpp;
	const char *s = srcpp;
	  if (d < s) {
   162b1:	48 39 f7             	cmp    %rsi,%rdi
  return dstpp;
#endif  
}

void * memmove (void * destpp, void * srcpp, size_t len)
{
   162b4:	48 89 f8             	mov    %rdi,%rax
   162b7:	48 89 e5             	mov    %rsp,%rbp
        BYTE_COPY_BWD (dstp, srcp, len);
    }
#else
	char *d = destpp;
	const char *s = srcpp;
	  if (d < s) {
   162ba:	73 24                	jae    162e0 <memmove+0x30>
			  while (len--)
   162bc:	31 c9                	xor    %ecx,%ecx
   162be:	48 85 d2             	test   %rdx,%rdx
   162c1:	74 12                	je     162d5 <memmove+0x25>
					*d++ = *s++;
   162c3:	44 0f b6 04 0e       	movzbl (%rsi,%rcx,1),%r8d
   162c8:	44 88 04 08          	mov    %r8b,(%rax,%rcx,1)
   162cc:	48 83 c1 01          	add    $0x1,%rcx
    }
#else
	char *d = destpp;
	const char *s = srcpp;
	  if (d < s) {
			  while (len--)
   162d0:	48 39 d1             	cmp    %rdx,%rcx
   162d3:	75 ee                	jne    162c3 <memmove+0x13>
			while (len--)
				*lastd-- = *lasts--;
		}
#endif
    return destpp;
}
   162d5:	5d                   	pop    %rbp
   162d6:	c3                   	retq   
   162d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   162de:	00 00 
			  while (len--)
					*d++ = *s++;
		} 
		else
		{
			char *lasts = s + (len-1);
   162e0:	48 8d 7a ff          	lea    -0x1(%rdx),%rdi
   162e4:	48 01 fe             	add    %rdi,%rsi
			char *lastd = d + (len-1);
   162e7:	48 01 c7             	add    %rax,%rdi
			while (len--)
   162ea:	48 85 d2             	test   %rdx,%rdx
   162ed:	74 e6                	je     162d5 <memmove+0x25>
   162ef:	48 f7 da             	neg    %rdx
   162f2:	31 c9                	xor    %ecx,%ecx
				*lastd-- = *lasts--;
   162f4:	44 0f b6 04 0e       	movzbl (%rsi,%rcx,1),%r8d
   162f9:	44 88 04 0f          	mov    %r8b,(%rdi,%rcx,1)
   162fd:	48 83 e9 01          	sub    $0x1,%rcx
		} 
		else
		{
			char *lasts = s + (len-1);
			char *lastd = d + (len-1);
			while (len--)
   16301:	48 39 d1             	cmp    %rdx,%rcx
   16304:	75 ee                	jne    162f4 <memmove+0x44>
				*lastd-- = *lasts--;
		}
#endif
    return destpp;
}
   16306:	5d                   	pop    %rbp
   16307:	c3                   	retq   
   16308:	90                   	nop    
   16309:	90                   	nop    
   1630a:	90                   	nop    
   1630b:	90                   	nop    
   1630c:	90                   	nop    
   1630d:	90                   	nop    
   1630e:	90                   	nop    
   1630f:	90                   	nop    

0000000000016310 <memcmp>:
   16310:	55                   	push   %rbp
   16311:	48 83 fa 0f          	cmp    $0xf,%rdx
   16315:	49 89 f8             	mov    %rdi,%r8
   16318:	48 89 e5             	mov    %rsp,%rbp
   1631b:	41 57                	push   %r15
   1631d:	41 56                	push   %r14
   1631f:	41 55                	push   %r13
   16321:	41 54                	push   %r12
   16323:	49 89 f7             	mov    %rsi,%r15
   16326:	53                   	push   %rbx
   16327:	0f 86 c4 00 00 00    	jbe    163f1 <memcmp+0xe1>
   1632d:	40 f6 c6 07          	test   $0x7,%sil
   16331:	49 89 f1             	mov    %rsi,%r9
   16334:	74 40                	je     16376 <memcmp+0x66>
   16336:	0f b6 07             	movzbl (%rdi),%eax
   16339:	0f b6 0e             	movzbl (%rsi),%ecx
   1633c:	49 83 c0 01          	add    $0x1,%r8
   16340:	49 83 c7 01          	add    $0x1,%r15
   16344:	48 29 c8             	sub    %rcx,%rax
   16347:	74 20                	je     16369 <memcmp+0x59>
   16349:	e9 de 00 00 00       	jmpq   1642c <memcmp+0x11c>
   1634e:	66 90                	xchg   %ax,%ax
   16350:	41 0f b6 00          	movzbl (%r8),%eax
   16354:	41 0f b6 09          	movzbl (%r9),%ecx
   16358:	49 83 c0 01          	add    $0x1,%r8
   1635c:	49 83 c7 01          	add    $0x1,%r15
   16360:	48 29 c8             	sub    %rcx,%rax
   16363:	0f 85 c3 00 00 00    	jne    1642c <memcmp+0x11c>
   16369:	48 83 ea 01          	sub    $0x1,%rdx
   1636d:	41 f6 c7 07          	test   $0x7,%r15b
   16371:	4d 89 f9             	mov    %r15,%r9
   16374:	75 da                	jne    16350 <memcmp+0x40>
   16376:	4c 89 c6             	mov    %r8,%rsi
   16379:	83 e6 07             	and    $0x7,%esi
   1637c:	0f 85 ce 00 00 00    	jne    16450 <memcmp+0x140>
   16382:	48 89 d1             	mov    %rdx,%rcx
   16385:	48 c1 e9 03          	shr    $0x3,%rcx
   16389:	48 89 c8             	mov    %rcx,%rax
   1638c:	83 e0 03             	and    $0x3,%eax
   1638f:	48 83 f8 01          	cmp    $0x1,%rax
   16393:	0f 84 e5 01 00 00    	je     1657e <memcmp+0x26e>
   16399:	0f 82 b4 01 00 00    	jb     16553 <memcmp+0x243>
   1639f:	48 83 f8 03          	cmp    $0x3,%rax
   163a3:	0f 85 27 01 00 00    	jne    164d0 <memcmp+0x1c0>
   163a9:	49 8b 38             	mov    (%r8),%rdi
   163ac:	4d 8b 17             	mov    (%r15),%r10
   163af:	49 8d 70 f8          	lea    -0x8(%r8),%rsi
   163b3:	49 8d 41 f8          	lea    -0x8(%r9),%rax
   163b7:	48 83 c1 01          	add    $0x1,%rcx
   163bb:	4c 39 d7             	cmp    %r10,%rdi
   163be:	4c 8b 5e 10          	mov    0x10(%rsi),%r11
   163c2:	48 8b 58 10          	mov    0x10(%rax),%rbx
   163c6:	0f 84 16 01 00 00    	je     164e2 <memcmp+0x1d2>
   163cc:	49 39 fa             	cmp    %rdi,%r10
   163cf:	48 19 c0             	sbb    %rax,%rax
   163d2:	83 e0 02             	and    $0x2,%eax
   163d5:	48 83 e8 01          	sub    $0x1,%rax
   163d9:	eb 51                	jmp    1642c <memcmp+0x11c>
   163db:	4c 39 d7             	cmp    %r10,%rdi
   163de:	75 ec                	jne    163cc <memcmp+0xbc>
   163e0:	48 89 d0             	mov    %rdx,%rax
   163e3:	83 e2 07             	and    $0x7,%edx
   163e6:	48 83 e0 f8          	and    $0xfffffffffffffff8,%rax
   163ea:	4e 8d 3c 08          	lea    (%rax,%r9,1),%r15
   163ee:	49 01 c0             	add    %rax,%r8
   163f1:	48 85 d2             	test   %rdx,%rdx
   163f4:	74 34                	je     1642a <memcmp+0x11a>
   163f6:	41 0f b6 08          	movzbl (%r8),%ecx
   163fa:	41 0f b6 07          	movzbl (%r15),%eax
   163fe:	49 8d 70 01          	lea    0x1(%r8),%rsi
   16402:	48 29 c1             	sub    %rax,%rcx
   16405:	75 39                	jne    16440 <memcmp+0x130>
   16407:	4c 89 f8             	mov    %r15,%rax
   1640a:	4c 01 c2             	add    %r8,%rdx
   1640d:	4c 29 c0             	sub    %r8,%rax
   16410:	eb 13                	jmp    16425 <memcmp+0x115>
   16412:	48 89 f7             	mov    %rsi,%rdi
   16415:	48 83 c6 01          	add    $0x1,%rsi
   16419:	0f b6 0f             	movzbl (%rdi),%ecx
   1641c:	0f b6 3c 38          	movzbl (%rax,%rdi,1),%edi
   16420:	48 29 f9             	sub    %rdi,%rcx
   16423:	75 1b                	jne    16440 <memcmp+0x130>
   16425:	48 39 d6             	cmp    %rdx,%rsi
   16428:	75 e8                	jne    16412 <memcmp+0x102>
   1642a:	31 c0                	xor    %eax,%eax
   1642c:	5b                   	pop    %rbx
   1642d:	41 5c                	pop    %r12
   1642f:	41 5d                	pop    %r13
   16431:	41 5e                	pop    %r14
   16433:	41 5f                	pop    %r15
   16435:	5d                   	pop    %rbp
   16436:	c3                   	retq   
   16437:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1643e:	00 00 
   16440:	89 c8                	mov    %ecx,%eax
   16442:	5b                   	pop    %rbx
   16443:	41 5c                	pop    %r12
   16445:	41 5d                	pop    %r13
   16447:	41 5e                	pop    %r14
   16449:	41 5f                	pop    %r15
   1644b:	5d                   	pop    %rbp
   1644c:	c3                   	retq   
   1644d:	0f 1f 00             	nopl   (%rax)
   16450:	49 89 d2             	mov    %rdx,%r10
   16453:	c1 e6 03             	shl    $0x3,%esi
   16456:	41 bb 40 00 00 00    	mov    $0x40,%r11d
   1645c:	49 c1 ea 03          	shr    $0x3,%r10
   16460:	4c 89 c7             	mov    %r8,%rdi
   16463:	41 29 f3             	sub    %esi,%r11d
   16466:	4c 89 d0             	mov    %r10,%rax
   16469:	48 83 e7 f8          	and    $0xfffffffffffffff8,%rdi
   1646d:	83 e0 03             	and    $0x3,%eax
   16470:	48 83 f8 01          	cmp    $0x1,%rax
   16474:	0f 84 86 01 00 00    	je     16600 <memcmp+0x2f0>
   1647a:	0f 82 27 01 00 00    	jb     165a7 <memcmp+0x297>
   16480:	48 83 f8 03          	cmp    $0x3,%rax
   16484:	75 7f                	jne    16505 <memcmp+0x1f5>
   16486:	49 8b 07             	mov    (%r15),%rax
   16489:	4c 8b 2f             	mov    (%rdi),%r13
   1648c:	49 83 c2 01          	add    $0x1,%r10
   16490:	4c 8b 67 08          	mov    0x8(%rdi),%r12
   16494:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
   16498:	49 8d 41 f8          	lea    -0x8(%r9),%rax
   1649c:	44 89 d9             	mov    %r11d,%ecx
   1649f:	4d 89 e6             	mov    %r12,%r14
   164a2:	48 8b 5f 10          	mov    0x10(%rdi),%rbx
   164a6:	49 d3 e6             	shl    %cl,%r14
   164a9:	89 f1                	mov    %esi,%ecx
   164ab:	4c 8b 78 10          	mov    0x10(%rax),%r15
   164af:	49 d3 ed             	shr    %cl,%r13
   164b2:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
   164b6:	4d 09 ee             	or     %r13,%r14
   164b9:	49 39 ce             	cmp    %rcx,%r14
   164bc:	74 5d                	je     1651b <memcmp+0x20b>
   164be:	4c 39 f1             	cmp    %r14,%rcx
   164c1:	48 19 c0             	sbb    %rax,%rax
   164c4:	83 e0 02             	and    $0x2,%eax
   164c7:	48 83 e8 01          	sub    $0x1,%rax
   164cb:	e9 5c ff ff ff       	jmpq   1642c <memcmp+0x11c>
   164d0:	4d 8b 18             	mov    (%r8),%r11
   164d3:	49 8b 1f             	mov    (%r15),%rbx
   164d6:	49 8d 70 f0          	lea    -0x10(%r8),%rsi
   164da:	49 8d 41 f0          	lea    -0x10(%r9),%rax
   164de:	48 83 c1 02          	add    $0x2,%rcx
   164e2:	49 39 db             	cmp    %rbx,%r11
   164e5:	48 8b 7e 18          	mov    0x18(%rsi),%rdi
   164e9:	4c 8b 50 18          	mov    0x18(%rax),%r10
   164ed:	0f 84 8c 01 00 00    	je     1667f <memcmp+0x36f>
   164f3:	4c 39 db             	cmp    %r11,%rbx
   164f6:	48 19 c0             	sbb    %rax,%rax
   164f9:	83 e0 02             	and    $0x2,%eax
   164fc:	48 83 e8 01          	sub    $0x1,%rax
   16500:	e9 27 ff ff ff       	jmpq   1642c <memcmp+0x11c>
   16505:	4d 8b 3f             	mov    (%r15),%r15
   16508:	49 8d 41 f0          	lea    -0x10(%r9),%rax
   1650c:	4c 8b 27             	mov    (%rdi),%r12
   1650f:	48 8b 5f 08          	mov    0x8(%rdi),%rbx
   16513:	49 83 c2 02          	add    $0x2,%r10
   16517:	48 83 ef 08          	sub    $0x8,%rdi
   1651b:	48 8b 48 18          	mov    0x18(%rax),%rcx
   1651f:	49 89 dd             	mov    %rbx,%r13
   16522:	4c 8b 77 18          	mov    0x18(%rdi),%r14
   16526:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
   1652a:	44 89 d9             	mov    %r11d,%ecx
   1652d:	49 d3 e5             	shl    %cl,%r13
   16530:	89 f1                	mov    %esi,%ecx
   16532:	49 d3 ec             	shr    %cl,%r12
   16535:	4d 09 e5             	or     %r12,%r13
   16538:	4d 39 fd             	cmp    %r15,%r13
   1653b:	0f 84 55 01 00 00    	je     16696 <memcmp+0x386>
   16541:	4d 39 ef             	cmp    %r13,%r15
   16544:	48 19 c0             	sbb    %rax,%rax
   16547:	83 e0 02             	and    $0x2,%eax
   1654a:	48 83 e8 01          	sub    $0x1,%rax
   1654e:	e9 d9 fe ff ff       	jmpq   1642c <memcmp+0x11c>
   16553:	48 85 c9             	test   %rcx,%rcx
   16556:	0f 84 84 fe ff ff    	je     163e0 <memcmp+0xd0>
   1655c:	4d 8b 18             	mov    (%r8),%r11
   1655f:	49 8b 1f             	mov    (%r15),%rbx
   16562:	4c 89 c6             	mov    %r8,%rsi
   16565:	49 39 db             	cmp    %rbx,%r11
   16568:	48 8b 7e 08          	mov    0x8(%rsi),%rdi
   1656c:	4c 89 f8             	mov    %r15,%rax
   1656f:	4d 8b 57 08          	mov    0x8(%r15),%r10
   16573:	0f 85 7a ff ff ff    	jne    164f3 <memcmp+0x1e3>
   16579:	e9 3d fe ff ff       	jmpq   163bb <memcmp+0xab>
   1657e:	48 83 e9 01          	sub    $0x1,%rcx
   16582:	49 8b 38             	mov    (%r8),%rdi
   16585:	4d 8b 17             	mov    (%r15),%r10
   16588:	0f 84 4d fe ff ff    	je     163db <memcmp+0xcb>
   1658e:	49 8d 70 08          	lea    0x8(%r8),%rsi
   16592:	4d 8d 79 08          	lea    0x8(%r9),%r15
   16596:	4c 39 d7             	cmp    %r10,%rdi
   16599:	4c 8b 1e             	mov    (%rsi),%r11
   1659c:	49 8b 1f             	mov    (%r15),%rbx
   1659f:	0f 85 27 fe ff ff    	jne    163cc <memcmp+0xbc>
   165a5:	eb be                	jmp    16565 <memcmp+0x255>
   165a7:	4d 85 d2             	test   %r10,%r10
   165aa:	0f 84 30 fe ff ff    	je     163e0 <memcmp+0xd0>
   165b0:	49 8b 07             	mov    (%r15),%rax
   165b3:	4c 8b 37             	mov    (%rdi),%r14
   165b6:	48 83 c7 08          	add    $0x8,%rdi
   165ba:	4c 8b 2f             	mov    (%rdi),%r13
   165bd:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
   165c1:	49 8b 5f 08          	mov    0x8(%r15),%rbx
   165c5:	44 89 d9             	mov    %r11d,%ecx
   165c8:	4c 8b 67 08          	mov    0x8(%rdi),%r12
   165cc:	4c 89 f8             	mov    %r15,%rax
   165cf:	48 89 5d d0          	mov    %rbx,-0x30(%rbp)
   165d3:	4c 89 eb             	mov    %r13,%rbx
   165d6:	48 d3 e3             	shl    %cl,%rbx
   165d9:	89 f1                	mov    %esi,%ecx
   165db:	49 d3 ee             	shr    %cl,%r14
   165de:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   165e2:	4c 09 f3             	or     %r14,%rbx
   165e5:	48 39 cb             	cmp    %rcx,%rbx
   165e8:	0f 84 ae fe ff ff    	je     1649c <memcmp+0x18c>
   165ee:	48 39 d9             	cmp    %rbx,%rcx
   165f1:	48 19 c0             	sbb    %rax,%rax
   165f4:	83 e0 02             	and    $0x2,%eax
   165f7:	48 83 e8 01          	sub    $0x1,%rax
   165fb:	e9 2c fe ff ff       	jmpq   1642c <memcmp+0x11c>
   16600:	49 8b 07             	mov    (%r15),%rax
   16603:	49 83 ea 01          	sub    $0x1,%r10
   16607:	48 8b 1f             	mov    (%rdi),%rbx
   1660a:	4c 8b 77 08          	mov    0x8(%rdi),%r14
   1660e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
   16612:	74 3e                	je     16652 <memcmp+0x342>
   16614:	4d 8d 79 08          	lea    0x8(%r9),%r15
   16618:	48 83 c7 10          	add    $0x10,%rdi
   1661c:	49 8b 07             	mov    (%r15),%rax
   1661f:	44 89 d9             	mov    %r11d,%ecx
   16622:	4c 8b 2f             	mov    (%rdi),%r13
   16625:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
   16629:	4c 89 f0             	mov    %r14,%rax
   1662c:	48 d3 e0             	shl    %cl,%rax
   1662f:	89 f1                	mov    %esi,%ecx
   16631:	48 d3 eb             	shr    %cl,%rbx
   16634:	48 09 d8             	or     %rbx,%rax
   16637:	48 8b 5d d0          	mov    -0x30(%rbp),%rbx
   1663b:	48 39 d8             	cmp    %rbx,%rax
   1663e:	74 81                	je     165c1 <memcmp+0x2b1>
   16640:	48 39 c3             	cmp    %rax,%rbx
   16643:	48 19 c0             	sbb    %rax,%rax
   16646:	83 e0 02             	and    $0x2,%eax
   16649:	48 83 e8 01          	sub    $0x1,%rax
   1664d:	e9 da fd ff ff       	jmpq   1642c <memcmp+0x11c>
   16652:	44 89 d9             	mov    %r11d,%ecx
   16655:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
   16659:	49 d3 e6             	shl    %cl,%r14
   1665c:	89 f1                	mov    %esi,%ecx
   1665e:	48 d3 eb             	shr    %cl,%rbx
   16661:	4c 09 f3             	or     %r14,%rbx
   16664:	48 39 c3             	cmp    %rax,%rbx
   16667:	0f 84 73 fd ff ff    	je     163e0 <memcmp+0xd0>
   1666d:	48 39 d8             	cmp    %rbx,%rax
   16670:	48 19 c0             	sbb    %rax,%rax
   16673:	83 e0 02             	and    $0x2,%eax
   16676:	48 83 e8 01          	sub    $0x1,%rax
   1667a:	e9 ad fd ff ff       	jmpq   1642c <memcmp+0x11c>
   1667f:	48 83 e9 04          	sub    $0x4,%rcx
   16683:	0f 84 52 fd ff ff    	je     163db <memcmp+0xcb>
   16689:	48 83 c6 20          	add    $0x20,%rsi
   1668d:	4c 8d 78 20          	lea    0x20(%rax),%r15
   16691:	e9 00 ff ff ff       	jmpq   16596 <memcmp+0x286>
   16696:	49 83 ea 04          	sub    $0x4,%r10
   1669a:	74 b6                	je     16652 <memcmp+0x342>
   1669c:	48 83 c7 20          	add    $0x20,%rdi
   166a0:	4c 8d 78 20          	lea    0x20(%rax),%r15
   166a4:	e9 73 ff ff ff       	jmpq   1661c <memcmp+0x30c>
   166a9:	90                   	nop    
   166aa:	90                   	nop    
   166ab:	90                   	nop    
   166ac:	90                   	nop    
   166ad:	90                   	nop    
   166ae:	90                   	nop    
   166af:	90                   	nop    

00000000000166b0 <strnlen>:

/* Find the length of S, but scan at most MAXLEN characters.  If no
   '\0' terminator is found in that many characters, return MAXLEN.  */
size_t
strnlen (const char *str, size_t maxlen)
{
   166b0:	55                   	push   %rbp
  const char *char_ptr, *end_ptr = str + maxlen;
  const unsigned long int *longword_ptr;
  unsigned long int longword, himagic, lomagic;

  if (maxlen == 0)
    return 0;
   166b1:	31 c0                	xor    %eax,%eax
{
  const char *char_ptr, *end_ptr = str + maxlen;
  const unsigned long int *longword_ptr;
  unsigned long int longword, himagic, lomagic;

  if (maxlen == 0)
   166b3:	48 85 f6             	test   %rsi,%rsi

/* Find the length of S, but scan at most MAXLEN characters.  If no
   '\0' terminator is found in that many characters, return MAXLEN.  */
size_t
strnlen (const char *str, size_t maxlen)
{
   166b6:	48 89 e5             	mov    %rsp,%rbp
  const char *char_ptr, *end_ptr = str + maxlen;
  const unsigned long int *longword_ptr;
  unsigned long int longword, himagic, lomagic;

  if (maxlen == 0)
   166b9:	0f 84 ab 00 00 00    	je     1676a <strnlen+0xba>
    return 0;

  if (__builtin_expect (end_ptr < str, 0))
    end_ptr = (const char *) ~0UL;
   166bf:	48 01 fe             	add    %rdi,%rsi
   166c2:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
   166c9:	48 0f 42 f0          	cmovb  %rax,%rsi

  /* Handle the first few characters by reading one character at a time.
     Do this until CHAR_PTR is aligned on a longword boundary.  */
  for (char_ptr = str; ((unsigned long int) char_ptr
   166cd:	40 f6 c7 07          	test   $0x7,%dil
			& (sizeof (longword) - 1)) != 0;
       ++char_ptr)
    if (*char_ptr == '\0')
   166d1:	48 89 f8             	mov    %rdi,%rax
  if (__builtin_expect (end_ptr < str, 0))
    end_ptr = (const char *) ~0UL;

  /* Handle the first few characters by reading one character at a time.
     Do this until CHAR_PTR is aligned on a longword boundary.  */
  for (char_ptr = str; ((unsigned long int) char_ptr
   166d4:	74 17                	je     166ed <strnlen+0x3d>
			& (sizeof (longword) - 1)) != 0;
       ++char_ptr)
    if (*char_ptr == '\0')
   166d6:	80 3f 00             	cmpb   $0x0,(%rdi)
   166d9:	75 0a                	jne    166e5 <strnlen+0x35>
   166db:	e9 80 00 00 00       	jmpq   16760 <strnlen+0xb0>
   166e0:	80 38 00             	cmpb   $0x0,(%rax)
   166e3:	74 7b                	je     16760 <strnlen+0xb0>

  /* Handle the first few characters by reading one character at a time.
     Do this until CHAR_PTR is aligned on a longword boundary.  */
  for (char_ptr = str; ((unsigned long int) char_ptr
			& (sizeof (longword) - 1)) != 0;
       ++char_ptr)
   166e5:	48 83 c0 01          	add    $0x1,%rax
  if (__builtin_expect (end_ptr < str, 0))
    end_ptr = (const char *) ~0UL;

  /* Handle the first few characters by reading one character at a time.
     Do this until CHAR_PTR is aligned on a longword boundary.  */
  for (char_ptr = str; ((unsigned long int) char_ptr
   166e9:	a8 07                	test   $0x7,%al
   166eb:	75 f3                	jne    166e0 <strnlen+0x30>
    return 0;

  /* Instead of the traditional loop which tests each character,
     we will test a longword at a time.  The tricky part is testing
     if *any of the four* bytes in the longword in question are zero.  */
  while (longword_ptr < (unsigned long int *) end_ptr)
   166ed:	48 39 c6             	cmp    %rax,%rsi
   166f0:	76 6e                	jbe    16760 <strnlen+0xb0>
	 So it ignores everything except 128's, when they're aligned
	 properly.  */

      longword = *longword_ptr++;

      if ((longword - lomagic) & himagic)
   166f2:	49 b9 ff fe fe fe fe 	mov    $0xfefefefefefefeff,%r9
   166f9:	fe fe fe 
   166fc:	49 b8 80 80 80 80 80 	mov    $0x8080808080808080,%r8
   16703:	80 80 80 
   16706:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1670d:	00 00 00 
	 at bit 32!

	 So it ignores everything except 128's, when they're aligned
	 properly.  */

      longword = *longword_ptr++;
   16710:	48 8d 50 08          	lea    0x8(%rax),%rdx

      if ((longword - lomagic) & himagic)
   16714:	4c 89 c9             	mov    %r9,%rcx
   16717:	48 03 4a f8          	add    -0x8(%rdx),%rcx
   1671b:	4c 85 c1             	test   %r8,%rcx
   1671e:	74 30                	je     16750 <strnlen+0xa0>
	     a misfire; continue the search.  */

	  const char *cp = (const char *) (longword_ptr - 1);

	  char_ptr = cp;
	  if (cp[0] == 0)
   16720:	80 7a f8 00          	cmpb   $0x0,-0x8(%rdx)
   16724:	74 3a                	je     16760 <strnlen+0xb0>
	    break;
	  char_ptr = cp + 1;
	  if (cp[1] == 0)
   16726:	80 7a f9 00          	cmpb   $0x0,-0x7(%rdx)
   1672a:	74 40                	je     1676c <strnlen+0xbc>
	    break;
	  char_ptr = cp + 2;
	  if (cp[2] == 0)
   1672c:	80 7a fa 00          	cmpb   $0x0,-0x6(%rdx)
   16730:	74 46                	je     16778 <strnlen+0xc8>
	    break;
	  char_ptr = cp + 3;
	  if (cp[3] == 0)
   16732:	80 7a fb 00          	cmpb   $0x0,-0x5(%rdx)
   16736:	74 3a                	je     16772 <strnlen+0xc2>
	    break;
	  if (sizeof (longword) > 4)
	    {
	      char_ptr = cp + 4;
	      if (cp[4] == 0)
   16738:	80 7a fc 00          	cmpb   $0x0,-0x4(%rdx)
   1673c:	74 40                	je     1677e <strnlen+0xce>
		break;
	      char_ptr = cp + 5;
	      if (cp[5] == 0)
   1673e:	80 7a fd 00          	cmpb   $0x0,-0x3(%rdx)
   16742:	74 40                	je     16784 <strnlen+0xd4>
		break;
	      char_ptr = cp + 6;
	      if (cp[6] == 0)
   16744:	80 7a fe 00          	cmpb   $0x0,-0x2(%rdx)
   16748:	74 40                	je     1678a <strnlen+0xda>
		break;
	      char_ptr = cp + 7;
	      if (cp[7] == 0)
   1674a:	80 7a ff 00          	cmpb   $0x0,-0x1(%rdx)
   1674e:	74 40                	je     16790 <strnlen+0xe0>
    return 0;

  /* Instead of the traditional loop which tests each character,
     we will test a longword at a time.  The tricky part is testing
     if *any of the four* bytes in the longword in question are zero.  */
  while (longword_ptr < (unsigned long int *) end_ptr)
   16750:	48 39 d6             	cmp    %rdx,%rsi
   16753:	48 89 d0             	mov    %rdx,%rax
   16756:	77 b8                	ja     16710 <strnlen+0x60>
   16758:	48 89 f0             	mov    %rsi,%rax
   1675b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   16760:	48 39 f0             	cmp    %rsi,%rax
   16763:	48 0f 47 c6          	cmova  %rsi,%rax
      char_ptr = end_ptr;
    }

  if (char_ptr > end_ptr)
    char_ptr = end_ptr;
  return char_ptr - str;
   16767:	48 29 f8             	sub    %rdi,%rax
}
   1676a:	5d                   	pop    %rbp
   1676b:	c3                   	retq   
	  const char *cp = (const char *) (longword_ptr - 1);

	  char_ptr = cp;
	  if (cp[0] == 0)
	    break;
	  char_ptr = cp + 1;
   1676c:	48 83 c0 01          	add    $0x1,%rax
   16770:	eb ee                	jmp    16760 <strnlen+0xb0>
	  if (cp[1] == 0)
	    break;
	  char_ptr = cp + 2;
	  if (cp[2] == 0)
	    break;
	  char_ptr = cp + 3;
   16772:	48 83 c0 03          	add    $0x3,%rax
   16776:	eb e8                	jmp    16760 <strnlen+0xb0>
	  if (cp[0] == 0)
	    break;
	  char_ptr = cp + 1;
	  if (cp[1] == 0)
	    break;
	  char_ptr = cp + 2;
   16778:	48 83 c0 02          	add    $0x2,%rax
   1677c:	eb e2                	jmp    16760 <strnlen+0xb0>
	  char_ptr = cp + 3;
	  if (cp[3] == 0)
	    break;
	  if (sizeof (longword) > 4)
	    {
	      char_ptr = cp + 4;
   1677e:	48 83 c0 04          	add    $0x4,%rax
   16782:	eb dc                	jmp    16760 <strnlen+0xb0>
	      if (cp[4] == 0)
		break;
	      char_ptr = cp + 5;
   16784:	48 83 c0 05          	add    $0x5,%rax
   16788:	eb d6                	jmp    16760 <strnlen+0xb0>
	      if (cp[5] == 0)
		break;
	      char_ptr = cp + 6;
   1678a:	48 83 c0 06          	add    $0x6,%rax
   1678e:	eb d0                	jmp    16760 <strnlen+0xb0>
	      if (cp[6] == 0)
		break;
	      char_ptr = cp + 7;
   16790:	48 83 c0 07          	add    $0x7,%rax
   16794:	eb ca                	jmp    16760 <strnlen+0xb0>
   16796:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1679d:	00 00 00 

00000000000167a0 <strlen>:
  return char_ptr - str;
}

size_t
strlen (const char *str)
{
   167a0:	55                   	push   %rbp
  return strnlen(str, -1);
   167a1:	48 c7 c6 ff ff ff ff 	mov    $0xffffffffffffffff,%rsi
  return char_ptr - str;
}

size_t
strlen (const char *str)
{
   167a8:	48 89 e5             	mov    %rsp,%rbp
  return strnlen(str, -1);
}
   167ab:	5d                   	pop    %rbp
}

size_t
strlen (const char *str)
{
  return strnlen(str, -1);
   167ac:	e9 ff fe ff ff       	jmpq   166b0 <strnlen>
   167b1:	90                   	nop    
   167b2:	90                   	nop    
   167b3:	90                   	nop    
   167b4:	90                   	nop    
   167b5:	90                   	nop    
   167b6:	90                   	nop    
   167b7:	90                   	nop    
   167b8:	90                   	nop    
   167b9:	90                   	nop    
   167ba:	90                   	nop    
   167bb:	90                   	nop    
   167bc:	90                   	nop    
   167bd:	90                   	nop    
   167be:	90                   	nop    
   167bf:	90                   	nop    

00000000000167c0 <strtol>:
   167c0:	0f b6 07             	movzbl (%rdi),%eax
   167c3:	55                   	push   %rbp
   167c4:	48 89 e5             	mov    %rsp,%rbp
   167c7:	53                   	push   %rbx
   167c8:	3c 09                	cmp    $0x9,%al
   167ca:	75 0f                	jne    167db <strtol+0x1b>
   167cc:	0f 1f 40 00          	nopl   0x0(%rax)
   167d0:	48 83 c7 01          	add    $0x1,%rdi
   167d4:	0f b6 07             	movzbl (%rdi),%eax
   167d7:	3c 09                	cmp    $0x9,%al
   167d9:	74 f5                	je     167d0 <strtol+0x10>
   167db:	3c 20                	cmp    $0x20,%al
   167dd:	74 f1                	je     167d0 <strtol+0x10>
   167df:	3c 2b                	cmp    $0x2b,%al
   167e1:	0f 84 a9 00 00 00    	je     16890 <strtol+0xd0>
   167e7:	45 31 d2             	xor    %r10d,%r10d
   167ea:	45 31 db             	xor    %r11d,%r11d
   167ed:	3c 2d                	cmp    $0x2d,%al
   167ef:	0f 84 ab 00 00 00    	je     168a0 <strtol+0xe0>
   167f5:	f7 c2 ef ff ff ff    	test   $0xffffffef,%edx
   167fb:	74 74                	je     16871 <strtol+0xb1>
   167fd:	0f b6 0f             	movzbl (%rdi),%ecx
   16800:	45 31 c9             	xor    %r9d,%r9d
   16803:	48 63 da             	movslq %edx,%rbx
   16806:	eb 25                	jmp    1682d <strtol+0x6d>
   16808:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   1680f:	00 
   16810:	44 0f be c1          	movsbl %cl,%r8d
   16814:	41 8d 48 d0          	lea    -0x30(%r8),%ecx
   16818:	39 d1                	cmp    %edx,%ecx
   1681a:	7d 2b                	jge    16847 <strtol+0x87>
   1681c:	4c 0f af cb          	imul   %rbx,%r9
   16820:	48 63 c9             	movslq %ecx,%rcx
   16823:	48 83 c7 01          	add    $0x1,%rdi
   16827:	49 01 c9             	add    %rcx,%r9
   1682a:	0f b6 0f             	movzbl (%rdi),%ecx
   1682d:	8d 41 d0             	lea    -0x30(%rcx),%eax
   16830:	3c 09                	cmp    $0x9,%al
   16832:	76 dc                	jbe    16810 <strtol+0x50>
   16834:	8d 41 9f             	lea    -0x61(%rcx),%eax
   16837:	3c 19                	cmp    $0x19,%al
   16839:	77 25                	ja     16860 <strtol+0xa0>
   1683b:	44 0f be c1          	movsbl %cl,%r8d
   1683f:	41 8d 48 a9          	lea    -0x57(%r8),%ecx
   16843:	39 d1                	cmp    %edx,%ecx
   16845:	7c d5                	jl     1681c <strtol+0x5c>
   16847:	48 85 f6             	test   %rsi,%rsi
   1684a:	74 03                	je     1684f <strtol+0x8f>
   1684c:	48 89 3e             	mov    %rdi,(%rsi)
   1684f:	4c 89 c9             	mov    %r9,%rcx
   16852:	4c 31 d9             	xor    %r11,%rcx
   16855:	4a 8d 04 11          	lea    (%rcx,%r10,1),%rax
   16859:	5b                   	pop    %rbx
   1685a:	5d                   	pop    %rbp
   1685b:	c3                   	retq   
   1685c:	0f 1f 40 00          	nopl   0x0(%rax)
   16860:	8d 41 bf             	lea    -0x41(%rcx),%eax
   16863:	3c 19                	cmp    $0x19,%al
   16865:	77 e0                	ja     16847 <strtol+0x87>
   16867:	44 0f be c1          	movsbl %cl,%r8d
   1686b:	41 8d 48 c9          	lea    -0x37(%r8),%ecx
   1686f:	eb a7                	jmp    16818 <strtol+0x58>
   16871:	0f b6 0f             	movzbl (%rdi),%ecx
   16874:	85 d2                	test   %edx,%edx
   16876:	0f 94 c0             	sete   %al
   16879:	80 f9 30             	cmp    $0x30,%cl
   1687c:	74 35                	je     168b3 <strtol+0xf3>
   1687e:	84 c0                	test   %al,%al
   16880:	b8 0a 00 00 00       	mov    $0xa,%eax
   16885:	0f 45 d0             	cmovne %eax,%edx
   16888:	e9 73 ff ff ff       	jmpq   16800 <strtol+0x40>
   1688d:	0f 1f 00             	nopl   (%rax)
   16890:	48 83 c7 01          	add    $0x1,%rdi
   16894:	45 31 d2             	xor    %r10d,%r10d
   16897:	45 31 db             	xor    %r11d,%r11d
   1689a:	e9 56 ff ff ff       	jmpq   167f5 <strtol+0x35>
   1689f:	90                   	nop    
   168a0:	48 83 c7 01          	add    $0x1,%rdi
   168a4:	41 b2 01             	mov    $0x1,%r10b
   168a7:	49 c7 c3 ff ff ff ff 	mov    $0xffffffffffffffff,%r11
   168ae:	e9 42 ff ff ff       	jmpq   167f5 <strtol+0x35>
   168b3:	44 0f b6 47 01       	movzbl 0x1(%rdi),%r8d
   168b8:	41 80 f8 78          	cmp    $0x78,%r8b
   168bc:	74 15                	je     168d3 <strtol+0x113>
   168be:	84 c0                	test   %al,%al
   168c0:	74 23                	je     168e5 <strtol+0x125>
   168c2:	48 83 c7 01          	add    $0x1,%rdi
   168c6:	44 89 c1             	mov    %r8d,%ecx
   168c9:	ba 08 00 00 00       	mov    $0x8,%edx
   168ce:	e9 2d ff ff ff       	jmpq   16800 <strtol+0x40>
   168d3:	0f b6 4f 02          	movzbl 0x2(%rdi),%ecx
   168d7:	ba 10 00 00 00       	mov    $0x10,%edx
   168dc:	48 83 c7 02          	add    $0x2,%rdi
   168e0:	e9 1b ff ff ff       	jmpq   16800 <strtol+0x40>
   168e5:	b9 30 00 00 00       	mov    $0x30,%ecx
   168ea:	e9 11 ff ff ff       	jmpq   16800 <strtol+0x40>
   168ef:	90                   	nop    

00000000000168f0 <atoi>:
   168f0:	55                   	push   %rbp
   168f1:	ba 0a 00 00 00       	mov    $0xa,%edx
   168f6:	31 f6                	xor    %esi,%esi
   168f8:	48 89 e5             	mov    %rsp,%rbp
   168fb:	e8 c0 fe ff ff       	callq  167c0 <strtol>
   16900:	5d                   	pop    %rbp
   16901:	c3                   	retq   
   16902:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
   16909:	1f 84 00 00 00 00 00 

0000000000016910 <atol>:
   16910:	55                   	push   %rbp
   16911:	ba 0a 00 00 00       	mov    $0xa,%edx
   16916:	31 f6                	xor    %esi,%esi
   16918:	48 89 e5             	mov    %rsp,%rbp
   1691b:	5d                   	pop    %rbp
   1691c:	e9 9f fe ff ff       	jmpq   167c0 <strtol>
   16921:	90                   	nop    
   16922:	90                   	nop    
   16923:	90                   	nop    
   16924:	90                   	nop    
   16925:	90                   	nop    
   16926:	90                   	nop    
   16927:	90                   	nop    
   16928:	90                   	nop    
   16929:	90                   	nop    
   1692a:	90                   	nop    
   1692b:	90                   	nop    
   1692c:	90                   	nop    
   1692d:	90                   	nop    
   1692e:	90                   	nop    
   1692f:	90                   	nop    

0000000000016930 <printnum>:
   16930:	55                   	push   %rbp
   16931:	44 89 c0             	mov    %r8d,%eax
   16934:	48 89 e5             	mov    %rsp,%rbp
   16937:	41 57                	push   %r15
   16939:	41 56                	push   %r14
   1693b:	41 55                	push   %r13
   1693d:	41 54                	push   %r12
   1693f:	49 89 f5             	mov    %rsi,%r13
   16942:	53                   	push   %rbx
   16943:	49 89 fc             	mov    %rdi,%r12
   16946:	49 89 d6             	mov    %rdx,%r14
   16949:	48 83 ec 18          	sub    $0x18,%rsp
   1694d:	48 39 c8             	cmp    %rcx,%rax
   16950:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
   16954:	44 8b 7d 10          	mov    0x10(%rbp),%r15d
   16958:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
   1695c:	76 52                	jbe    169b0 <printnum+0x80>
   1695e:	41 8d 59 ff          	lea    -0x1(%r9),%ebx
   16962:	85 db                	test   %ebx,%ebx
   16964:	7e 1b                	jle    16981 <printnum+0x51>
   16966:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   1696d:	00 00 00 
   16970:	4c 89 f2             	mov    %r14,%rdx
   16973:	44 89 fe             	mov    %r15d,%esi
   16976:	4c 89 ef             	mov    %r13,%rdi
   16979:	41 ff d4             	callq  *%r12
   1697c:	83 eb 01             	sub    $0x1,%ebx
   1697f:	75 ef                	jne    16970 <printnum+0x40>
   16981:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
   16985:	31 d2                	xor    %edx,%edx
   16987:	4c 89 ef             	mov    %r13,%rdi
   1698a:	48 f7 75 c8          	divq   -0x38(%rbp)
   1698e:	48 8d 05 47 85 00 00 	lea    0x8547(%rip),%rax        # 1eedc <CSWTCH.16+0x9c>
   16995:	0f be 34 10          	movsbl (%rax,%rdx,1),%esi
   16999:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   1699d:	4c 89 f2             	mov    %r14,%rdx
   169a0:	4c 89 e0             	mov    %r12,%rax
   169a3:	5b                   	pop    %rbx
   169a4:	41 5c                	pop    %r12
   169a6:	41 5d                	pop    %r13
   169a8:	41 5e                	pop    %r14
   169aa:	41 5f                	pop    %r15
   169ac:	5d                   	pop    %rbp
   169ad:	ff e0                	jmpq   *%rax
   169af:	90                   	nop    
   169b0:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
   169b4:	31 d2                	xor    %edx,%edx
   169b6:	48 83 ec 08          	sub    $0x8,%rsp
   169ba:	41 57                	push   %r15
   169bc:	41 83 e9 01          	sub    $0x1,%r9d
   169c0:	48 f7 75 c8          	divq   -0x38(%rbp)
   169c4:	4c 89 f2             	mov    %r14,%rdx
   169c7:	48 89 c1             	mov    %rax,%rcx
   169ca:	e8 61 ff ff ff       	callq  16930 <printnum>
   169cf:	58                   	pop    %rax
   169d0:	5a                   	pop    %rdx
   169d1:	eb ae                	jmp    16981 <printnum+0x51>
   169d3:	66 66 66 66 2e 0f 1f 	nopw   %cs:0x0(%rax,%rax,1)
   169da:	84 00 00 00 00 00 

00000000000169e0 <getuint>:
   169e0:	55                   	push   %rbp
   169e1:	83 fe 01             	cmp    $0x1,%esi
   169e4:	8b 07                	mov    (%rdi),%eax
   169e6:	48 89 e5             	mov    %rsp,%rbp
   169e9:	7e 25                	jle    16a10 <getuint+0x30>
   169eb:	83 f8 30             	cmp    $0x30,%eax
   169ee:	73 10                	jae    16a00 <getuint+0x20>
   169f0:	89 c2                	mov    %eax,%edx
   169f2:	48 03 57 10          	add    0x10(%rdi),%rdx
   169f6:	83 c0 08             	add    $0x8,%eax
   169f9:	89 07                	mov    %eax,(%rdi)
   169fb:	48 8b 02             	mov    (%rdx),%rax
   169fe:	5d                   	pop    %rbp
   169ff:	c3                   	retq   
   16a00:	48 8b 57 08          	mov    0x8(%rdi),%rdx
   16a04:	48 8d 42 08          	lea    0x8(%rdx),%rax
   16a08:	48 89 47 08          	mov    %rax,0x8(%rdi)
   16a0c:	eb ed                	jmp    169fb <getuint+0x1b>
   16a0e:	66 90                	xchg   %ax,%ax
   16a10:	85 f6                	test   %esi,%esi
   16a12:	75 d7                	jne    169eb <getuint+0xb>
   16a14:	83 f8 30             	cmp    $0x30,%eax
   16a17:	73 17                	jae    16a30 <getuint+0x50>
   16a19:	89 c2                	mov    %eax,%edx
   16a1b:	48 03 57 10          	add    0x10(%rdi),%rdx
   16a1f:	83 c0 08             	add    $0x8,%eax
   16a22:	89 07                	mov    %eax,(%rdi)
   16a24:	8b 02                	mov    (%rdx),%eax
   16a26:	5d                   	pop    %rbp
   16a27:	c3                   	retq   
   16a28:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   16a2f:	00 
   16a30:	48 8b 57 08          	mov    0x8(%rdi),%rdx
   16a34:	48 8d 42 08          	lea    0x8(%rdx),%rax
   16a38:	48 89 47 08          	mov    %rax,0x8(%rdi)
   16a3c:	8b 02                	mov    (%rdx),%eax
   16a3e:	eb e6                	jmp    16a26 <getuint+0x46>

0000000000016a40 <getint>:
   16a40:	55                   	push   %rbp
   16a41:	83 fe 01             	cmp    $0x1,%esi
   16a44:	8b 07                	mov    (%rdi),%eax
   16a46:	48 89 e5             	mov    %rsp,%rbp
   16a49:	7e 25                	jle    16a70 <getint+0x30>
   16a4b:	83 f8 30             	cmp    $0x30,%eax
   16a4e:	73 10                	jae    16a60 <getint+0x20>
   16a50:	89 c2                	mov    %eax,%edx
   16a52:	48 03 57 10          	add    0x10(%rdi),%rdx
   16a56:	83 c0 08             	add    $0x8,%eax
   16a59:	89 07                	mov    %eax,(%rdi)
   16a5b:	48 8b 02             	mov    (%rdx),%rax
   16a5e:	5d                   	pop    %rbp
   16a5f:	c3                   	retq   
   16a60:	48 8b 57 08          	mov    0x8(%rdi),%rdx
   16a64:	48 8d 42 08          	lea    0x8(%rdx),%rax
   16a68:	48 89 47 08          	mov    %rax,0x8(%rdi)
   16a6c:	eb ed                	jmp    16a5b <getint+0x1b>
   16a6e:	66 90                	xchg   %ax,%ax
   16a70:	85 f6                	test   %esi,%esi
   16a72:	75 d7                	jne    16a4b <getint+0xb>
   16a74:	83 f8 30             	cmp    $0x30,%eax
   16a77:	73 17                	jae    16a90 <getint+0x50>
   16a79:	89 c2                	mov    %eax,%edx
   16a7b:	48 03 57 10          	add    0x10(%rdi),%rdx
   16a7f:	83 c0 08             	add    $0x8,%eax
   16a82:	89 07                	mov    %eax,(%rdi)
   16a84:	48 63 02             	movslq (%rdx),%rax
   16a87:	5d                   	pop    %rbp
   16a88:	c3                   	retq   
   16a89:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
   16a90:	48 8b 57 08          	mov    0x8(%rdi),%rdx
   16a94:	48 8d 42 08          	lea    0x8(%rdx),%rax
   16a98:	48 89 47 08          	mov    %rax,0x8(%rdi)
   16a9c:	eb e6                	jmp    16a84 <getint+0x44>
   16a9e:	66 90                	xchg   %ax,%ax

0000000000016aa0 <fprintfmt>:
   16aa0:	55                   	push   %rbp
   16aa1:	48 89 e5             	mov    %rsp,%rbp
   16aa4:	48 81 ec d0 00 00 00 	sub    $0xd0,%rsp
   16aab:	84 c0                	test   %al,%al
   16aad:	4c 89 85 70 ff ff ff 	mov    %r8,-0x90(%rbp)
   16ab4:	4c 89 8d 78 ff ff ff 	mov    %r9,-0x88(%rbp)
   16abb:	74 20                	je     16add <fprintfmt+0x3d>
   16abd:	0f 29 45 80          	movaps %xmm0,-0x80(%rbp)
   16ac1:	0f 29 4d 90          	movaps %xmm1,-0x70(%rbp)
   16ac5:	0f 29 55 a0          	movaps %xmm2,-0x60(%rbp)
   16ac9:	0f 29 5d b0          	movaps %xmm3,-0x50(%rbp)
   16acd:	0f 29 65 c0          	movaps %xmm4,-0x40(%rbp)
   16ad1:	0f 29 6d d0          	movaps %xmm5,-0x30(%rbp)
   16ad5:	0f 29 75 e0          	movaps %xmm6,-0x20(%rbp)
   16ad9:	0f 29 7d f0          	movaps %xmm7,-0x10(%rbp)
   16add:	48 8d 45 10          	lea    0x10(%rbp),%rax
   16ae1:	4c 8d 85 38 ff ff ff 	lea    -0xc8(%rbp),%r8
   16ae8:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
   16aef:	48 8d 85 50 ff ff ff 	lea    -0xb0(%rbp),%rax
   16af6:	c7 85 38 ff ff ff 20 	movl   $0x20,-0xc8(%rbp)
   16afd:	00 00 00 
   16b00:	c7 85 3c ff ff ff 30 	movl   $0x30,-0xc4(%rbp)
   16b07:	00 00 00 
   16b0a:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
   16b11:	e8 0a 00 00 00       	callq  16b20 <vfprintfmt>
   16b16:	c9                   	leaveq 
   16b17:	c3                   	retq   
   16b18:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   16b1f:	00 

0000000000016b20 <vfprintfmt>:
   16b20:	55                   	push   %rbp
   16b21:	48 89 e5             	mov    %rsp,%rbp
   16b24:	41 57                	push   %r15
   16b26:	41 56                	push   %r14
   16b28:	41 55                	push   %r13
   16b2a:	41 54                	push   %r12
   16b2c:	49 89 fd             	mov    %rdi,%r13
   16b2f:	53                   	push   %rbx
   16b30:	49 89 f4             	mov    %rsi,%r12
   16b33:	48 89 d3             	mov    %rdx,%rbx
   16b36:	49 89 cf             	mov    %rcx,%r15
   16b39:	48 83 ec 38          	sub    $0x38,%rsp
   16b3d:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
   16b41:	41 0f b6 37          	movzbl (%r15),%esi
   16b45:	4d 8d 77 01          	lea    0x1(%r15),%r14
   16b49:	83 fe 25             	cmp    $0x25,%esi
   16b4c:	75 19                	jne    16b67 <vfprintfmt+0x47>
   16b4e:	eb 30                	jmp    16b80 <vfprintfmt+0x60>
   16b50:	49 83 c6 01          	add    $0x1,%r14
   16b54:	48 89 da             	mov    %rbx,%rdx
   16b57:	4c 89 e7             	mov    %r12,%rdi
   16b5a:	41 ff d5             	callq  *%r13
   16b5d:	41 0f b6 76 ff       	movzbl -0x1(%r14),%esi
   16b62:	83 fe 25             	cmp    $0x25,%esi
   16b65:	74 19                	je     16b80 <vfprintfmt+0x60>
   16b67:	85 f6                	test   %esi,%esi
   16b69:	75 e5                	jne    16b50 <vfprintfmt+0x30>
   16b6b:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   16b6f:	5b                   	pop    %rbx
   16b70:	41 5c                	pop    %r12
   16b72:	41 5d                	pop    %r13
   16b74:	41 5e                	pop    %r14
   16b76:	41 5f                	pop    %r15
   16b78:	5d                   	pop    %rbp
   16b79:	c3                   	retq   
   16b7a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
   16b80:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   16b85:	41 bb 20 00 00 00    	mov    $0x20,%r11d
   16b8b:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
   16b92:	41 89 c9             	mov    %ecx,%r9d
   16b95:	31 d2                	xor    %edx,%edx
   16b97:	31 ff                	xor    %edi,%edi
   16b99:	41 0f b6 36          	movzbl (%r14),%esi
   16b9d:	4d 8d 7e 01          	lea    0x1(%r14),%r15
   16ba1:	89 f0                	mov    %esi,%eax
   16ba3:	83 e8 23             	sub    $0x23,%eax
   16ba6:	3c 55                	cmp    $0x55,%al
   16ba8:	0f 87 87 03 00 00    	ja     16f35 <vfprintfmt+0x415>
   16bae:	4c 8d 15 4b 83 00 00 	lea    0x834b(%rip),%r10        # 1ef00 <CSWTCH.16+0xc0>
   16bb5:	0f b6 c0             	movzbl %al,%eax
   16bb8:	49 63 04 82          	movslq (%r10,%rax,4),%rax
   16bbc:	4c 01 d0             	add    %r10,%rax
   16bbf:	ff e0                	jmpq   *%rax
   16bc1:	4d 89 fe             	mov    %r15,%r14
   16bc4:	41 bb 20 00 00 00    	mov    $0x20,%r11d
   16bca:	eb cd                	jmp    16b99 <vfprintfmt+0x79>
   16bcc:	45 85 c9             	test   %r9d,%r9d
   16bcf:	4d 89 fe             	mov    %r15,%r14
   16bd2:	44 0f 48 cf          	cmovs  %edi,%r9d
   16bd6:	eb c1                	jmp    16b99 <vfprintfmt+0x79>
   16bd8:	4d 89 fe             	mov    %r15,%r14
   16bdb:	41 bb 30 00 00 00    	mov    $0x30,%r11d
   16be1:	eb b6                	jmp    16b99 <vfprintfmt+0x79>
   16be3:	41 0f be 46 01       	movsbl 0x1(%r14),%eax
   16be8:	8d 4e d0             	lea    -0x30(%rsi),%ecx
   16beb:	4d 89 fe             	mov    %r15,%r14
   16bee:	8d 70 d0             	lea    -0x30(%rax),%esi
   16bf1:	83 fe 09             	cmp    $0x9,%esi
   16bf4:	77 21                	ja     16c17 <vfprintfmt+0xf7>
   16bf6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   16bfd:	00 00 00 
   16c00:	8d 0c 89             	lea    (%rcx,%rcx,4),%ecx
   16c03:	49 83 c6 01          	add    $0x1,%r14
   16c07:	8d 4c 48 d0          	lea    -0x30(%rax,%rcx,2),%ecx
   16c0b:	41 0f be 06          	movsbl (%r14),%eax
   16c0f:	8d 70 d0             	lea    -0x30(%rax),%esi
   16c12:	83 fe 09             	cmp    $0x9,%esi
   16c15:	76 e9                	jbe    16c00 <vfprintfmt+0xe0>
   16c17:	45 85 c9             	test   %r9d,%r9d
   16c1a:	0f 89 79 ff ff ff    	jns    16b99 <vfprintfmt+0x79>
   16c20:	41 89 c9             	mov    %ecx,%r9d
   16c23:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
   16c28:	e9 6c ff ff ff       	jmpq   16b99 <vfprintfmt+0x79>
   16c2d:	48 89 da             	mov    %rbx,%rdx
   16c30:	be 1b 00 00 00       	mov    $0x1b,%esi
   16c35:	4c 89 e7             	mov    %r12,%rdi
   16c38:	41 ff d5             	callq  *%r13
   16c3b:	e9 01 ff ff ff       	jmpq   16b41 <vfprintfmt+0x21>
   16c40:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   16c44:	8b 00                	mov    (%rax),%eax
   16c46:	83 f8 30             	cmp    $0x30,%eax
   16c49:	0f 83 ea 03 00 00    	jae    17039 <vfprintfmt+0x519>
   16c4f:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
   16c53:	89 c1                	mov    %eax,%ecx
   16c55:	83 c0 08             	add    $0x8,%eax
   16c58:	48 03 4f 10          	add    0x10(%rdi),%rcx
   16c5c:	89 07                	mov    %eax,(%rdi)
   16c5e:	48 89 da             	mov    %rbx,%rdx
   16c61:	8b 31                	mov    (%rcx),%esi
   16c63:	4c 89 e7             	mov    %r12,%rdi
   16c66:	41 ff d5             	callq  *%r13
   16c69:	e9 d3 fe ff ff       	jmpq   16b41 <vfprintfmt+0x21>
   16c6e:	83 fa 01             	cmp    $0x1,%edx
   16c71:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   16c75:	0f 8e e8 03 00 00    	jle    17063 <vfprintfmt+0x543>
   16c7b:	8b 00                	mov    (%rax),%eax
   16c7d:	83 f8 2f             	cmp    $0x2f,%eax
   16c80:	0f 87 74 03 00 00    	ja     16ffa <vfprintfmt+0x4da>
   16c86:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   16c8a:	89 c2                	mov    %eax,%edx
   16c8c:	83 c0 08             	add    $0x8,%eax
   16c8f:	48 03 51 10          	add    0x10(%rcx),%rdx
   16c93:	89 01                	mov    %eax,(%rcx)
   16c95:	48 8b 0a             	mov    (%rdx),%rcx
   16c98:	48 85 c9             	test   %rcx,%rcx
   16c9b:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
   16ca1:	0f 89 24 01 00 00    	jns    16dcb <vfprintfmt+0x2ab>
   16ca7:	44 89 45 a8          	mov    %r8d,-0x58(%rbp)
   16cab:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
   16caf:	48 89 da             	mov    %rbx,%rdx
   16cb2:	44 89 4d b8          	mov    %r9d,-0x48(%rbp)
   16cb6:	44 88 5d c4          	mov    %r11b,-0x3c(%rbp)
   16cba:	be 2d 00 00 00       	mov    $0x2d,%esi
   16cbf:	4c 89 e7             	mov    %r12,%rdi
   16cc2:	41 ff d5             	callq  *%r13
   16cc5:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
   16cc9:	44 0f be 5d c4       	movsbl -0x3c(%rbp),%r11d
   16cce:	44 8b 4d b8          	mov    -0x48(%rbp),%r9d
   16cd2:	44 8b 45 a8          	mov    -0x58(%rbp),%r8d
   16cd6:	48 f7 d9             	neg    %rcx
   16cd9:	e9 ed 00 00 00       	jmpq   16dcb <vfprintfmt+0x2ab>
   16cde:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   16ce2:	8b 00                	mov    (%rax),%eax
   16ce4:	83 f8 30             	cmp    $0x30,%eax
   16ce7:	0f 83 61 03 00 00    	jae    1704e <vfprintfmt+0x52e>
   16ced:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   16cf1:	89 c2                	mov    %eax,%edx
   16cf3:	83 c0 08             	add    $0x8,%eax
   16cf6:	48 03 51 10          	add    0x10(%rcx),%rdx
   16cfa:	89 01                	mov    %eax,(%rcx)
   16cfc:	8b 02                	mov    (%rdx),%eax
   16cfe:	99                   	cltd   
   16cff:	31 d0                	xor    %edx,%eax
   16d01:	29 d0                	sub    %edx,%eax
   16d03:	48 8b 15 be cd 20 00 	mov    0x20cdbe(%rip),%rdx        # 223ac8 <_DYNAMIC+0x2e0>
   16d0a:	48 63 c8             	movslq %eax,%rcx
   16d0d:	48 8b 12             	mov    (%rdx),%rdx
   16d10:	4c 8b 04 ca          	mov    (%rdx,%rcx,8),%r8
   16d14:	4d 85 c0             	test   %r8,%r8
   16d17:	0f 84 fc 03 00 00    	je     17119 <vfprintfmt+0x5f9>
   16d1d:	48 8d 0d 9e 1c 00 00 	lea    0x1c9e(%rip),%rcx        # 189c2 <handle_sizes.1924+0x242>
   16d24:	48 89 da             	mov    %rbx,%rdx
   16d27:	4c 89 e6             	mov    %r12,%rsi
   16d2a:	4c 89 ef             	mov    %r13,%rdi
   16d2d:	31 c0                	xor    %eax,%eax
   16d2f:	e8 6c fd ff ff       	callq  16aa0 <fprintfmt>
   16d34:	e9 08 fe ff ff       	jmpq   16b41 <vfprintfmt+0x21>
   16d39:	83 c2 01             	add    $0x1,%edx
   16d3c:	4d 89 fe             	mov    %r15,%r14
   16d3f:	e9 55 fe ff ff       	jmpq   16b99 <vfprintfmt+0x79>
   16d44:	83 fa 01             	cmp    $0x1,%edx
   16d47:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   16d4b:	0f 8e 9c 03 00 00    	jle    170ed <vfprintfmt+0x5cd>
   16d51:	8b 00                	mov    (%rax),%eax
   16d53:	83 f8 2f             	cmp    $0x2f,%eax
   16d56:	0f 87 89 02 00 00    	ja     16fe5 <vfprintfmt+0x4c5>
   16d5c:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   16d60:	89 c2                	mov    %eax,%edx
   16d62:	83 c0 08             	add    $0x8,%eax
   16d65:	48 03 51 10          	add    0x10(%rcx),%rdx
   16d69:	89 01                	mov    %eax,(%rcx)
   16d6b:	48 8b 0a             	mov    (%rdx),%rcx
   16d6e:	41 b8 08 00 00 00    	mov    $0x8,%r8d
   16d74:	eb 55                	jmp    16dcb <vfprintfmt+0x2ab>
   16d76:	44 88 5d b8          	mov    %r11b,-0x48(%rbp)
   16d7a:	44 89 4d c4          	mov    %r9d,-0x3c(%rbp)
   16d7e:	48 89 da             	mov    %rbx,%rdx
   16d81:	be 30 00 00 00       	mov    $0x30,%esi
   16d86:	4c 89 e7             	mov    %r12,%rdi
   16d89:	41 ff d5             	callq  *%r13
   16d8c:	48 89 da             	mov    %rbx,%rdx
   16d8f:	be 78 00 00 00       	mov    $0x78,%esi
   16d94:	4c 89 e7             	mov    %r12,%rdi
   16d97:	41 ff d5             	callq  *%r13
   16d9a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   16d9e:	44 8b 4d c4          	mov    -0x3c(%rbp),%r9d
   16da2:	44 0f be 5d b8       	movsbl -0x48(%rbp),%r11d
   16da7:	8b 00                	mov    (%rax),%eax
   16da9:	83 f8 30             	cmp    $0x30,%eax
   16dac:	0f 82 f5 00 00 00    	jb     16ea7 <vfprintfmt+0x387>
   16db2:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   16db6:	48 8b 51 08          	mov    0x8(%rcx),%rdx
   16dba:	48 8d 42 08          	lea    0x8(%rdx),%rax
   16dbe:	48 89 41 08          	mov    %rax,0x8(%rcx)
   16dc2:	48 8b 0a             	mov    (%rdx),%rcx
   16dc5:	41 b8 10 00 00 00    	mov    $0x10,%r8d
   16dcb:	48 83 ec 08          	sub    $0x8,%rsp
   16dcf:	48 89 da             	mov    %rbx,%rdx
   16dd2:	4c 89 e6             	mov    %r12,%rsi
   16dd5:	41 53                	push   %r11
   16dd7:	4c 89 ef             	mov    %r13,%rdi
   16dda:	e8 51 fb ff ff       	callq  16930 <printnum>
   16ddf:	58                   	pop    %rax
   16de0:	5a                   	pop    %rdx
   16de1:	e9 5b fd ff ff       	jmpq   16b41 <vfprintfmt+0x21>
   16de6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   16dea:	8b 00                	mov    (%rax),%eax
   16dec:	83 f8 30             	cmp    $0x30,%eax
   16def:	0f 83 2f 02 00 00    	jae    17024 <vfprintfmt+0x504>
   16df5:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
   16df9:	89 c2                	mov    %eax,%edx
   16dfb:	83 c0 08             	add    $0x8,%eax
   16dfe:	48 03 57 10          	add    0x10(%rdi),%rdx
   16e02:	89 07                	mov    %eax,(%rdi)
   16e04:	4c 8b 32             	mov    (%rdx),%r14
   16e07:	48 8d 05 df 80 00 00 	lea    0x80df(%rip),%rax        # 1eeed <CSWTCH.16+0xad>
   16e0e:	44 88 5d b0          	mov    %r11b,-0x50(%rbp)
   16e12:	44 89 4d b8          	mov    %r9d,-0x48(%rbp)
   16e16:	4d 85 f6             	test   %r14,%r14
   16e19:	4c 0f 44 f0          	cmove  %rax,%r14
   16e1d:	45 85 c9             	test   %r9d,%r9d
   16e20:	0f 8e 3b 01 00 00    	jle    16f61 <vfprintfmt+0x441>
   16e26:	48 63 f1             	movslq %ecx,%rsi
   16e29:	4c 89 f7             	mov    %r14,%rdi
   16e2c:	89 4d a8             	mov    %ecx,-0x58(%rbp)
   16e2f:	e8 7c f8 ff ff       	callq  166b0 <strnlen>
   16e34:	44 8b 4d b8          	mov    -0x48(%rbp),%r9d
   16e38:	8b 4d a8             	mov    -0x58(%rbp),%ecx
   16e3b:	41 29 c1             	sub    %eax,%r9d
   16e3e:	45 85 c9             	test   %r9d,%r9d
   16e41:	0f 8e 1a 01 00 00    	jle    16f61 <vfprintfmt+0x441>
   16e47:	0f be 45 b0          	movsbl -0x50(%rbp),%eax
   16e4b:	4c 89 75 b8          	mov    %r14,-0x48(%rbp)
   16e4f:	45 89 ce             	mov    %r9d,%r14d
   16e52:	4c 89 7d a8          	mov    %r15,-0x58(%rbp)
   16e56:	89 4d b0             	mov    %ecx,-0x50(%rbp)
   16e59:	41 89 c7             	mov    %eax,%r15d
   16e5c:	0f 1f 40 00          	nopl   0x0(%rax)
   16e60:	48 89 da             	mov    %rbx,%rdx
   16e63:	44 89 fe             	mov    %r15d,%esi
   16e66:	4c 89 e7             	mov    %r12,%rdi
   16e69:	41 ff d5             	callq  *%r13
   16e6c:	41 83 ee 01          	sub    $0x1,%r14d
   16e70:	75 ee                	jne    16e60 <vfprintfmt+0x340>
   16e72:	4c 8b 75 b8          	mov    -0x48(%rbp),%r14
   16e76:	4c 8b 7d a8          	mov    -0x58(%rbp),%r15
   16e7a:	8b 4d b0             	mov    -0x50(%rbp),%ecx
   16e7d:	4c 89 7d b8          	mov    %r15,-0x48(%rbp)
   16e81:	4d 89 ef             	mov    %r13,%r15
   16e84:	4d 89 f5             	mov    %r14,%r13
   16e87:	41 89 ce             	mov    %ecx,%r14d
   16e8a:	e9 e1 00 00 00       	jmpq   16f70 <vfprintfmt+0x450>
   16e8f:	83 fa 01             	cmp    $0x1,%edx
   16e92:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   16e96:	0f 8e 21 02 00 00    	jle    170bd <vfprintfmt+0x59d>
   16e9c:	8b 00                	mov    (%rax),%eax
   16e9e:	83 f8 2f             	cmp    $0x2f,%eax
   16ea1:	0f 87 0b ff ff ff    	ja     16db2 <vfprintfmt+0x292>
   16ea7:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   16eab:	89 c2                	mov    %eax,%edx
   16ead:	83 c0 08             	add    $0x8,%eax
   16eb0:	48 03 51 10          	add    0x10(%rcx),%rdx
   16eb4:	89 01                	mov    %eax,(%rcx)
   16eb6:	e9 07 ff ff ff       	jmpq   16dc2 <vfprintfmt+0x2a2>
   16ebb:	4d 89 fe             	mov    %r15,%r14
   16ebe:	c7 45 c4 01 00 00 00 	movl   $0x1,-0x3c(%rbp)
   16ec5:	e9 cf fc ff ff       	jmpq   16b99 <vfprintfmt+0x79>
   16eca:	83 fa 01             	cmp    $0x1,%edx
   16ecd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   16ed1:	0f 8e b6 01 00 00    	jle    1708d <vfprintfmt+0x56d>
   16ed7:	8b 00                	mov    (%rax),%eax
   16ed9:	83 f8 2f             	cmp    $0x2f,%eax
   16edc:	0f 87 ee 00 00 00    	ja     16fd0 <vfprintfmt+0x4b0>
   16ee2:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   16ee6:	89 c2                	mov    %eax,%edx
   16ee8:	83 c0 08             	add    $0x8,%eax
   16eeb:	48 03 51 10          	add    0x10(%rcx),%rdx
   16eef:	89 01                	mov    %eax,(%rcx)
   16ef1:	48 8b 0a             	mov    (%rdx),%rcx
   16ef4:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
   16efa:	e9 cc fe ff ff       	jmpq   16dcb <vfprintfmt+0x2ab>
   16eff:	48 89 da             	mov    %rbx,%rdx
   16f02:	4c 89 e7             	mov    %r12,%rdi
   16f05:	41 ff d5             	callq  *%r13
   16f08:	e9 34 fc ff ff       	jmpq   16b41 <vfprintfmt+0x21>
   16f0d:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   16f11:	8b 00                	mov    (%rax),%eax
   16f13:	83 f8 30             	cmp    $0x30,%eax
   16f16:	0f 83 f3 00 00 00    	jae    1700f <vfprintfmt+0x4ef>
   16f1c:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
   16f20:	89 c1                	mov    %eax,%ecx
   16f22:	83 c0 08             	add    $0x8,%eax
   16f25:	48 03 4e 10          	add    0x10(%rsi),%rcx
   16f29:	89 06                	mov    %eax,(%rsi)
   16f2b:	8b 09                	mov    (%rcx),%ecx
   16f2d:	4d 89 fe             	mov    %r15,%r14
   16f30:	e9 e2 fc ff ff       	jmpq   16c17 <vfprintfmt+0xf7>
   16f35:	48 89 da             	mov    %rbx,%rdx
   16f38:	be 25 00 00 00       	mov    $0x25,%esi
   16f3d:	4c 89 e7             	mov    %r12,%rdi
   16f40:	41 ff d5             	callq  *%r13
   16f43:	41 80 7e ff 25       	cmpb   $0x25,-0x1(%r14)
   16f48:	4d 89 f7             	mov    %r14,%r15
   16f4b:	0f 84 f0 fb ff ff    	je     16b41 <vfprintfmt+0x21>
   16f51:	49 83 ef 01          	sub    $0x1,%r15
   16f55:	41 80 7f ff 25       	cmpb   $0x25,-0x1(%r15)
   16f5a:	75 f5                	jne    16f51 <vfprintfmt+0x431>
   16f5c:	e9 e0 fb ff ff       	jmpq   16b41 <vfprintfmt+0x21>
   16f61:	4c 89 7d b8          	mov    %r15,-0x48(%rbp)
   16f65:	4d 89 ef             	mov    %r13,%r15
   16f68:	4d 89 f5             	mov    %r14,%r13
   16f6b:	41 89 ce             	mov    %ecx,%r14d
   16f6e:	66 90                	xchg   %ax,%ax
   16f70:	49 83 c5 01          	add    $0x1,%r13
   16f74:	41 0f be 75 ff       	movsbl -0x1(%r13),%esi
   16f79:	85 f6                	test   %esi,%esi
   16f7b:	74 34                	je     16fb1 <vfprintfmt+0x491>
   16f7d:	45 85 f6             	test   %r14d,%r14d
   16f80:	78 0a                	js     16f8c <vfprintfmt+0x46c>
   16f82:	41 83 ee 01          	sub    $0x1,%r14d
   16f86:	41 83 fe ff          	cmp    $0xffffffffffffffff,%r14d
   16f8a:	74 25                	je     16fb1 <vfprintfmt+0x491>
   16f8c:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
   16f8f:	85 c9                	test   %ecx,%ecx
   16f91:	74 08                	je     16f9b <vfprintfmt+0x47b>
   16f93:	8d 56 e0             	lea    -0x20(%rsi),%edx
   16f96:	83 fa 5e             	cmp    $0x5e,%edx
   16f99:	77 25                	ja     16fc0 <vfprintfmt+0x4a0>
   16f9b:	49 83 c5 01          	add    $0x1,%r13
   16f9f:	48 89 da             	mov    %rbx,%rdx
   16fa2:	4c 89 e7             	mov    %r12,%rdi
   16fa5:	41 ff d7             	callq  *%r15
   16fa8:	41 0f be 75 ff       	movsbl -0x1(%r13),%esi
   16fad:	85 f6                	test   %esi,%esi
   16faf:	75 cc                	jne    16f7d <vfprintfmt+0x45d>
   16fb1:	4d 89 fd             	mov    %r15,%r13
   16fb4:	4c 8b 7d b8          	mov    -0x48(%rbp),%r15
   16fb8:	e9 84 fb ff ff       	jmpq   16b41 <vfprintfmt+0x21>
   16fbd:	0f 1f 00             	nopl   (%rax)
   16fc0:	48 89 da             	mov    %rbx,%rdx
   16fc3:	be 3f 00 00 00       	mov    $0x3f,%esi
   16fc8:	4c 89 e7             	mov    %r12,%rdi
   16fcb:	41 ff d7             	callq  *%r15
   16fce:	eb a0                	jmp    16f70 <vfprintfmt+0x450>
   16fd0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   16fd4:	48 8b 51 08          	mov    0x8(%rcx),%rdx
   16fd8:	48 8d 42 08          	lea    0x8(%rdx),%rax
   16fdc:	48 89 41 08          	mov    %rax,0x8(%rcx)
   16fe0:	e9 0c ff ff ff       	jmpq   16ef1 <vfprintfmt+0x3d1>
   16fe5:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   16fe9:	48 8b 51 08          	mov    0x8(%rcx),%rdx
   16fed:	48 8d 42 08          	lea    0x8(%rdx),%rax
   16ff1:	48 89 41 08          	mov    %rax,0x8(%rcx)
   16ff5:	e9 71 fd ff ff       	jmpq   16d6b <vfprintfmt+0x24b>
   16ffa:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   16ffe:	48 8b 51 08          	mov    0x8(%rcx),%rdx
   17002:	48 8d 42 08          	lea    0x8(%rdx),%rax
   17006:	48 89 41 08          	mov    %rax,0x8(%rcx)
   1700a:	e9 86 fc ff ff       	jmpq   16c95 <vfprintfmt+0x175>
   1700f:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
   17013:	48 8b 4e 08          	mov    0x8(%rsi),%rcx
   17017:	48 8d 41 08          	lea    0x8(%rcx),%rax
   1701b:	48 89 46 08          	mov    %rax,0x8(%rsi)
   1701f:	e9 07 ff ff ff       	jmpq   16f2b <vfprintfmt+0x40b>
   17024:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
   17028:	48 8b 57 08          	mov    0x8(%rdi),%rdx
   1702c:	48 8d 42 08          	lea    0x8(%rdx),%rax
   17030:	48 89 47 08          	mov    %rax,0x8(%rdi)
   17034:	e9 cb fd ff ff       	jmpq   16e04 <vfprintfmt+0x2e4>
   17039:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
   1703d:	48 8b 4f 08          	mov    0x8(%rdi),%rcx
   17041:	48 8d 41 08          	lea    0x8(%rcx),%rax
   17045:	48 89 47 08          	mov    %rax,0x8(%rdi)
   17049:	e9 10 fc ff ff       	jmpq   16c5e <vfprintfmt+0x13e>
   1704e:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   17052:	48 8b 51 08          	mov    0x8(%rcx),%rdx
   17056:	48 8d 42 08          	lea    0x8(%rdx),%rax
   1705a:	48 89 41 08          	mov    %rax,0x8(%rcx)
   1705e:	e9 99 fc ff ff       	jmpq   16cfc <vfprintfmt+0x1dc>
   17063:	85 d2                	test   %edx,%edx
   17065:	8b 10                	mov    (%rax),%edx
   17067:	0f 84 15 01 00 00    	je     17182 <vfprintfmt+0x662>
   1706d:	83 fa 2f             	cmp    $0x2f,%edx
   17070:	0f 87 9e 01 00 00    	ja     17214 <vfprintfmt+0x6f4>
   17076:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   1707a:	89 d0                	mov    %edx,%eax
   1707c:	83 c2 08             	add    $0x8,%edx
   1707f:	48 03 41 10          	add    0x10(%rcx),%rax
   17083:	89 11                	mov    %edx,(%rcx)
   17085:	48 8b 08             	mov    (%rax),%rcx
   17088:	e9 0b fc ff ff       	jmpq   16c98 <vfprintfmt+0x178>
   1708d:	85 d2                	test   %edx,%edx
   1708f:	8b 10                	mov    (%rax),%edx
   17091:	0f 84 c6 00 00 00    	je     1715d <vfprintfmt+0x63d>
   17097:	83 fa 2f             	cmp    $0x2f,%edx
   1709a:	0f 87 4a 01 00 00    	ja     171ea <vfprintfmt+0x6ca>
   170a0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   170a4:	89 d0                	mov    %edx,%eax
   170a6:	83 c2 08             	add    $0x8,%edx
   170a9:	48 03 41 10          	add    0x10(%rcx),%rax
   170ad:	89 11                	mov    %edx,(%rcx)
   170af:	48 8b 08             	mov    (%rax),%rcx
   170b2:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
   170b8:	e9 0e fd ff ff       	jmpq   16dcb <vfprintfmt+0x2ab>
   170bd:	85 d2                	test   %edx,%edx
   170bf:	8b 10                	mov    (%rax),%edx
   170c1:	0f 84 db 00 00 00    	je     171a2 <vfprintfmt+0x682>
   170c7:	83 fa 2f             	cmp    $0x2f,%edx
   170ca:	0f 87 6e 01 00 00    	ja     1723e <vfprintfmt+0x71e>
   170d0:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   170d4:	89 d0                	mov    %edx,%eax
   170d6:	83 c2 08             	add    $0x8,%edx
   170d9:	48 03 41 10          	add    0x10(%rcx),%rax
   170dd:	89 11                	mov    %edx,(%rcx)
   170df:	48 8b 08             	mov    (%rax),%rcx
   170e2:	41 b8 10 00 00 00    	mov    $0x10,%r8d
   170e8:	e9 de fc ff ff       	jmpq   16dcb <vfprintfmt+0x2ab>
   170ed:	85 d2                	test   %edx,%edx
   170ef:	8b 10                	mov    (%rax),%edx
   170f1:	74 45                	je     17138 <vfprintfmt+0x618>
   170f3:	83 fa 2f             	cmp    $0x2f,%edx
   170f6:	0f 87 c7 00 00 00    	ja     171c3 <vfprintfmt+0x6a3>
   170fc:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   17100:	89 d0                	mov    %edx,%eax
   17102:	83 c2 08             	add    $0x8,%edx
   17105:	48 03 41 10          	add    0x10(%rcx),%rax
   17109:	89 11                	mov    %edx,(%rcx)
   1710b:	48 8b 08             	mov    (%rax),%rcx
   1710e:	41 b8 08 00 00 00    	mov    $0x8,%r8d
   17114:	e9 b2 fc ff ff       	jmpq   16dcb <vfprintfmt+0x2ab>
   17119:	48 8d 0d d4 7d 00 00 	lea    0x7dd4(%rip),%rcx        # 1eef4 <CSWTCH.16+0xb4>
   17120:	41 89 c0             	mov    %eax,%r8d
   17123:	48 89 da             	mov    %rbx,%rdx
   17126:	4c 89 e6             	mov    %r12,%rsi
   17129:	4c 89 ef             	mov    %r13,%rdi
   1712c:	31 c0                	xor    %eax,%eax
   1712e:	e8 6d f9 ff ff       	callq  16aa0 <fprintfmt>
   17133:	e9 09 fa ff ff       	jmpq   16b41 <vfprintfmt+0x21>
   17138:	83 fa 2f             	cmp    $0x2f,%edx
   1713b:	0f 87 be 00 00 00    	ja     171ff <vfprintfmt+0x6df>
   17141:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   17145:	89 d0                	mov    %edx,%eax
   17147:	83 c2 08             	add    $0x8,%edx
   1714a:	48 03 41 10          	add    0x10(%rcx),%rax
   1714e:	89 11                	mov    %edx,(%rcx)
   17150:	8b 08                	mov    (%rax),%ecx
   17152:	41 b8 08 00 00 00    	mov    $0x8,%r8d
   17158:	e9 6e fc ff ff       	jmpq   16dcb <vfprintfmt+0x2ab>
   1715d:	83 fa 2f             	cmp    $0x2f,%edx
   17160:	0f 87 c3 00 00 00    	ja     17229 <vfprintfmt+0x709>
   17166:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   1716a:	89 d0                	mov    %edx,%eax
   1716c:	83 c2 08             	add    $0x8,%edx
   1716f:	48 03 41 10          	add    0x10(%rcx),%rax
   17173:	89 11                	mov    %edx,(%rcx)
   17175:	8b 08                	mov    (%rax),%ecx
   17177:	41 b8 0a 00 00 00    	mov    $0xa,%r8d
   1717d:	e9 49 fc ff ff       	jmpq   16dcb <vfprintfmt+0x2ab>
   17182:	83 fa 2f             	cmp    $0x2f,%edx
   17185:	0f 87 c8 00 00 00    	ja     17253 <vfprintfmt+0x733>
   1718b:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   1718f:	89 d0                	mov    %edx,%eax
   17191:	83 c2 08             	add    $0x8,%edx
   17194:	48 03 41 10          	add    0x10(%rcx),%rax
   17198:	89 11                	mov    %edx,(%rcx)
   1719a:	48 63 08             	movslq (%rax),%rcx
   1719d:	e9 f6 fa ff ff       	jmpq   16c98 <vfprintfmt+0x178>
   171a2:	83 fa 2f             	cmp    $0x2f,%edx
   171a5:	77 31                	ja     171d8 <vfprintfmt+0x6b8>
   171a7:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   171ab:	89 d0                	mov    %edx,%eax
   171ad:	83 c2 08             	add    $0x8,%edx
   171b0:	48 03 41 10          	add    0x10(%rcx),%rax
   171b4:	89 11                	mov    %edx,(%rcx)
   171b6:	8b 08                	mov    (%rax),%ecx
   171b8:	41 b8 10 00 00 00    	mov    $0x10,%r8d
   171be:	e9 08 fc ff ff       	jmpq   16dcb <vfprintfmt+0x2ab>
   171c3:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   171c7:	48 8b 41 08          	mov    0x8(%rcx),%rax
   171cb:	48 8d 50 08          	lea    0x8(%rax),%rdx
   171cf:	48 89 51 08          	mov    %rdx,0x8(%rcx)
   171d3:	e9 33 ff ff ff       	jmpq   1710b <vfprintfmt+0x5eb>
   171d8:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   171dc:	48 8b 41 08          	mov    0x8(%rcx),%rax
   171e0:	48 8d 50 08          	lea    0x8(%rax),%rdx
   171e4:	48 89 51 08          	mov    %rdx,0x8(%rcx)
   171e8:	eb cc                	jmp    171b6 <vfprintfmt+0x696>
   171ea:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   171ee:	48 8b 41 08          	mov    0x8(%rcx),%rax
   171f2:	48 8d 50 08          	lea    0x8(%rax),%rdx
   171f6:	48 89 51 08          	mov    %rdx,0x8(%rcx)
   171fa:	e9 b0 fe ff ff       	jmpq   170af <vfprintfmt+0x58f>
   171ff:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   17203:	48 8b 41 08          	mov    0x8(%rcx),%rax
   17207:	48 8d 50 08          	lea    0x8(%rax),%rdx
   1720b:	48 89 51 08          	mov    %rdx,0x8(%rcx)
   1720f:	e9 3c ff ff ff       	jmpq   17150 <vfprintfmt+0x630>
   17214:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   17218:	48 8b 41 08          	mov    0x8(%rcx),%rax
   1721c:	48 8d 50 08          	lea    0x8(%rax),%rdx
   17220:	48 89 51 08          	mov    %rdx,0x8(%rcx)
   17224:	e9 5c fe ff ff       	jmpq   17085 <vfprintfmt+0x565>
   17229:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   1722d:	48 8b 41 08          	mov    0x8(%rcx),%rax
   17231:	48 8d 50 08          	lea    0x8(%rax),%rdx
   17235:	48 89 51 08          	mov    %rdx,0x8(%rcx)
   17239:	e9 37 ff ff ff       	jmpq   17175 <vfprintfmt+0x655>
   1723e:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   17242:	48 8b 41 08          	mov    0x8(%rcx),%rax
   17246:	48 8d 50 08          	lea    0x8(%rax),%rdx
   1724a:	48 89 51 08          	mov    %rdx,0x8(%rcx)
   1724e:	e9 8c fe ff ff       	jmpq   170df <vfprintfmt+0x5bf>
   17253:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
   17257:	48 8b 41 08          	mov    0x8(%rcx),%rax
   1725b:	48 8d 50 08          	lea    0x8(%rax),%rdx
   1725f:	48 89 51 08          	mov    %rdx,0x8(%rcx)
   17263:	e9 32 ff ff ff       	jmpq   1719a <vfprintfmt+0x67a>
   17268:	90                   	nop    
   17269:	90                   	nop    
   1726a:	90                   	nop    
   1726b:	90                   	nop    
   1726c:	90                   	nop    
   1726d:	90                   	nop    
   1726e:	90                   	nop    
   1726f:	90                   	nop    

0000000000017270 <inet_pton4>:
 *    does not touch `dst' unless it's returning 1.
 * author:
 *    Paul Vixie, 1996.
 */
static int inet_pton4 (const char *src, unsigned char *dst)
{
   17270:	55                   	push   %rbp
   17271:	49 89 f3             	mov    %rsi,%r11
    int saw_digit, octets, ch;
    unsigned char tmp[NS_INADDRSZ], *tp;

    saw_digit = 0;
    octets = 0;
   17274:	45 31 d2             	xor    %r10d,%r10d
static int inet_pton4 (const char *src, unsigned char *dst)
{
    int saw_digit, octets, ch;
    unsigned char tmp[NS_INADDRSZ], *tp;

    saw_digit = 0;
   17277:	31 d2                	xor    %edx,%edx
 *    does not touch `dst' unless it's returning 1.
 * author:
 *    Paul Vixie, 1996.
 */
static int inet_pton4 (const char *src, unsigned char *dst)
{
   17279:	48 89 e5             	mov    %rsp,%rbp
   1727c:	48 83 ec 10          	sub    $0x10,%rsp
    int saw_digit, octets, ch;
    unsigned char tmp[NS_INADDRSZ], *tp;

    saw_digit = 0;
    octets = 0;
    *(tp = tmp) = 0;
   17280:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
   17284:	c6 45 f0 00          	movb   $0x0,-0x10(%rbp)
   17288:	49 89 f0             	mov    %rsi,%r8
   1728b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    while ((ch = *src++) != '\0') {
   17290:	48 83 c7 01          	add    $0x1,%rdi
   17294:	0f be 47 ff          	movsbl -0x1(%rdi),%eax
   17298:	85 c0                	test   %eax,%eax
   1729a:	74 46                	je     172e2 <inet_pton4+0x72>

        if (ch >= '0' && ch <= '9') {
   1729c:	8d 48 d0             	lea    -0x30(%rax),%ecx
   1729f:	83 f9 09             	cmp    $0x9,%ecx
   172a2:	77 4c                	ja     172f0 <inet_pton4+0x80>
            u_int new = *tp * 10 + (ch - '0');
   172a4:	45 0f b6 08          	movzbl (%r8),%r9d
   172a8:	44 89 c8             	mov    %r9d,%eax
   172ab:	47 8d 0c 89          	lea    (%r9,%r9,4),%r9d

            if (saw_digit && *tp == 0)
   172af:	84 c0                	test   %al,%al
    octets = 0;
    *(tp = tmp) = 0;
    while ((ch = *src++) != '\0') {

        if (ch >= '0' && ch <= '9') {
            u_int new = *tp * 10 + (ch - '0');
   172b1:	42 8d 0c 49          	lea    (%rcx,%r9,2),%ecx

            if (saw_digit && *tp == 0)
   172b5:	75 04                	jne    172bb <inet_pton4+0x4b>
   172b7:	85 d2                	test   %edx,%edx
   172b9:	75 2d                	jne    172e8 <inet_pton4+0x78>
                return (0);
            if (new > 255)
   172bb:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
   172c1:	77 25                	ja     172e8 <inet_pton4+0x78>
                return (0);
            *tp = new;
            if (! saw_digit) {
   172c3:	85 d2                	test   %edx,%edx

            if (saw_digit && *tp == 0)
                return (0);
            if (new > 255)
                return (0);
            *tp = new;
   172c5:	41 88 08             	mov    %cl,(%r8)
            if (! saw_digit) {
   172c8:	75 46                	jne    17310 <inet_pton4+0xa0>
                if (++octets > 4)
   172ca:	41 83 c2 01          	add    $0x1,%r10d
   172ce:	41 83 fa 04          	cmp    $0x4,%r10d
   172d2:	7f 14                	jg     172e8 <inet_pton4+0x78>
    unsigned char tmp[NS_INADDRSZ], *tp;

    saw_digit = 0;
    octets = 0;
    *(tp = tmp) = 0;
    while ((ch = *src++) != '\0') {
   172d4:	48 83 c7 01          	add    $0x1,%rdi
   172d8:	0f be 47 ff          	movsbl -0x1(%rdi),%eax
                return (0);
            *tp = new;
            if (! saw_digit) {
                if (++octets > 4)
                    return (0);
                saw_digit = 1;
   172dc:	b2 01                	mov    $0x1,%dl
    unsigned char tmp[NS_INADDRSZ], *tp;

    saw_digit = 0;
    octets = 0;
    *(tp = tmp) = 0;
    while ((ch = *src++) != '\0') {
   172de:	85 c0                	test   %eax,%eax
   172e0:	75 ba                	jne    1729c <inet_pton4+0x2c>
            *++tp = 0;
            saw_digit = 0;
        } else
            return (0);
    }
    if (octets < 4)
   172e2:	41 83 fa 03          	cmp    $0x3,%r10d
   172e6:	7f 32                	jg     1731a <inet_pton4+0xaa>

        if (ch >= '0' && ch <= '9') {
            u_int new = *tp * 10 + (ch - '0');

            if (saw_digit && *tp == 0)
                return (0);
   172e8:	31 c0                	xor    %eax,%eax
    }
    if (octets < 4)
        return (0);
    memcpy (dst, tmp, NS_INADDRSZ);
    return (1);
}
   172ea:	c9                   	leaveq 
   172eb:	c3                   	retq   
   172ec:	0f 1f 40 00          	nopl   0x0(%rax)
            if (! saw_digit) {
                if (++octets > 4)
                    return (0);
                saw_digit = 1;
            }
        } else if (ch == '.' && saw_digit) {
   172f0:	83 f8 2e             	cmp    $0x2e,%eax
   172f3:	0f 94 c0             	sete   %al
   172f6:	21 c2                	and    %eax,%edx
            if (octets == 4)
   172f8:	41 83 fa 04          	cmp    $0x4,%r10d
   172fc:	0f 94 c0             	sete   %al
   172ff:	38 c2                	cmp    %al,%dl
   17301:	76 e5                	jbe    172e8 <inet_pton4+0x78>
                return (0);
            *++tp = 0;
   17303:	41 c6 40 01 00       	movb   $0x0,0x1(%r8)
            saw_digit = 0;
   17308:	31 d2                	xor    %edx,%edx
                saw_digit = 1;
            }
        } else if (ch == '.' && saw_digit) {
            if (octets == 4)
                return (0);
            *++tp = 0;
   1730a:	49 83 c0 01          	add    $0x1,%r8
   1730e:	eb 80                	jmp    17290 <inet_pton4+0x20>
   17310:	ba 01 00 00 00       	mov    $0x1,%edx
   17315:	e9 76 ff ff ff       	jmpq   17290 <inet_pton4+0x20>
        } else
            return (0);
    }
    if (octets < 4)
        return (0);
    memcpy (dst, tmp, NS_INADDRSZ);
   1731a:	ba 04 00 00 00       	mov    $0x4,%edx
   1731f:	4c 89 df             	mov    %r11,%rdi
   17322:	e8 59 ef ff ff       	callq  16280 <memcpy>
    return (1);
   17327:	b8 01 00 00 00       	mov    $0x1,%eax
}
   1732c:	c9                   	leaveq 
   1732d:	c3                   	retq   
   1732e:	66 90                	xchg   %ax,%ax

0000000000017330 <__inet_pton>:
 *    -1 if some other error occurred (`dst' is untouched in this case, too)
 * author:
 *    Paul Vixie, 1996.
 */
int inet_pton (int af, const char *src, void *dst)
{
   17330:	55                   	push   %rbp
   17331:	48 89 e5             	mov    %rsp,%rbp
   17334:	41 57                	push   %r15
   17336:	41 56                	push   %r14
   17338:	41 55                	push   %r13
   1733a:	41 54                	push   %r12
   1733c:	49 89 f7             	mov    %rsi,%r15
   1733f:	53                   	push   %rbx
   17340:	49 89 d5             	mov    %rdx,%r13
   17343:	48 83 ec 48          	sub    $0x48,%rsp
    switch (af) {
   17347:	83 ff 02             	cmp    $0x2,%edi
   1734a:	0f 84 25 01 00 00    	je     17475 <__inet_pton+0x145>
   17350:	83 ff 1c             	cmp    $0x1c,%edi
   17353:	0f 85 08 01 00 00    	jne    17461 <__inet_pton+0x131>
    unsigned char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;
    const char *curtok;
    int ch, saw_xdigit;
    unsigned int val;

    tp = memset (tmp, '\0', NS_IN6ADDRSZ);
   17359:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
   1735d:	31 f6                	xor    %esi,%esi
   1735f:	ba 10 00 00 00       	mov    $0x10,%edx
   17364:	48 89 c7             	mov    %rax,%rdi
   17367:	48 89 45 98          	mov    %rax,-0x68(%rbp)
   1736b:	e8 30 ee ff ff       	callq  161a0 <memset>
    endp = tp + NS_IN6ADDRSZ;
    colonp = NULL;
    /* Leading :: requires some special handling. */
    if (*src == ':')
   17370:	41 0f be 1f          	movsbl (%r15),%ebx
    unsigned char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;
    const char *curtok;
    int ch, saw_xdigit;
    unsigned int val;

    tp = memset (tmp, '\0', NS_IN6ADDRSZ);
   17374:	49 89 c6             	mov    %rax,%r14
    endp = tp + NS_IN6ADDRSZ;
   17377:	48 8d 40 10          	lea    0x10(%rax),%rax
   1737b:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
    colonp = NULL;
    /* Leading :: requires some special handling. */
    if (*src == ':')
   1737f:	80 fb 3a             	cmp    $0x3a,%bl
   17382:	0f 84 29 01 00 00    	je     174b1 <__inet_pton+0x181>
    return (1);
}

static int tolower (char c)
{
  return c >= 'A' && c < 'Z' ? c + ('a' - 'A') : c;
   17388:	8d 43 bf             	lea    -0x41(%rbx),%eax
    colonp = NULL;
    /* Leading :: requires some special handling. */
    if (*src == ':')
        if (*++src != ':')
            return (0);
    curtok = src;
   1738b:	4c 89 7d 90          	mov    %r15,-0x70(%rbp)
    saw_xdigit = 0;
    val = 0;
   1738f:	45 31 e4             	xor    %r12d,%r12d
    while ((ch = tolower (*src++)) != '\0') {
   17392:	49 83 c7 01          	add    $0x1,%r15
    unsigned char tmp[NS_IN6ADDRSZ], *tp, *endp, *colonp;
    const char *curtok;
    int ch, saw_xdigit;
    unsigned int val;

    tp = memset (tmp, '\0', NS_IN6ADDRSZ);
   17396:	4c 89 75 a8          	mov    %r14,-0x58(%rbp)
    /* Leading :: requires some special handling. */
    if (*src == ':')
        if (*++src != ':')
            return (0);
    curtok = src;
    saw_xdigit = 0;
   1739a:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
    return (1);
}

static int tolower (char c)
{
  return c >= 'A' && c < 'Z' ? c + ('a' - 'A') : c;
   173a1:	3c 18                	cmp    $0x18,%al
    int ch, saw_xdigit;
    unsigned int val;

    tp = memset (tmp, '\0', NS_IN6ADDRSZ);
    endp = tp + NS_IN6ADDRSZ;
    colonp = NULL;
   173a3:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
   173aa:	00 
    return (1);
}

static int tolower (char c)
{
  return c >= 'A' && c < 'Z' ? c + ('a' - 'A') : c;
   173ab:	77 4e                	ja     173fb <__inet_pton+0xcb>
   173ad:	83 c3 20             	add    $0x20,%ebx
    saw_xdigit = 0;
    val = 0;
    while ((ch = tolower (*src++)) != '\0') {
        const char *pch;

        pch = strchr (xdigits, ch);
   173b0:	48 8d 3d a9 7c 00 00 	lea    0x7ca9(%rip),%rdi        # 1f060 <xdigits.2821>
   173b7:	89 de                	mov    %ebx,%esi
   173b9:	e8 52 ec ff ff       	callq  16010 <strchr>
        if (pch != NULL) {
   173be:	48 85 c0             	test   %rax,%rax
   173c1:	0f 84 ac 01 00 00    	je     17573 <__inet_pton+0x243>
            val <<= 4;
            val |= (pch - xdigits);
   173c7:	48 8d 0d 92 7c 00 00 	lea    0x7c92(%rip),%rcx        # 1f060 <xdigits.2821>
    while ((ch = tolower (*src++)) != '\0') {
        const char *pch;

        pch = strchr (xdigits, ch);
        if (pch != NULL) {
            val <<= 4;
   173ce:	41 c1 e4 04          	shl    $0x4,%r12d
            val |= (pch - xdigits);
   173d2:	48 29 c8             	sub    %rcx,%rax
   173d5:	41 09 c4             	or     %eax,%r12d
            if (val > 0xffff)
   173d8:	41 81 fc ff ff 00 00 	cmp    $0xffff,%r12d
   173df:	0f 87 bb 00 00 00    	ja     174a0 <__inet_pton+0x170>
                return (0);
            saw_xdigit = 1;
   173e5:	c7 45 bc 01 00 00 00 	movl   $0x1,-0x44(%rbp)
   173ec:	41 0f be 1f          	movsbl (%r15),%ebx
        if (*++src != ':')
            return (0);
    curtok = src;
    saw_xdigit = 0;
    val = 0;
    while ((ch = tolower (*src++)) != '\0') {
   173f0:	49 83 c7 01          	add    $0x1,%r15
    return (1);
}

static int tolower (char c)
{
  return c >= 'A' && c < 'Z' ? c + ('a' - 'A') : c;
   173f4:	8d 43 bf             	lea    -0x41(%rbx),%eax
   173f7:	3c 18                	cmp    $0x18,%al
   173f9:	76 b2                	jbe    173ad <__inet_pton+0x7d>
        if (*++src != ':')
            return (0);
    curtok = src;
    saw_xdigit = 0;
    val = 0;
    while ((ch = tolower (*src++)) != '\0') {
   173fb:	85 db                	test   %ebx,%ebx
   173fd:	0f 84 dd 00 00 00    	je     174e0 <__inet_pton+0x1b0>
        const char *pch;

        pch = strchr (xdigits, ch);
   17403:	48 8d 3d 56 7c 00 00 	lea    0x7c56(%rip),%rdi        # 1f060 <xdigits.2821>
   1740a:	89 de                	mov    %ebx,%esi
   1740c:	e8 ff eb ff ff       	callq  16010 <strchr>
        if (pch != NULL) {
   17411:	48 85 c0             	test   %rax,%rax
   17414:	75 b1                	jne    173c7 <__inet_pton+0x97>
            if (val > 0xffff)
                return (0);
            saw_xdigit = 1;
            continue;
        }
        if (ch == ':') {
   17416:	83 fb 3a             	cmp    $0x3a,%ebx
   17419:	0f 85 54 01 00 00    	jne    17573 <__inet_pton+0x243>
            curtok = src;
            if (!saw_xdigit) {
   1741f:	8b 4d bc             	mov    -0x44(%rbp),%ecx
   17422:	85 c9                	test   %ecx,%ecx
   17424:	0f 84 97 00 00 00    	je     174c1 <__inet_pton+0x191>
                if (colonp)
                    return (0);
                colonp = tp;
                continue;
            } else if (*src == '\0') {
   1742a:	41 80 3f 00          	cmpb   $0x0,(%r15)
   1742e:	74 70                	je     174a0 <__inet_pton+0x170>
                return (0);
            }
            if (tp + NS_INT16SZ > endp)
   17430:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
   17434:	48 89 c8             	mov    %rcx,%rax
   17437:	48 83 c0 02          	add    $0x2,%rax
   1743b:	48 39 45 b0          	cmp    %rax,-0x50(%rbp)
   1743f:	72 5f                	jb     174a0 <__inet_pton+0x170>
                return (0);
            *tp++ = (unsigned char) (val >> 8) & 0xff;
   17441:	44 89 e2             	mov    %r12d,%edx
            *tp++ = (unsigned char) val & 0xff;
   17444:	44 88 61 01          	mov    %r12b,0x1(%rcx)
   17448:	4c 89 7d 90          	mov    %r15,-0x70(%rbp)
            } else if (*src == '\0') {
                return (0);
            }
            if (tp + NS_INT16SZ > endp)
                return (0);
            *tp++ = (unsigned char) (val >> 8) & 0xff;
   1744c:	c1 ea 08             	shr    $0x8,%edx
            *tp++ = (unsigned char) val & 0xff;
   1744f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
            saw_xdigit = 0;
            val = 0;
   17453:	45 31 e4             	xor    %r12d,%r12d
            } else if (*src == '\0') {
                return (0);
            }
            if (tp + NS_INT16SZ > endp)
                return (0);
            *tp++ = (unsigned char) (val >> 8) & 0xff;
   17456:	88 11                	mov    %dl,(%rcx)
            *tp++ = (unsigned char) val & 0xff;
            saw_xdigit = 0;
   17458:	c7 45 bc 00 00 00 00 	movl   $0x0,-0x44(%rbp)
   1745f:	eb 8b                	jmp    173ec <__inet_pton+0xbc>
    case AF_INET:
        return (inet_pton4(src, dst));
    case AF_INET6:
        return (inet_pton6(src, dst));
    default:
        return -EAFNOSUPPORT;
   17461:	b8 9f ff ff ff       	mov    $0xffffff9f,%eax
    }
    /* NOTREACHED */
}
   17466:	48 83 c4 48          	add    $0x48,%rsp
   1746a:	5b                   	pop    %rbx
   1746b:	41 5c                	pop    %r12
   1746d:	41 5d                	pop    %r13
   1746f:	41 5e                	pop    %r14
   17471:	41 5f                	pop    %r15
   17473:	5d                   	pop    %rbp
   17474:	c3                   	retq   
 */
int inet_pton (int af, const char *src, void *dst)
{
    switch (af) {
    case AF_INET:
        return (inet_pton4(src, dst));
   17475:	4c 89 ff             	mov    %r15,%rdi
   17478:	48 89 d6             	mov    %rdx,%rsi
   1747b:	e8 f0 fd ff ff       	callq  17270 <inet_pton4>
        return (inet_pton6(src, dst));
    default:
        return -EAFNOSUPPORT;
    }
    /* NOTREACHED */
}
   17480:	48 83 c4 48          	add    $0x48,%rsp
   17484:	5b                   	pop    %rbx
   17485:	41 5c                	pop    %r12
   17487:	41 5d                	pop    %r13
   17489:	41 5e                	pop    %r14
   1748b:	41 5f                	pop    %r15
   1748d:	5d                   	pop    %rbp
   1748e:	c3                   	retq   
            endp[- i] = colonp[n - i];
            colonp[n - i] = 0;
        }
        tp = endp;
    }
    if (tp != endp)
   1748f:	48 39 4d b0          	cmp    %rcx,-0x50(%rbp)
   17493:	0f 84 bf 00 00 00    	je     17558 <__inet_pton+0x228>
   17499:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    endp = tp + NS_IN6ADDRSZ;
    colonp = NULL;
    /* Leading :: requires some special handling. */
    if (*src == ':')
        if (*++src != ':')
            return (0);
   174a0:	31 c0                	xor    %eax,%eax
        return (inet_pton6(src, dst));
    default:
        return -EAFNOSUPPORT;
    }
    /* NOTREACHED */
}
   174a2:	48 83 c4 48          	add    $0x48,%rsp
   174a6:	5b                   	pop    %rbx
   174a7:	41 5c                	pop    %r12
   174a9:	41 5d                	pop    %r13
   174ab:	41 5e                	pop    %r14
   174ad:	41 5f                	pop    %r15
   174af:	5d                   	pop    %rbp
   174b0:	c3                   	retq   
    tp = memset (tmp, '\0', NS_IN6ADDRSZ);
    endp = tp + NS_IN6ADDRSZ;
    colonp = NULL;
    /* Leading :: requires some special handling. */
    if (*src == ':')
        if (*++src != ':')
   174b1:	41 80 7f 01 3a       	cmpb   $0x3a,0x1(%r15)
   174b6:	75 e8                	jne    174a0 <__inet_pton+0x170>
   174b8:	49 83 c7 01          	add    $0x1,%r15
   174bc:	e9 c7 fe ff ff       	jmpq   17388 <__inet_pton+0x58>
            continue;
        }
        if (ch == ':') {
            curtok = src;
            if (!saw_xdigit) {
                if (colonp)
   174c1:	48 83 7d a0 00       	cmpq   $0x0,-0x60(%rbp)
   174c6:	75 d8                	jne    174a0 <__inet_pton+0x170>
   174c8:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
        if (*++src != ':')
            return (0);
    curtok = src;
    saw_xdigit = 0;
    val = 0;
    while ((ch = tolower (*src++)) != '\0') {
   174cc:	4c 89 7d 90          	mov    %r15,-0x70(%rbp)
            continue;
        }
        if (ch == ':') {
            curtok = src;
            if (!saw_xdigit) {
                if (colonp)
   174d0:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
   174d4:	e9 13 ff ff ff       	jmpq   173ec <__inet_pton+0xbc>
   174d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            saw_xdigit = 0;
            break;    /* '\0' was seen by inet_pton4(). */
        }
        return (0);
    }
    if (saw_xdigit) {
   174e0:	8b 55 bc             	mov    -0x44(%rbp),%edx
        if (*++src != ':')
            return (0);
    curtok = src;
    saw_xdigit = 0;
    val = 0;
    while ((ch = tolower (*src++)) != '\0') {
   174e3:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
            saw_xdigit = 0;
            break;    /* '\0' was seen by inet_pton4(). */
        }
        return (0);
    }
    if (saw_xdigit) {
   174e7:	85 d2                	test   %edx,%edx
   174e9:	74 1a                	je     17505 <__inet_pton+0x1d5>
        if (tp + NS_INT16SZ > endp)
   174eb:	48 8d 56 02          	lea    0x2(%rsi),%rdx
   174ef:	48 39 55 b0          	cmp    %rdx,-0x50(%rbp)
   174f3:	72 ab                	jb     174a0 <__inet_pton+0x170>
            return (0);
        *tp++ = (unsigned char) (val >> 8) & 0xff;
   174f5:	44 89 e1             	mov    %r12d,%ecx
        *tp++ = (unsigned char) val & 0xff;
   174f8:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
   174fc:	44 88 66 01          	mov    %r12b,0x1(%rsi)
        return (0);
    }
    if (saw_xdigit) {
        if (tp + NS_INT16SZ > endp)
            return (0);
        *tp++ = (unsigned char) (val >> 8) & 0xff;
   17500:	c1 e9 08             	shr    $0x8,%ecx
   17503:	88 0e                	mov    %cl,(%rsi)
        *tp++ = (unsigned char) val & 0xff;
    }
    if (colonp != NULL) {
   17505:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
        /*
         * Since some memmove()'s erroneously fail to handle
         * overlapping regions, we'll do the shift by hand.
         */
        const int n = tp - colonp;
   17509:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
        if (tp + NS_INT16SZ > endp)
            return (0);
        *tp++ = (unsigned char) (val >> 8) & 0xff;
        *tp++ = (unsigned char) val & 0xff;
    }
    if (colonp != NULL) {
   1750d:	48 85 d2             	test   %rdx,%rdx
   17510:	0f 84 79 ff ff ff    	je     1748f <__inet_pton+0x15f>
        /*
         * Since some memmove()'s erroneously fail to handle
         * overlapping regions, we'll do the shift by hand.
         */
        const int n = tp - colonp;
   17516:	48 89 c8             	mov    %rcx,%rax
   17519:	48 29 d0             	sub    %rdx,%rax
        int i;

        if (tp == endp)
   1751c:	48 39 4d b0          	cmp    %rcx,-0x50(%rbp)
    if (colonp != NULL) {
        /*
         * Since some memmove()'s erroneously fail to handle
         * overlapping regions, we'll do the shift by hand.
         */
        const int n = tp - colonp;
   17520:	48 63 d0             	movslq %eax,%rdx
        int i;

        if (tp == endp)
   17523:	0f 84 77 ff ff ff    	je     174a0 <__inet_pton+0x170>
            return (0);
        for (i = 1; i <= n; i++) {
   17529:	85 c0                	test   %eax,%eax
   1752b:	7e 2b                	jle    17558 <__inet_pton+0x228>
   1752d:	48 03 55 a0          	add    -0x60(%rbp),%rdx
   17531:	8d 70 ff             	lea    -0x1(%rax),%esi
   17534:	31 c0                	xor    %eax,%eax
   17536:	48 f7 d6             	not    %rsi
   17539:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
            endp[- i] = colonp[n - i];
   17540:	0f b6 4c 02 ff       	movzbl -0x1(%rdx,%rax,1),%ecx
   17545:	41 88 4c 06 0f       	mov    %cl,0xf(%r14,%rax,1)
            colonp[n - i] = 0;
   1754a:	c6 44 02 ff 00       	movb   $0x0,-0x1(%rdx,%rax,1)
   1754f:	48 83 e8 01          	sub    $0x1,%rax
        const int n = tp - colonp;
        int i;

        if (tp == endp)
            return (0);
        for (i = 1; i <= n; i++) {
   17553:	48 39 f0             	cmp    %rsi,%rax
   17556:	75 e8                	jne    17540 <__inet_pton+0x210>
        }
        tp = endp;
    }
    if (tp != endp)
        return (0);
    memcpy (dst, tmp, NS_IN6ADDRSZ);
   17558:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
   1755c:	ba 10 00 00 00       	mov    $0x10,%edx
   17561:	4c 89 ef             	mov    %r13,%rdi
   17564:	e8 17 ed ff ff       	callq  16280 <memcpy>
    return (1);
   17569:	b8 01 00 00 00       	mov    $0x1,%eax
   1756e:	e9 f3 fe ff ff       	jmpq   17466 <__inet_pton+0x136>
            *tp++ = (unsigned char) val & 0xff;
            saw_xdigit = 0;
            val = 0;
            continue;
        }
        if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&
   17573:	83 fb 2e             	cmp    $0x2e,%ebx
   17576:	0f 85 24 ff ff ff    	jne    174a0 <__inet_pton+0x170>
   1757c:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
   17580:	48 8d 58 04          	lea    0x4(%rax),%rbx
   17584:	48 39 5d b0          	cmp    %rbx,-0x50(%rbp)
   17588:	0f 82 12 ff ff ff    	jb     174a0 <__inet_pton+0x170>
            inet_pton4(curtok, tp) > 0) {
   1758e:	48 8b 7d 90          	mov    -0x70(%rbp),%rdi
   17592:	48 89 c6             	mov    %rax,%rsi
   17595:	e8 d6 fc ff ff       	callq  17270 <inet_pton4>
            *tp++ = (unsigned char) val & 0xff;
            saw_xdigit = 0;
            val = 0;
            continue;
        }
        if (ch == '.' && ((tp + NS_INADDRSZ) <= endp) &&
   1759a:	85 c0                	test   %eax,%eax
   1759c:	48 89 5d a8          	mov    %rbx,-0x58(%rbp)
   175a0:	0f 8f 5f ff ff ff    	jg     17505 <__inet_pton+0x1d5>
    endp = tp + NS_IN6ADDRSZ;
    colonp = NULL;
    /* Leading :: requires some special handling. */
    if (*src == ':')
        if (*++src != ':')
            return (0);
   175a6:	31 c0                	xor    %eax,%eax
   175a8:	e9 f5 fe ff ff       	jmpq   174a2 <__inet_pton+0x172>
   175ad:	90                   	nop    
   175ae:	90                   	nop    
   175af:	90                   	nop    

00000000000175b0 <__dup_config>:
   175b0:	55                   	push   %rbp
   175b1:	48 89 e5             	mov    %rsp,%rbp
   175b4:	41 57                	push   %r15
   175b6:	41 56                	push   %r14
   175b8:	41 55                	push   %r13
   175ba:	41 54                	push   %r12
   175bc:	49 89 cc             	mov    %rcx,%r12
   175bf:	53                   	push   %rbx
   175c0:	48 89 d3             	mov    %rdx,%rbx
   175c3:	48 83 ec 38          	sub    $0x38,%rsp
   175c7:	48 8b 06             	mov    (%rsi),%rax
   175ca:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
   175ce:	48 89 75 a8          	mov    %rsi,-0x58(%rbp)
   175d2:	48 89 f7             	mov    %rsi,%rdi
   175d5:	48 8d 72 10          	lea    0x10(%rdx),%rsi
   175d9:	4c 89 45 b8          	mov    %r8,-0x48(%rbp)
   175dd:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
   175e1:	48 39 c7             	cmp    %rax,%rdi
   175e4:	4c 8d 78 c0          	lea    -0x40(%rax),%r15
   175e8:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
   175ec:	0f 85 ef 00 00 00    	jne    176e1 <__dup_config+0x131>
   175f2:	e9 4e 02 00 00       	jmpq   17845 <__dup_config+0x295>
   175f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   175fe:	00 00 
   17600:	4d 85 f6             	test   %r14,%r14
   17603:	41 0f 94 c3          	sete   %r11b
   17607:	31 c9                	xor    %ecx,%ecx
   17609:	4d 85 ed             	test   %r13,%r13
   1760c:	49 8b 37             	mov    (%r15),%rsi
   1760f:	75 09                	jne    1761a <__dup_config+0x6a>
   17611:	48 85 f6             	test   %rsi,%rsi
   17614:	0f 85 46 02 00 00    	jne    17860 <__dup_config+0x2b0>
   1761a:	45 84 db             	test   %r11b,%r11b
   1761d:	49 8b 77 08          	mov    0x8(%r15),%rsi
   17621:	74 09                	je     1762c <__dup_config+0x7c>
   17623:	48 85 f6             	test   %rsi,%rsi
   17626:	0f 85 f4 01 00 00    	jne    17820 <__dup_config+0x270>
   1762c:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
   17630:	bf 50 00 00 00       	mov    $0x50,%edi
   17635:	ff 53 30             	callq  *0x30(%rbx)
   17638:	48 85 c0             	test   %rax,%rax
   1763b:	48 89 c2             	mov    %rax,%rdx
   1763e:	0f 84 4c 02 00 00    	je     17890 <__dup_config+0x2e0>
   17644:	4c 89 28             	mov    %r13,(%rax)
   17647:	41 8b 47 10          	mov    0x10(%r15),%eax
   1764b:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
   1764f:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
   17653:	4c 89 72 08          	mov    %r14,0x8(%rdx)
   17657:	89 42 10             	mov    %eax,0x10(%rdx)
   1765a:	41 8b 47 14          	mov    0x14(%r15),%eax
   1765e:	48 89 4a 18          	mov    %rcx,0x18(%rdx)
   17662:	89 42 14             	mov    %eax,0x14(%rdx)
   17665:	48 8d 42 20          	lea    0x20(%rdx),%rax
   17669:	48 89 42 28          	mov    %rax,0x28(%rdx)
   1766d:	48 8b 4b 18          	mov    0x18(%rbx),%rcx
   17671:	48 89 43 18          	mov    %rax,0x18(%rbx)
   17675:	48 89 7a 20          	mov    %rdi,0x20(%rdx)
   17679:	48 89 4a 28          	mov    %rcx,0x28(%rdx)
   1767d:	48 89 01             	mov    %rax,(%rcx)
   17680:	48 8d 42 40          	lea    0x40(%rdx),%rax
   17684:	48 8d 4a 30          	lea    0x30(%rdx),%rcx
   17688:	48 89 42 48          	mov    %rax,0x48(%rdx)
   1768c:	48 89 4a 38          	mov    %rcx,0x38(%rdx)
   17690:	49 8b 74 24 08       	mov    0x8(%r12),%rsi
   17695:	48 89 4a 30          	mov    %rcx,0x30(%rdx)
   17699:	49 89 44 24 08       	mov    %rax,0x8(%r12)
   1769e:	4c 89 62 40          	mov    %r12,0x40(%rdx)
   176a2:	48 89 72 48          	mov    %rsi,0x48(%rdx)
   176a6:	48 89 06             	mov    %rax,(%rsi)
   176a9:	49 8d 77 30          	lea    0x30(%r15),%rsi
   176ad:	49 39 77 30          	cmp    %rsi,0x30(%r15)
   176b1:	74 1c                	je     176cf <__dup_config+0x11f>
   176b3:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
   176b7:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
   176bb:	48 89 da             	mov    %rbx,%rdx
   176be:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
   176c2:	e8 e9 fe ff ff       	callq  175b0 <__dup_config>
   176c7:	85 c0                	test   %eax,%eax
   176c9:	0f 88 78 01 00 00    	js     17847 <__dup_config+0x297>
   176cf:	49 8b 47 40          	mov    0x40(%r15),%rax
   176d3:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
   176d7:	4c 8d 78 c0          	lea    -0x40(%rax),%r15
   176db:	0f 84 64 01 00 00    	je     17845 <__dup_config+0x295>
   176e1:	49 8b 37             	mov    (%r15),%rsi
   176e4:	48 85 f6             	test   %rsi,%rsi
   176e7:	0f 84 03 01 00 00    	je     177f0 <__dup_config+0x240>
   176ed:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   176f1:	49 63 57 10          	movslq 0x10(%r15),%rdx
   176f5:	48 8b 00             	mov    (%rax),%rax
   176f8:	48 89 d1             	mov    %rdx,%rcx
   176fb:	48 39 d0             	cmp    %rdx,%rax
   176fe:	77 70                	ja     17770 <__dup_config+0x1c0>
   17700:	49 83 7f 08 00       	cmpq   $0x0,0x8(%r15)
   17705:	0f 84 a5 00 00 00    	je     177b0 <__dup_config+0x200>
   1770b:	45 31 ed             	xor    %r13d,%r13d
   1770e:	49 63 57 14          	movslq 0x14(%r15),%rdx
   17712:	48 39 c2             	cmp    %rax,%rdx
   17715:	72 2a                	jb     17741 <__dup_config+0x191>
   17717:	01 d1                	add    %edx,%ecx
   17719:	45 31 f6             	xor    %r14d,%r14d
   1771c:	85 c9                	test   %ecx,%ecx
   1771e:	0f 84 dc fe ff ff    	je     17600 <__dup_config+0x50>
   17724:	89 cf                	mov    %ecx,%edi
   17726:	ff 53 30             	callq  *0x30(%rbx)
   17729:	48 85 c0             	test   %rax,%rax
   1772c:	48 89 c1             	mov    %rax,%rcx
   1772f:	0f 84 5b 01 00 00    	je     17890 <__dup_config+0x2e0>
   17735:	4d 85 f6             	test   %r14,%r14
   17738:	41 0f 94 c3          	sete   %r11b
   1773c:	e9 c8 fe ff ff       	jmpq   17609 <__dup_config+0x59>
   17741:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
   17745:	48 29 d0             	sub    %rdx,%rax
   17748:	89 4d c0             	mov    %ecx,-0x40(%rbp)
   1774b:	4c 8b 37             	mov    (%rdi),%r14
   1774e:	49 8d 34 16          	lea    (%r14,%rdx,1),%rsi
   17752:	48 89 37             	mov    %rsi,(%rdi)
   17755:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
   17759:	49 8b 77 08          	mov    0x8(%r15),%rsi
   1775d:	48 89 07             	mov    %rax,(%rdi)
   17760:	4c 89 f7             	mov    %r14,%rdi
   17763:	e8 18 eb ff ff       	callq  16280 <memcpy>
   17768:	8b 4d c0             	mov    -0x40(%rbp),%ecx
   1776b:	eb af                	jmp    1771c <__dup_config+0x16c>
   1776d:	0f 1f 00             	nopl   (%rax)
   17770:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
   17774:	48 29 d0             	sub    %rdx,%rax
   17777:	4c 8b 2f             	mov    (%rdi),%r13
   1777a:	49 8d 4c 15 00       	lea    0x0(%r13,%rdx,1),%rcx
   1777f:	48 89 0f             	mov    %rcx,(%rdi)
   17782:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
   17786:	49 8b 37             	mov    (%r15),%rsi
   17789:	48 89 07             	mov    %rax,(%rdi)
   1778c:	4c 89 ef             	mov    %r13,%rdi
   1778f:	e8 ec ea ff ff       	callq  16280 <memcpy>
   17794:	49 83 7f 08 00       	cmpq   $0x0,0x8(%r15)
   17799:	74 5f                	je     177fa <__dup_config+0x24a>
   1779b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   1779f:	31 c9                	xor    %ecx,%ecx
   177a1:	48 8b 00             	mov    (%rax),%rax
   177a4:	e9 65 ff ff ff       	jmpq   1770e <__dup_config+0x15e>
   177a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
   177b0:	85 d2                	test   %edx,%edx
   177b2:	0f 85 b8 00 00 00    	jne    17870 <__dup_config+0x2c0>
   177b8:	41 bb 01 00 00 00    	mov    $0x1,%r11d
   177be:	45 31 f6             	xor    %r14d,%r14d
   177c1:	45 31 ed             	xor    %r13d,%r13d
   177c4:	4c 89 ef             	mov    %r13,%rdi
   177c7:	44 88 5d c0          	mov    %r11b,-0x40(%rbp)
   177cb:	e8 b0 ea ff ff       	callq  16280 <memcpy>
   177d0:	44 0f b6 5d c0       	movzbl -0x40(%rbp),%r11d
   177d5:	49 8b 77 08          	mov    0x8(%r15),%rsi
   177d9:	45 84 db             	test   %r11b,%r11b
   177dc:	74 09                	je     177e7 <__dup_config+0x237>
   177de:	48 85 f6             	test   %rsi,%rsi
   177e1:	0f 85 99 00 00 00    	jne    17880 <__dup_config+0x2d0>
   177e7:	4c 89 e9             	mov    %r13,%rcx
   177ea:	e9 3d fe ff ff       	jmpq   1762c <__dup_config+0x7c>
   177ef:	90                   	nop    
   177f0:	45 31 ed             	xor    %r13d,%r13d
   177f3:	49 83 7f 08 00       	cmpq   $0x0,0x8(%r15)
   177f8:	75 a1                	jne    1779b <__dup_config+0x1eb>
   177fa:	49 8b 37             	mov    (%r15),%rsi
   177fd:	4d 85 ed             	test   %r13,%r13
   17800:	41 0f 94 c3          	sete   %r11b
   17804:	48 85 f6             	test   %rsi,%rsi
   17807:	0f 95 c0             	setne  %al
   1780a:	41 20 c3             	and    %al,%r11b
   1780d:	75 47                	jne    17856 <__dup_config+0x2a6>
   1780f:	31 c9                	xor    %ecx,%ecx
   17811:	45 31 f6             	xor    %r14d,%r14d
   17814:	e9 13 fe ff ff       	jmpq   1762c <__dup_config+0x7c>
   17819:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
   17820:	45 31 c9             	xor    %r9d,%r9d
   17823:	4c 39 e9             	cmp    %r13,%rcx
   17826:	74 58                	je     17880 <__dup_config+0x2d0>
   17828:	49 63 57 14          	movslq 0x14(%r15),%rdx
   1782c:	4e 8d 34 09          	lea    (%rcx,%r9,1),%r14
   17830:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
   17834:	4c 89 f7             	mov    %r14,%rdi
   17837:	e8 44 ea ff ff       	callq  16280 <memcpy>
   1783c:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
   17840:	e9 e7 fd ff ff       	jmpq   1762c <__dup_config+0x7c>
   17845:	31 c0                	xor    %eax,%eax
   17847:	48 83 c4 38          	add    $0x38,%rsp
   1784b:	5b                   	pop    %rbx
   1784c:	41 5c                	pop    %r12
   1784e:	41 5d                	pop    %r13
   17850:	41 5e                	pop    %r14
   17852:	41 5f                	pop    %r15
   17854:	5d                   	pop    %rbp
   17855:	c3                   	retq   
   17856:	45 31 f6             	xor    %r14d,%r14d
   17859:	31 c9                	xor    %ecx,%ecx
   1785b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   17860:	49 63 57 10          	movslq 0x10(%r15),%rdx
   17864:	49 89 cd             	mov    %rcx,%r13
   17867:	e9 58 ff ff ff       	jmpq   177c4 <__dup_config+0x214>
   1786c:	0f 1f 40 00          	nopl   0x0(%rax)
   17870:	45 31 ed             	xor    %r13d,%r13d
   17873:	45 31 f6             	xor    %r14d,%r14d
   17876:	e9 a9 fe ff ff       	jmpq   17724 <__dup_config+0x174>
   1787b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   17880:	4d 63 4f 10          	movslq 0x10(%r15),%r9
   17884:	4c 89 e9             	mov    %r13,%rcx
   17887:	eb 9f                	jmp    17828 <__dup_config+0x278>
   17889:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
   17890:	48 83 c4 38          	add    $0x38,%rsp
   17894:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   17899:	5b                   	pop    %rbx
   1789a:	41 5c                	pop    %r12
   1789c:	41 5d                	pop    %r13
   1789e:	41 5e                	pop    %r14
   178a0:	41 5f                	pop    %r15
   178a2:	5d                   	pop    %rbp
   178a3:	c3                   	retq   
   178a4:	66 66 66 2e 0f 1f 84 	nopw   %cs:0x0(%rax,%rax,1)
   178ab:	00 00 00 00 00 

00000000000178b0 <__get_config>:
   178b0:	55                   	push   %rbp
   178b1:	48 89 e5             	mov    %rsp,%rbp
   178b4:	41 57                	push   %r15
   178b6:	41 56                	push   %r14
   178b8:	41 55                	push   %r13
   178ba:	41 54                	push   %r12
   178bc:	49 89 f7             	mov    %rsi,%r15
   178bf:	53                   	push   %rbx
   178c0:	31 db                	xor    %ebx,%ebx
   178c2:	49 89 fe             	mov    %rdi,%r14
   178c5:	48 83 ec 18          	sub    $0x18,%rsp
   178c9:	0f b6 06             	movzbl (%rsi),%eax
   178cc:	84 c0                	test   %al,%al
   178ce:	0f 84 97 00 00 00    	je     1796b <__get_config+0xbb>
   178d4:	3c 2e                	cmp    $0x2e,%al
   178d6:	0f 84 a5 00 00 00    	je     17981 <__get_config+0xd1>
   178dc:	49 8d 47 01          	lea    0x1(%r15),%rax
   178e0:	41 bc 01 00 00 00    	mov    $0x1,%r12d
   178e6:	eb 10                	jmp    178f8 <__get_config+0x48>
   178e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   178ef:	00 
   178f0:	80 fa 2e             	cmp    $0x2e,%dl
   178f3:	74 19                	je     1790e <__get_config+0x5e>
   178f5:	49 89 cc             	mov    %rcx,%r12
   178f8:	0f b6 10             	movzbl (%rax),%edx
   178fb:	49 89 c0             	mov    %rax,%r8
   178fe:	48 83 c0 01          	add    $0x1,%rax
   17902:	45 89 e5             	mov    %r12d,%r13d
   17905:	49 8d 4c 24 01       	lea    0x1(%r12),%rcx
   1790a:	84 d2                	test   %dl,%dl
   1790c:	75 e2                	jne    178f0 <__get_config+0x40>
   1790e:	49 8b 06             	mov    (%r14),%rax
   17911:	49 39 c6             	cmp    %rax,%r14
   17914:	48 8d 58 c0          	lea    -0x40(%rax),%rbx
   17918:	75 13                	jne    1792d <__get_config+0x7d>
   1791a:	eb 54                	jmp    17970 <__get_config+0xc0>
   1791c:	0f 1f 40 00          	nopl   0x0(%rax)
   17920:	48 8b 43 40          	mov    0x40(%rbx),%rax
   17924:	49 39 c6             	cmp    %rax,%r14
   17927:	48 8d 58 c0          	lea    -0x40(%rax),%rbx
   1792b:	74 43                	je     17970 <__get_config+0xc0>
   1792d:	44 39 6b 10          	cmp    %r13d,0x10(%rbx)
   17931:	75 ed                	jne    17920 <__get_config+0x70>
   17933:	48 8b 3b             	mov    (%rbx),%rdi
   17936:	4c 89 e2             	mov    %r12,%rdx
   17939:	4c 89 fe             	mov    %r15,%rsi
   1793c:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
   17940:	e8 cb e9 ff ff       	callq  16310 <memcmp>
   17945:	85 c0                	test   %eax,%eax
   17947:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
   1794b:	75 d3                	jne    17920 <__get_config+0x70>
   1794d:	41 80 38 01          	cmpb   $0x1,(%r8)
   17951:	4c 8d 73 30          	lea    0x30(%rbx),%r14
   17955:	41 83 dd ff          	sbb    $0xffffffffffffffff,%r13d
   17959:	4d 63 ed             	movslq %r13d,%r13
   1795c:	4d 01 ef             	add    %r13,%r15
   1795f:	41 0f b6 07          	movzbl (%r15),%eax
   17963:	84 c0                	test   %al,%al
   17965:	0f 85 69 ff ff ff    	jne    178d4 <__get_config+0x24>
   1796b:	48 89 d8             	mov    %rbx,%rax
   1796e:	eb 02                	jmp    17972 <__get_config+0xc2>
   17970:	31 c0                	xor    %eax,%eax
   17972:	48 83 c4 18          	add    $0x18,%rsp
   17976:	5b                   	pop    %rbx
   17977:	41 5c                	pop    %r12
   17979:	41 5d                	pop    %r13
   1797b:	41 5e                	pop    %r14
   1797d:	41 5f                	pop    %r15
   1797f:	5d                   	pop    %rbp
   17980:	c3                   	retq   
   17981:	4d 89 f8             	mov    %r15,%r8
   17984:	45 31 e4             	xor    %r12d,%r12d
   17987:	45 31 ed             	xor    %r13d,%r13d
   1798a:	eb 82                	jmp    1790e <__get_config+0x5e>
   1798c:	0f 1f 40 00          	nopl   0x0(%rax)

0000000000017990 <__del_config>:
   17990:	55                   	push   %rbp
   17991:	49 89 d1             	mov    %rdx,%r9
   17994:	48 89 e5             	mov    %rsp,%rbp
   17997:	41 57                	push   %r15
   17999:	41 56                	push   %r14
   1799b:	41 55                	push   %r13
   1799d:	41 54                	push   %r12
   1799f:	49 89 f7             	mov    %rsi,%r15
   179a2:	53                   	push   %rbx
   179a3:	48 83 ec 28          	sub    $0x28,%rsp
   179a7:	0f b6 02             	movzbl (%rdx),%eax
   179aa:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
   179ae:	84 c0                	test   %al,%al
   179b0:	0f 84 57 01 00 00    	je     17b0d <__del_config+0x17d>
   179b6:	3c 2e                	cmp    $0x2e,%al
   179b8:	0f 84 4f 01 00 00    	je     17b0d <__del_config+0x17d>
   179be:	48 8d 42 01          	lea    0x1(%rdx),%rax
   179c2:	41 bc 01 00 00 00    	mov    $0x1,%r12d
   179c8:	eb 0e                	jmp    179d8 <__del_config+0x48>
   179ca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
   179d0:	80 f9 2e             	cmp    $0x2e,%cl
   179d3:	74 19                	je     179ee <__del_config+0x5e>
   179d5:	49 89 d4             	mov    %rdx,%r12
   179d8:	0f b6 08             	movzbl (%rax),%ecx
   179db:	49 89 c0             	mov    %rax,%r8
   179de:	48 83 c0 01          	add    $0x1,%rax
   179e2:	45 89 e6             	mov    %r12d,%r14d
   179e5:	49 8d 54 24 01       	lea    0x1(%r12),%rdx
   179ea:	84 c9                	test   %cl,%cl
   179ec:	75 e2                	jne    179d0 <__del_config+0x40>
   179ee:	49 8b 07             	mov    (%r15),%rax
   179f1:	49 39 c7             	cmp    %rax,%r15
   179f4:	48 8d 58 c0          	lea    -0x40(%rax),%rbx
   179f8:	75 17                	jne    17a11 <__del_config+0x81>
   179fa:	e9 d1 00 00 00       	jmpq   17ad0 <__del_config+0x140>
   179ff:	90                   	nop    
   17a00:	48 8b 43 40          	mov    0x40(%rbx),%rax
   17a04:	49 39 c7             	cmp    %rax,%r15
   17a07:	48 8d 58 c0          	lea    -0x40(%rax),%rbx
   17a0b:	0f 84 bf 00 00 00    	je     17ad0 <__del_config+0x140>
   17a11:	44 39 73 10          	cmp    %r14d,0x10(%rbx)
   17a15:	75 e9                	jne    17a00 <__del_config+0x70>
   17a17:	48 8b 3b             	mov    (%rbx),%rdi
   17a1a:	4c 89 ce             	mov    %r9,%rsi
   17a1d:	4c 89 e2             	mov    %r12,%rdx
   17a20:	4c 89 45 c0          	mov    %r8,-0x40(%rbp)
   17a24:	4c 89 4d c8          	mov    %r9,-0x38(%rbp)
   17a28:	e8 e3 e8 ff ff       	callq  16310 <memcmp>
   17a2d:	85 c0                	test   %eax,%eax
   17a2f:	41 89 c5             	mov    %eax,%r13d
   17a32:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
   17a36:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
   17a3a:	75 c4                	jne    17a00 <__del_config+0x70>
   17a3c:	41 80 38 00          	cmpb   $0x0,(%r8)
   17a40:	0f 84 a2 00 00 00    	je     17ae8 <__del_config+0x158>
   17a46:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
   17a4b:	0f 85 af 00 00 00    	jne    17b00 <__del_config+0x170>
   17a51:	4c 8d 73 30          	lea    0x30(%rbx),%r14
   17a55:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
   17a59:	4b 8d 54 21 01       	lea    0x1(%r9,%r12,1),%rdx
   17a5e:	4c 89 f6             	mov    %r14,%rsi
   17a61:	e8 2a ff ff ff       	callq  17990 <__del_config>
   17a66:	85 c0                	test   %eax,%eax
   17a68:	0f 88 9a 00 00 00    	js     17b08 <__del_config+0x178>
   17a6e:	4c 3b 73 30          	cmp    0x30(%rbx),%r14
   17a72:	75 62                	jne    17ad6 <__del_config+0x146>
   17a74:	48 8b 53 40          	mov    0x40(%rbx),%rdx
   17a78:	48 8b 43 48          	mov    0x48(%rbx),%rax
   17a7c:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
   17a80:	48 89 42 08          	mov    %rax,0x8(%rdx)
   17a84:	48 89 10             	mov    %rdx,(%rax)
   17a87:	48 8b 43 28          	mov    0x28(%rbx),%rax
   17a8b:	48 8b 53 20          	mov    0x20(%rbx),%rdx
   17a8f:	48 85 ff             	test   %rdi,%rdi
   17a92:	48 c7 43 40 00 01 10 	movq   $0x100100,0x40(%rbx)
   17a99:	00 
   17a9a:	48 c7 43 48 00 02 20 	movq   $0x200200,0x48(%rbx)
   17aa1:	00 
   17aa2:	48 89 42 08          	mov    %rax,0x8(%rdx)
   17aa6:	48 89 10             	mov    %rdx,(%rax)
   17aa9:	48 c7 43 20 00 01 10 	movq   $0x100100,0x20(%rbx)
   17ab0:	00 
   17ab1:	48 c7 43 28 00 02 20 	movq   $0x200200,0x28(%rbx)
   17ab8:	00 
   17ab9:	74 07                	je     17ac2 <__del_config+0x132>
   17abb:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
   17abf:	ff 50 38             	callq  *0x38(%rax)
   17ac2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
   17ac6:	48 89 df             	mov    %rbx,%rdi
   17ac9:	ff 50 38             	callq  *0x38(%rax)
   17acc:	eb 08                	jmp    17ad6 <__del_config+0x146>
   17ace:	66 90                	xchg   %ax,%ax
   17ad0:	41 bd fe ff ff ff    	mov    $0xfffffffe,%r13d
   17ad6:	48 83 c4 28          	add    $0x28,%rsp
   17ada:	44 89 e8             	mov    %r13d,%eax
   17add:	5b                   	pop    %rbx
   17ade:	41 5c                	pop    %r12
   17ae0:	41 5d                	pop    %r13
   17ae2:	41 5e                	pop    %r14
   17ae4:	41 5f                	pop    %r15
   17ae6:	5d                   	pop    %rbp
   17ae7:	c3                   	retq   
   17ae8:	48 83 7b 08 00       	cmpq   $0x0,0x8(%rbx)
   17aed:	75 85                	jne    17a74 <__del_config+0xe4>
   17aef:	41 bd eb ff ff ff    	mov    $0xffffffeb,%r13d
   17af5:	eb df                	jmp    17ad6 <__del_config+0x146>
   17af7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   17afe:	00 00 
   17b00:	41 bd ec ff ff ff    	mov    $0xffffffec,%r13d
   17b06:	eb ce                	jmp    17ad6 <__del_config+0x146>
   17b08:	41 89 c5             	mov    %eax,%r13d
   17b0b:	eb c9                	jmp    17ad6 <__del_config+0x146>
   17b0d:	4d 89 c8             	mov    %r9,%r8
   17b10:	45 31 e4             	xor    %r12d,%r12d
   17b13:	45 31 f6             	xor    %r14d,%r14d
   17b16:	e9 d3 fe ff ff       	jmpq   179ee <__del_config+0x5e>
   17b1b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000017b20 <__add_config>:
   17b20:	55                   	push   %rbp
   17b21:	48 89 f8             	mov    %rdi,%rax
   17b24:	48 89 e5             	mov    %rsp,%rbp
   17b27:	41 57                	push   %r15
   17b29:	41 56                	push   %r14
   17b2b:	41 55                	push   %r13
   17b2d:	41 54                	push   %r12
   17b2f:	41 89 d6             	mov    %edx,%r14d
   17b32:	53                   	push   %rbx
   17b33:	48 83 ec 38          	sub    $0x38,%rsp
   17b37:	85 d2                	test   %edx,%edx
   17b39:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
   17b3d:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
   17b41:	44 89 45 ac          	mov    %r8d,-0x54(%rbp)
   17b45:	4c 89 4d a0          	mov    %r9,-0x60(%rbp)
   17b49:	0f 84 b7 00 00 00    	je     17c06 <__add_config+0xe6>
   17b4f:	48 83 c0 10          	add    $0x10,%rax
   17b53:	48 89 f3             	mov    %rsi,%rbx
   17b56:	49 89 ff             	mov    %rdi,%r15
   17b59:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
   17b5d:	0f 1f 00             	nopl   (%rax)
   17b60:	45 85 f6             	test   %r14d,%r14d
   17b63:	0f 8e 3c 01 00 00    	jle    17ca5 <__add_config+0x185>
   17b69:	80 3b 2e             	cmpb   $0x2e,(%rbx)
   17b6c:	0f 84 33 01 00 00    	je     17ca5 <__add_config+0x185>
   17b72:	48 8d 43 01          	lea    0x1(%rbx),%rax
   17b76:	45 31 ed             	xor    %r13d,%r13d
   17b79:	eb 0f                	jmp    17b8a <__add_config+0x6a>
   17b7b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   17b80:	48 83 c0 01          	add    $0x1,%rax
   17b84:	80 78 ff 2e          	cmpb   $0x2e,-0x1(%rax)
   17b88:	74 09                	je     17b93 <__add_config+0x73>
   17b8a:	41 83 c5 01          	add    $0x1,%r13d
   17b8e:	45 39 f5             	cmp    %r14d,%r13d
   17b91:	75 ed                	jne    17b80 <__add_config+0x60>
   17b93:	49 8b 07             	mov    (%r15),%rax
   17b96:	49 63 f5             	movslq %r13d,%rsi
   17b99:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
   17b9d:	49 39 c7             	cmp    %rax,%r15
   17ba0:	4c 8d 60 c0          	lea    -0x40(%rax),%r12
   17ba4:	75 18                	jne    17bbe <__add_config+0x9e>
   17ba6:	eb 78                	jmp    17c20 <__add_config+0x100>
   17ba8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   17baf:	00 
   17bb0:	49 8b 44 24 40       	mov    0x40(%r12),%rax
   17bb5:	49 39 c7             	cmp    %rax,%r15
   17bb8:	4c 8d 60 c0          	lea    -0x40(%rax),%r12
   17bbc:	74 62                	je     17c20 <__add_config+0x100>
   17bbe:	45 39 6c 24 10       	cmp    %r13d,0x10(%r12)
   17bc3:	75 eb                	jne    17bb0 <__add_config+0x90>
   17bc5:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
   17bc9:	49 8b 3c 24          	mov    (%r12),%rdi
   17bcd:	48 89 de             	mov    %rbx,%rsi
   17bd0:	e8 3b e7 ff ff       	callq  16310 <memcmp>
   17bd5:	85 c0                	test   %eax,%eax
   17bd7:	75 d7                	jne    17bb0 <__add_config+0x90>
   17bd9:	4d 8d 7c 24 30       	lea    0x30(%r12),%r15
   17bde:	4c 89 e0             	mov    %r12,%rax
   17be1:	31 d2                	xor    %edx,%edx
   17be3:	45 39 f5             	cmp    %r14d,%r13d
   17be6:	0f 9c c2             	setl   %dl
   17be9:	41 01 d5             	add    %edx,%r13d
   17bec:	49 63 d5             	movslq %r13d,%rdx
   17bef:	48 01 d3             	add    %rdx,%rbx
   17bf2:	45 29 ee             	sub    %r13d,%r14d
   17bf5:	0f 84 b2 00 00 00    	je     17cad <__add_config+0x18d>
   17bfb:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
   17c00:	0f 84 5a ff ff ff    	je     17b60 <__add_config+0x40>
   17c06:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17c0b:	48 83 c4 38          	add    $0x38,%rsp
   17c0f:	5b                   	pop    %rbx
   17c10:	41 5c                	pop    %r12
   17c12:	41 5d                	pop    %r13
   17c14:	41 5e                	pop    %r14
   17c16:	41 5f                	pop    %r15
   17c18:	5d                   	pop    %rbp
   17c19:	c3                   	retq   
   17c1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
   17c20:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
   17c24:	bf 50 00 00 00       	mov    $0x50,%edi
   17c29:	ff 50 30             	callq  *0x30(%rax)
   17c2c:	48 85 c0             	test   %rax,%rax
   17c2f:	0f 84 b8 00 00 00    	je     17ced <__add_config+0x1cd>
   17c35:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
   17c39:	48 8d 50 20          	lea    0x20(%rax),%rdx
   17c3d:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
   17c41:	48 89 18             	mov    %rbx,(%rax)
   17c44:	44 89 68 10          	mov    %r13d,0x10(%rax)
   17c48:	48 89 50 28          	mov    %rdx,0x28(%rax)
   17c4c:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
   17c53:	00 
   17c54:	48 8b 4f 18          	mov    0x18(%rdi),%rcx
   17c58:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%rax)
   17c5f:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
   17c66:	00 
   17c67:	48 89 57 18          	mov    %rdx,0x18(%rdi)
   17c6b:	48 89 70 20          	mov    %rsi,0x20(%rax)
   17c6f:	48 89 48 28          	mov    %rcx,0x28(%rax)
   17c73:	48 89 11             	mov    %rdx,(%rcx)
   17c76:	48 8d 50 30          	lea    0x30(%rax),%rdx
   17c7a:	48 8d 48 40          	lea    0x40(%rax),%rcx
   17c7e:	48 89 50 38          	mov    %rdx,0x38(%rax)
   17c82:	48 89 50 30          	mov    %rdx,0x30(%rax)
   17c86:	48 89 48 48          	mov    %rcx,0x48(%rax)
   17c8a:	49 8b 77 08          	mov    0x8(%r15),%rsi
   17c8e:	49 89 4f 08          	mov    %rcx,0x8(%r15)
   17c92:	4c 89 78 40          	mov    %r15,0x40(%rax)
   17c96:	49 89 d7             	mov    %rdx,%r15
   17c99:	48 89 70 48          	mov    %rsi,0x48(%rax)
   17c9d:	48 89 0e             	mov    %rcx,(%rsi)
   17ca0:	e9 3c ff ff ff       	jmpq   17be1 <__add_config+0xc1>
   17ca5:	45 31 ed             	xor    %r13d,%r13d
   17ca8:	e9 e6 fe ff ff       	jmpq   17b93 <__add_config+0x73>
   17cad:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
   17cb2:	0f 85 4e ff ff ff    	jne    17c06 <__add_config+0xe6>
   17cb8:	4c 39 78 30          	cmp    %r15,0x30(%rax)
   17cbc:	0f 85 44 ff ff ff    	jne    17c06 <__add_config+0xe6>
   17cc2:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
   17cc6:	48 89 48 08          	mov    %rcx,0x8(%rax)
   17cca:	8b 4d ac             	mov    -0x54(%rbp),%ecx
   17ccd:	89 48 14             	mov    %ecx,0x14(%rax)
   17cd0:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
   17cd4:	48 85 c9             	test   %rcx,%rcx
   17cd7:	74 28                	je     17d01 <__add_config+0x1e1>
   17cd9:	48 89 01             	mov    %rax,(%rcx)
   17cdc:	48 83 c4 38          	add    $0x38,%rsp
   17ce0:	31 c0                	xor    %eax,%eax
   17ce2:	5b                   	pop    %rbx
   17ce3:	41 5c                	pop    %r12
   17ce5:	41 5d                	pop    %r13
   17ce7:	41 5e                	pop    %r14
   17ce9:	41 5f                	pop    %r15
   17ceb:	5d                   	pop    %rbp
   17cec:	c3                   	retq   
   17ced:	48 83 c4 38          	add    $0x38,%rsp
   17cf1:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   17cf6:	5b                   	pop    %rbx
   17cf7:	41 5c                	pop    %r12
   17cf9:	41 5d                	pop    %r13
   17cfb:	41 5e                	pop    %r14
   17cfd:	41 5f                	pop    %r15
   17cff:	5d                   	pop    %rbp
   17d00:	c3                   	retq   
   17d01:	31 c0                	xor    %eax,%eax
   17d03:	e9 03 ff ff ff       	jmpq   17c0b <__add_config+0xeb>
   17d08:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   17d0f:	00 

0000000000017d10 <__write_config>:
   17d10:	55                   	push   %rbp
   17d11:	48 89 e5             	mov    %rsp,%rbp
   17d14:	41 57                	push   %r15
   17d16:	41 56                	push   %r14
   17d18:	41 55                	push   %r13
   17d1a:	41 54                	push   %r12
   17d1c:	45 31 f6             	xor    %r14d,%r14d
   17d1f:	53                   	push   %rbx
   17d20:	31 db                	xor    %ebx,%ebx
   17d22:	4d 89 cc             	mov    %r9,%r12
   17d25:	48 83 ec 48          	sub    $0x48,%rsp
   17d29:	48 8b 01             	mov    (%rcx),%rax
   17d2c:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
   17d30:	4c 89 c6             	mov    %r8,%rsi
   17d33:	48 89 7d c0          	mov    %rdi,-0x40(%rbp)
   17d37:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
   17d3b:	4c 01 ce             	add    %r9,%rsi
   17d3e:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
   17d42:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
   17d46:	48 39 c1             	cmp    %rax,%rcx
   17d49:	4c 8d 78 c0          	lea    -0x40(%rax),%r15
   17d4d:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
   17d51:	0f 84 d6 00 00 00    	je     17e2d <__write_config+0x11d>
   17d57:	4c 89 f8             	mov    %r15,%rax
   17d5a:	45 89 f7             	mov    %r14d,%r15d
   17d5d:	49 89 c6             	mov    %rax,%r14
   17d60:	49 83 7e 08 00       	cmpq   $0x0,0x8(%r14)
   17d65:	0f 84 d5 00 00 00    	je     17e40 <__write_config+0x130>
   17d6b:	41 8b 46 14          	mov    0x14(%r14),%eax
   17d6f:	41 03 46 10          	add    0x10(%r14),%eax
   17d73:	46 8d 6c 20 02       	lea    0x2(%rax,%r12,1),%r13d
   17d78:	45 39 fd             	cmp    %r15d,%r13d
   17d7b:	7e 2e                	jle    17dab <__write_config+0x9b>
   17d7d:	44 89 f8             	mov    %r15d,%eax
   17d80:	48 81 ec 10 01 00 00 	sub    $0x110,%rsp
   17d87:	05 00 01 00 00       	add    $0x100,%eax
   17d8c:	48 8d 5c 24 0f       	lea    0xf(%rsp),%rbx
   17d91:	48 83 e3 f0          	and    $0xfffffffffffffff0,%rbx
   17d95:	41 39 c5             	cmp    %eax,%r13d
   17d98:	7f e6                	jg     17d80 <__write_config+0x70>
   17d9a:	41 8d 45 ff          	lea    -0x1(%r13),%eax
   17d9e:	44 29 f8             	sub    %r15d,%eax
   17da1:	30 c0                	xor    %al,%al
   17da3:	45 8d bc 07 00 01 00 	lea    0x100(%r15,%rax,1),%r15d
   17daa:	00 
   17dab:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
   17daf:	4c 89 e2             	mov    %r12,%rdx
   17db2:	48 89 df             	mov    %rbx,%rdi
   17db5:	4d 63 ed             	movslq %r13d,%r13
   17db8:	e8 c3 e4 ff ff       	callq  16280 <memcpy>
   17dbd:	49 63 56 10          	movslq 0x10(%r14),%rdx
   17dc1:	4e 8d 04 23          	lea    (%rbx,%r12,1),%r8
   17dc5:	49 8b 36             	mov    (%r14),%rsi
   17dc8:	4c 89 c7             	mov    %r8,%rdi
   17dcb:	4c 89 45 c8          	mov    %r8,-0x38(%rbp)
   17dcf:	e8 ac e4 ff ff       	callq  16280 <memcpy>
   17dd4:	49 63 46 10          	movslq 0x10(%r14),%rax
   17dd8:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
   17ddc:	41 c6 04 00 3d       	movb   $0x3d,(%r8,%rax,1)
   17de1:	49 63 56 14          	movslq 0x14(%r14),%rdx
   17de5:	49 8b 76 08          	mov    0x8(%r14),%rsi
   17de9:	48 89 d7             	mov    %rdx,%rdi
   17dec:	48 f7 d7             	not    %rdi
   17def:	4c 01 ef             	add    %r13,%rdi
   17df2:	48 01 df             	add    %rbx,%rdi
   17df5:	e8 86 e4 ff ff       	callq  16280 <memcpy>
   17dfa:	42 c6 44 2b ff 0a    	movb   $0xa,-0x1(%rbx,%r13,1)
   17e00:	4c 89 ea             	mov    %r13,%rdx
   17e03:	48 89 de             	mov    %rbx,%rsi
   17e06:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
   17e0a:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
   17e0e:	ff d0                	callq  *%rax
   17e10:	85 c0                	test   %eax,%eax
   17e12:	78 1b                	js     17e2f <__write_config+0x11f>
   17e14:	48 8b 45 10          	mov    0x10(%rbp),%rax
   17e18:	4c 01 28             	add    %r13,(%rax)
   17e1b:	49 8b 46 40          	mov    0x40(%r14),%rax
   17e1f:	48 39 45 a8          	cmp    %rax,-0x58(%rbp)
   17e23:	4c 8d 70 c0          	lea    -0x40(%rax),%r14
   17e27:	0f 85 33 ff ff ff    	jne    17d60 <__write_config+0x50>
   17e2d:	31 c0                	xor    %eax,%eax
   17e2f:	48 8d 65 d8          	lea    -0x28(%rbp),%rsp
   17e33:	5b                   	pop    %rbx
   17e34:	41 5c                	pop    %r12
   17e36:	41 5d                	pop    %r13
   17e38:	41 5e                	pop    %r14
   17e3a:	41 5f                	pop    %r15
   17e3c:	5d                   	pop    %rbp
   17e3d:	c3                   	retq   
   17e3e:	66 90                	xchg   %ax,%ax
   17e40:	49 63 56 10          	movslq 0x10(%r14),%rdx
   17e44:	4a 8d 44 22 01       	lea    0x1(%rdx,%r12,1),%rax
   17e49:	48 3d 00 01 00 00    	cmp    $0x100,%rax
   17e4f:	77 4a                	ja     17e9b <__write_config+0x18b>
   17e51:	4c 8b 6d 98          	mov    -0x68(%rbp),%r13
   17e55:	49 8b 36             	mov    (%r14),%rsi
   17e58:	4c 89 ef             	mov    %r13,%rdi
   17e5b:	e8 20 e4 ff ff       	callq  16280 <memcpy>
   17e60:	49 63 46 10          	movslq 0x10(%r14),%rax
   17e64:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
   17e68:	48 83 ec 08          	sub    $0x8,%rsp
   17e6c:	4c 8b 45 b0          	mov    -0x50(%rbp),%r8
   17e70:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
   17e74:	49 8d 4e 30          	lea    0x30(%r14),%rcx
   17e78:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
   17e7c:	41 c6 44 05 00 2e    	movb   $0x2e,0x0(%r13,%rax,1)
   17e82:	49 63 46 10          	movslq 0x10(%r14),%rax
   17e86:	ff 75 10             	pushq  0x10(%rbp)
   17e89:	4d 8d 4c 04 01       	lea    0x1(%r12,%rax,1),%r9
   17e8e:	e8 7d fe ff ff       	callq  17d10 <__write_config>
   17e93:	85 c0                	test   %eax,%eax
   17e95:	5a                   	pop    %rdx
   17e96:	59                   	pop    %rcx
   17e97:	79 82                	jns    17e1b <__write_config+0x10b>
   17e99:	eb 94                	jmp    17e2f <__write_config+0x11f>
   17e9b:	b8 dc ff ff ff       	mov    $0xffffffdc,%eax
   17ea0:	eb 8d                	jmp    17e2f <__write_config+0x11f>
   17ea2:	66 66 66 66 66 2e 0f 	nopw   %cs:0x0(%rax,%rax,1)
   17ea9:	1f 84 00 00 00 00 00 

0000000000017eb0 <get_config>:
   17eb0:	55                   	push   %rbp
   17eb1:	48 89 e5             	mov    %rsp,%rbp
   17eb4:	41 55                	push   %r13
   17eb6:	41 54                	push   %r12
   17eb8:	53                   	push   %rbx
   17eb9:	49 89 d4             	mov    %rdx,%r12
   17ebc:	49 89 cd             	mov    %rcx,%r13
   17ebf:	48 83 ec 08          	sub    $0x8,%rsp
   17ec3:	e8 e8 f9 ff ff       	callq  178b0 <__get_config>
   17ec8:	48 85 c0             	test   %rax,%rax
   17ecb:	48 89 c3             	mov    %rax,%rbx
   17ece:	74 40                	je     17f10 <get_config+0x60>
   17ed0:	48 8b 70 08          	mov    0x8(%rax),%rsi
   17ed4:	48 85 f6             	test   %rsi,%rsi
   17ed7:	74 37                	je     17f10 <get_config+0x60>
   17ed9:	48 63 50 14          	movslq 0x14(%rax),%rdx
   17edd:	b8 dc ff ff ff       	mov    $0xffffffdc,%eax
   17ee2:	4c 39 ea             	cmp    %r13,%rdx
   17ee5:	73 14                	jae    17efb <get_config+0x4b>
   17ee7:	4c 89 e7             	mov    %r12,%rdi
   17eea:	e8 91 e3 ff ff       	callq  16280 <memcpy>
   17eef:	48 63 43 14          	movslq 0x14(%rbx),%rax
   17ef3:	41 c6 04 04 00       	movb   $0x0,(%r12,%rax,1)
   17ef8:	8b 43 14             	mov    0x14(%rbx),%eax
   17efb:	48 83 c4 08          	add    $0x8,%rsp
   17eff:	5b                   	pop    %rbx
   17f00:	41 5c                	pop    %r12
   17f02:	41 5d                	pop    %r13
   17f04:	5d                   	pop    %rbp
   17f05:	c3                   	retq   
   17f06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   17f0d:	00 00 00 
   17f10:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   17f15:	eb e4                	jmp    17efb <get_config+0x4b>
   17f17:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   17f1e:	00 00 

0000000000017f20 <get_config_entries>:
   17f20:	55                   	push   %rbp
   17f21:	48 89 e5             	mov    %rsp,%rbp
   17f24:	41 57                	push   %r15
   17f26:	41 56                	push   %r14
   17f28:	41 55                	push   %r13
   17f2a:	41 54                	push   %r12
   17f2c:	49 89 d6             	mov    %rdx,%r14
   17f2f:	53                   	push   %rbx
   17f30:	49 89 cf             	mov    %rcx,%r15
   17f33:	bb ea ff ff ff       	mov    $0xffffffea,%ebx
   17f38:	48 83 ec 08          	sub    $0x8,%rsp
   17f3c:	e8 6f f9 ff ff       	callq  178b0 <__get_config>
   17f41:	48 85 c0             	test   %rax,%rax
   17f44:	74 6d                	je     17fb3 <get_config_entries+0x93>
   17f46:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
   17f4b:	75 66                	jne    17fb3 <get_config_entries+0x93>
   17f4d:	4c 8d 60 30          	lea    0x30(%rax),%r12
   17f51:	48 8b 40 30          	mov    0x30(%rax),%rax
   17f55:	49 39 c4             	cmp    %rax,%r12
   17f58:	4c 8d 68 c0          	lea    -0x40(%rax),%r13
   17f5c:	74 6d                	je     17fcb <get_config_entries+0xab>
   17f5e:	48 63 50 d0          	movslq -0x30(%rax),%rdx
   17f62:	31 db                	xor    %ebx,%ebx
   17f64:	49 39 d7             	cmp    %rdx,%r15
   17f67:	77 10                	ja     17f79 <get_config_entries+0x59>
   17f69:	eb 59                	jmp    17fc4 <get_config_entries+0xa4>
   17f6b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   17f70:	48 63 50 d0          	movslq -0x30(%rax),%rdx
   17f74:	4c 39 fa             	cmp    %r15,%rdx
   17f77:	73 4b                	jae    17fc4 <get_config_entries+0xa4>
   17f79:	49 8b 75 00          	mov    0x0(%r13),%rsi
   17f7d:	4c 89 f7             	mov    %r14,%rdi
   17f80:	83 c3 01             	add    $0x1,%ebx
   17f83:	e8 f8 e2 ff ff       	callq  16280 <memcpy>
   17f88:	49 63 45 10          	movslq 0x10(%r13),%rax
   17f8c:	41 c6 04 06 00       	movb   $0x0,(%r14,%rax,1)
   17f91:	49 63 45 10          	movslq 0x10(%r13),%rax
   17f95:	48 89 c6             	mov    %rax,%rsi
   17f98:	4d 8d 74 06 01       	lea    0x1(%r14,%rax,1),%r14
   17f9d:	49 8b 45 40          	mov    0x40(%r13),%rax
   17fa1:	83 c6 01             	add    $0x1,%esi
   17fa4:	48 63 f6             	movslq %esi,%rsi
   17fa7:	49 29 f7             	sub    %rsi,%r15
   17faa:	49 39 c4             	cmp    %rax,%r12
   17fad:	4c 8d 68 c0          	lea    -0x40(%rax),%r13
   17fb1:	75 bd                	jne    17f70 <get_config_entries+0x50>
   17fb3:	48 83 c4 08          	add    $0x8,%rsp
   17fb7:	89 d8                	mov    %ebx,%eax
   17fb9:	5b                   	pop    %rbx
   17fba:	41 5c                	pop    %r12
   17fbc:	41 5d                	pop    %r13
   17fbe:	41 5e                	pop    %r14
   17fc0:	41 5f                	pop    %r15
   17fc2:	5d                   	pop    %rbp
   17fc3:	c3                   	retq   
   17fc4:	bb dc ff ff ff       	mov    $0xffffffdc,%ebx
   17fc9:	eb e8                	jmp    17fb3 <get_config_entries+0x93>
   17fcb:	31 db                	xor    %ebx,%ebx
   17fcd:	eb e4                	jmp    17fb3 <get_config_entries+0x93>
   17fcf:	90                   	nop    

0000000000017fd0 <set_config>:
   17fd0:	48 85 f6             	test   %rsi,%rsi
   17fd3:	0f 84 20 01 00 00    	je     180f9 <set_config+0x129>
   17fd9:	55                   	push   %rbp
   17fda:	48 89 e5             	mov    %rsp,%rbp
   17fdd:	41 57                	push   %r15
   17fdf:	41 56                	push   %r14
   17fe1:	41 55                	push   %r13
   17fe3:	41 54                	push   %r12
   17fe5:	49 89 d4             	mov    %rdx,%r12
   17fe8:	53                   	push   %rbx
   17fe9:	48 89 f3             	mov    %rsi,%rbx
   17fec:	48 83 ec 28          	sub    $0x28,%rsp
   17ff0:	48 85 d2             	test   %rdx,%rdx
   17ff3:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
   17ff7:	0f 84 94 00 00 00    	je     18091 <set_config+0xc1>
   17ffd:	48 89 f7             	mov    %rsi,%rdi
   18000:	e8 9b e7 ff ff       	callq  167a0 <strlen>
   18005:	4c 89 e7             	mov    %r12,%rdi
   18008:	49 89 c6             	mov    %rax,%r14
   1800b:	e8 90 e7 ff ff       	callq  167a0 <strlen>
   18010:	42 8d 7c 30 02       	lea    0x2(%rax,%r14,1),%edi
   18015:	49 89 c7             	mov    %rax,%r15
   18018:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
   1801c:	ff 50 30             	callq  *0x30(%rax)
   1801f:	48 85 c0             	test   %rax,%rax
   18022:	49 89 c5             	mov    %rax,%r13
   18025:	0f 84 b5 00 00 00    	je     180e0 <set_config+0x110>
   1802b:	41 8d 56 01          	lea    0x1(%r14),%edx
   1802f:	48 89 de             	mov    %rbx,%rsi
   18032:	48 89 c7             	mov    %rax,%rdi
   18035:	48 63 d2             	movslq %edx,%rdx
   18038:	e8 43 e2 ff ff       	callq  16280 <memcpy>
   1803d:	49 63 c6             	movslq %r14d,%rax
   18040:	41 8d 57 01          	lea    0x1(%r15),%edx
   18044:	4c 89 e6             	mov    %r12,%rsi
   18047:	49 8d 4c 05 01       	lea    0x1(%r13,%rax,1),%rcx
   1804c:	48 63 d2             	movslq %edx,%rdx
   1804f:	48 89 cf             	mov    %rcx,%rdi
   18052:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
   18056:	e8 25 e2 ff ff       	callq  16280 <memcpy>
   1805b:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
   1805f:	48 89 de             	mov    %rbx,%rsi
   18062:	e8 49 f8 ff ff       	callq  178b0 <__get_config>
   18067:	48 85 c0             	test   %rax,%rax
   1806a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
   1806e:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
   18072:	74 3c                	je     180b0 <set_config+0xe0>
   18074:	48 89 48 08          	mov    %rcx,0x8(%rax)
   18078:	44 89 78 14          	mov    %r15d,0x14(%rax)
   1807c:	4c 89 68 18          	mov    %r13,0x18(%rax)
   18080:	31 c0                	xor    %eax,%eax
   18082:	48 83 c4 28          	add    $0x28,%rsp
   18086:	5b                   	pop    %rbx
   18087:	41 5c                	pop    %r12
   18089:	41 5d                	pop    %r13
   1808b:	41 5e                	pop    %r14
   1808d:	41 5f                	pop    %r15
   1808f:	5d                   	pop    %rbp
   18090:	c3                   	retq   
   18091:	48 89 f2             	mov    %rsi,%rdx
   18094:	48 89 fe             	mov    %rdi,%rsi
   18097:	e8 f4 f8 ff ff       	callq  17990 <__del_config>
   1809c:	48 83 c4 28          	add    $0x28,%rsp
   180a0:	5b                   	pop    %rbx
   180a1:	41 5c                	pop    %r12
   180a3:	41 5d                	pop    %r13
   180a5:	41 5e                	pop    %r14
   180a7:	41 5f                	pop    %r15
   180a9:	5d                   	pop    %rbp
   180aa:	c3                   	retq   
   180ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   180b0:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
   180b4:	4c 8d 4d c8          	lea    -0x38(%rbp),%r9
   180b8:	45 89 f8             	mov    %r15d,%r8d
   180bb:	44 89 f2             	mov    %r14d,%edx
   180be:	4c 89 ee             	mov    %r13,%rsi
   180c1:	e8 5a fa ff ff       	callq  17b20 <__add_config>
   180c6:	85 c0                	test   %eax,%eax
   180c8:	78 1d                	js     180e7 <set_config+0x117>
   180ca:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
   180ce:	4c 89 68 18          	mov    %r13,0x18(%rax)
   180d2:	31 c0                	xor    %eax,%eax
   180d4:	eb ac                	jmp    18082 <set_config+0xb2>
   180d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
   180dd:	00 00 00 
   180e0:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   180e5:	eb 9b                	jmp    18082 <set_config+0xb2>
   180e7:	89 45 b0             	mov    %eax,-0x50(%rbp)
   180ea:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
   180ee:	4c 89 ef             	mov    %r13,%rdi
   180f1:	ff 50 38             	callq  *0x38(%rax)
   180f4:	8b 45 b0             	mov    -0x50(%rbp),%eax
   180f7:	eb 89                	jmp    18082 <set_config+0xb2>
   180f9:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   180fe:	c3                   	retq   
   180ff:	90                   	nop    

0000000000018100 <read_config>:
   18100:	55                   	push   %rbp
   18101:	48 8d 47 10          	lea    0x10(%rdi),%rax
   18105:	48 89 e5             	mov    %rsp,%rbp
   18108:	41 57                	push   %r15
   1810a:	41 56                	push   %r14
   1810c:	41 55                	push   %r13
   1810e:	41 54                	push   %r12
   18110:	53                   	push   %rbx
   18111:	48 83 ec 28          	sub    $0x28,%rsp
   18115:	4c 8b 67 20          	mov    0x20(%rdi),%r12
   18119:	48 89 3f             	mov    %rdi,(%rdi)
   1811c:	48 89 7f 08          	mov    %rdi,0x8(%rdi)
   18120:	48 89 47 10          	mov    %rax,0x10(%rdi)
   18124:	48 89 47 18          	mov    %rax,0x18(%rdi)
   18128:	4c 89 e3             	mov    %r12,%rbx
   1812b:	48 03 5f 28          	add    0x28(%rdi),%rbx
   1812f:	49 39 dc             	cmp    %rbx,%r12
   18132:	0f 83 e3 00 00 00    	jae    1821b <read_config+0x11b>
   18138:	49 89 d7             	mov    %rdx,%r15
   1813b:	49 89 f6             	mov    %rsi,%r14
   1813e:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
   18142:	45 31 ed             	xor    %r13d,%r13d
   18145:	eb 31                	jmp    18178 <read_config+0x78>
   18147:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
   1814e:	00 00 
   18150:	41 0f b6 04 24       	movzbl (%r12),%eax
   18155:	3c 0a                	cmp    $0xa,%al
   18157:	41 0f 94 c5          	sete   %r13b
   1815b:	3c 0d                	cmp    $0xd,%al
   1815d:	0f 94 c0             	sete   %al
   18160:	41 09 c5             	or     %eax,%r13d
   18163:	41 83 f5 01          	xor    $0x1,%r13d
   18167:	45 0f b6 ed          	movzbl %r13b,%r13d
   1816b:	49 83 c4 01          	add    $0x1,%r12
   1816f:	4c 39 e3             	cmp    %r12,%rbx
   18172:	0f 86 a3 00 00 00    	jbe    1821b <read_config+0x11b>
   18178:	45 85 ed             	test   %r13d,%r13d
   1817b:	75 d3                	jne    18150 <read_config+0x50>
   1817d:	41 0f b6 0c 24       	movzbl (%r12),%ecx
   18182:	80 f9 23             	cmp    $0x23,%cl
   18185:	0f 84 85 00 00 00    	je     18210 <read_config+0x110>
   1818b:	80 f9 0d             	cmp    $0xd,%cl
   1818e:	74 db                	je     1816b <read_config+0x6b>
   18190:	8d 41 f7             	lea    -0x9(%rcx),%eax
   18193:	3c 01                	cmp    $0x1,%al
   18195:	76 d4                	jbe    1816b <read_config+0x6b>
   18197:	80 f9 20             	cmp    $0x20,%cl
   1819a:	74 cf                	je     1816b <read_config+0x6b>
   1819c:	4c 39 e3             	cmp    %r12,%rbx
   1819f:	4d 89 e3             	mov    %r12,%r11
   181a2:	76 77                	jbe    1821b <read_config+0x11b>
   181a4:	89 c8                	mov    %ecx,%eax
   181a6:	83 e0 df             	and    $0xffffffffffffffdf,%eax
   181a9:	83 e8 41             	sub    $0x41,%eax
   181ac:	3c 19                	cmp    $0x19,%al
   181ae:	76 10                	jbe    181c0 <read_config+0xc0>
   181b0:	8d 41 d0             	lea    -0x30(%rcx),%eax
   181b3:	3c 09                	cmp    $0x9,%al
   181b5:	76 09                	jbe    181c0 <read_config+0xc0>
   181b7:	80 f9 5f             	cmp    $0x5f,%cl
   181ba:	0f 85 87 02 00 00    	jne    18447 <read_config+0x347>
   181c0:	4c 89 e0             	mov    %r12,%rax
   181c3:	eb 03                	jmp    181c8 <read_config+0xc8>
   181c5:	0f b6 08             	movzbl (%rax),%ecx
   181c8:	89 ca                	mov    %ecx,%edx
   181ca:	83 e2 df             	and    $0xffffffffffffffdf,%edx
   181cd:	83 ea 41             	sub    $0x41,%edx
   181d0:	80 fa 19             	cmp    $0x19,%dl
   181d3:	76 0d                	jbe    181e2 <read_config+0xe2>
   181d5:	8d 51 d0             	lea    -0x30(%rcx),%edx
   181d8:	80 fa 09             	cmp    $0x9,%dl
   181db:	76 05                	jbe    181e2 <read_config+0xe2>
   181dd:	80 f9 5f             	cmp    $0x5f,%cl
   181e0:	75 4e                	jne    18230 <read_config+0x130>
   181e2:	48 83 c0 01          	add    $0x1,%rax
   181e6:	48 39 c3             	cmp    %rax,%rbx
   181e9:	77 da                	ja     181c5 <read_config+0xc5>
   181eb:	48 8d 15 ca 6e 00 00 	lea    0x6eca(%rip),%rdx        # 1f0bc <xdigits.2821+0x5c>
   181f2:	4d 85 ff             	test   %r15,%r15
   181f5:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
   181fa:	74 21                	je     1821d <read_config+0x11d>
   181fc:	49 89 17             	mov    %rdx,(%r15)
   181ff:	48 83 c4 28          	add    $0x28,%rsp
   18203:	5b                   	pop    %rbx
   18204:	41 5c                	pop    %r12
   18206:	41 5d                	pop    %r13
   18208:	41 5e                	pop    %r14
   1820a:	41 5f                	pop    %r15
   1820c:	5d                   	pop    %rbp
   1820d:	c3                   	retq   
   1820e:	66 90                	xchg   %ax,%ax
   18210:	41 bd 01 00 00 00    	mov    $0x1,%r13d
   18216:	e9 50 ff ff ff       	jmpq   1816b <read_config+0x6b>
   1821b:	31 c0                	xor    %eax,%eax
   1821d:	48 83 c4 28          	add    $0x28,%rsp
   18221:	5b                   	pop    %rbx
   18222:	41 5c                	pop    %r12
   18224:	41 5d                	pop    %r13
   18226:	41 5e                	pop    %r14
   18228:	41 5f                	pop    %r15
   1822a:	5d                   	pop    %rbp
   1822b:	c3                   	retq   
   1822c:	0f 1f 40 00          	nopl   0x0(%rax)
   18230:	48 39 c3             	cmp    %rax,%rbx
   18233:	76 b6                	jbe    181eb <read_config+0xeb>
   18235:	4c 39 e0             	cmp    %r12,%rax
   18238:	74 1b                	je     18255 <read_config+0x155>
   1823a:	80 f9 2e             	cmp    $0x2e,%cl
   1823d:	0f 85 2d 01 00 00    	jne    18370 <read_config+0x270>
   18243:	4c 8d 60 01          	lea    0x1(%rax),%r12
   18247:	4c 39 e3             	cmp    %r12,%rbx
   1824a:	76 12                	jbe    1825e <read_config+0x15e>
   1824c:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
   18250:	e9 6b ff ff ff       	jmpq   181c0 <read_config+0xc0>
   18255:	48 8d 15 45 6e 00 00 	lea    0x6e45(%rip),%rdx        # 1f0a1 <xdigits.2821+0x41>
   1825c:	eb 94                	jmp    181f2 <read_config+0xf2>
   1825e:	0f b6 48 01          	movzbl 0x1(%rax),%ecx
   18262:	44 89 e2             	mov    %r12d,%edx
   18265:	44 29 da             	sub    %r11d,%edx
   18268:	80 f9 3d             	cmp    $0x3d,%cl
   1826b:	0f 85 f8 01 00 00    	jne    18469 <read_config+0x369>
   18271:	49 8d 4c 24 01       	lea    0x1(%r12),%rcx
   18276:	48 39 cb             	cmp    %rcx,%rbx
   18279:	0f 86 34 01 00 00    	jbe    183b3 <read_config+0x2b3>
   1827f:	41 0f b6 44 24 01    	movzbl 0x1(%r12),%eax
   18285:	3c 09                	cmp    $0x9,%al
   18287:	75 1b                	jne    182a4 <read_config+0x1a4>
   18289:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
   18290:	48 83 c1 01          	add    $0x1,%rcx
   18294:	48 39 d9             	cmp    %rbx,%rcx
   18297:	0f 84 16 01 00 00    	je     183b3 <read_config+0x2b3>
   1829d:	0f b6 01             	movzbl (%rcx),%eax
   182a0:	3c 09                	cmp    $0x9,%al
   182a2:	74 ec                	je     18290 <read_config+0x190>
   182a4:	3c 20                	cmp    $0x20,%al
   182a6:	74 e8                	je     18290 <read_config+0x190>
   182a8:	3c 22                	cmp    $0x22,%al
   182aa:	0f 84 0f 01 00 00    	je     183bf <read_config+0x2bf>
   182b0:	3c 23                	cmp    $0x23,%al
   182b2:	49 89 cc             	mov    %rcx,%r12
   182b5:	0f 84 a0 01 00 00    	je     1845b <read_config+0x35b>
   182bb:	3c 0a                	cmp    $0xa,%al
   182bd:	0f 84 90 01 00 00    	je     18453 <read_config+0x353>
   182c3:	3c 0d                	cmp    $0xd,%al
   182c5:	75 1e                	jne    182e5 <read_config+0x1e5>
   182c7:	e9 87 01 00 00       	jmpq   18453 <read_config+0x353>
   182cc:	0f 1f 40 00          	nopl   0x0(%rax)
   182d0:	41 0f b6 04 24       	movzbl (%r12),%eax
   182d5:	3c 23                	cmp    $0x23,%al
   182d7:	0f 84 37 01 00 00    	je     18414 <read_config+0x314>
   182dd:	3c 0a                	cmp    $0xa,%al
   182df:	74 0d                	je     182ee <read_config+0x1ee>
   182e1:	3c 0d                	cmp    $0xd,%al
   182e3:	74 09                	je     182ee <read_config+0x1ee>
   182e5:	49 83 c4 01          	add    $0x1,%r12
   182e9:	4c 39 e3             	cmp    %r12,%rbx
   182ec:	77 e2                	ja     182d0 <read_config+0x1d0>
   182ee:	45 89 e0             	mov    %r12d,%r8d
   182f1:	41 29 c8             	sub    %ecx,%r8d
   182f4:	49 83 c4 01          	add    $0x1,%r12
   182f8:	4d 85 f6             	test   %r14,%r14
   182fb:	74 2e                	je     1832b <read_config+0x22b>
   182fd:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
   18301:	44 89 45 b8          	mov    %r8d,-0x48(%rbp)
   18305:	89 d6                	mov    %edx,%esi
   18307:	89 55 bc             	mov    %edx,-0x44(%rbp)
   1830a:	4c 89 df             	mov    %r11,%rdi
   1830d:	4c 89 5d c0          	mov    %r11,-0x40(%rbp)
   18311:	41 ff d6             	callq  *%r14
   18314:	85 c0                	test   %eax,%eax
   18316:	4c 8b 5d c0          	mov    -0x40(%rbp),%r11
   1831a:	8b 55 bc             	mov    -0x44(%rbp),%edx
   1831d:	44 8b 45 b8          	mov    -0x48(%rbp),%r8d
   18321:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
   18325:	0f 85 44 fe ff ff    	jne    1816f <read_config+0x6f>
   1832b:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
   1832f:	45 31 c9             	xor    %r9d,%r9d
   18332:	4c 89 de             	mov    %r11,%rsi
   18335:	e8 e6 f7 ff ff       	callq  17b20 <__add_config>
   1833a:	85 c0                	test   %eax,%eax
   1833c:	0f 89 2d fe ff ff    	jns    1816f <read_config+0x6f>
   18342:	83 f8 dc             	cmp    $0xffffffffffffffdc,%eax
   18345:	48 8d 15 a6 6d 00 00 	lea    0x6da6(%rip),%rdx        # 1f0f2 <xdigits.2821+0x92>
   1834c:	0f 84 a0 fe ff ff    	je     181f2 <read_config+0xf2>
   18352:	83 f8 ea             	cmp    $0xffffffffffffffea,%eax
   18355:	48 8d 15 88 6d 00 00 	lea    0x6d88(%rip),%rdx        # 1f0e4 <xdigits.2821+0x84>
   1835c:	48 8d 05 9c 6d 00 00 	lea    0x6d9c(%rip),%rax        # 1f0ff <xdigits.2821+0x9f>
   18363:	48 0f 44 d0          	cmove  %rax,%rdx
   18367:	e9 86 fe ff ff       	jmpq   181f2 <read_config+0xf2>
   1836c:	0f 1f 40 00          	nopl   0x0(%rax)
   18370:	89 c2                	mov    %eax,%edx
   18372:	48 89 c6             	mov    %rax,%rsi
   18375:	44 29 da             	sub    %r11d,%edx
   18378:	80 f9 09             	cmp    $0x9,%cl
   1837b:	74 13                	je     18390 <read_config+0x290>
   1837d:	80 f9 20             	cmp    $0x20,%cl
   18380:	49 89 c4             	mov    %rax,%r12
   18383:	0f 85 df fe ff ff    	jne    18268 <read_config+0x168>
   18389:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
   18390:	4c 8d 66 01          	lea    0x1(%rsi),%r12
   18394:	0f b6 4e 01          	movzbl 0x1(%rsi),%ecx
   18398:	4c 39 e3             	cmp    %r12,%rbx
   1839b:	0f 86 c7 fe ff ff    	jbe    18268 <read_config+0x168>
   183a1:	80 f9 09             	cmp    $0x9,%cl
   183a4:	4c 89 e6             	mov    %r12,%rsi
   183a7:	74 e7                	je     18390 <read_config+0x290>
   183a9:	80 f9 20             	cmp    $0x20,%cl
   183ac:	74 e2                	je     18390 <read_config+0x290>
   183ae:	e9 b5 fe ff ff       	jmpq   18268 <read_config+0x168>
   183b3:	48 8d 15 cc 6c 00 00 	lea    0x6ccc(%rip),%rdx        # 1f086 <xdigits.2821+0x26>
   183ba:	e9 33 fe ff ff       	jmpq   181f2 <read_config+0xf2>
   183bf:	48 8d 71 01          	lea    0x1(%rcx),%rsi
   183c3:	48 39 f3             	cmp    %rsi,%rbx
   183c6:	76 5d                	jbe    18425 <read_config+0x325>
   183c8:	0f b6 49 01          	movzbl 0x1(%rcx),%ecx
   183cc:	49 89 f4             	mov    %rsi,%r12
   183cf:	80 f9 22             	cmp    $0x22,%cl
   183d2:	0f 84 9d 00 00 00    	je     18475 <read_config+0x375>
   183d8:	31 c0                	xor    %eax,%eax
   183da:	eb 19                	jmp    183f5 <read_config+0x2f5>
   183dc:	85 c0                	test   %eax,%eax
   183de:	4c 89 e1             	mov    %r12,%rcx
   183e1:	75 1f                	jne    18402 <read_config+0x302>
   183e3:	4c 8d 61 01          	lea    0x1(%rcx),%r12
   183e7:	4c 39 e3             	cmp    %r12,%rbx
   183ea:	76 39                	jbe    18425 <read_config+0x325>
   183ec:	0f b6 49 01          	movzbl 0x1(%rcx),%ecx
   183f0:	80 f9 22             	cmp    $0x22,%cl
   183f3:	74 3c                	je     18431 <read_config+0x331>
   183f5:	80 f9 5c             	cmp    $0x5c,%cl
   183f8:	75 e2                	jne    183dc <read_config+0x2dc>
   183fa:	49 8d 4c 24 01       	lea    0x1(%r12),%rcx
   183ff:	83 c0 01             	add    $0x1,%eax
   18402:	44 0f b6 01          	movzbl (%rcx),%r8d
   18406:	48 63 f8             	movslq %eax,%rdi
   18409:	49 89 ca             	mov    %rcx,%r10
   1840c:	49 29 fa             	sub    %rdi,%r10
   1840f:	45 88 02             	mov    %r8b,(%r10)
   18412:	eb cf                	jmp    183e3 <read_config+0x2e3>
   18414:	45 89 e0             	mov    %r12d,%r8d
   18417:	41 bd 01 00 00 00    	mov    $0x1,%r13d
   1841d:	41 29 c8             	sub    %ecx,%r8d
   18420:	e9 cf fe ff ff       	jmpq   182f4 <read_config+0x1f4>
   18425:	48 8d 15 ec 6c 00 00 	lea    0x6cec(%rip),%rdx        # 1f118 <xdigits.2821+0xb8>
   1842c:	e9 c1 fd ff ff       	jmpq   181f2 <read_config+0xf2>
   18431:	48 98                	cltq   
   18433:	48 f7 d8             	neg    %rax
   18436:	4c 01 e0             	add    %r12,%rax
   18439:	48 89 f1             	mov    %rsi,%rcx
   1843c:	41 89 c0             	mov    %eax,%r8d
   1843f:	41 29 f0             	sub    %esi,%r8d
   18442:	e9 ad fe ff ff       	jmpq   182f4 <read_config+0x1f4>
   18447:	48 8d 15 23 6c 00 00 	lea    0x6c23(%rip),%rdx        # 1f071 <xdigits.2821+0x11>
   1844e:	e9 9f fd ff ff       	jmpq   181f2 <read_config+0xf2>
   18453:	45 31 c0             	xor    %r8d,%r8d
   18456:	e9 99 fe ff ff       	jmpq   182f4 <read_config+0x1f4>
   1845b:	45 31 c0             	xor    %r8d,%r8d
   1845e:	41 bd 01 00 00 00    	mov    $0x1,%r13d
   18464:	e9 8b fe ff ff       	jmpq   182f4 <read_config+0x1f4>
   18469:	48 8d 15 60 6c 00 00 	lea    0x6c60(%rip),%rdx        # 1f0d0 <xdigits.2821+0x70>
   18470:	e9 7d fd ff ff       	jmpq   181f2 <read_config+0xf2>
   18475:	31 c0                	xor    %eax,%eax
   18477:	eb bd                	jmp    18436 <read_config+0x336>
   18479:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000018480 <free_config>:
   18480:	55                   	push   %rbp
   18481:	48 89 e5             	mov    %rsp,%rbp
   18484:	41 56                	push   %r14
   18486:	41 55                	push   %r13
   18488:	41 54                	push   %r12
   1848a:	53                   	push   %rbx
   1848b:	4c 8d 77 10          	lea    0x10(%rdi),%r14
   1848f:	48 8b 47 10          	mov    0x10(%rdi),%rax
   18493:	49 89 fd             	mov    %rdi,%r13
   18496:	48 8b 08             	mov    (%rax),%rcx
   18499:	49 39 c6             	cmp    %rax,%r14
   1849c:	48 8d 58 e0          	lea    -0x20(%rax),%rbx
   184a0:	4c 8d 61 e0          	lea    -0x20(%rcx),%r12
   184a4:	75 0d                	jne    184b3 <free_config+0x33>
   184a6:	eb 35                	jmp    184dd <free_config+0x5d>
   184a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   184af:	00 
   184b0:	49 89 c4             	mov    %rax,%r12
   184b3:	48 8b 7b 18          	mov    0x18(%rbx),%rdi
   184b7:	48 85 ff             	test   %rdi,%rdi
   184ba:	74 04                	je     184c0 <free_config+0x40>
   184bc:	41 ff 55 38          	callq  *0x38(%r13)
   184c0:	48 89 df             	mov    %rbx,%rdi
   184c3:	4c 89 e3             	mov    %r12,%rbx
   184c6:	41 ff 55 38          	callq  *0x38(%r13)
   184ca:	49 8b 44 24 20       	mov    0x20(%r12),%rax
   184cf:	49 8d 54 24 20       	lea    0x20(%r12),%rdx
   184d4:	48 83 e8 20          	sub    $0x20,%rax
   184d8:	49 39 d6             	cmp    %rdx,%r14
   184db:	75 d3                	jne    184b0 <free_config+0x30>
   184dd:	5b                   	pop    %rbx
   184de:	4d 89 75 10          	mov    %r14,0x10(%r13)
   184e2:	4d 89 75 18          	mov    %r14,0x18(%r13)
   184e6:	31 c0                	xor    %eax,%eax
   184e8:	41 5c                	pop    %r12
   184ea:	4d 89 6d 00          	mov    %r13,0x0(%r13)
   184ee:	4d 89 6d 08          	mov    %r13,0x8(%r13)
   184f2:	41 5d                	pop    %r13
   184f4:	41 5e                	pop    %r14
   184f6:	5d                   	pop    %rbp
   184f7:	c3                   	retq   
   184f8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
   184ff:	00 

0000000000018500 <copy_config>:
   18500:	55                   	push   %rbp
   18501:	48 8d 46 10          	lea    0x10(%rsi),%rax
   18505:	48 8d 57 10          	lea    0x10(%rdi),%rdx
   18509:	48 89 e5             	mov    %rsp,%rbp
   1850c:	41 55                	push   %r13
   1850e:	41 54                	push   %r12
   18510:	53                   	push   %rbx
   18511:	49 89 f4             	mov    %rsi,%r12
   18514:	31 db                	xor    %ebx,%ebx
   18516:	49 89 fd             	mov    %rdi,%r13
   18519:	48 83 ec 18          	sub    $0x18,%rsp
   1851d:	49 89 34 24          	mov    %rsi,(%r12)
   18521:	49 89 74 24 08       	mov    %rsi,0x8(%r12)
   18526:	48 89 46 10          	mov    %rax,0x10(%rsi)
   1852a:	48 8b 4f 10          	mov    0x10(%rdi),%rcx
   1852e:	48 89 46 18          	mov    %rax,0x18(%rsi)
   18532:	48 39 ca             	cmp    %rcx,%rdx
   18535:	48 8d 41 e0          	lea    -0x20(%rcx),%rax
   18539:	74 25                	je     18560 <copy_config+0x60>
   1853b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
   18540:	48 83 38 00          	cmpq   $0x0,(%rax)
   18544:	74 03                	je     18549 <copy_config+0x49>
   18546:	03 58 10             	add    0x10(%rax),%ebx
   18549:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
   1854e:	74 03                	je     18553 <copy_config+0x53>
   18550:	03 58 14             	add    0x14(%rax),%ebx
   18553:	4c 8b 40 20          	mov    0x20(%rax),%r8
   18557:	4c 39 c2             	cmp    %r8,%rdx
   1855a:	49 8d 40 e0          	lea    -0x20(%r8),%rax
   1855e:	75 e0                	jne    18540 <copy_config+0x40>
   18560:	89 df                	mov    %ebx,%edi
   18562:	41 ff 54 24 30       	callq  *0x30(%r12)
   18567:	48 85 c0             	test   %rax,%rax
   1856a:	74 39                	je     185a5 <copy_config+0xa5>
   1856c:	48 63 db             	movslq %ebx,%rbx
   1856f:	4c 8d 4d d8          	lea    -0x28(%rbp),%r9
   18573:	4c 8d 45 d0          	lea    -0x30(%rbp),%r8
   18577:	49 89 44 24 20       	mov    %rax,0x20(%r12)
   1857c:	49 89 5c 24 28       	mov    %rbx,0x28(%r12)
   18581:	4c 89 e1             	mov    %r12,%rcx
   18584:	4c 89 e2             	mov    %r12,%rdx
   18587:	4c 89 ee             	mov    %r13,%rsi
   1858a:	4c 89 ef             	mov    %r13,%rdi
   1858d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
   18591:	48 89 5d d8          	mov    %rbx,-0x28(%rbp)
   18595:	e8 16 f0 ff ff       	callq  175b0 <__dup_config>
   1859a:	48 83 c4 18          	add    $0x18,%rsp
   1859e:	5b                   	pop    %rbx
   1859f:	41 5c                	pop    %r12
   185a1:	41 5d                	pop    %r13
   185a3:	5d                   	pop    %rbp
   185a4:	c3                   	retq   
   185a5:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
   185aa:	eb ee                	jmp    1859a <copy_config+0x9a>
   185ac:	0f 1f 40 00          	nopl   0x0(%rax)

00000000000185b0 <write_config>:
   185b0:	55                   	push   %rbp
   185b1:	45 31 c9             	xor    %r9d,%r9d
   185b4:	48 89 d1             	mov    %rdx,%rcx
   185b7:	48 89 e5             	mov    %rsp,%rbp
   185ba:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
   185c1:	48 8d 85 f8 fe ff ff 	lea    -0x108(%rbp),%rax
   185c8:	4c 8d 85 00 ff ff ff 	lea    -0x100(%rbp),%r8
   185cf:	48 c7 85 f8 fe ff ff 	movq   $0x0,-0x108(%rbp)
   185d6:	00 00 00 00 
   185da:	50                   	push   %rax
   185db:	e8 30 f7 ff ff       	callq  17d10 <__write_config>
   185e0:	c9                   	leaveq 
   185e1:	c3                   	retq   
